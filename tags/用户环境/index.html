
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="码龙的窝">
    <title>标签: 用户环境 - 码龙的窝</title>
    <meta name="author" content="CoSidian">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="/* 0与1之风吹遍山谷 */">
<meta property="og:type" content="blog">
<meta property="og:title" content="码龙的窝">
<meta property="og:url" content="http://blog.codedragon.tech/tags/用户环境/index.html">
<meta property="og:site_name" content="码龙的窝">
<meta property="og:description" content="/* 0与1之风吹遍山谷 */">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="码龙的窝">
<meta name="twitter:description" content="/* 0与1之风吹遍山谷 */">
    
    
        
    
    
        <meta property="og:image" content="http://blog.codedragon.tech/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-gtvt1lbvzeqmr99zec4y42qrxw5ogq1gul5orw7somyh6cv5ckqsrl4abr9a.min.css">
    <!--STYLES END-->
    
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-108458894-1', 'auto');
        ga('send', 'pageview');
    </script>


    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">码龙的窝</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">CoSidian</h4>
                
                    <h5 class="sidebar-profile-bio"><p>码龙黑曜 - iOS开发者/计算机科学/兽人控</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="首页"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="分类"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="标签"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="归档"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/about"
                            
                            title="关于"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/BlackDragonF" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://t.me/Cosidian" target="_blank" rel="noopener" title="Telegram">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-paper-plane" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Telegram</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://steamcommunity.com/id/BlackDragonF/" target="_blank" rel="noopener" title="Steam">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-steam" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Steam</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:obsidiandragon2016@gmail.com" target="_blank" rel="noopener" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/friendly-links"
                            
                            title="友情链接"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-link" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">友情链接</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/book-recommend"
                            
                            title="图书推荐"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-book" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">图书推荐</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/">
                            MIT6.828操作系统工程Lab3-User Environments实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-02-23T19:12:13+08:00">
	
		    2月 23, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <blockquote>
<p>Lab3 - User Environments需要实现基本的内核功能，使得一个受保护的用户环境（进程）可以运行。在本实验中，需要让内核设置数据结构以追踪用户环境，创建一个单用户环境，加载程序镜像并执行。此外，内核还需要能处理用户环境的系统调用以及引发的异常。<br>2018年2月26日，完成了实验并写完了报告。</p>
</blockquote>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>根据官网，切换到分支lab3并且合并分支lab2。在合并的过程中，发生了冲突。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user% git checkout -b lab3 origin/lab3</div><div class="line">user% git merge lab2</div></pre></td></tr></table></figure>
<p>根据提示，是<code>kern/monitor.c</code>中发生了冲突，因为仅有一处冲突，手动编辑<code>kern/monitor.c</code>文件，并commit，即可解决冲突并合并分支。</p>
<p>实验三包括如下的新文件：</p>
<ul>
<li>inc/env.h 用户模式环境的公有定义</li>
<li>inc/trap.h 陷阱处理的公有定义</li>
<li>inc/syscall.h 用户环境对内核的系统调用的公有定义</li>
<li>inc/lib.h 用户模式支持的库公有定义</li>
<li>kern/env.h 用户模式环境的内核私有定义</li>
<li>kern/env.c 用户模式环境的内核代码实现</li>
<li>kern/trap.h 内核私有的陷阱处理定义</li>
<li>kern/trap.c 陷阱处理代码</li>
<li>kern/trapentry.S 汇编语言的陷阱处理程序入口</li>
<li>kern/syscall.h 系统调用处理的内核私有定义</li>
<li>kern/syscall.c 系统调用实现代码</li>
<li>lib/Makefrag 用户模式库obj/lib/libjos.a的Makefile</li>
<li>lib/entry.S 用户环境的汇编语言入口</li>
<li>lib/libmain.c entry.S调用的用户模式库安装代码</li>
<li>lib/syscall.c 用户模式系统调用的打桩函数</li>
<li>lib/console.c 用户模式的putchar和getchar实现，提供了控制台IO</li>
<li>lib/exit.c 用户模式的exit实现</li>
<li>lib/panic.c 用户模式的panic实现</li>
<li>user/* 检验内核实验三代码的测试程序</li>
</ul>
<p>此外，lab2中的一些文件在lab3中也被添加了新的内容，可以用<code>git diff lab2</code>查看具体的比较信息。</p>
<h4 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h4><p>本实验中可能会用到<code>GCC</code>的内联汇编特性，应当至少理解给出的代码中的内联汇编代码片段。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="第一部分-User-Environments-and-Exception-Handling-用户环境和错误处理"><a href="#第一部分-User-Environments-and-Exception-Handling-用户环境和错误处理" class="headerlink" title="第一部分 User Environments and Exception Handling - 用户环境和错误处理"></a>第一部分 User Environments and Exception Handling - 用户环境和错误处理</h3><p><code>inc/env.h</code>中给出了用户环境的基本定义。内核通过<code>struct Env</code>追踪每一个用户环境。本实验中只需要创建一个环境，然而你需要设计JOS内核实际支持多用户环境。实验四中，你将通过允许一个用户环境<code>fork</code>别的用户环境来利用多用户环境的特性。</p>
<p><code>kern/env.c</code>中可以看到，内核管理3个与环境有关的全局变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *       <span class="title">envs</span>   = <span class="title">NULL</span>;</span>    <span class="comment">// All environments</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *       <span class="title">curenv</span> = <span class="title">NULL</span>;</span>    <span class="comment">// The current env</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span>    <span class="comment">// Free environment list</span></div></pre></td></tr></table></figure></p>
<p>当JOS成功运行之后，<code>envs</code>指针指向一个<code>struct Env</code>的数组，代表了系统中所有的环境。在设计上，JOS内核允许NNEV个同时激活的环境，NNEV在<code>inc/env.h</code>中定义。<br>JOS内核使用<code>env_free_list</code>维护所有未激活的<code>struct Env</code>，这样的设计简化的环境的分配和释放，它们仅仅需要从该链表上添加或移除。<br>JOS内核使用<code>curenv</code>去追踪在任意时刻当前正在执行的环境。在启动之后到第一个环境运行的时间段中，<code>curenv</code>被初始化为<code>NULL</code>。</p>
<h4 id="环境状态"><a href="#环境状态" class="headerlink" title="环境状态"></a>环境状态</h4><p><code>struct Env</code>在<code>inc/env.h</code>中被定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>	<span class="comment">// Saved registers</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>		<span class="comment">// Next free Env</span></div><div class="line">	<span class="keyword">envid_t</span> env_id;			<span class="comment">// Unique environment identifier</span></div><div class="line">	<span class="keyword">envid_t</span> env_parent_id;		<span class="comment">// env_id of this env's parent</span></div><div class="line">	<span class="keyword">enum</span> EnvType env_type;		<span class="comment">// Indicates special system environments</span></div><div class="line">	<span class="keyword">unsigned</span> env_status;		<span class="comment">// Status of the environment</span></div><div class="line">	<span class="keyword">uint32_t</span> env_runs;		<span class="comment">// Number of times environment has run</span></div><div class="line"></div><div class="line">	<span class="comment">// Address space</span></div><div class="line">	<span class="keyword">pde_t</span> *env_pgdir;		<span class="comment">// Kernel virtual address of page dir</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<ul>
<li>env_tf - <code>struct TrapFrame</code>在<code>inc/trap.h</code>中被定义，表示了当环境不运行时被保存的寄存器值，主要用于上下文切换</li>
<li>env_link - 指向了<code>env_free_list</code>上的下一个<code>struct Env</code>。<code>env_free_list</code>指向了链表中的第一个空闲环境</li>
<li>env_id - 唯一标识当前正在使用<code>struct Env</code>的环境。当环境终止后，<code>struct Env</code>可能被内核重新分配用于另一个不同的环境，但它们的env_id是不同的</li>
<li>env_parent_id - 存储了创建该环境的环境的<code>env_id</code>，通过该方式构建一个环境树，用于安全方面的决策</li>
<li>env_type - 用于区分特殊环境，对于大部分环境，该值为<code>ENV_TYPE_USER</code>，在后续Lab中会介绍其他的值</li>
<li>env_status - 状态<ul>
<li>ENV_FREE - 表明<code>struct Env</code>处于空闲状态，应当位于<code>env_free_list</code>上</li>
<li>ENV_RUNNABLE - 表明<code>struct Env</code>代表的环境正等待运行于处理器上</li>
<li>ENV_RUNNING - 表明<code>struct Env</code>代表的环境为正在运行的环境</li>
<li>ENV_NOT_RUNNABLE - 表明<code>struct Env</code>代表了一个正在运行的环境，但却没有准备好运行，如正在等待另一个环境的IPC（进程间通信）</li>
<li>ENV_DYING - 表明<code>struct Env</code>代表了一个僵死环境，僵死环境将在下一次陷入内核时被释放（直到Lab4才会使用该Flag）</li>
</ul>
</li>
<li>env_pgdir - 保存了环境的页目录的内核虚拟地址</li>
</ul>
<p>JOS中环境的概念综合了“线程”和“地址空间”，“线程”由<code>env_tf</code>域的被保存的寄存器值定义，“地址空间”由<code>env_pgdir</code>域指向的页目录和页表定义。为了运行一个环境，内核必须用保存的寄存器值和合适的地址空间设置CPU。</p>
<p>JOS的<code>struct Env</code>和xv6的<code>struct proc</code>很像，两种结构体都持有环境的用户模式寄存器状态（通过<code>struct TrapFrame</code>），然而，JOS中，独立的环境并不具有不同的内核栈，因为JOS内核中同时只能有一个运行的JOS环境，因此JOS只需要一个内核栈。</p>
<h4 id="分配环境数组"><a href="#分配环境数组" class="headerlink" title="分配环境数组"></a>分配环境数组</h4><p>练习1的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Make 'envs' point to an array of size 'NENV' of 'struct Env'.</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// get size of envs</span></div><div class="line"><span class="keyword">uint32_t</span> envs_size = <span class="keyword">sizeof</span>(struct Env) * NENV;</div><div class="line"><span class="comment">// use boot_alloc to allocate memory</span></div><div class="line">envs = (struct Env *)boot_alloc(envs_size);</div><div class="line"><span class="comment">// initialization</span></div><div class="line"><span class="built_in">memset</span>(envs, <span class="number">0</span>, envs_size);</div><div class="line"></div><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Map the 'envs' array read-only by the user at linear address UENVS</span></div><div class="line"><span class="comment">// (ie. perm = PTE_U | PTE_P).</span></div><div class="line"><span class="comment">// Permissions:</span></div><div class="line"><span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></div><div class="line"><span class="comment">//    - envs itself -- kernel RW, user NONE</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line">boot_map_region(kern_pgdir, UENVS, envs_size, PADDR(envs), PTE_U | PTE_P);</div></pre></td></tr></table></figure></p>
<h4 id="创建并运行环境"><a href="#创建并运行环境" class="headerlink" title="创建并运行环境"></a>创建并运行环境</h4><p>现在将在<code>kern/env.c</code>中编写必要的代码去运行用户环境。由于JOS内核还不支持文件系统，所以只能配置内核以加载一个嵌入内核中静态二进制镜像。JOS内核将这个二进制镜像以ELF可执行镜像格式嵌入。</p>
<p>Lab3的GNU<code>Makefile</code>在<code>obj/user/</code>目录下生成了一些二进制镜像。<code>kern/Makefrag</code>下可以看到，链接器的<code>-b binary</code>选项使得这些文件以原始的未被翻译二进制文件而非普通的被编译器生成的<code>.o</code>文件的方式链接， 通过<code>-b binary</code>方式链接的二进制文件就链接器而言可以为任意类型，甚至是文本文件或是图片。</p>
<p>如果在构建内核后观察<code>obj/kern/kernel.sym</code>，可以看到链接器生成了一些“奇怪”名字的符号如<code>_binary_obj_user_hello_start</code>， <code>_binary_obj_user_hello_end</code>或 <code>_binary_obj_user_hello_size</code>。链接器通过二进制文件的名字生成了这些符号的名字，这些符号使得内核代码可以以某种方式引用这些嵌入的二进制文件。</p>
<p>练习2中遇到的问题：</p>
<ul>
<li>除了<code>env-&gt;env_tf.tf_eip</code>以外不要修改其他的值，因为其已经在<code>env_alloc()</code>中被初始化</li>
<li><code>region_alloc()</code>中笔误导致只映射了一页</li>
<li><code>load_icode()</code>中需要切换页表，之后加载每段仅用一个<code>memcpy</code>即可实现</li>
</ul>
<p>练习2的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In env_init():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="keyword">ssize_t</span> i;</div><div class="line"><span class="comment">// loop in reverse order to keep ascending order in env free list</span></div><div class="line"><span class="keyword">for</span> (i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">    <span class="comment">// set env_status, env_id</span></div><div class="line">    envs[i].env_status = ENV_FREE;</div><div class="line">    envs[i].env_id     = <span class="number">0</span>;</div><div class="line">    <span class="comment">// set env_link and insert into env_free_list</span></div><div class="line">    envs[i].env_link = env_free_list;</div><div class="line">    env_free_list    = &amp;envs[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In env_setup_vm():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// set env_pgdir and generate page directory based on kern_pgdir</span></div><div class="line">e-&gt;env_pgdir = (<span class="keyword">pde_t</span> *)page2kva(p);</div><div class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</div><div class="line"><span class="comment">// increase pp_ref</span></div><div class="line">p-&gt;pp_ref++;</div><div class="line"></div><div class="line"><span class="comment">// In region_alloc():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// (But only if you need it for load_icode.)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></div><div class="line"><span class="comment">//   'va' and 'len' values that are not page-aligned.</span></div><div class="line"><span class="comment">//   You should round va down, and round (va + len) up.</span></div><div class="line"><span class="comment">//   (Watch out for corner-cases!)</span></div><div class="line"></div><div class="line"><span class="comment">// round va and va + len</span></div><div class="line"><span class="keyword">uintptr_t</span> start = (<span class="keyword">uintptr_t</span>)ROUNDDOWN(va, PGSIZE);</div><div class="line"><span class="keyword">uintptr_t</span> end   = (<span class="keyword">uintptr_t</span>)ROUNDUP(va + len, PGSIZE);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (; start &lt; end; start += PGSIZE) &#123;</div><div class="line">    <span class="comment">// alloc page</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span>;</span></div><div class="line">    p = page_alloc(ALLOC_ZERO);</div><div class="line">    <span class="keyword">if</span> (!p) &#123; panic(<span class="string">"out of memory when allocating region!"</span>); &#125;</div><div class="line">    <span class="comment">// insert page into environment's page directory</span></div><div class="line">    <span class="keyword">if</span> (page_insert(e-&gt;env_pgdir, p, (<span class="keyword">char</span> *)start, PTE_W | PTE_U | PTE_P) &lt;</div><div class="line">        <span class="number">0</span>) &#123;</div><div class="line">        panic(<span class="string">"out of memory when allocating region!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In load_icode():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// switch address space for loading program segments</span></div><div class="line">lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elf</span> = (<span class="title">struct</span> <span class="title">Elf</span> *)<span class="title">binary</span>;</span></div><div class="line"><span class="comment">// check elf magic</span></div><div class="line"><span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123; panic(<span class="string">"invalid elf format!"</span>); &#125;</div><div class="line"></div><div class="line"><span class="comment">// set the program entry for env</span></div><div class="line">e-&gt;env_tf.tf_eip = elf-&gt;e_entry;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></div><div class="line"></div><div class="line"><span class="comment">// get the start and end of program header entry</span></div><div class="line">ph  = (struct Proghdr *)(binary + elf-&gt;e_phoff);</div><div class="line">eph = ph + elf-&gt;e_phnum;</div><div class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</div><div class="line">    <span class="keyword">if</span> (ph-&gt;p_type == ELF_PROG_LOAD) &#123;    <span class="comment">// if the segment is to be loaded</span></div><div class="line">        <span class="comment">// alloc corresponding region(clear zero)</span></div><div class="line">        region_alloc(e, (<span class="keyword">char</span> *)ph-&gt;p_va, ph-&gt;p_memsz);</div><div class="line">        <span class="comment">// copy from ELF header to virtual addresses directly</span></div><div class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span> *)ph-&gt;p_va, (<span class="keyword">char</span> *)binary + ph-&gt;p_offset, ph-&gt;p_filesz);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// switch back</span></div><div class="line">lcr3(PADDR(kern_pgdir));</div><div class="line"></div><div class="line"><span class="comment">// Now map one page for the program's initial stack</span></div><div class="line"><span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// allocate a page and insert it into env's page directory</span></div><div class="line"><span class="comment">// panic when page_alloc or page_insert failed</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">stack_page</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></div><div class="line"><span class="keyword">if</span> (!stack_page) &#123; panic(<span class="string">"out of memory when alloc program's stack!"</span>); &#125;</div><div class="line"><span class="keyword">if</span> (page_insert(e-&gt;env_pgdir, stack_page, (<span class="keyword">char</span> *)(USTACKTOP - PGSIZE),</div><div class="line">                PTE_W | PTE_U | PTE_P) &lt; <span class="number">0</span>) &#123;</div><div class="line">    panic(<span class="string">"failed to set program's stack!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In env_create():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></div><div class="line"><span class="comment">// allocate new env with parent ID 0</span></div><div class="line"><span class="keyword">if</span> (env_alloc(&amp;env, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123; panic(<span class="string">"failed to allocate env!"</span>); &#125;</div><div class="line"><span class="comment">// load elf binary and set env_type</span></div><div class="line">load_icode(env, binary);</div><div class="line">env-&gt;env_type = type;</div><div class="line"></div><div class="line"><span class="comment">// In env_run():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="keyword">if</span> (curenv != <span class="literal">NULL</span>) &#123;    <span class="comment">// context switch</span></div><div class="line">    <span class="keyword">if</span> (curenv-&gt;env_status == ENV_RUNNING) &#123;</div><div class="line">        <span class="comment">// change to runnable if current status is running</span></div><div class="line">        <span class="comment">// for not runnable, is not necessary to do this</span></div><div class="line">        curenv-&gt;env_status = ENV_RUNNABLE;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// set new curenv, update status and counter</span></div><div class="line">curenv        = e;</div><div class="line">e-&gt;env_status = ENV_RUNNING;</div><div class="line">e-&gt;env_runs++;</div><div class="line"><span class="comment">// address space switch</span></div><div class="line"><span class="comment">// reference from inc/x86.h</span></div><div class="line">lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line"><span class="comment">// drop into user mode</span></div><div class="line">env_pop_tf(&amp;(e-&gt;env_tf));</div><div class="line"></div><div class="line"><span class="comment">// panic("env_run not yet implemented");</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>成功进入用户环境后，若用户环境尝试使用<code>int</code>指令进行系统调用时，将产生错误，因为JOS没有设置任何从用户空间进入内核的方式。<br>当CPU发现无法处理系统中断调用后，会产生一个通用保护错误，发现无法处理它，然后生成一个二重错误，最终因无法处理而生成一个三重错误并放弃，然后系统重启。但是为了便于调试，patch的<code>qemu</code>不会重启。<br>关于重启的理由可以参考<a href="https://blogs.msdn.microsoft.com/larryosterman/2005/02/08/faster-syscall-trap-redux/" target="_blank" rel="external">这里</a>。</p>
</blockquote>
<p>完成后经过测试，程序在<code>int $0x30</code>处Triple Fault，可知本部分代码基本正确。</p>
<h4 id="处理中断和异常"><a href="#处理中断和异常" class="headerlink" title="处理中断和异常"></a>处理中断和异常</h4><p>练习3要求阅读Intel 80386编程手册中的<a href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/c09.htm" target="_blank" rel="external">第九章：异常和中断</a>。</p>
<p>本实验中将沿用Intel关于中断和异常的术语。中断是由处理器以外的异步事件引发的，而异常是由当前正在执行的指令同步引发的。</p>
<h4 id="保护控制转移基础"><a href="#保护控制转移基础" class="headerlink" title="保护控制转移基础"></a>保护控制转移基础</h4><p>异常和中断均为“保护控制转移”，会引发处理器从用户到内核模式（CPL=0），从而避免给用户模式的代码干扰内核或是其他环境的机会。这要求了引发中断或者是异常的代码不能选择进入内核的地点或方式。<br>在x86中，主要有两种机制一起保证了内核总是在受保护的情况下进入，这两种机制为中断描述符表（Interrupt Descriptor Table）和任务状态段（Task State Segment）。</p>
<p>中断描述符表中，处理器保证了异常和中断仅能导致内核在若干个具体的、由内核明确定义好的入口执行，而不是在中断和异常发生时运行的代码。<br>x86允许最多设立256个不同的中断或异常入口，每一个入口都具有一个中断向量。中断向量为0-255的数字，中断向量由中断来源决定：不同的设备，错误条件和应用程序对内核的请求会产生不同向量的中断。CPU使用中断向量作为处理器的中断描述符表的索引。中断描述符表在内核私有的内存中建立。<br>处理器从该表中加载送入EIP寄存器的值（处理程序的入口），以及送入CS段寄存器的值（包括了特权级，在JOS中，所有的异常均在内核模式执行，即特权级0）。</p>
<p>任务状态段。处理器需要在唤醒处理程序前将在中断或异常发生前的旧的处理器状态保存起来，如旧的EIP寄存器值和旧的CS段寄存器值，以便处理程序之后能恢复现场，从中断或异常发生的地方继续执行。然而，保存旧的处理器状态的区域必须对于非特权的用户模式代码处于被保护的状态。否则，错误的或是恶意的用户代码可能会破坏内核。<br>因此，当x86处理器从用户模式特权级切换到内核模式时，其也会切换到内核内存中的一个栈。任务状态段指定了相应的段寄存器以及相应栈的地址。处理器将<code>SS</code>, <code>EFLAGS</code>, <code>CS</code>, <code>EIP</code>以及一个可选的错误码压入这个新栈中。然后从中断描述符中读取相应的<code>CS</code>和<code>EIP</code>，并设置<code>ESP</code>和<code>SS</code>指向新的栈。<br>尽管<code>TSS</code>有着多种作用，JOS仅用它来定义从用户模式切换到内核模式时的内核栈。因为JOS中的内核模式为x86的特权级0，故处理器仅使用<code>TSS</code>的<code>ESP0</code>和<code>SS0</code>域。</p>
<h4 id="异常和中断的类型"><a href="#异常和中断的类型" class="headerlink" title="异常和中断的类型"></a>异常和中断的类型</h4><p>x86处理器能产生的所有同步异常均使用了0-31的中断向量，映射为<code>IDT</code>的0-31号入口。超过31的中断向量仅供由<code>int</code>指令或是由异步硬件中断产生的“软中断”使用。</p>
<h4 id="嵌套异常和中断"><a href="#嵌套异常和中断" class="headerlink" title="嵌套异常和中断"></a>嵌套异常和中断</h4><p>处理器能同时处理内核模式和用户模式的异常。在内核模式中的异常不需要切换栈，因此，不需要压入旧的<code>SS</code>和<code>ESP</code>值。通过这种方式，内核可以优雅地处理内核产生的嵌套异常和中断。该能力对于实现保护是非常重要的。</p>
<p>若处理器已经在内核模式中并且接受了一个异常并且无法将旧值压入内核栈中时（如内存不足），那么，处理器将无论如何也无法恢复，只能重启。内核必须设计良好以避免这种情况发生。</p>
<h4 id="建立IDT表"><a href="#建立IDT表" class="headerlink" title="建立IDT表"></a>建立IDT表</h4><p>由于JOS中使用的为IA_32的陷阱码，更推荐参考<a href="https://pdos.csail.mit.edu/6.828/2017/readings/ia32/IA32-3A.pdf" target="_blank" rel="external">IA_32的第五章</a>。</p>
<p>练习4中遇到的问题如下：</p>
<ul>
<li>设置陷阱门时段选择子应当为<code>GD_KT</code>而不是<code>GD_KD</code>，因为错误处理函数均被链接至了内核的<code>text</code>段。</li>
<li>已存在<code>page_fault_handler</code>的函数，命名时需避免重名。</li>
<li>不能直接用立即数设置段寄存器。</li>
</ul>
<p>练习4的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In trapentry.S:</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Lab 3: Your code here for generating entry points for the different traps.</div><div class="line"> */</div><div class="line"></div><div class="line">TRAPHANDLER_NOEC(divide_error_handler, T_DIVIDE)</div><div class="line">TRAPHANDLER_NOEC(debug_exception_handler, T_DEBUG)</div><div class="line">TRAPHANDLER_NOEC(non_maskable_interrupt_handler, T_NMI)</div><div class="line">TRAPHANDLER_NOEC(breakpoint_handler, T_BRKPT)</div><div class="line">TRAPHANDLER_NOEC(overflow_handler, T_OFLOW)</div><div class="line">TRAPHANDLER_NOEC(bounds_check_handler, T_BOUND)</div><div class="line">TRAPHANDLER_NOEC(invalid_opcode_handler, T_ILLOP)</div><div class="line">TRAPHANDLER_NOEC(device_not_available_handler, T_DEVICE)</div><div class="line">TRAPHANDLER(double_fault_handler, T_DBLFLT)</div><div class="line">TRAPHANDLER(invalid_tss_handler, T_TSS)</div><div class="line">TRAPHANDLER(segment_not_present_handler, T_SEGNP)</div><div class="line">TRAPHANDLER(stack_exception_handler, T_STACK)</div><div class="line">TRAPHANDLER(general_protection_fault_handler, T_GPFLT)</div><div class="line">TRAPHANDLER(pagefault_handler, T_PGFLT)</div><div class="line">TRAPHANDLER_NOEC(floating_point_error_handler, T_FPERR)</div><div class="line">TRAPHANDLER(alignment_check_handler, T_ALIGN)</div><div class="line">TRAPHANDLER_NOEC(machine_check_handler, T_MCHK)</div><div class="line">TRAPHANDLER_NOEC(simd_floating_point_error_handler, T_SIMDERR)</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Lab 3: Your code here for _alltraps</div><div class="line"> */</div><div class="line"></div><div class="line">_alltraps:</div><div class="line"><span class="comment">// push ds and es and general registers</span></div><div class="line">push %ds</div><div class="line">push %es</div><div class="line">pushal</div><div class="line"></div><div class="line"><span class="comment">// load ds and es with GD_KD, for kernel stack locates in data</span></div><div class="line">mov $GD_KD, %ax</div><div class="line">mov %ax, %ds</div><div class="line">mov %ax, %es</div><div class="line"></div><div class="line"><span class="comment">// pass tf as an argument</span></div><div class="line">pushl %esp</div><div class="line"></div><div class="line"><span class="comment">// call trap and no need to return</span></div><div class="line">call trap</div><div class="line"></div><div class="line"><span class="comment">// In trap.c, trap_init():</span></div><div class="line"></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// declare of exception handler</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide_error_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug_exception_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">non_maskable_interrupt_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">breakpoint_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bounds_check_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalid_opcode_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_not_available_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">double_fault_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalid_tss_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">segment_not_present_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">stack_exception_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">general_protection_fault_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pagefault_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">floating_point_error_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">alignment_check_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">machine_check_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">simd_floating_point_error_handler</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// set up trap gate descriptor</span></div><div class="line">SETGATE(idt[T_DIVIDE],	 <span class="number">1</span>, GD_KT, divide_error_handler,           	   <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_DEBUG],    <span class="number">1</span>, GD_KT, debug_exception_handler,            <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_NMI],      <span class="number">1</span>, GD_KT, non_maskable_interrupt_handler,     <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_BRKPT],    <span class="number">1</span>, GD_KT, breakpoint_handler,                 <span class="number">3</span>);</div><div class="line">SETGATE(idt[T_OFLOW],    <span class="number">1</span>, GD_KT, overflow_handler,                   <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_BOUND],    <span class="number">1</span>, GD_KT, bounds_check_handler,               <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_ILLOP],    <span class="number">1</span>, GD_KT, invalid_opcode_handler,             <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_DEVICE],   <span class="number">1</span>, GD_KT, device_not_available_handler,       <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_DBLFLT],   <span class="number">1</span>, GD_KT, double_fault_handler,               <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_TSS],      <span class="number">1</span>, GD_KT, invalid_tss_handler,                <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_SEGNP],    <span class="number">1</span>, GD_KT, segment_not_present_handler,        <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_STACK],    <span class="number">1</span>, GD_KT, stack_exception_handler,            <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_GPFLT],    <span class="number">1</span>, GD_KT, general_protection_fault_handler,   <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_PGFLT],    <span class="number">1</span>, GD_KT, pagefault_handler,                  <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_FPERR],    <span class="number">1</span>, GD_KT, floating_point_error_handler,       <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_ALIGN],    <span class="number">1</span>, GD_KT, alignment_check_handler,            <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_MCHK],     <span class="number">1</span>, GD_KT, machine_check_handler,              <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_SIMDERR],  <span class="number">1</span>, GD_KT, simd_floating_point_error_handler,  <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>问题1：<br>若是使用同一个处理程序，将无法限制调用错误处理程序的代码的特权级，也无法得知中断向量的值。</p>
<p>问题2：<br>仅有内核代码允许执行页错误处理程序，尽管调用了<code>int $14</code>，仍然因为保护机制而生成了中断向量13。如果内核允许<code>int $14</code>唤醒页错误处理程序，那么恶意的程序可以因此而随意触发缺页错误，导致系统无法正常工作。</p>
<h3 id="第二部分-Page-Faults-Breakpoints-Exceptions-and-System-Calls-页错误，断点异常和系统调用"><a href="#第二部分-Page-Faults-Breakpoints-Exceptions-and-System-Calls-页错误，断点异常和系统调用" class="headerlink" title="第二部分 Page Faults, Breakpoints Exceptions, and System Calls - 页错误，断点异常和系统调用"></a>第二部分 Page Faults, Breakpoints Exceptions, and System Calls - 页错误，断点异常和系统调用</h3><h4 id="处理页错误"><a href="#处理页错误" class="headerlink" title="处理页错误"></a>处理页错误</h4><p>页错误的中断向量号为14，是非常重要的异常。当处理器接收一个页错误时，会将引发页错误的线性地址存储在处理器控制寄存器<code>CR2</code>中。</p>
<p>练习5的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In trap_dispatch():</span></div><div class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_PGFLT) &#123;</div><div class="line">    <span class="comment">// dispatch page fault exceptions</span></div><div class="line">    page_fault_handler(tf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="断点异常"><a href="#断点异常" class="headerlink" title="断点异常"></a>断点异常</h4><p>断点异常的中断向量号为3，通常被调试器用作向程序代码中添加断点，原理是将程序中的某一条指令暂时改为1字节的<code>int3</code>的软中断指令。在JOS中，将大量使用这一异常来实现一个原始的伪系统调用，使得用户环境可以使用它来环境JOS内核监视器，可以把内核监视器看做一个原始的调试器。<br>用户模式的<code>panic</code>，就是通过显示panic消息后执行<code>int3</code>实现的。</p>
<p>练习6的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_BRKPT) &#123;</div><div class="line">    <span class="comment">// dispatch breakpoint exceptions</span></div><div class="line">    monitor(tf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>问题3：<br>若是用特权级0初始化断点异常的IDT，那么会触发通用保护错误，这是因为用户模式的代码无法执行特权级0（内核模式）的处理程序，需要用特权级3初始化断点异常的IDT，这样才能使得断点测试正确通过。</p>
<p>问题4：<br>这些措施都是为了保护内核和用户环境的相互独立，使得用户环境仅能在收到允许的情况下执行某些内核的代码，保证了恶意程序不会破坏内核，窃取数据。同时也能保证用户环境能从内核得到必要的功能支持。</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>用户进程通过系统调用请求内核为它工作。当用户进程唤醒系统调用时，处理器进入内核模式，处理器和内核合作保存用户进程状态，内核执行合适的代码完成系统调用，并恢复至用户进程。系统调用的具体实现随平台不同而不同。</p>
<p>JOS内核使用<code>int $0x30</code>作为系统调用。需要建立相关的中断描述符，注意中断向量<code>0x30</code>不可能由硬件生成，毫无疑问应该允许用户执行对应的处理程序。</p>
<p>应用程序会将系统调用号和系统调用参数存入寄存器中。避免了内核访问用户环境栈或是指令流。系统调用号放在寄存器<code>%eax</code>中，最多五个参数分别被相应地放在寄存器<code>%edx</code>, <code>%ecx</code>, <code>%ebx</code>, <code>%edi</code>和<code>%esi</code>中。内核将返回值放在寄存器<code>%eax</code>中。唤醒系统调用的汇编代码已经提供为<code>lib/syscall.c</code>中的<code>syscall()</code>。</p>
<p>练习7中遇到的问题如下：</p>
<ul>
<li>syscall作为软中断不会压入错误码</li>
<li>调用syscall函数时应当使用保存的栈帧中的寄存器值而非实际的寄存器值，原因是在函数调用间某些寄存器的值会发生改变</li>
<li>练习7需要参考<code>lib/syscall.c</code>中得知参数的位置关系</li>
</ul>
<p>练习7的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In trapentry.S:</span></div><div class="line">TRAPHANDLER_NOEC(syscall_handler, T_SYSCALL)</div><div class="line"></div><div class="line"><span class="comment">// In trap.c, trap_init():</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_handler</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KT, syscall_handler, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="comment">// In kern/syscall.c, syscall():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"></div><div class="line"><span class="comment">// panic("syscall not implemented");</span></div><div class="line"></div><div class="line"><span class="keyword">switch</span> (syscallno) &#123;</div><div class="line">    <span class="keyword">case</span> SYS_cputs:</div><div class="line">        <span class="comment">// call sys_cputs</span></div><div class="line">        sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, (<span class="keyword">size_t</span>)a2);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> SYS_cgetc:</div><div class="line">        <span class="comment">// cll sys_cgetc</span></div><div class="line">        <span class="keyword">return</span> sys_cgetc();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> SYS_getenvid:</div><div class="line">        <span class="comment">// call sys_getenvid</span></div><div class="line">        <span class="keyword">return</span> sys_getenvid();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> SYS_env_destroy:</div><div class="line">        <span class="comment">// call sys_env_destroy</span></div><div class="line">        <span class="keyword">return</span> sys_env_destroy((<span class="keyword">envid_t</span>)a1);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> -E_INVAL;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// will not reach here</span></div><div class="line"><span class="keyword">return</span> -E_UNSPECIFIED;</div></pre></td></tr></table></figure></p>
<h4 id="用户模式启动"><a href="#用户模式启动" class="headerlink" title="用户模式启动"></a>用户模式启动</h4><p>一个用户在<code>lib/entry.S</code>的顶部开始运行，经过某些设置后，代码调用<code>lib/libmain.c</code>。你应当修改<code>libmain()</code>以初始化指向当前环境的<code>struct Env</code>指针<code>thisenv</code>（注意到<code>lib/entry.S</code>已经定义了指向你在第一部分映射的<code>UENVS</code>的<code>envs</code>）。</p>
<p><code>libmain()</code>然后调用<code>umain</code>，对于hello程序而言，位于<code>user/hello.c</code>中。在打印<code>hello, world</code>后，它尝试访问<code>thisenv-&gt;env_id</code>。这也是为什么hello程序会出现<code>fault</code>。</p>
<p>练习8中遇到的问题如下：</p>
<ul>
<li>可以使用宏<code>ENVX</code>从<code>envid</code>得到<code>env</code>在<code>envs</code>中的偏移量，而无需遍历整个<code>envs</code></li>
<li>Lab2中<code>pgdir_walk</code>未设置<code>PTE_U</code>导致访问时出现了页错误（仅有PTE项中设置<code>PTE_U</code>是不足的）。</li>
</ul>
<p>练习8的答案如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In libmain.c, libmain():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// get env id use system call and use ENVX to get index</span></div><div class="line">thisenv = envs + ENVX(sys_getenvid());</div></pre></td></tr></table></figure></p>
<h4 id="页错误和内存保护"><a href="#页错误和内存保护" class="headerlink" title="页错误和内存保护"></a>页错误和内存保护</h4><p>内存保护是操作系统的重要特性，保证了一个程序的错误不会毁坏内核或是其他的程序。<br>操作系统通常和硬件一起实现内存保护。操作系统负责告知硬件哪些虚拟地址是有效的、哪些是无效的。当一个程序试图去访问一个无效的地址或是一个没有权限的地址时，处理器在引起错误的指令处停止程序，然后带着相应的信息陷入内核。若错误可修复，则内核修复该错误并继续执行程序；若错误不可恢复，则程序无法继续运行。<br>现在考虑系统调用，系统调用允许用户程序向内核传递指针，内核在处理系统调用时将指针解引用，会出现以下两种问题：</p>
<ol>
<li>内核的缺页错误潜在地比用户程序的缺页更加严重。若内核在操作私有的数据结构时发生缺页，那么将是内核自己的漏洞，错误处理程序应当panic内核。然而当内核解引用用户程序传递的指针时，需要某种方式标记由解引用导致的缺页实际上代表的是用户程序的利益。</li>
<li>内核比用户程序具有更多的权限。在这种情况下，用户程序可能传递给内核一个指针，该指针指向的内存只能被内核读写而不能被用户程序读写。在这种情况下，内核不能对该指针解引用，这么做会暴露私有数据或是破坏内核完整性。</li>
</ol>
<p>当内核处理用户程序传递的指针时必须非常小心。内核必须检查用户传入的指针。</p>
<p>练习9和练习10遇到的问题如下：</p>
<ul>
<li>需要获取段寄存器的最低两位以得到段特权级</li>
</ul>
<p>练习9和练习10的答案如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In kern/trap.c, page_fault_handler():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// code that causes page fault in kernel mode</span></div><div class="line">    panic(<span class="string">"page fault in kernel!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In kern/pmap.c, user_mem_check():</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">user_mem_check</span><span class="params">(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span> </span>&#123;</div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= ULIM) &#123;</div><div class="line">        <span class="comment">// condition 1 - below ULIM violated</span></div><div class="line">        user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va;</div><div class="line">        <span class="keyword">return</span> -E_FAULT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">uintptr_t</span> va_start = (<span class="keyword">uintptr_t</span>)ROUNDDOWN(va, PGSIZE);</div><div class="line">    <span class="keyword">uintptr_t</span> va_end   = (<span class="keyword">uintptr_t</span>)ROUNDUP(va + len, PGSIZE);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (; va_start &lt; va_end; va_start += PGSIZE) &#123;</div><div class="line">        <span class="comment">// note we set page directory entry with less restrict</span></div><div class="line">        <span class="comment">// we will only test page table entry here</span></div><div class="line">        <span class="keyword">pte_t</span> *pgtable_entry_ptr =</div><div class="line">            pgdir_walk(env-&gt;env_pgdir, (<span class="keyword">char</span> *)va_start, <span class="literal">false</span>);</div><div class="line">        <span class="keyword">if</span> ((*pgtable_entry_ptr &amp; (perm | PTE_P)) != (perm | PTE_P)) &#123;</div><div class="line">            <span class="comment">// condition 2 - permission violated</span></div><div class="line">            <span class="keyword">if</span> (va_start &lt;= (<span class="keyword">uintptr_t</span>)va) &#123;</div><div class="line">                <span class="comment">// va lie in the first page and not aligned, return va</span></div><div class="line">                user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (va_start &gt;= (<span class="keyword">uintptr_t</span>)va + len) &#123;</div><div class="line">                <span class="comment">// va lie in the last page and exceed va + len, return va + len</span></div><div class="line">                user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va + len;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// return corresponding page's initial address</span></div><div class="line">                user_mem_check_addr = va_start;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> -E_FAULT;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// pass user memory check</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In kern/syscall.c, syscall():</span></div><div class="line"><span class="keyword">case</span> SYS_cputs:</div><div class="line">    <span class="comment">// checks memory before use sys_cputs to dereference a1</span></div><div class="line">    user_mem_assert(curenv, (<span class="keyword">char</span> *)a1, (<span class="keyword">size_t</span>)a2, PTE_U);</div><div class="line">    <span class="comment">// call sys_cputs</span></div><div class="line">    sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, (<span class="keyword">size_t</span>)a2);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line"><span class="comment">// In kern/kdebug.c, debuginfo_eip():</span></div><div class="line"><span class="comment">// Make sure this memory is valid.</span></div><div class="line"><span class="comment">// Return -1 if it is not.  Hint: Call user_mem_check.</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="keyword">if</span> (user_mem_check(curenv, usd, <span class="keyword">sizeof</span>(struct UserStabData), PTE_U) &lt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Make sure the STABS and string table memory is valid.</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="keyword">if</span> ((user_mem_check(curenv, stabs, stab_end - stabs, PTE_U) &lt; <span class="number">0</span>) ||</div><div class="line">    (user_mem_check(curenv, stabstr, stabstr_end - stabstr, PTE_U) &lt; <span class="number">0</span>)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发生了页错误的原因还要观察<code>memlayout.h</code>，在<code>USTACKTOP</code>上方有一个位于<code>0xeebfd000</code>的<code>Empty Memory</code>，该虚拟地址没有映射任何的物理页。而在<code>mon_backtrace</code>的最后，访问到了位于此处的虚拟地址，因而导致了一个不可处理的页错误。</p>
<h2 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h2><p>最终执行<code>make grade</code>，评分脚本的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">divzero:</div><div class="line">$ make run-divzero-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.3s)</div><div class="line">softint:</div><div class="line">$ make run-softint-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">badsegment:</div><div class="line">$ make run-badsegment-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">Part A score: 30/30</div><div class="line">faultread:</div><div class="line">$ make run-faultread-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">faultreadkernel:</div><div class="line">$ make run-faultreadkernel-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (0.9s)</div><div class="line">faultwrite:</div><div class="line">$ make run-faultwrite-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">faultwritekernel:</div><div class="line">$ make run-faultwritekernel-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">breakpoint:</div><div class="line">$ make run-breakpoint-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (2.0s)</div><div class="line">testbss:</div><div class="line">$ make run-testbss-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (2.1s)</div><div class="line">hello:</div><div class="line">$ make run-hello-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">buggyhello:</div><div class="line">$ make run-buggyhello-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.8s)</div><div class="line">buggyhello2:</div><div class="line">$ make run-buggyhello2-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (2.1s)</div><div class="line">evilhello:</div><div class="line">$ make run-evilhello-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.1s)</div><div class="line">Part B score: 50/50</div><div class="line">Score: 80/80</div></pre></td></tr></table></figure><br>至此，实验三结束。</p>
<p>第三个实验的难度明显比实验一和实验二大。<br>用户环境的管理相对简单，而设置陷阱和中断的部分涉及大量的x86硬件知识，需要大量参考Intel手册，要求直接写汇编代码设置栈帧也颇有挑战。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 页 共 1 页</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 CoSidian. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">CoSidian</h4>
        
            <div id="about-card-bio"><p>码龙黑曜 - iOS开发者/计算机科学/兽人控</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>本科在读</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                HUST, Wuhan, China
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-i7zzex3jvqnxdf0lp2pg3bcyurjikigtrw9ljle5skc4mit2m7a13rwuyp8g.min.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
