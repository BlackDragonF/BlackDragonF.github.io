
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="码龙的窝">
    <title>标签: 进程间通信 - 码龙的窝</title>
    <meta name="author" content="CoSidian">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="/* 0与1之风吹遍山谷 */">
<meta property="og:type" content="blog">
<meta property="og:title" content="码龙的窝">
<meta property="og:url" content="http://blog.codedragon.tech/tags/进程间通信/index.html">
<meta property="og:site_name" content="码龙的窝">
<meta property="og:description" content="/* 0与1之风吹遍山谷 */">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="码龙的窝">
<meta name="twitter:description" content="/* 0与1之风吹遍山谷 */">
    
    
        
    
    
        <meta property="og:image" content="http://blog.codedragon.tech/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-gtvt1lbvzeqmr99zec4y42qrxw5ogq1gul5orw7somyh6cv5ckqsrl4abr9a.min.css">
    <!--STYLES END-->
    
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-108458894-1', 'auto');
        ga('send', 'pageview');
    </script>


    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">码龙的窝</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">CoSidian</h4>
                
                    <h5 class="sidebar-profile-bio"><p>码龙黑曜 - iOS开发者/计算机科学/兽人控</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="首页"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="分类"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="标签"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="归档"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/projects"
                            
                            title="项目"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-code" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">项目</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/about"
                            
                            title="关于"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/BlackDragonF" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://t.me/Cosidian" target="_blank" rel="noopener" title="Telegram">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-paper-plane" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Telegram</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://steamcommunity.com/id/BlackDragonF/" target="_blank" rel="noopener" title="Steam">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-steam" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Steam</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:obsidiandragon2016@gmail.com" target="_blank" rel="noopener" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/friendly-links"
                            
                            title="友情链接"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-link" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">友情链接</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/book-recommend"
                            
                            title="图书推荐"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-book" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">图书推荐</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/">
                            MIT6.828操作系统工程Lab4-Preemptive Multitasking实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-02-26T16:52:56+08:00">
	
		    2月 26, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <blockquote>
<p>Lab4 - Preemptive Multitasking需要在多个同时激活的用户模式环境中实现抢占式多任务。<br>实验分为三个部分。第一部分要求为JOS添加多处理器支持，并实现论询调度以及基本的环境管理系统调用；第二部分需要实现一个Unix-like的fork函数，使得用户环境可以创建一份自己的拷贝；第三部分需要实现进程间通讯功能，允许不同的用户环境显式地互相通信和同步。同时还需要实现对于硬件时钟中断和抢占的支持。<br>2018年3月2日，完成了实验并写完了报告。</p>
</blockquote>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p> 根据官网，切换到分支lab4并合并分支lab3。在合并的过程中，发生了冲突。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user% git checkout -b lab3 origin/lab3</div><div class="line">user% git merge lab3</div></pre></td></tr></table></figure>
<p> 根据提示，是<code>conf/lab.mk</code>中发生了冲突。打开后可以发现是其中记录的时间和实验数发生了变化，直接采用分支lab4的版本即可，然后提交，分支合并完成。</p>
<p> 实验四包括如下的新文件：</p>
<ul>
<li>kern/cpu.h 内核私有的关于多处理器的支持</li>
<li>kern/mpconfig.c 读取多处理器配置的代码</li>
<li>kern/lapic.c 内核驱动每个处理的的APIC（高级可编程中断控制器）的代码</li>
<li>kern/mpentry.S 非引导CPU的汇编入口代码</li>
<li>kern/spinlock.h 内核私有的自旋锁定义，包括大内核锁</li>
<li>kern/spinlock.c 内核实现自旋锁的代码</li>
<li>kern/sched.c 需要实现的调度器的代码框架</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="第一部分-Multiprocessor-Support-and-Cooperative-Multitasking-多处理器支和写作式多任务"><a href="#第一部分-Multiprocessor-Support-and-Cooperative-Multitasking-多处理器支和写作式多任务" class="headerlink" title="第一部分 Multiprocessor Support and Cooperative Multitasking - 多处理器支和写作式多任务"></a>第一部分 Multiprocessor Support and Cooperative Multitasking - 多处理器支和写作式多任务</h3><p>在第一部分中，需要使JOS运行在一个多处理器系统上，并且实现新的JOS内核系统调用去允许用户级别的环境创建额外的新环境。还需要实现协同式的论询调度，允许内核当旧的用户环境自愿放弃CPU或退出时切换至一个新的用户环境。</p>
<h4 id="多处理器支持"><a href="#多处理器支持" class="headerlink" title="多处理器支持"></a>多处理器支持</h4><p>需要使JOS支持“对称多处理”（Symmetric Multiprocessing），在该模型下，所有的CPU都有着对系统资源（内存、IO总线等）的平等访问权。尽管在SMP下所有的CPU在功能上均等价，在启动时仍然分为两种类型——引导处理器（Bootstrap Processor或是BSP）负责初始化系统并且引导操作系统；应用处理器（Application Processors或是APs）仅在系统启动运行后被BSP激活。BSP处理器由硬件和BIOS决定。在此刻，所有已有的代码已经运行在了BSP上。</p>
<p>在SMP中，每一个CPU都有一个相伴的本地APIC（LAPIC）单元。LAPIC单元负责在整个系统中传递中断。LAPIC为相连的CPU提供了一个唯一标识。在本实验中，将利用LAPIC的一下功能（在<code>kern/lapic.c</code>中）：</p>
<ul>
<li>读取LAPIC标识（APIC ID）以告知CPU代码运行在哪一个CPU上（参考<code>cpunum()</code>）</li>
<li>从BSP向APs发送STARTUP处理器间中断（Interprocessor interrupt或IPI）以唤醒其他CPU（参考<code>lapic_startup()</code>）</li>
<li>在第三部分中，通过编程LAPIC内置的计时器去引发时钟中断以实现抢占式多任务（参考<code>apic_init()</code></li>
</ul>
<p>处理器通过内存映射IO（Memory-mapped I/O 或是MMIO）访问LAPIC。在MMIO中，一部分物理内存被硬连接至某些IO设备的寄存器。所以相同的访问内存的<code>load/store</code>指令可以被用来访问设备寄存器。你可能已经见过了存在于物理地址<code>0xA0000</code>中IO洞（以此来写VGA显示缓存）。LAPIC存在于物理地址从<code>0xFE000000</code>（4064M）开始的洞中。该地址太高以至于无法在KERNBASE的直接映射访问。JOS的虚拟内存映射在<code>MMIOBASE</code>处留下了4MB的空隙。在之后的实验中会引入更多的<code>MMIO</code>区域，所以应当写一个简单的函数从该区域分配空间并映射内存。</p>
<p>练习1的答案如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In kern/pmap.c, mmio_map_region():</span></div><div class="line"><span class="comment">// Your code here:</span></div><div class="line">size = ROUNDUP(size, PGSIZE);</div><div class="line"><span class="keyword">if</span> (base + size &gt; MMIOLIM) &#123;</div><div class="line">    <span class="comment">// reservation overflog MMIOLIM</span></div><div class="line">    panic(<span class="string">"reservation bytes overflows!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// use boot_map_region to map [pa, pa + size) to [base, base + size)</span></div><div class="line">boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_PWT);</div><div class="line"></div><div class="line"><span class="comment">// update base and return</span></div><div class="line"><span class="keyword">uintptr_t</span> saved_base = base;</div><div class="line">base += size;</div><div class="line"><span class="keyword">return</span> (<span class="keyword">char</span> *)saved_base;</div><div class="line"></div><div class="line"><span class="comment">// panic("mmio_map_region not implemented");</span></div></pre></td></tr></table></figure></p>
<h5 id="应用处理器引导"><a href="#应用处理器引导" class="headerlink" title="应用处理器引导"></a>应用处理器引导</h5><p>BSP在引导APs之前应当首先收集多处理器系统的信息，如总CPU数，APIC IDs以及LAPIC单元的内存映射IO地址等。<code>kern/mpconfig.c</code>中的<code>mp_init()</code>函数通过读取BIOS内存中的MP配置表获取相应的信息。<br>在<code>kern/init.c</code>中的<code>boot_aps()</code>函数驱动AP引导过程。APs在实模式中启动，所以<code>boot_aps()</code>从<code>kern/mpentry.S</code>中拷贝AP入口代码到一个实模式可寻址的位置。可以在一定程度上控制AP执行开始代码的位置。在本实验中，将入口代码拷贝至<code>0x7000</code>（MPENTRY_PADDR），但实际上任何640KB以下的、页对齐的和未使用的物理地址均可使用。<br>然后，<code>boot_aps()</code>通过向对应AP的LAPIC单元发送STARTUP处理器间中断和初始的CS:IP地址（本实验中为MPENTRY_PADDR），依次激活APs。在简单的设置后，将AP启动分页，使得AP进入保护模式，然后调用启动例程<code>mp_main()</code>（在<code>kern/init.c</code>中。<code>boot_aps()</code>在唤醒下一个AP之前先等待当前AP在<code>struct CpuInfo</code>的<code>cpu_status</code>域中发送一个<code>CPU_STARTED</code>标记。<br>AP引导的汇编代码和C代码同实验一BSP的引导代码相似，可以比对异同。</p>
<p>练习2的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In kern/pmap.c, page_init():</span></div><div class="line"><span class="comment">// code MODIFIED</span></div><div class="line"><span class="keyword">size_t</span> i;</div><div class="line"></div><div class="line"><span class="comment">// initialize from page 1 to page npages_basemem - 1</span></div><div class="line"><span class="comment">// set pp_ref to 0, set pp_link to last page_free_list</span></div><div class="line"><span class="comment">// and then update page_free_list</span></div><div class="line"></div><div class="line"><span class="comment">// Lab 4: remove page at MPENTRY_PADDR</span></div><div class="line"><span class="keyword">size_t</span> mp_entry_page = PGNUM(MPENTRY_PADDR);</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; npages_basemem ; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (i == mp_entry_page) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    pages[i].pp_ref = <span class="number">0</span>;</div><div class="line">    pages[i].pp_link = page_free_list;</div><div class="line">    page_free_list = &amp;pages[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>问题1：<br>宏<code>MPBOOTPHYS</code>作用是将给定的内核虚拟地址（在<code>mpentry.S</code>中）转换成相应的加载后的物理地址。这么做的原因是在<code>mpentry.S</code>中，保护模式与分页机制尚未开启，设置分段等需要知道相应的物理地址。</p>
<h5 id="每CPU状态和初始化"><a href="#每CPU状态和初始化" class="headerlink" title="每CPU状态和初始化"></a>每CPU状态和初始化</h5><p>当编写多处理器操作系统时，区分对于每个处理器而言私有的每CPU状态以及整个系统共享的全局状态是很重要的。<code>kern/cpu.h</code>定义了大部分每CPU状态，包括了存储了每CPU变量的<code>struct CpuInfo</code>。<code>cpunum()</code>总是返回调用它的CPU ID，能用来索引例如<code>cpus</code>的数组。宏<code>thiscpu</code>是当前CPU的<code>struct CpuInfo</code>的简写。</p>
<p>以下是你需要注意的每CPU状态：</p>
<ul>
<li>每CPU内核栈 - 多个CPU可能会同时陷入内核，因此每个处理器需要独立的内核栈以避免互相干扰。<code>percpu_kstacks[NCPU][KSTKSIZE]</code>为<code>NCPU</code>个内核栈预留空间。在实验二中，将<code>bootstack</code>指向的物理内存作为BSP的栈映射在了KSTACKTOP下面。相似地，本实验中，需要将每个CPU的内核栈映射到该区域同时分配保护页作为它们之间的缓冲。CPU 0的栈将从KSTACKTOP开始向下增长；CPU 1的栈将从CPU 0栈下方间隔KSTKGAP处开始增长。<code>inc/memlayout.h</code>展示了映射约束。</li>
<li>每CPU的TSS和TSS描述符 - 每CPU的任务状态段同样用来致命每个CPU内核栈的位置。CPU i的TSS被存储于<code>cpus[i].cpu_ts</code>中，相应的TSS描述符在GDT入口<code>gdt[(GD_TSS0 &gt;&gt; 3) + i]</code>处被定义。<code>kern/trap.c</code>中定义的<code>ts</code>将不再有效。</li>
<li>每CPU的当前环境指针 - 由于每个CPU都能同步地执行不同的用户环境。重新将<code>curenv</code>定义为指向当前CPU（当前代码正在执行的CPU）正在执行的环境的<code>cpus[cpunum()].cpu_env</code>（或是<code>thiscpu-&gt;cpu_env</code>）。</li>
<li>每CPU的系统寄存器 - 包括系统寄存器在内的所有寄存器都属于CPU私有。因此初始化这些寄存器的指令如<code>lcr3</code>, <code>ltr</code>, ‘lgdt’等，必须在每个CPU上都被执行。函数<code>env_init_percpu()</code>以及<code>trap_init_percpu</code>正是为此而被定义。</li>
</ul>
<p>除此之外任何额外的用来CPU初始化的所有每CPU状态都应该在每个CPU处重复。</p>
<p>练习3中遇到的问题：</p>
<ul>
<li>在使用boot_map_region映射内存时忘记将kstacktop_i减去KSTKSIZE，导致未通过检查</li>
</ul>
<p>练习3的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LAB 4: Your code here:</span></div><div class="line"><span class="keyword">size_t</span> i;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</div><div class="line">    <span class="comment">// traverser through 0 to NCPU to use boot_map_region to map</span></div><div class="line">    <span class="comment">// per-CPU's kernel stack to corresponding va</span></div><div class="line">    <span class="keyword">uintptr_t</span> kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);</div><div class="line">    boot_map_region(kern_pgdir, kstacktop_i - KSTKSIZE, KSTKSIZE,</div><div class="line">                    PADDR(percpu_kstacks[i]), PTE_W | PTE_P);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>练习4中遇到的问题：</p>
<ul>
<li>使用ltr加载任务段选择子时，每个CPU应当使用不同的选择子，<code>inc/memlayout.c</code>中的GD_TSS0为CPU0的任务段选择子，应该加上i &lt;&lt; 3的偏移</li>
<li>完成<code>trap_init_percpu()</code>后，旧的使用<code>ts</code>的代码应当被注释</li>
</ul>
<p>练习4的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LAB 4: Your code here:</span></div><div class="line"><span class="comment">// trap_init_percpu() is called by all CPUs</span></div><div class="line"><span class="comment">// set esp0 and ss0 of task state segment to provide</span></div><div class="line"><span class="comment">// per-CPU's kernel stack access</span></div><div class="line">thiscpu-&gt;cpu_ts.ts_esp0 = (<span class="keyword">uintptr_t</span>)percpu_kstacks[cpunum()];</div><div class="line">thiscpu-&gt;cpu_ts.ts_ss0  = GD_KD;</div><div class="line"><span class="comment">// set IO map base address to prevent unauthorized environments</span></div><div class="line"><span class="comment">// this line works together as we'll set TSS segment limit later</span></div><div class="line"><span class="comment">// so all ports in address space have no corresponding IOPB</span></div><div class="line">thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</div><div class="line"></div><div class="line"><span class="comment">// set TSS in gdt</span></div><div class="line"><span class="comment">// 0 means RPL and sd_s = 0 means system segment</span></div><div class="line">gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>)(&amp;(thiscpu-&gt;cpu_ts)),</div><div class="line">                                       <span class="keyword">sizeof</span>(struct Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpunum()].sd_s = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// Load TSS selector</span></div><div class="line">ltr(GD_TSS0 + (cpunum() &lt;&lt; <span class="number">3</span>));</div><div class="line"></div><div class="line"><span class="comment">// load the IDT</span></div><div class="line">lidt(&amp;idt_pd);</div></pre></td></tr></table></figure></p>
<h5 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h5><p>当前的代码在<code>mp_main()</code>中初始化完AP之后忙等待。在继续下一步之前，首先得解决多个CPU同时执行内核代码时的竞争条件。最简答的方式是使用一个“大”内核锁，大内核锁在从用户模式进入内核模式时被获取，在从环境返回用户模式时被释放。在这种模型下，用户模式环境可以在任意多个CPU上运行，但同时只能有一个环境能在内核中运行，其他想在内核中运行的环境被强制等待。</p>
<p><code>kern/spinlock.h</code>声明了内核锁，同时提供了<code>lock_kernel</code>提供加锁的功能；<code>unlock_kernel</code>提供解锁的功能，你应当在如下4个地方应用内核锁：</p>
<ul>
<li>在<code>i386_init()</code>中，在BSP唤醒其他CPU之前加锁</li>
<li>在<code>mp_main()</code>中，在初始化AP后加锁，然后调用<code>sched_yield()</code>去在当前AP上执行环境</li>
<li>在<code>trap()</code>中，当从用户模式陷入的时候加锁，通过检查tf_cs的低位判断陷阱发生于用户模式还是内核模式</li>
<li>在<code>env_run()</code>中，在“刚好”切换回用户模式之前解锁。太早或太晚解锁会导致严重的竞争和死锁</li>
</ul>
<p>练习5的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In i386_init():</span></div><div class="line"><span class="comment">// Acquire the big kernel lock before waking up APs</span></div><div class="line"><span class="comment">// Your code here:</span></div><div class="line">lock_kernel();</div><div class="line"></div><div class="line"><span class="comment">// In mp_main():</span></div><div class="line"><span class="comment">// Now that we have finished some basic setup, call sched_yield()</span></div><div class="line"><span class="comment">// to start running processes on this CPU.  But make sure that</span></div><div class="line"><span class="comment">// only one CPU can enter the scheduler at a time!</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Your code here:</span></div><div class="line"><span class="comment">// lock the kernel and start running enviroments</span></div><div class="line">lock_kernel();</div><div class="line">sched_yield();</div><div class="line"></div><div class="line"><span class="comment">// In trap():</span></div><div class="line"><span class="comment">// Trapped from user mode.</span></div><div class="line"><span class="comment">// Acquire the big kernel lock before doing any</span></div><div class="line"><span class="comment">// serious kernel work.</span></div><div class="line"><span class="comment">// LAB 4: Your code here.</span></div><div class="line">lock_kernel();</div><div class="line"></div><div class="line"><span class="comment">// In env_run():</span></div><div class="line"><span class="comment">// address space switch</span></div><div class="line"><span class="comment">// reference from inc/x86.h</span></div><div class="line">lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line"><span class="comment">// release kernel lock here</span></div><div class="line">unlock_kernel(); <span class="comment">// newly added code</span></div><div class="line"><span class="comment">// drop into user mode</span></div><div class="line">env_pop_tf(&amp;(e-&gt;env_tf));</div></pre></td></tr></table></figure></p>
<p>问题2：<br>即使受到内核锁的保护，CPU之间仍然需要独立的内核栈。假设CPU0因中断陷入内核并在内核栈中保留了相关的信息，此时若CPU1也发生中断而陷入内核，在同一个内核栈的情况下，CPU0中的信息将会被覆盖从而导致出现错误。</p>
<h4 id="论询调度"><a href="#论询调度" class="headerlink" title="论询调度"></a>论询调度</h4><p>下一个任务是改变JOS内核使得其能按照“论询”的方式在多个环境中切换。在JOS中，论询调度按如下方式工作：</p>
<ul>
<li>‘kern/sched.c’中的<code>sched_yield()</code>负责选择一个新环境执行。其循环按顺序遍历<code>envs</code>数组，从上一次运行的环境（如果没有之前运行的环境，则从第一个环境）开始，找到第一个具有状态ENV_RUNNABLE的环境，调用<code>env_run()</code>执行。</li>
<li><code>sched_yield()</code>绝对不能同时在两个CPU上运行相同的环境。其会告知环境当前已经正在运行在某CPU上（很可能是当前环境），因为该环境的状态将为ENV_RUNNING。</li>
<li>将实现一个新的系统调用<code>sys_yield()</code>，用户环境可以通过该系统调用唤醒<code>sched_yield()</code>函数以主动放弃CPU。</li>
</ul>
<p>练习6中遇到的问题：</p>
<ul>
<li>在实现<code>sched_yield()</code>的时候没有检查<code>thiscpu-&gt;cpu_env</code>是否为空，对空指针的访问导致了缺页错误</li>
<li>一开始的实现弄错了获取env_index和自增的顺序，参考代码中第一个<code>if</code>处的<code>else</code>分支的注释</li>
<li>练习6结束后需要将<code>init.c</code>中<code>mp_main()</code>的最后一行注释</li>
</ul>
<p>练习6的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In kern/sched.c, sched_yield():</span></div><div class="line"><span class="comment">// LAB 4: Your code here.</span></div><div class="line"><span class="comment">// get index from current CPU's env</span></div><div class="line"><span class="keyword">size_t</span> env_index;</div><div class="line"><span class="comment">// set curenv_flag to default true</span></div><div class="line"><span class="keyword">int</span> curenv_flag = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="keyword">size_t</span> i;</div><div class="line"><span class="keyword">if</span> (thiscpu-&gt;cpu_env == <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="comment">// no previous running environment</span></div><div class="line">    <span class="comment">// start at beginning of envs array</span></div><div class="line">    i         = <span class="number">0</span>;</div><div class="line">    env_index = NENV - <span class="number">1</span>;</div><div class="line">    <span class="comment">// mark curenv_flag as true</span></div><div class="line">    curenv_flag = <span class="literal">false</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// start at previous running environment</span></div><div class="line">    env_index = ENVX(thiscpu-&gt;cpu_env-&gt;env_id);</div><div class="line">    <span class="comment">// NB: don't mess with code order here, must first retrieve</span></div><div class="line">    <span class="comment">// env_index then increment</span></div><div class="line">    i = (env_index == NENV - <span class="number">1</span>) ? <span class="number">0</span> : env_index + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// traverse through envs list to find first ENV_RUNNABLE</span></div><div class="line"><span class="comment">// env</span></div><div class="line"><span class="keyword">for</span> (; i != env_index; i = ((i == NENV - <span class="number">1</span>) ? <span class="number">0</span> : i + <span class="number">1</span>)) &#123;</div><div class="line">    <span class="keyword">if</span> (envs[i].env_status == ENV_RUNNABLE) &#123;</div><div class="line">        <span class="comment">// found, set idle and break from loop</span></div><div class="line">        idle = &amp;envs[i];</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// if idle is NULL and curenv_flag is true,</span></div><div class="line"><span class="comment">// means no envs are runnable and last previous running env is ENV_RUNNING</span></div><div class="line"><span class="comment">// check if last previous environment is ENV_RUNNING,</span></div><div class="line"><span class="comment">// if so, choose it.</span></div><div class="line"><span class="keyword">if</span> (!idle &amp;&amp; curenv_flag &amp;&amp; envs[env_index].env_status == ENV_RUNNING) &#123;</div><div class="line">    idle = &amp;envs[env_index];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (idle) &#123;</div><div class="line">    <span class="comment">// idle env choosed, run it directly</span></div><div class="line">    env_run(idle);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// failed to choose idle env, halt CPU</span></div><div class="line">    <span class="comment">// sched_halt never returns</span></div><div class="line">    sched_halt();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In kern/syscall.c, syscall():</span></div><div class="line"><span class="comment">// code added:</span></div><div class="line"><span class="keyword">case</span> SYS_yield:</div><div class="line">    <span class="comment">// call sys_yield</span></div><div class="line">    sys_yield();</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line"><span class="comment">// In kern/init.c, i386_init():</span></div><div class="line"><span class="comment">// code modified:</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(TEST)</span></div><div class="line">    <span class="comment">// Don't touch -- used by grading script!</span></div><div class="line">    ENV_CREATE(TEST, ENV_TYPE_USER);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="comment">// Touch all you want.</span></div><div class="line">    <span class="comment">// create three user_yield</span></div><div class="line">    <span class="comment">// code MODIFIED here</span></div><div class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</div><div class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</div><div class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>    <span class="comment">// TEST*</span></span></div></pre></td></tr></table></figure></p>
<p>问题3：<br>地址切换前后的页表中，<code>e</code>指向的虚拟地址都被同一块物理页映射。出现这种情况的原因在于<code>env</code>的<code>env_pgdir</code>是以<code>kern_pgdir</code>为原型产生的，<code>e</code>出于UTOP之上的地址，而UTOP以上的地址的映射关系在两个页表中是一样的。</p>
<p>问题4：<br>当发生地址转换时一定是从用户陷入内核之后，无论以何种方式陷入内核，必须要经过<code>kern/trap.c</code>中的<code>trap()</code>函数。观察该函数，可以发现，当从用户模式陷入内核时，代码将内核栈中的<code>tf</code>（包括页表和寄存器等）拷贝至内核间共享的对应的<code>env</code>中，所以之后寄存器状态才能恢复。</p>
<h4 id="环境创建的系统调用"><a href="#环境创建的系统调用" class="headerlink" title="环境创建的系统调用"></a>环境创建的系统调用</h4><p>尽管内核已经可以运行并在不同环境间切换了，但内核任然被限制了只能执行内核初始设置的用户环境。<br>需要实现必要的系统调用使得JOS可以允许用户环境创建和启动其他的用户环境。</p>
<p>Unix提供了<code>fork()</code>作为它的进程创建原语。Unix的<code>fork()</code>拷贝调用进程（父进程）的整个地址空间以创建子进程。<br>从用户空间来看，父子进程唯一可观察的差异就是它们的进程ID和父进程ID（通过<code>gitpid()</code>和<code>getppid()</code>返回。在父进程中，<code>fork()</code>返回子进程ID；在子进程中，<code>fork()</code>返回0。默认情况下，每个进程均获得其私有的地址空间，并且任意一个进程对于内存的修改对于其他进程都是不可见的。</p>
<p>将要实现一个不同的、更加原始的JOS系统调用原语集合去创建新的用户模式环境，通过这些系统调用，除了其他类型的环境创建以外，将能够在用户空间实现一个完整的类Unix<code>fork()</code>系统调用。需要实现的系统调用为：</p>
<ul>
<li><code>sys_exofork</code> - 创建一个几乎空白的新环境：在地址空间没有任何的用户映射，并且也无法运行。新环境将会有和父环境在执行<code>sys_exofork</code>系统调用时完全一致的寄存器状态。在父进程中，<code>sys_exofork</code>会返回新创建环境的<code>envid_t</code>（若环境创建错误则返回一个错误码）；子进程则会返回0（因为子进程最初被标记为不可运行，直到父进程通过显式标记子进程可运行之后，<code>sys_exofork</code>返回。</li>
<li><code>sys_env_set_status</code> - 设置指定的环境的状态为ENV_RUNNABLE或是ENV_NOT_RUNNABLE。该系统调用通常在一个新环境的地址空间和寄存器状态完全初始化之后标记其为可运行。</li>
<li><code>sys_page_alloc</code> - 分配一页的物理内存并将其映射到给定环境地址空间的给定虚拟地址。</li>
<li><code>sys_page_alloc</code> - 将一页映射（而不是实际的页内容）从一个环境的地址空间拷贝至另一个，共享内存使得新映射和旧映射指向同一页物理内存。</li>
<li><code>sys_page_unmap</code> - 将给定环境的给定虚拟地址的页面解除映射。</li>
</ul>
<p>上述所有的系统调用接受环境ID，内核支持将0到“当前环境”转换，在<code>kern/env.c</code>中的<code>envid2env()</code>实现。</p>
<p>已经在<code>user/dumpfork.c</code>中提供了非常原始的类Unix的<code>fork()</code>实现。测试程序用上述系统调用创建并运行一个当前地址空间拷贝的子进程，然后两个环境使用<code>sys_yield()</code>来回切换。父进程在10次迭代后退出；子进程在20次迭代后退出。</p>
<p>练习7的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In sys_exofork():</span></div><div class="line"><span class="comment">// Allocate a new environment.</span></div><div class="line"><span class="comment">// Returns envid of new environment, or &lt; 0 on error.  Errors are:</span></div><div class="line"><span class="comment">//  -E_NO_FREE_ENV if no free environment is available.</span></div><div class="line"><span class="comment">//  -E_NO_MEM on memory exhaustion.</span></div><div class="line"><span class="function"><span class="keyword">static</span> envid_t <span class="title">sys_exofork</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="comment">// Create the new environment with env_alloc(), from kern/env.c.</span></div><div class="line">    <span class="comment">// It should be left as env_alloc created it, except that</span></div><div class="line">    <span class="comment">// status is set to ENV_NOT_RUNNABLE, and the register set is copied</span></div><div class="line">    <span class="comment">// from the current environment -- but tweaked so sys_exofork</span></div><div class="line">    <span class="comment">// will appear to return 0.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// get env_id of current environment</span></div><div class="line">    <span class="keyword">envid_t</span> parent_id = thiscpu-&gt;cpu_env-&gt;env_id;</div><div class="line"></div><div class="line">    <span class="comment">// use env_alloc to create new environment and</span></div><div class="line">    <span class="comment">// do some basic setup(status and register set)</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span> = <span class="title">NULL</span>;</span></div><div class="line">    <span class="keyword">if</span> (env_alloc(&amp;env, parent_id) &lt; <span class="number">0</span>) &#123; panic(<span class="string">"sys_exofork failed!"</span>); &#125;</div><div class="line">    env-&gt;env_status = ENV_NOT_RUNNABLE;</div><div class="line">    env-&gt;env_tf     = thiscpu-&gt;cpu_env-&gt;env_tf;</div><div class="line"></div><div class="line">    <span class="comment">// do the trick to set eax register of newly</span></div><div class="line">    <span class="comment">// alloc environment to 0</span></div><div class="line">    env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// return new environment's ID</span></div><div class="line">    <span class="keyword">return</span> env-&gt;env_id;</div><div class="line"></div><div class="line">    <span class="comment">// panic("sys_exofork not implemented");</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In sys_env_set_status():</span></div><div class="line"><span class="comment">// Set envid's env_status to status, which must be ENV_RUNNABLE</span></div><div class="line"><span class="comment">// or ENV_NOT_RUNNABLE.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></div><div class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist,</span></div><div class="line"><span class="comment">//		or the caller doesn't have permission to change envid.</span></div><div class="line"><span class="comment">//  -E_INVAL if status is not a valid status for an environment.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_env_set_status</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status)</span> </span>&#123;</div><div class="line">    <span class="comment">// Hint: Use the 'envid2env' function from kern/env.c to translate an</span></div><div class="line">    <span class="comment">// envid to a struct Env.</span></div><div class="line">    <span class="comment">// You should set envid2env's third argument to 1, which will</span></div><div class="line">    <span class="comment">// check whether the current environment has permission to set</span></div><div class="line">    <span class="comment">// envid's status.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// check status passed in</span></div><div class="line">    <span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) &#123;</div><div class="line">        <span class="comment">// invalid status</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></div><div class="line">    <span class="comment">// call envid2env to translate envid passed in</span></div><div class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">true</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// bad environment</span></div><div class="line">        <span class="keyword">return</span> -E_BAD_ENV;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// set status</span></div><div class="line">    env-&gt;env_status = status;</div><div class="line"></div><div class="line">    <span class="comment">// panic("sys_env_set_status not implemented");</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In sys_page_alloc():</span></div><div class="line"><span class="comment">// Allocate a page of memory and map it at 'va' with permission</span></div><div class="line"><span class="comment">// 'perm' in the address space of 'envid'.</span></div><div class="line"><span class="comment">// The page's contents are set to 0.</span></div><div class="line"><span class="comment">// If a page is already mapped at 'va', that page is unmapped as a</span></div><div class="line"><span class="comment">// side effect.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set,</span></div><div class="line"><span class="comment">//         but no other bits may be set.  See PTE_SYSCALL in inc/mmu.h.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></div><div class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist,</span></div><div class="line"><span class="comment">//      or the caller doesn't have permission to change envid.</span></div><div class="line"><span class="comment">//  -E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></div><div class="line"><span class="comment">//  -E_INVAL if perm is inappropriate (see above).</span></div><div class="line"><span class="comment">//  -E_NO_MEM if there's no memory to allocate the new page,</span></div><div class="line"><span class="comment">//      or to allocate any necessary page tables.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_page_alloc</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span> </span>&#123;</div><div class="line">    <span class="comment">// Hint: This function is a wrapper around page_alloc() and</span></div><div class="line">    <span class="comment">//   page_insert() from kern/pmap.c.</span></div><div class="line">    <span class="comment">//   Most of the new code you write should be to check the</span></div><div class="line">    <span class="comment">//   parameters for correctness.</span></div><div class="line">    <span class="comment">//   If page_insert() fails, remember to free the page you</span></div><div class="line">    <span class="comment">//   allocated!</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></div><div class="line">    <span class="comment">// check and get env</span></div><div class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">true</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// envid not exist or permission error</span></div><div class="line">        <span class="keyword">return</span> -E_BAD_ENV;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// check va</span></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= UTOP || PGOFF(va) != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// va above UTOP or va is not page-aligned</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// check perm</span></div><div class="line">    <span class="keyword">if</span> ((perm &amp; (~PTE_SYSCALL)) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P)) &#123;</div><div class="line">        <span class="comment">// invalid perm</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// allocate page and then insert it</span></div><div class="line">    <span class="comment">// check if out of memory</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span>;</span></div><div class="line">    <span class="keyword">if</span> ((page = page_alloc(ALLOC_ZERO)) == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="comment">// failed to allocate page</span></div><div class="line">        <span class="keyword">return</span> -E_NO_MEM;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (page_insert(env-&gt;env_pgdir, page, va, perm) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// page table couldn't be allocated</span></div><div class="line">        <span class="comment">// free ununsed page</span></div><div class="line">        page_free(page);</div><div class="line">        <span class="keyword">return</span> -E_NO_MEM;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// panic("sys_page_alloc not implemented");</span></div><div class="line"></div><div class="line">    <span class="comment">// page successfully allocated</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In sys_page_map():</span></div><div class="line"><span class="comment">// Map the page of memory at 'srcva' in srcenvid's address space</span></div><div class="line"><span class="comment">// at 'dstva' in dstenvid's address space with permission 'perm'.</span></div><div class="line"><span class="comment">// Perm has the same restrictions as in sys_page_alloc, except</span></div><div class="line"><span class="comment">// that it also must not grant write access to a read-only</span></div><div class="line"><span class="comment">// page.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></div><div class="line"><span class="comment">//  -E_BAD_ENV if srcenvid and/or dstenvid doesn't currently exist,</span></div><div class="line"><span class="comment">//      or the caller doesn't have permission to change one of them.</span></div><div class="line"><span class="comment">//  -E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,</span></div><div class="line"><span class="comment">//      or dstva &gt;= UTOP or dstva is not page-aligned.</span></div><div class="line"><span class="comment">//  -E_INVAL is srcva is not mapped in srcenvid's address space.</span></div><div class="line"><span class="comment">//  -E_INVAL if perm is inappropriate (see sys_page_alloc).</span></div><div class="line"><span class="comment">//  -E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid's</span></div><div class="line"><span class="comment">//      address space.</span></div><div class="line"><span class="comment">//  -E_NO_MEM if there's no memory to allocate any necessary page tables.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_page_map</span><span class="params">(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva, <span class="keyword">envid_t</span> dstenvid,</span></span></div><div class="line">                        <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm) &#123;</div><div class="line">    <span class="comment">// Hint: This function is a wrapper around page_lookup() and</span></div><div class="line">    <span class="comment">//   page_insert() from kern/pmap.c.</span></div><div class="line">    <span class="comment">//   Again, most of the new code you write should be to check the</span></div><div class="line">    <span class="comment">//   parameters for correctness.</span></div><div class="line">    <span class="comment">//   Use the third argument to page_lookup() to</span></div><div class="line">    <span class="comment">//   check the current permissions on the page.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srcenv</span>, *<span class="title">dstenv</span>;</span></div><div class="line">    <span class="comment">// check environment</span></div><div class="line">    <span class="keyword">if</span> ((envid2env(srcenvid, &amp;srcenv, <span class="literal">true</span>) &lt; <span class="number">0</span>) ||</div><div class="line">        (envid2env(dstenvid, &amp;dstenv, <span class="literal">true</span>) &lt; <span class="number">0</span>)) &#123;</div><div class="line">        <span class="comment">// srcenvid or dstenvid doesn't exist or</span></div><div class="line">        <span class="comment">// caller doesn't have permissions</span></div><div class="line">        <span class="keyword">return</span> -E_BAD_ENV;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// check srcva and dstva about address and page-aligned</span></div><div class="line">    <span class="comment">// get srcenv and dstenv</span></div><div class="line">    <span class="keyword">if</span> (((<span class="keyword">uintptr_t</span>)srcva &gt;= UTOP) || ((<span class="keyword">uintptr_t</span>)dstva &gt;= UTOP) ||</div><div class="line">        (PGOFF(srcva) != <span class="number">0</span>) || (PGOFF(dstva) != <span class="number">0</span>)) &#123;</div><div class="line">        <span class="comment">// addresses above UTOP or addresses not page_aligned</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">srcpage</span>;</span></div><div class="line">    <span class="keyword">pte_t</span> *          scrpte_ptr;</div><div class="line">    <span class="comment">// use page look up to get source page and corresponding pte_t *</span></div><div class="line">    <span class="keyword">if</span> ((srcpage = page_lookup(srcenv-&gt;env_pgdir, srcva, &amp;scrpte_ptr)) ==</div><div class="line">        <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="comment">// srcva not mapped in srcenvid's address space</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// check perm passed in</span></div><div class="line">    <span class="keyword">if</span> ((perm &amp; (~PTE_SYSCALL)) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P)) &#123;</div><div class="line">        <span class="comment">// invalid perm</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// check if srcva is writable if perm has PTE_W</span></div><div class="line">    <span class="keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; (!((*scrpte_ptr) &amp; PTE_W))) &#123;</div><div class="line">        <span class="comment">// perm has PTE_W while srcva ISN'T writable</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// insert source page into dstenv's pgdir with perm</span></div><div class="line">    <span class="comment">// check if out of memory</span></div><div class="line">    <span class="keyword">if</span> (page_insert(dstenv-&gt;env_pgdir, srcpage, dstva, perm) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// out of memory to allocate page table</span></div><div class="line">        <span class="keyword">return</span> -E_NO_MEM;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// panic("sys_page_map not implemented");</span></div><div class="line"></div><div class="line">    <span class="comment">// page successfully mapped</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In sys_page_unmap():</span></div><div class="line"><span class="comment">// Unmap the page of memory at 'va' in the address space of 'envid'.</span></div><div class="line"><span class="comment">// If no page is mapped, the function silently succeeds.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></div><div class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist,</span></div><div class="line"><span class="comment">//      or the caller doesn't have permission to change envid.</span></div><div class="line"><span class="comment">//  -E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_page_unmap</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va)</span> </span>&#123;</div><div class="line">    <span class="comment">// Hint: This function is a wrapper around page_remove().</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></div><div class="line">    <span class="comment">// check and get env</span></div><div class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">true</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// envid not exist or permission error</span></div><div class="line">        <span class="keyword">return</span> -E_BAD_ENV;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// check va</span></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= UTOP || PGOFF(va) != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// va above UTOP or va is not page-aligned</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// call page_remove to unmap page</span></div><div class="line">    page_remove(env-&gt;env_pgdir, va);</div><div class="line"></div><div class="line">    <span class="comment">// panic("sys_page_unmap not implemented");</span></div><div class="line"></div><div class="line">    <span class="comment">// page successfully unmapped</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In syscall():</span></div><div class="line"><span class="comment">// new code added</span></div><div class="line"><span class="keyword">case</span> SYS_exofork:</div><div class="line">    <span class="comment">// call sys_exofork</span></div><div class="line">    <span class="keyword">return</span> sys_exofork();</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> SYS_env_set_status:</div><div class="line">    <span class="comment">// call sys_env_set_status</span></div><div class="line">    <span class="keyword">return</span> sys_env_set_status((<span class="keyword">envid_t</span>)a1, (<span class="keyword">int</span>)a2);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> SYS_page_alloc:</div><div class="line">    <span class="comment">// call sys_page_alloc</span></div><div class="line">    <span class="keyword">return</span> sys_page_alloc((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2, (<span class="keyword">int</span>)a3);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> SYS_page_map:</div><div class="line">    <span class="comment">// call sys_page_map</span></div><div class="line">    <span class="keyword">return</span> sys_page_map((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2, (<span class="keyword">envid_t</span>)a3, (<span class="keyword">void</span> *)a4,</div><div class="line">                        (<span class="keyword">int</span>)a5);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> SYS_page_unmap:</div><div class="line">    <span class="comment">// call sys_page_unmap</span></div><div class="line">    <span class="keyword">return</span> sys_page_unmap((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2);</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<h3 id="第二部分-Copy-on-Write-Fork-写时复制Fork"><a href="#第二部分-Copy-on-Write-Fork-写时复制Fork" class="headerlink" title="第二部分 Copy-on-Write Fork - 写时复制Fork"></a>第二部分 Copy-on-Write Fork - 写时复制Fork</h3><p>Unix提供了一个<code>fork()</code>系统调用作为其原始的进程创建原语。<code>fork()</code>系统调用将调用进程的整个地址空间拷贝以创建子进程。</p>
<p>xv6通过将父进程页中的所有数据复制到子进程中的新页中来实现<code>fork()</code>，这本质上就是<code>dumbfowk()</code>采用的方法。对于父进程地址空间的拷贝是整个<code>fork()</code>操作中最“贵”的部分。</p>
<p>然而，对于fork()的调用通常紧跟着一个对子进程的<code>exec()</code>系统调用，该系统调用用一个新程序替换子进程的内存，这就是一个典型的shell所做的。在这种情况下，花费的用于复制父进程的地址空间的时间是被浪费的，因为子进程在调用<code>exec()</code>前只会使用很少的内存。</p>
<p>出于以上的原因，Unix之后的版本利用了虚拟内存硬件去允许父进程和子进程共享映射到各自地址空间的内存，直到其中一个进程实际修改为止。该技术又被称作写时复制。<br>为了实现写时复制，在<code>fork()</code>中内核仅仅从父进程拷贝地址的映射而非实际映射的页面到子进程，并且在同时将共享的页面标记为只读。<br>当两个进程之一尝试写入其中一个共享页面时，该过程触发页面错误。<br>内核意识到该页面实际上是一个“虚拟”或是“写时复制”页面，所以其会创建一个错误页面的新的，私有的，可写的页副本。<br>通过这种方式，直到实际写入时，独立页面的内容才被复制。<br>该过程使得紧接着<code>exec()</code>的<code>fork()</code>调用更加节约：子进程在调用<code>exec()</code>很可能只会复制一页（栈的当前页）。</p>
<p>本实验的下一个部分要求完成一个合适的类Unix的<code>fork()</code>的写时复制的实现（作为用户空间库例程）。在用户空间实现<code>fork()</code>并且支持写时复制使得内核能保留相对简洁，因此更不容易出现严重的错误。这同样可以允许独立的用户模式程序实现自己的<code>fork()</code>语义。</p>
<h4 id="用户级别的页错误处理"><a href="#用户级别的页错误处理" class="headerlink" title="用户级别的页错误处理"></a>用户级别的页错误处理</h4><p>用户级别的写时复制<code>fork()</code>实现需要知道写保护页面的页错误。写时复制只是用户级别的页错误处理的诸多可能用处之一。</p>
<p>通常的做法是设置一个地址空间以便页错误指示何时需要采取某些行动。大多数Unix内核通常只会为新进程的栈区域分配一页，随着进程栈逐渐增长直至访问到了还未被映射的栈地址，触发页错误，然后内核会“按需”分配更多的栈页面。<br>典型的Unix内核必须追踪进程的空间中的不同区域发生页错误时所采取的行动。栈区域的页错误通常会导致新页的分配和映射。BSS区域的页错误通常会导致分配一个新页，填充0，并映射。对于具有按需分页的可执行文件的系统，text段的页错误会导致内核从磁盘上的二进制文件读取相应的页面并映射。</p>
<p>内核需要追踪大量的信息。与传统的Unix方法不同，本实验需要用户决定如何处理用户空间中的每个页面错误，而这些错误的损害通常不大。这种设计还为程序定义存储区域带来了极大的灵活性。之后将会应用用户级别的错误处理程序来映射和访问基于磁盘的文件系统上的文件。</p>
<h5 id="设置页错误处理程序"><a href="#设置页错误处理程序" class="headerlink" title="设置页错误处理程序"></a>设置页错误处理程序</h5><p>为了处理用户环境自己的页错误，用户环境必须向JOS内核注册一个页错误处理程序入口。用户环境通过<code>sys_env_set_pgfault_upcall()</code>的“上行”系统调用注册自己的错误处理程序入口。已经向<code>struct Env</code>添加了新的域<code>env_pgfault_upcall</code>来记录该信息。</p>
<p>练习8的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In sys_env_set_pgfault_upcall():</span></div><div class="line"><span class="comment">// Set the page fault upcall for 'envid' by modifying the corresponding struct</span></div><div class="line"><span class="comment">// Env's 'env_pgfault_upcall' field.  When 'envid' causes a page fault, the</span></div><div class="line"><span class="comment">// kernel will push a fault record onto the exception stack, then branch to</span></div><div class="line"><span class="comment">// 'func'.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></div><div class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist,</span></div><div class="line"><span class="comment">//      or the caller doesn't have permission to change envid.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_env_set_pgfault_upcall</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *func)</span> </span>&#123;</div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></div><div class="line">    <span class="comment">// check and translate the envid</span></div><div class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">true</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// envid not exist or permission error</span></div><div class="line">        <span class="keyword">return</span> -E_BAD_ENV;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// set func</span></div><div class="line">    env-&gt;env_pgfault_upcall = func;</div><div class="line"></div><div class="line">    <span class="comment">// panic("sys_env_set_pgfault_upcall not implemented");</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In syscall():</span></div><div class="line"><span class="comment">// new code added</span></div><div class="line"><span class="keyword">case</span> SYS_env_set_pgfault_upcall:</div><div class="line">    <span class="comment">// call sys_env_set_pgfault_upcall</span></div><div class="line">    <span class="keyword">return</span> sys_env_set_pgfault_upcall((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2);</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<h5 id="用户环境中的正常栈和异常栈"><a href="#用户环境中的正常栈和异常栈" class="headerlink" title="用户环境中的正常栈和异常栈"></a>用户环境中的正常栈和异常栈</h5><p>在正常执行时，JOS中的用户环境会在正常栈中执行：正常栈的ESP寄存器指向USTACKTOP，并且压入的栈数据会存放于USTACKTOP - PGSIZE到USTACKTOP - 1的闭区域。<br>然而，当一个页错误在用户模式发生时，内核将重启用户环境，在一个另外的栈上运行一个特定的用户级别的页错误处理程序，该栈被称为用户异常栈。<br>实际上，将使JOS代表用户环境自动执行“栈切换”，就像x86处理器在用户模式转换到内核模式时已经代表JOS实现了栈切换一样。</p>
<p>JOS用户异常栈的大小也为一个页面大，栈顶被定义为指向虚拟地址UXSTACKTOP，用户异常栈的有效字节为UXSTACKTOP - PGSIZE到UXSTACKTOP - 1的闭区域。<br>当运行于异常栈上时，用户级别的页错误处理程序可以使用JOS的常规系统调用映射新的页或是调整页映射以修复任何可能导致页错误的问题。<br>然后用户级别的页错误处理程序通过汇编语言存根返回至原始栈上的错误代码处。</p>
<p>每一个想要支持用户级别页错误处理程序的用户环境需要自己为其异常栈通过<code>sys_page_alloc()</code>分配内存。</p>
<h5 id="唤醒用户页错误处理程序"><a href="#唤醒用户页错误处理程序" class="headerlink" title="唤醒用户页错误处理程序"></a>唤醒用户页错误处理程序</h5><p>现在需要改变<code>kern/trap.c</code>中的页错误处理程序按特定的方式处理用户模式的页错误。<br>将错误时的用户环境状态叫做陷阱时状态。</p>
<p>若是没有页面错误处理函数被注册，则JOS内核会和之前一样，摧毁用户环境并输出一条消息。否则，内核会在异常栈设置在<code>inc/trap.h</code>中如<code>struct UTrapFrame</code>定义的陷阱帧。</p>
<p>然后内核会安排用户环境以页错误处理程序以上述栈帧在异常栈上恢复执行。<code>fault_va</code>是导致也错误的虚拟地址。</p>
<p>如果当异常发生时用户环境已经在用户异常栈上运行，则错误处理程序自身发生了错误。在这种情况下，你应当在当前的<code>tf-&gt;tf_esp</code>中而非UXSTACKTOP中重新启动栈帧。你应当首先压入一个4字节的字，然后一个<code>struct UTrapFrame</code>。</p>
<p>检查tf-&gt;tf_esp是否在UXSTACKTOP - PGSIZE到UXSTACKTOP - 1的闭区间内来判断其是否已经在用户异常栈上。</p>
<p>练习9中遇到的问题：</p>
<ul>
<li><code>curenv</code>已经被重新定义为<code>thiscpu-&gt;cpu_env</code>，因此可以使用</li>
<li>判断tf-&gt;tf_esp的if语句中，将与写成了或</li>
</ul>
<p>练习9的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In trap.c, page_fault_handler():</span></div><div class="line"><span class="comment">// LAB 4: Your code here.</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> *<span class="title">utf</span>;</span></div><div class="line"><span class="keyword">uintptr_t</span>          utf_addr;</div><div class="line"></div><div class="line"><span class="comment">// check tf-&gt;tf_esp's location to calculate utf's address</span></div><div class="line"><span class="keyword">if</span> ((tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE) &amp;&amp; (tf-&gt;tf_esp &lt; UXSTACKTOP)) &#123;</div><div class="line">    <span class="comment">// recursive case</span></div><div class="line">    <span class="comment">// reason why here needs to substract a 4-byte word</span></div><div class="line">    <span class="comment">// is to reserve space for reset eip/esp</span></div><div class="line">    utf_addr = tf-&gt;tf_esp - <span class="keyword">sizeof</span>(struct UTrapframe) - <span class="number">4</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// non-recursive case, set utf_addr to the top of</span></div><div class="line">    <span class="comment">// user exception stack</span></div><div class="line">    utf_addr = UXSTACKTOP - <span class="keyword">sizeof</span>(struct UTrapframe);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (curenv-&gt;env_pgfault_upcall) &#123;</div><div class="line">    <span class="comment">// page fault upcall exist</span></div><div class="line"></div><div class="line">    <span class="comment">// use mem assert to check environment allocates the exception</span></div><div class="line">    <span class="comment">// stack and has write permission to it, and stack ISN'T overflow</span></div><div class="line">    <span class="comment">// combine three case with only one user_mem_assert to check utf_addr</span></div><div class="line">    <span class="comment">// NB: curenv HAS been redefined as thiscpu-&gt;cpu_env</span></div><div class="line">    user_mem_assert(curenv, (<span class="keyword">void</span> *)utf_addr, <span class="keyword">sizeof</span>(struct UTrapframe),</div><div class="line">                    PTE_U | PTE_W | PTE_P);</div><div class="line"></div><div class="line">    <span class="comment">// set user stack frame</span></div><div class="line">    utf               = (struct UTrapframe *)utf_addr;</div><div class="line">    utf-&gt;utf_fault_va = fault_va;</div><div class="line">    utf-&gt;utf_err      = tf-&gt;tf_err;</div><div class="line">    utf-&gt;utf_regs     = tf-&gt;tf_regs;</div><div class="line">    utf-&gt;utf_eip      = tf-&gt;tf_eip;</div><div class="line">    utf-&gt;utf_eflags   = tf-&gt;tf_eflags;</div><div class="line">    utf-&gt;utf_esp      = tf-&gt;tf_esp;</div><div class="line"></div><div class="line">    <span class="comment">// modify stack frame to set entry for env_pgfault_upcall</span></div><div class="line">    <span class="comment">// and set address for user exception stack</span></div><div class="line">    tf-&gt;tf_eip = (<span class="keyword">uintptr_t</span>)curenv-&gt;env_pgfault_upcall;</div><div class="line">    tf-&gt;tf_esp = utf_addr;</div><div class="line"></div><div class="line">    env_run(curenv);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="用户模式页错误入口"><a href="#用户模式页错误入口" class="headerlink" title="用户模式页错误入口"></a>用户模式页错误入口</h5><p>然后需要实现汇编例程，该例程调用C页错误处理程序，然后在恢复在原始的错误指令处的执行。该例程就是被<code>sys_env_set_pgfault_upcall()</code>注册的例程。</p>
<p>最后需要在C用户库实现用户模式的页错误处理机制。</p>
<p>练习10中遇到的问题：</p>
<ul>
<li>需要想清楚思路，即先将eip“压入”陷阱时栈中，使用一个sub后接一个mov指令来模拟该压栈过程，若为递归过程，则会将eip填入之前留下的空白。然后依次恢复寄存器以及eflags。最后pop %esp以切换栈并调用ret返回</li>
</ul>
<p>练习10的代码如下，仅供参考：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// <span class="keyword">In</span> pfentry.S:</div><div class="line">// LAB <span class="number">4</span>: Your code here.</div><div class="line">// <span class="keyword">push</span> trap-time %eip to trap-time stack</div><div class="line">// <span class="keyword">mov</span> utf_eip to %eax</div><div class="line">movl <span class="number">0x28</span>(%esp), %eax</div><div class="line">// use <span class="keyword">sub</span> <span class="keyword">and</span> <span class="keyword">mov</span> to *simulate* <span class="keyword">push</span></div><div class="line">subl <span class="number">$0</span>x4, <span class="number">0x30</span>(%esp)</div><div class="line">movl <span class="number">0x30</span>(%esp), %ebp</div><div class="line">movl %eax, (%ebp)</div><div class="line">// <span class="keyword">pop</span> the unused fault_va <span class="keyword">and</span> err</div><div class="line">popl %eax</div><div class="line">popl %eax</div><div class="line"></div><div class="line">// Restore the trap-time registers.  After you <span class="built_in">do</span> this, you</div><div class="line">// can no longer modify any general-purpose registers.</div><div class="line">// LAB <span class="number">4</span>: Your code here.</div><div class="line">popal</div><div class="line"></div><div class="line">// Restore eflags from the stack.  After you <span class="built_in">do</span> this, you can</div><div class="line">// no longer use arithmetic operations <span class="keyword">or</span> anything else that</div><div class="line">// modifies eflags.</div><div class="line">// LAB <span class="number">4</span>: Your code here.</div><div class="line">addl <span class="number">$0</span>x4, %esp</div><div class="line">popfl</div><div class="line"></div><div class="line">// Switch back to the adjusted trap-time stack.</div><div class="line">// LAB <span class="number">4</span>: Your code here.</div><div class="line">popl %esp</div><div class="line"></div><div class="line">// Return to re-execute the instruction that faulted.</div><div class="line">// LAB <span class="number">4</span>: Your code here.</div><div class="line"><span class="keyword">ret</span></div></pre></td></tr></table></figure></p>
<p>练习11中遇到的问题：</p>
<ul>
<li>注意描述，要使用<code>_pgfault_upcall()</code>（汇编例程包装）来注册用户页处理函数而非传入的那个函数</li>
</ul>
<p>练习11的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In set_pgfault_handler():</span></div><div class="line"><span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// First time through!</span></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// alloc one page for user exception stack</span></div><div class="line">    <span class="comment">// and register user-level page fault upcall</span></div><div class="line">    <span class="keyword">if</span> (sys_page_alloc(thisenv-&gt;env_id, (<span class="keyword">void</span> *)(UXSTACKTOP - PGSIZE),</div><div class="line">                       PTE_U | PTE_W | PTE_P) &lt; <span class="number">0</span>) &#123;</div><div class="line">        panic(<span class="string">"failed to alloc page for user exception stack!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (sys_env_set_pgfault_upcall(thisenv-&gt;env_id, _pgfault_upcall) &lt; <span class="number">0</span>) &#123;</div><div class="line">        panic(<span class="string">"failed to register page fault upcall!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// panic("set_pgfault_handler not implemented");</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>faultalloc能成功而faultallocbad失败的原因在于faultallocbad直接使用系统调用输出，该输出会使用先使用内存检查而失败；而faultalloc使用了用户库中的<code>cprintf</code>，该函数在使用系统调用输出之前已经尝试对错误地址进行了解引用，触发了用户级别的缺页错误，在实际执行系统调用时，错误的地址已经被分配了页面，因此能通过内存检查。</p>
<h4 id="实现写时复制"><a href="#实现写时复制" class="headerlink" title="实现写时复制"></a>实现写时复制</h4><p>已经拥有了在用户空间中完整实现写时复制<code>fork()</code>的内核设施基础。</p>
<p>现在已经在<code>lib/fork.c</code>中给出了<code>fork()</code>的框架。同<code>dumbfork()</code>相似，<code>fork()</code>首先创建了一个新环境，然后扫描父进程的地址空间并在子进程中建立相同的页映射。核心区别在于<code>dumbfork()</code>复制页，而<code>fork()</code>只实现页映射的复制。<code>fork()</code>直到某环境尝试写时在复制对应的页。</p>
<p><code>fork()</code>的基本控制流为：</p>
<ol>
<li>父进程设置<code>pgfault()</code>作为C级别的页错误处理程序，使用实现了的<code>set_pgfault_handler()</code>函数</li>
<li>父进程调用<code>sys_exofork()</code>去创建子环境</li>
<li>对于地址空间中每一个在UTOP下的可写的或是写时复制的页面，父进程调用<code>duppage()</code>，该函数将该页面以写时复制映射进子进程然后在父进程的地址空间中重新映射该页面为写时复制（顺序很重要）。<code>duppage()</code>同时设置PTE，所以页面将不可写。通过avail域的PTE_COW区分写时复制页面和真正的只读页面。然而，异常栈却不按该方式重映射。需要为子进程分配一个新页面作为异常栈。由于页处理程序实际执行了页复制并且页处理程序运行于异常栈上，异常栈不能写时复制。<code>fork()</code>也需要处理存在但既不是写时复制也不是可写的页面。</li>
<li>父进程为子进程设置用户页错误入口。</li>
<li>子进程已经准备好运行了，有父进程将其标记为可运行。</li>
</ol>
<p>每一次环境尝试向一个还不可写的写时复制的页面写入时，将出现页错误，用户页错误处理程序的控制流为：</p>
<ol>
<li>内核将页错误传递给页错误上行调用，即调用了<code>fork()</code>的页错误处理程序。</li>
<li><code>pgfault()</code>检查错误为写入导致并且相应页面的PTE被标记为写时复制，否则使内核恐慌。</li>
<li><code>pgfault()</code>分配一个新的页面，映射至一个临时位置，然后复制错误页面的内容到新分配的页面，最后将新页面以读写权限映射到合适的地址，替代旧的只读页。</li>
</ol>
<p>用户级别的<code>lib/fork.c</code>代码必须查询环境的页表（如查询某页面的PTE被标记为写时复制）。内核将环境的页表映射在UVPT正是为了这个目的。内核通过将页目录的指针指向自己的映射技巧使得可以为用户代码快速查找PTEs，<code>lib/entry.S</code>已经设置了<code>uvpd</code>和<code>uvpd</code>，你可以快速在<code>lib/fork.c</code>中查找页表信息。</p>
<p>练习12中遇到的问题：</p>
<ul>
<li>注意在<code>pgfault()</code>和<code>duppage()</code>中，必须使用0而不是<code>thisenv-&gt;env_id</code>，原因已经在代码注释中标出</li>
<li>在<code>fork()</code>中需要显式地判断用户异常页并跳过<code>duppage()</code></li>
<li>阅读给出的uvpt技巧，需要在代码中使用</li>
<li>为了简化错误处理，避免重复代码，使用了<code>goto</code></li>
<li>假定先将父进程的用户栈标记为COW，然后再尝试将子进程的用户栈标记为COW之前，可能会出现父进程的用户栈已经被写入的情况而触发缺页错误，因此<code>fork()</code>会立刻分配新页，拷贝内容并重新映射。子进程被标记COW时复制的页映射已经不是原来的页映射了，因此，后来对父进程做的改动会反映在子进程上，这显然是错误的</li>
<li>fork后必须修改thisenv的值以保证用户程序行为正确</li>
</ul>
<p>练习12的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In lib/fork.c, fork():</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// User-level fork with copy-on-write.</span></div><div class="line"><span class="comment">// Set up our page fault handler appropriately.</span></div><div class="line"><span class="comment">// Create a child.</span></div><div class="line"><span class="comment">// Copy our address space and page fault handler setup to the child.</span></div><div class="line"><span class="comment">// Then mark the child as runnable and return.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Returns: child's envid to the parent, 0 to the child, &lt; 0 on error.</span></div><div class="line"><span class="comment">// It is also OK to panic on error.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Hint:</span></div><div class="line"><span class="comment">//   Use uvpd, uvpt, and duppage.</span></div><div class="line"><span class="comment">//   Remember to fix "thisenv" in the child process.</span></div><div class="line"><span class="comment">//   Neither user exception stack should ever be marked copy-on-write,</span></div><div class="line"><span class="comment">//   so you must allocate a new page for the child's user exception stack.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">envid_t</span> fork(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="keyword">int</span> r;</div><div class="line"></div><div class="line">    <span class="comment">// use set_pgfault_handler to install pgfault() as page fault handler</span></div><div class="line">    set_pgfault_handler(pgfault);</div><div class="line"></div><div class="line">    <span class="comment">// use system call to create new blank child environment</span></div><div class="line">    <span class="keyword">envid_t</span> child_env_id = sys_exofork();</div><div class="line">    <span class="keyword">if</span> (child_env_id == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// must update thisenv to make sure user program behave</span></div><div class="line">        <span class="comment">// normally</span></div><div class="line">        thisenv = envs + ENVX(sys_getenvid());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (child_env_id &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// error when create new environment, simply return</span></div><div class="line">        <span class="keyword">return</span> child_env_id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// traverse through parent's address space and use duppage</span></div><div class="line">    <span class="comment">// to copy address mappings</span></div><div class="line">    <span class="keyword">uintptr_t</span> addr;</div><div class="line">    <span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; UTOP; addr += PGSIZE) &#123;</div><div class="line">        <span class="keyword">if</span> ((((<span class="keyword">pde_t</span> *)uvpd)[PDX(addr)] &amp; PTE_P) &amp;&amp;</div><div class="line">            (((<span class="keyword">pte_t</span> *)uvpt)[PGNUM(addr)] &amp; PTE_P)) &#123;</div><div class="line">            <span class="comment">// if both page directory entry and page table entry</span></div><div class="line">            <span class="comment">// exist for one address(page-aligned), then call duppage</span></div><div class="line">            <span class="keyword">if</span> (addr == (UXSTACKTOP - PGSIZE)) &#123;</div><div class="line">                <span class="comment">// ignore user exception stack</span></div><div class="line">                <span class="comment">// for we will map a page for user exception later</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> ((r = duppage(child_env_id, PGNUM(addr))) &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// duppage failed</span></div><div class="line">                <span class="comment">// destroy child environment and return</span></div><div class="line">                <span class="keyword">goto</span> error_handle;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// child must have its own exception stack</span></div><div class="line">    <span class="comment">// so alloc page and map it for child here</span></div><div class="line">    <span class="keyword">if</span> ((r = sys_page_alloc(child_env_id, (<span class="keyword">void</span> *)(UXSTACKTOP - PGSIZE),</div><div class="line">                            PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// failed to set child environment's exception stack</span></div><div class="line">        <span class="comment">// destroy child environment and return</span></div><div class="line">        <span class="keyword">goto</span> error_handle;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// set child's page fault handler so that parent</span></div><div class="line">    <span class="comment">// and child looks the same</span></div><div class="line">    <span class="comment">// use sys_env_set_pgfault_upcall system call</span></div><div class="line">    <span class="keyword">extern</span> <span class="keyword">void</span> _pgfault_upcall(<span class="keyword">void</span>);</div><div class="line">    <span class="keyword">if</span> ((r = sys_env_set_pgfault_upcall(child_env_id, _pgfault_upcall)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// failed to set child's page fault upcall</span></div><div class="line">        <span class="comment">// destroy child environment and return</span></div><div class="line">        <span class="keyword">goto</span> error_handle;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// now child is ready to run, set child to ENV_RUNNABLE</span></div><div class="line">    <span class="comment">// use sys_env_set_status system call</span></div><div class="line">    <span class="keyword">if</span> ((r = sys_env_set_status(child_env_id, ENV_RUNNABLE)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// failed to change child environment's running status</span></div><div class="line">        <span class="comment">// destroy child environment and return</span></div><div class="line">        <span class="keyword">goto</span> error_handle;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// panic("fork not implemented");</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> child_env_id;</div><div class="line"></div><div class="line"><span class="comment">// use goto to avoid meaningless error_handle code</span></div><div class="line"><span class="comment">// copy and paste everywhere</span></div><div class="line">error_handle:</div><div class="line">    <span class="keyword">if</span> (sys_env_destroy(child_env_id) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// failed either, panic then</span></div><div class="line">        panic(<span class="string">"failed to destroy child environment!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> r;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In lib/fork.c, duppage():</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Map our virtual page pn (address pn*PGSIZE) into the target envid</span></div><div class="line"><span class="comment">// at the same virtual address.  If the page is writable or copy-on-write,</span></div><div class="line"><span class="comment">// the new mapping must be created copy-on-write, and then our mapping must be</span></div><div class="line"><span class="comment">// marked copy-on-write as well.  (Exercise: Why do we need to mark ours</span></div><div class="line"><span class="comment">// copy-on-write again if it was already copy-on-write at the beginning of</span></div><div class="line"><span class="comment">// this function?)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Returns: 0 on success, &lt; 0 on error.</span></div><div class="line"><span class="comment">// It is also OK to panic on error.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">duppage</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> r;</div><div class="line"></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="keyword">int</span> perm = PTE_P | PTE_U;</div><div class="line">    <span class="keyword">if</span> ((((<span class="keyword">pte_t</span> *)uvpt)[pn] &amp; (PTE_W | PTE_COW))) &#123;</div><div class="line">        <span class="comment">// check for writable or copy-on-write page</span></div><div class="line">        <span class="comment">// and add perm with PTE_COW</span></div><div class="line">        perm |= PTE_COW;</div><div class="line">        <span class="comment">// NB: we also use 0 to replace thisenv-&gt;env_id</span></div><div class="line">        <span class="comment">// for in unix-like fork() implementation, we will copy</span></div><div class="line">        <span class="comment">// address space from parent process to child process</span></div><div class="line">        <span class="comment">// at current time, thisenv-&gt;env_id IS ABSOLUTELY WRONG</span></div><div class="line"></div><div class="line">        <span class="comment">// map from parent environment to child environment</span></div><div class="line">        <span class="keyword">if</span> (sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)(pn * PGSIZE), envid, (<span class="keyword">void</span> *)(pn * PGSIZE),</div><div class="line">                         perm) &lt; <span class="number">0</span>) &#123;</div><div class="line">            panic(<span class="string">"failed to map page from parent to child!"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// remap parent's environment</span></div><div class="line">        <span class="keyword">if</span> (sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)(pn * PGSIZE), <span class="number">0</span>, (<span class="keyword">void</span> *)(pn * PGSIZE),</div><div class="line">                         perm) &lt; <span class="number">0</span>) &#123;</div><div class="line">            panic(<span class="string">"failed to remap page in parent!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// for other pages, simply map from</span></div><div class="line">        <span class="comment">// parent environment to child environment</span></div><div class="line">        <span class="keyword">if</span> (sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)(pn * PGSIZE), envid, (<span class="keyword">void</span> *)(pn * PGSIZE),</div><div class="line">                         perm) &lt; <span class="number">0</span>) &#123;</div><div class="line">            panic(<span class="string">"failed to map page from parent to child!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// panic("duppage not implemented");</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In lib/fork.c, pgfault():</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Custom page fault handler - if faulting page is copy-on-write,</span></div><div class="line"><span class="comment">// map in our own private writable copy.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pgfault</span><span class="params">(struct UTrapframe *utf)</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> *   addr = (<span class="keyword">void</span> *)utf-&gt;utf_fault_va;</div><div class="line">    <span class="keyword">uint32_t</span> err  = utf-&gt;utf_err;</div><div class="line">    <span class="keyword">int</span>      r;</div><div class="line"></div><div class="line">    <span class="comment">// Check that the faulting access was (1) a write, and (2) to a</span></div><div class="line">    <span class="comment">// copy-on-write page.  If not, panic.</span></div><div class="line">    <span class="comment">// Hint:</span></div><div class="line">    <span class="comment">//   Use the read-only page table mappings at uvpt</span></div><div class="line">    <span class="comment">//   (see &lt;inc/memlayout.h&gt;).</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// use uvpt to get PTE and check premissions</span></div><div class="line">    <span class="keyword">if</span> (!(err &amp; FEC_WR) || !(((<span class="keyword">pte_t</span> *)uvpt)[PGNUM(addr)] &amp; PTE_COW)) &#123;</div><div class="line">        panic(<span class="string">"fault isn't write or PTE is not marked as PTE_COW or both!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span></div><div class="line">    <span class="comment">// copy the data from the old page to the new page, then move the new</span></div><div class="line">    <span class="comment">// page to the old page's address.</span></div><div class="line">    <span class="comment">// Hint:</span></div><div class="line">    <span class="comment">//   You should make three system calls.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// allocate a page and map it at PFTEMP</span></div><div class="line">    <span class="comment">// use sys_page_alloc system call</span></div><div class="line">    <span class="comment">// NB: use 0 instead of thisenv-&gt;env_id</span></div><div class="line">    <span class="comment">// for normally when child environment scheduled by JOS</span></div><div class="line">    <span class="comment">// first it tries to store 0(return value of fork()) to</span></div><div class="line">    <span class="comment">// local variable child_env_id on the stack</span></div><div class="line">    <span class="comment">// which will take a page fault and kernel will trasfer control</span></div><div class="line">    <span class="comment">// to pgfault here</span></div><div class="line">    <span class="comment">// thisenv-&gt;env_id IS ABSOLUTELY WRONG here, so use 0</span></div><div class="line">    <span class="comment">// and let kernel convert from 0 to correct env_id</span></div><div class="line">    <span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, (<span class="keyword">void</span> *)PFTEMP, PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        panic(<span class="string">"failed to allocate page at temp location - %e, %x!"</span>, r,</div><div class="line">              thisenv-&gt;env_id);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    addr = ROUNDDOWN(addr, PGSIZE);</div><div class="line">    <span class="comment">// use memcpy to copy from fault address's page to PFTEMP's newly</span></div><div class="line">    <span class="comment">// allocated page</span></div><div class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)PFTEMP, addr, PGSIZE);</div><div class="line"></div><div class="line">    <span class="comment">// use sys_page_map system call to map newly allocated</span></div><div class="line">    <span class="comment">// page at PFTEMP at addr with read/write permissions</span></div><div class="line">    <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)PFTEMP, <span class="number">0</span>, addr, PTE_P | PTE_U | PTE_W)) &lt;</div><div class="line">        <span class="number">0</span>) &#123;</div><div class="line">        panic(<span class="string">"failed to map new page - %e!"</span>, r);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// use sys_page_unmap system call to unmap page at</span></div><div class="line">    <span class="comment">// temp location PFTEMP</span></div><div class="line">    <span class="keyword">if</span> ((r = sys_page_unmap(<span class="number">0</span>, (<span class="keyword">void</span> *)PFTEMP)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        panic(<span class="string">"failed to unmap page at PFTEMP - %e!"</span>, r);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// panic("pgfault not implemented");</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="第三部分-Preemptive-Multitasking-and-Inter-Process-communication-IPC-抢占式多任务和进程间通信"><a href="#第三部分-Preemptive-Multitasking-and-Inter-Process-communication-IPC-抢占式多任务和进程间通信" class="headerlink" title="第三部分 - Preemptive Multitasking and Inter-Process communication (IPC) 抢占式多任务和进程间通信"></a>第三部分 - Preemptive Multitasking and Inter-Process communication (IPC) 抢占式多任务和进程间通信</h3><p>最后一部分要求你修改内核，实现抢占式非协作环境以及允许环境显式传递信息。</p>
<h4 id="时钟中断和抢占"><a href="#时钟中断和抢占" class="headerlink" title="时钟中断和抢占"></a>时钟中断和抢占</h4><p>运行<code>user/spin</code>测试程序，该测试程序<code>fork</code>一个用户环境，生成的子环境一旦获得了CPU，就会执行一个无限循环，无论是父环境还是内核都无法重新获得CPU。<br>对于从错误和恶意代码中保护系统而言，这不是一个理想的情况，因为任何用户环境都可以通过一个无限循环以及永不放弃使得整个系统停机。为了允许内核抢占一个用户环境并强制从该环境处获取CPU的控制，需要扩展JOS内核以支持时钟硬件的外部硬件中断。</p>
<h5 id="中断规则"><a href="#中断规则" class="headerlink" title="中断规则"></a>中断规则</h5><p>外部中断（如设备中断）被称为IRQs（Interrupt request）。总共有16种可能的IRQs，分别从0编号到15。从IRQ号到IDT入口的映射并不固定。<code>picirq.c</code>中的<code>pic_init()</code>将IRQs从0到15映射到了IRQ_OFFSET到IRQ_OFFSET + 15。</p>
<p>在<code>inc/trap.h</code>中，IRQ_OFFSET被定义为32，因此IDT入口32-47对应于IRQ的0-15。例如，始终中断是IRQ 0。因此，IDT[IRQ_OFFSET + 0]包含了内核中时钟中断处理程序的地址。IRQ_OFFSET设置为32后，设备中断将不会和处理器异常号重叠。</p>
<p>同xv6 Unix相比，JOS内核提供了一个关键性简化。在内核中时，外部设备中断永远是被禁止的（但是在用户环境中是被允许的）。外部中断被%eflags寄存器的FL_IF标记控制。当该bit被设置时，外部中断被允许。尽管有若干种方式可以修改该bit位，将在进入和退出用户模式时通过保存和恢复%eflags寄存器的过程来处理它。</p>
<p>必须确保在用户环境中FL_IF标记被设置，这样当中断到达后，并且将中断传递给处理器，并由内核中的中断处理程序处理。否则中断会被屏蔽和忽略之道中断重新被允许。在引导程序的第一条指定就屏蔽了外部设备中断，并且直到目前为止，还没有重新启用。</p>
<p>练习13中遇到的问题：</p>
<ul>
<li>注意到简化规则要求中说明必须在陷入内核时将IF置0，所以必须修改之前的代码，将所有门都改为中断门</li>
</ul>
<p>练习13的代码如下，仅供参考：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// In kern/trapentry.S:</div><div class="line">// externel interrupts</div><div class="line">TRAPHANDLER_NOEC(irq_0_handler,  IRQ_OFFSET + 0);</div><div class="line">TRAPHANDLER_NOEC(irq_1_handler,  IRQ_OFFSET + 1);</div><div class="line">TRAPHANDLER_NOEC(irq_2_handler,  IRQ_OFFSET + 2);</div><div class="line">TRAPHANDLER_NOEC(irq_3_handler,  IRQ_OFFSET + 3);</div><div class="line">TRAPHANDLER_NOEC(irq_4_handler,  IRQ_OFFSET + 4);</div><div class="line">TRAPHANDLER_NOEC(irq_5_handler,  IRQ_OFFSET + 5);</div><div class="line">TRAPHANDLER_NOEC(irq_6_handler,  IRQ_OFFSET + 6);</div><div class="line">TRAPHANDLER_NOEC(irq_7_handler,  IRQ_OFFSET + 7);</div><div class="line">TRAPHANDLER_NOEC(irq_8_handler,  IRQ_OFFSET + 8);</div><div class="line">TRAPHANDLER_NOEC(irq_9_handler,  IRQ_OFFSET + 9);</div><div class="line">TRAPHANDLER_NOEC(irq_10_handler, IRQ_OFFSET + 10);</div><div class="line">TRAPHANDLER_NOEC(irq_11_handler, IRQ_OFFSET + 11);</div><div class="line">TRAPHANDLER_NOEC(irq_12_handler, IRQ_OFFSET + 12);</div><div class="line">TRAPHANDLER_NOEC(irq_13_handler, IRQ_OFFSET + 13);</div><div class="line">TRAPHANDLER_NOEC(irq_14_handler, IRQ_OFFSET + 14);</div><div class="line">TRAPHANDLER_NOEC(irq_15_handler, IRQ_OFFSET + 15);</div><div class="line"></div><div class="line">// In kern/trap.c, trap_init():</div><div class="line">// set up interupt gate descriptor</div><div class="line">SETGATE(idt[IRQ_OFFSET + 0],  0, GD_KT, irq_0_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 1],  0, GD_KT, irq_1_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 2],  0, GD_KT, irq_2_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 3],  0, GD_KT, irq_3_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 4],  0, GD_KT, irq_4_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 5],  0, GD_KT, irq_5_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 6],  0, GD_KT, irq_6_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 7],  0, GD_KT, irq_7_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 8],  0, GD_KT, irq_8_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 9],  0, GD_KT, irq_9_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 10], 0, GD_KT, irq_10_handler, 0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 11], 0, GD_KT, irq_11_handler, 0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 12], 0, GD_KT, irq_12_handler, 0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 13], 0, GD_KT, irq_13_handler, 0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 14], 0, GD_KT, irq_14_handler, 0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 15], 0, GD_KT, irq_15_handler, 0);</div><div class="line"></div><div class="line">// In kern/env.c, env_alloc():</div><div class="line">// Enable interrupts while in user mode.</div><div class="line">// LAB 4: Your code here.</div><div class="line">// simply use bit or to set FL_IF</div><div class="line">e-&gt;env_tf.tf_eflags |= FL_IF;</div><div class="line"></div><div class="line">// In kern/sched.c, sched_halt():</div><div class="line">// Reset stack pointer, enable interrupts and then halt.</div><div class="line">asm volatile (</div><div class="line">    "movl $0, %%ebp\n"</div><div class="line">    "movl %0, %%esp\n"</div><div class="line">    "pushl $0\n"</div><div class="line">    "pushl $0\n"</div><div class="line">    // Uncomment the following line after completing exercise 13</div><div class="line">    "sti\n"</div><div class="line">    "1:\n"</div><div class="line">    "hlt\n"</div><div class="line">    "jmp 1b\n"</div><div class="line">: : "a" (thiscpu-&gt;cpu_ts.ts_esp0));</div></pre></td></tr></table></figure></p>
<h5 id="处理时钟中断"><a href="#处理时钟中断" class="headerlink" title="处理时钟中断"></a>处理时钟中断</h5><p>在<code>user/spin</code>程序中，在子环境第一次运行后，会陷入无限循环，而内核将无法得到控制权，需要对硬件编程以定时产生时钟中断，该终端会将控制权强行切回CPU，然后可以将控制权交给另一个用户环境。</p>
<p>对于<code>lapic_init()</code>和<code>pic_init()</code>的调用已经写好，它们会设置时钟并且终端控制器会定时生成中断。需要完成代码处理这些中断。</p>
<p>练习14中遇到的问题：</p>
<ul>
<li>首先需要调用<code>lapic_eoi()</code>以确认接收到了中断，否则会一直卡住</li>
</ul>
<p>练习14的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in kern/trap.c, trap_dispatch():</span></div><div class="line"><span class="comment">// new code added</span></div><div class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</div><div class="line">    <span class="comment">// dispatch clock interupts</span></div><div class="line">    <span class="comment">// call sched_yield() to find and run a different environment</span></div><div class="line">    <span class="comment">// NB: should first call lapic_eoi() to ACKNOWLEDGE interupt</span></div><div class="line">    lapic_eoi();</div><div class="line">    sched_yield();</div><div class="line">    <span class="comment">// sched_yield() might not return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h4><p>到目前位置实验一直关注于操作系统的独立部分，操作系统通过虚拟化提供了一种每个环境都独占整个机器的“错觉”。然而操作系统的另一项服务是允许程序在必要的时候通讯，该功能非常强大，Unix管道就是一个典型的例子。</p>
<p>有许多进程间通讯的模型，即使是现在也有许多关于哪一种模型是最好的争论。我们不参与争论。相反，我们将实现一个简单的IPC模型。</p>
<h5 id="JOS中的IPC"><a href="#JOS中的IPC" class="headerlink" title="JOS中的IPC"></a>JOS中的IPC</h5><p>你将实现一些额外的JOS内核系统调用，这些调用共同提供一个简单的进程间通讯机制。具体的系统调用为<code>sys_ipc_recv()</code>和<code>sys_ipc_try_send()</code>，然后你将实现两个库包装<code>ipc_recv()</code>和<code>ipc_send()</code>。</p>
<p>用户环境通过JOS的IPC机制向其他环境互相发送的信息包括两部分，一个32-bit的值和一个可选的单页映射。允许环境传递页映射提供了一个比传递一个32-bit的整数更有效的数据交换方式，这也可以较为方便的设置共享内存。</p>
<h5 id="发送和接收消息"><a href="#发送和接收消息" class="headerlink" title="发送和接收消息"></a>发送和接收消息</h5><p>环境调用<code>sys_ipc_recv()</code>去接受消息。该系统调用取消调度当前环境并且直到一条消息被收到后才会被继续运行。当一个环境等待接收消息时，任何其他的环境可以向其发送一条消息 - 并不限于特定的环境，也不限于父子进程间传递消息，换言之，你在第一部分中实现的权限检查将不适用于IPC，因为IPC系统调用经过精心设计以保证安全，环境不会通过简单地发送消息而导致其他环境出现错误（除非目标环境也有错误）。</p>
<p>环境调用<code>sys_ipc_try_send()</code>去尝试发送一个值（并附带上接受者的环境ID），如果指定的环境实际上正在接受该值（已调用<code>sys_ipc_recv()</code>并且尚未获得值），则值成功发送并返回0。否则，返回-E_IPC_NOT_RECV表示目标环境当前不期望接收值。</p>
<p>用户空间的库函数<code>ipc_recv()</code>将负责调用<code>sys_ipc_recv()</code>并在当前环境的<code>struct Env</code>中查找接收值的信息。</p>
<p>用户空间的库函数<code>ipc_send()</code>将负责反复调用<code>sys_ipc_try_send()</code>直到发送成功。</p>
<h5 id="传输页"><a href="#传输页" class="headerlink" title="传输页"></a>传输页</h5><p>当一个环境以一个有效的<code>dstva</code>参数（小于UTOP）调用<code>sys_ipc_recv()</code>时，环境改变状态以表明想要接受一个页映射。如果发送者发送了一个页，那么该页将会被映射到接收者地址空间的<code>dstva</code>处。如果接收者已经在<code>dstva</code>映射了一页，那么之前的页会被解映射。</p>
<p>当一个环境以一个有效的<code>srcva</code>参数（小于UTOP）调用<code>sys_ipc_try_send()</code>时，表明发送者想要将当前映射在<code>srcva</code>的页发送给接收者，并且带有权限<code>perm</code>。在一次成功的IPC之后，发送者在其地址空间保留在<code>srcva</code>处原有的页映射，但是接收者也持有最开始由发送者指定的相同的物理页面在<code>dstva</code>的映射。最终，该页面在发送者和接收者之间共享。</p>
<p>如果发送者和接收者两者之一没有表明要传输页面，那么将不会有页面被传输。在任意一次IPC之后将接收者的<code>struct Env</code>中新的域<code>env_ipc_perm</code>设置为接受页面的权限，如果没有收到页面，则为0。</p>
<h5 id="实现IPC"><a href="#实现IPC" class="headerlink" title="实现IPC"></a>实现IPC</h5><p>练习15中遇到的问题：</p>
<ul>
<li>在<code>sys_ipc_try_send()</code>和<code>sys_ipc_recv()</code>中，均不将超过UTOP的地址标记为错误，超过UTOP的地址是无效的，但并不会导致系统调用失败</li>
<li>在<code>sys_ipc_recv()</code>中在接收到消息前将环境状态置为不可运行，那么在收到消息后，应当恢复到可运行的状态</li>
<li>在<code>sys_ipc_try_send()</code>中调用<code>page_lookup()</code>时，要记住检查的是源地址的映射，因此应当使用当前环境的页表而非接收者环境的页表</li>
</ul>
<p>练习15的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In kern/syscall.c, sys_ipc_recv():</span></div><div class="line"><span class="comment">// Block until a value is ready.  Record that you want to receive</span></div><div class="line"><span class="comment">// using the env_ipc_recving and env_ipc_dstva fields of struct Env,</span></div><div class="line"><span class="comment">// mark yourself not runnable, and then give up the CPU.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// If 'dstva' is &lt; UTOP, then you are willing to receive a page of data.</span></div><div class="line"><span class="comment">// 'dstva' is the virtual address at which the sent page should be mapped.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// This function only returns on error, but the system call will eventually</span></div><div class="line"><span class="comment">// return 0 on success.</span></div><div class="line"><span class="comment">// Return &lt; 0 on error.  Errors are:</span></div><div class="line"><span class="comment">//  -E_INVAL if dstva &lt; UTOP but dstva is not page-aligned.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_ipc_recv</span><span class="params">(<span class="keyword">void</span> *dstva)</span> </span>&#123;</div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// similar to sys_ipc_try_send, will not mark an error</span></div><div class="line">    <span class="comment">// if dstva &gt;= UTOP</span></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)dstva &lt; UTOP &amp;&amp; PGOFF(dstva) != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// if dstva &lt; UTOP but dstva is not page-aligned</span></div><div class="line">        <span class="comment">// NB: &amp;&amp; rather than ||, we won't report error</span></div><div class="line">        <span class="comment">// when dstva &gt;= UTOP</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// mark calling environment as not runnable</span></div><div class="line">    curenv-&gt;env_status = ENV_NOT_RUNNABLE;</div><div class="line">    <span class="comment">// update status to mark receiver is willing to receive message</span></div><div class="line">    curenv-&gt;env_ipc_recving = <span class="literal">true</span>;</div><div class="line">    curenv-&gt;env_ipc_dstva   = dstva;</div><div class="line"></div><div class="line">    <span class="comment">// give up cpu</span></div><div class="line">    sys_yield();</div><div class="line"></div><div class="line">    <span class="comment">// panic("sys_ipc_recv not implemented");</span></div><div class="line"></div><div class="line">    <span class="comment">// ipc succeeds</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In kern/syscall.c, sys_ipc_try_send():</span></div><div class="line"><span class="comment">// Try to send 'value' to the target env 'envid'.</span></div><div class="line"><span class="comment">// If srcva &lt; UTOP, then also send page currently mapped at 'srcva',</span></div><div class="line"><span class="comment">// so that receiver gets a duplicate mapping of the same page.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// The send fails with a return value of -E_IPC_NOT_RECV if the</span></div><div class="line"><span class="comment">// target is not blocked, waiting for an IPC.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// The send also can fail for the other reasons listed below.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Otherwise, the send succeeds, and the target's ipc fields are</span></div><div class="line"><span class="comment">// updated as follows:</span></div><div class="line"><span class="comment">//    env_ipc_recving is set to 0 to block future sends;</span></div><div class="line"><span class="comment">//    env_ipc_from is set to the sending envid;</span></div><div class="line"><span class="comment">//    env_ipc_value is set to the 'value' parameter;</span></div><div class="line"><span class="comment">//    env_ipc_perm is set to 'perm' if a page was transferred, 0 otherwise.</span></div><div class="line"><span class="comment">// The target environment is marked runnable again, returning 0</span></div><div class="line"><span class="comment">// from the paused sys_ipc_recv system call.  (Hint: does the</span></div><div class="line"><span class="comment">// sys_ipc_recv function ever actually return?)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// If the sender wants to send a page but the receiver isn't asking for one,</span></div><div class="line"><span class="comment">// then no page mapping is transferred, but no error occurs.</span></div><div class="line"><span class="comment">// The ipc only happens when no errors occur.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.</span></div><div class="line"><span class="comment">// Errors are:</span></div><div class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist.</span></div><div class="line"><span class="comment">//      (No need to check permissions.)</span></div><div class="line"><span class="comment">//  -E_IPC_NOT_RECV if envid is not currently blocked in sys_ipc_recv,</span></div><div class="line"><span class="comment">//      or another environment managed to send first.</span></div><div class="line"><span class="comment">//  -E_INVAL if srcva &lt; UTOP but srcva is not page-aligned.</span></div><div class="line"><span class="comment">//  -E_INVAL if srcva &lt; UTOP and perm is inappropriate</span></div><div class="line"><span class="comment">//      (see sys_page_alloc).</span></div><div class="line"><span class="comment">//  -E_INVAL if srcva &lt; UTOP but srcva is not mapped in the caller's</span></div><div class="line"><span class="comment">//      address space.</span></div><div class="line"><span class="comment">//  -E_INVAL if (perm &amp; PTE_W), but srcva is read-only in the</span></div><div class="line"><span class="comment">//      current environment's address space.</span></div><div class="line"><span class="comment">//  -E_NO_MEM if there's not enough memory to map srcva in envid's</span></div><div class="line"><span class="comment">//      address space.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_ipc_try_send</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">uint32_t</span> value, <span class="keyword">void</span> *srcva,</span></span></div><div class="line">                            <span class="keyword">unsigned</span> perm) &#123;</div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// check for existence of env with envid</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></div><div class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">false</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// environment envid doesn't currently exist</span></div><div class="line">        <span class="keyword">return</span> -E_BAD_ENV;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// check receiver's status</span></div><div class="line">    <span class="keyword">if</span> (!env-&gt;env_ipc_recving) &#123;</div><div class="line">        <span class="comment">// envid is not currently blocked in sys_ipc_recv</span></div><div class="line">        <span class="comment">// or another environment managed to send first</span></div><div class="line">        <span class="keyword">return</span> -E_IPC_NOT_RECV;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)srcva &lt; UTOP) &#123;</div><div class="line">        <span class="comment">// srcva is valid</span></div><div class="line">        <span class="comment">// check srcva is page-aligned</span></div><div class="line">        <span class="keyword">if</span> (PGOFF(srcva) != <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// srcva is not page-aligned</span></div><div class="line">            <span class="keyword">return</span> -E_INVAL;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// check perm passed in</span></div><div class="line">        <span class="keyword">if</span> ((perm &amp; (~PTE_SYSCALL)) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P)) &#123;</div><div class="line">            <span class="comment">// invalid perm</span></div><div class="line">            <span class="keyword">return</span> -E_INVAL;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// check srcva actually be mapped</span></div><div class="line">        <span class="keyword">pte_t</span> *          pgtable_entry;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span>;</span></div><div class="line">        <span class="keyword">if</span> ((page = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;pgtable_entry)) ==</div><div class="line">            <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="comment">// NB: check for SRCVA here, so use curenv-&gt;env_pgdir</span></div><div class="line">            <span class="comment">// srcva is not mapped at caller's address space</span></div><div class="line">            <span class="keyword">return</span> -E_INVAL;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// check PTE_W between sender and receiver</span></div><div class="line">        <span class="keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; (!((*pgtable_entry) &amp; PTE_W))) &#123;</div><div class="line">            <span class="comment">// if perm has PTE_W while srcva is read-only in</span></div><div class="line">            <span class="comment">// current environment's address space</span></div><div class="line">            <span class="keyword">return</span> -E_INVAL;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)(env-&gt;env_ipc_dstva) &lt; UTOP) &#123;</div><div class="line">            <span class="comment">// receiver also expects page to be transferred</span></div><div class="line">            <span class="comment">// call page_insert to actually transer the page</span></div><div class="line">            <span class="keyword">if</span> (page_insert(env-&gt;env_pgdir, page, env-&gt;env_ipc_dstva, perm) &lt;</div><div class="line">                <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// out of memory when try to insert page</span></div><div class="line">                <span class="keyword">return</span> -E_NO_MEM;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// page successfully transferred</span></div><div class="line">            env-&gt;env_ipc_perm = perm;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// srcva &gt;= UTOP</span></div><div class="line">        <span class="comment">// invalid srcva, but we won't return error here</span></div><div class="line">        <span class="comment">// ipc_send will panic if we do so</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// update receiver's information</span></div><div class="line">    env-&gt;env_ipc_recving = <span class="literal">false</span>;</div><div class="line">    env-&gt;env_ipc_from    = curenv-&gt;env_id;</div><div class="line">    env-&gt;env_ipc_value   = value;</div><div class="line">    <span class="comment">// mark receiver to be runnable to match what we do in sys_ipc_recv</span></div><div class="line">    env-&gt;env_status = ENV_RUNNABLE;</div><div class="line">    <span class="comment">// modify trapframe's eax register to `update' return value</span></div><div class="line">    env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// panic("sys_ipc_try_send not implemented");</span></div><div class="line"></div><div class="line">    <span class="comment">// ipc succeeds</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In lib/ipc.c, ipc_recv():</span></div><div class="line"><span class="comment">// Receive a value via IPC and return it.</span></div><div class="line"><span class="comment">// If 'pg' is nonnull, then any page sent by the sender will be mapped at</span></div><div class="line"><span class="comment">//	that address.</span></div><div class="line"><span class="comment">// If 'from_env_store' is nonnull, then store the IPC sender's envid in</span></div><div class="line"><span class="comment">//	*from_env_store.</span></div><div class="line"><span class="comment">// If 'perm_store' is nonnull, then store the IPC sender's page permission</span></div><div class="line"><span class="comment">//	in *perm_store (this is nonzero if a page was successfully</span></div><div class="line"><span class="comment">//	transferred to 'pg').</span></div><div class="line"><span class="comment">// If the system call fails, then store 0 in *fromenv and *perm (if</span></div><div class="line"><span class="comment">//	they're nonnull) and return the error.</span></div><div class="line"><span class="comment">// Otherwise, return the value sent by the sender</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Hint:</span></div><div class="line"><span class="comment">//   Use 'thisenv' to discover the value and who sent it.</span></div><div class="line"><span class="comment">//   If 'pg' is null, pass sys_ipc_recv a value that it will understand</span></div><div class="line"><span class="comment">//   as meaning "no page".  (Zero is not the right value, since that's</span></div><div class="line"><span class="comment">//   a perfectly valid place to map a page.)</span></div><div class="line"><span class="keyword">int32_t</span> ipc_recv(<span class="keyword">envid_t</span> *from_env_store, <span class="keyword">void</span> *pg, <span class="keyword">int</span> *perm_store) &#123;</div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// check pg, if pg is null, then should set it to UTOP,</span></div><div class="line">    <span class="comment">// for only if dstva is below UTOP, sender knows that</span></div><div class="line">    <span class="comment">// receiver wants a page to be transferred</span></div><div class="line">    <span class="keyword">if</span> (!pg) &#123; pg = (<span class="keyword">void</span> *)UTOP; &#125;</div><div class="line">    <span class="keyword">int</span> r;</div><div class="line">    <span class="keyword">if</span> ((r = sys_ipc_recv(pg)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// system call fails</span></div><div class="line">        <span class="comment">// store from env and perm if corresponding pointer is not null</span></div><div class="line">        <span class="keyword">if</span> (from_env_store) &#123; *from_env_store = <span class="number">0</span>; &#125;</div><div class="line">        <span class="keyword">if</span> (perm_store) &#123; *perm_store = <span class="number">0</span>; &#125;</div><div class="line">        <span class="comment">// return the error</span></div><div class="line">        <span class="keyword">return</span> r;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// system call succeeds</span></div><div class="line">    <span class="comment">// extract information from thisenv's IPC fields</span></div><div class="line">    <span class="keyword">if</span> (from_env_store) &#123;</div><div class="line">        <span class="comment">// store IPC sender's envid into *from_env_store</span></div><div class="line">        *from_env_store = thisenv-&gt;env_ipc_from;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (perm_store) &#123;</div><div class="line">        <span class="comment">// store IPC sender's page permission</span></div><div class="line">        *perm_store = thisenv-&gt;env_ipc_perm;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// panic("ipc_recv not implemented");</span></div><div class="line"></div><div class="line">    <span class="comment">// return the value send by the sender</span></div><div class="line">    <span class="keyword">return</span> thisenv-&gt;env_ipc_value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In kern/syscall.c, syscall():</span></div><div class="line"><span class="comment">// new code added</span></div><div class="line"><span class="keyword">case</span> SYS_ipc_recv:</div><div class="line">    <span class="comment">// call sys_ipc_recv</span></div><div class="line">    <span class="keyword">return</span> sys_ipc_recv((<span class="keyword">void</span> *)a1);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> SYS_ipc_try_send:</div><div class="line">    <span class="comment">// call sys_ipc_try_send</span></div><div class="line">    <span class="keyword">return</span> sys_ipc_try_send((<span class="keyword">envid_t</span>)a1, (<span class="keyword">uint32_t</span>)a2, (<span class="keyword">void</span> *)a3,</div><div class="line">                            (<span class="keyword">unsigned</span>)a4);</div><div class="line"></div><div class="line"><span class="comment">// In lib/ipc.c, ipc_send():</span></div><div class="line"><span class="comment">// Send 'val' (and 'pg' with 'perm', if 'pg' is nonnull) to 'toenv'.</span></div><div class="line"><span class="comment">// This function keeps trying until it succeeds.</span></div><div class="line"><span class="comment">// It should panic() on any error other than -E_IPC_NOT_RECV.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Hint:</span></div><div class="line"><span class="comment">//   Use sys_yield() to be CPU-friendly.</span></div><div class="line"><span class="comment">//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand</span></div><div class="line"><span class="comment">//   as meaning "no page".  (Zero is not the right value.)</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ipc_send</span><span class="params">(<span class="keyword">envid_t</span> to_env, <span class="keyword">uint32_t</span> val, <span class="keyword">void</span> *pg, <span class="keyword">int</span> perm)</span> </span>&#123;</div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// check pg, if pg is null, then should set it to UTOP(invalid value</span></div><div class="line">    <span class="comment">// but won't result in panic)</span></div><div class="line">    <span class="keyword">if</span> (!pg) &#123; pg = (<span class="keyword">void</span> *)UTOP; &#125;</div><div class="line">    <span class="keyword">int</span> r;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        <span class="comment">// keeps trying until succeeds or panic</span></div><div class="line">        r = sys_ipc_try_send(to_env, val, pg, perm);</div><div class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// message successfully sent, return</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (r != -E_IPC_NOT_RECV) &#123;</div><div class="line">            <span class="comment">// error when sending, should panic</span></div><div class="line">            panic(<span class="string">"failed to send messages - %e!"</span>, r);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// use sys_yield to avoid waste on CPU</span></div><div class="line">        sys_yield();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// panic("ipc_send not implemented");</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h2><p>最终执行<code>make grade</code>，评分脚本的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">dumbfork:</div><div class="line">$ make run-dumbfork-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.6s)</div><div class="line">Part A score: 5/5</div><div class="line">faultread:</div><div class="line">$ make run-faultread-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">faultwrite:</div><div class="line">$ make run-faultwrite-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">faultdie:</div><div class="line">$ make run-faultdie-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">faultregs:</div><div class="line">$ make run-faultregs-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.1s)</div><div class="line">faultalloc:</div><div class="line">$ make run-faultalloc-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (4.6s)</div><div class="line">faultallocbad:</div><div class="line">$ make run-faultallocbad-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.3s)</div><div class="line">faultnostack:</div><div class="line">$ make run-faultnostack-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.8s)</div><div class="line">faultbadhandler:</div><div class="line">$ make run-faultbadhandler-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.2s)</div><div class="line">faultevilhandler:</div><div class="line">$ make run-faultevilhandler-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">forktree:</div><div class="line">$ make run-forktree-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.4s)</div><div class="line">Part B score: 50/50</div><div class="line">spin:</div><div class="line">$ make run-spin-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (0.7s)</div><div class="line">stresssched:</div><div class="line">$ make run-stresssched-nox-gdb CPUS=4 QEMUEXTRA+=-snapshot</div><div class="line">OK (3.0s)</div><div class="line">sendpage:</div><div class="line">$ make run-sendpage-nox-gdb CPUS=2 QEMUEXTRA+=-snapshot</div><div class="line">OK (1.7s)</div><div class="line">pingpong:</div><div class="line">$ make run-pingpong-nox-gdb CPUS=4 QEMUEXTRA+=-snapshot</div><div class="line">OK (2.1s)</div><div class="line">primes:</div><div class="line">$ make run-primes-nox-gdb CPUS=4 QEMUEXTRA+=-snapshot</div><div class="line">OK (4.5s)</div><div class="line">Part C score: 25/25</div><div class="line">Score: 80/80</div></pre></td></tr></table></figure><br>至此，实验四结束。</p>
<p>第四个实验是第一到第四个实验中难度最大、代码量最多的一个实验，在前三个实验中任何的代码错误（尽管可能在当时的实验评分中没有反映出来）都会导致实验四出现难以调试的错误。</p>
<p>实验四中每个练习遇到的问题我都已经在报告中总结，此外，也在代码中以NB标明。其中大部分都是一些小错误，还有少部分是没有将问题考虑全面导致的。尽管如此，几乎每一个错误我都花费了至少几十分钟去调试。</p>
<p>操作系统的调试不仅仅困难（Triple Fault会导致不打补丁的qemu重启），任何一个小错误都会导致系统崩溃。现代操作系统如Linux的鲁棒性可见一斑。</p>
<p>本学期的事情比起上学期只增不减，加上课程设计只要求完成四个实验，实验四结束后，MIT-6.828系列就告一段落了。</p>
<p>希望我的这四篇实验报告能对正在写实验的你产生些许的启发，也欢迎找我交流相关的问题。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 页 共 1 页</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 CoSidian. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">CoSidian</h4>
        
            <div id="about-card-bio"><p>码龙黑曜 - iOS开发者/计算机科学/兽人控</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>本科在读</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                HUST, Wuhan, China
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-i7zzex3jvqnxdf0lp2pg3bcyurjikigtrw9ljle5skc4mit2m7a13rwuyp8g.min.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
