
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="码龙的窝">
    <title>分类: 操作系统 - 码龙的窝</title>
    <meta name="author" content="CoSidian">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="/* 0与1之风吹遍山谷 */">
<meta property="og:type" content="blog">
<meta property="og:title" content="码龙的窝">
<meta property="og:url" content="http://blog.codedragon.tech/categories/操作系统/index.html">
<meta property="og:site_name" content="码龙的窝">
<meta property="og:description" content="/* 0与1之风吹遍山谷 */">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="码龙的窝">
<meta name="twitter:description" content="/* 0与1之风吹遍山谷 */">
    
    
        
    
    
        <meta property="og:image" content="http://blog.codedragon.tech/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-gtvt1lbvzeqmr99zec4y42qrxw5ogq1gul5orw7somyh6cv5ckqsrl4abr9a.min.css">
    <!--STYLES END-->
    
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-108458894-1', 'auto');
        ga('send', 'pageview');
    </script>


    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">码龙的窝</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">CoSidian</h4>
                
                    <h5 class="sidebar-profile-bio"><p>码龙黑曜 - iOS开发者/计算机科学/兽人控</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="首页"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="分类"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="标签"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="归档"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/about"
                            
                            title="关于"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/BlackDragonF" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://t.me/Cosidian" target="_blank" rel="noopener" title="Telegram">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-paper-plane" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Telegram</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://steamcommunity.com/id/BlackDragonF/" target="_blank" rel="noopener" title="Steam">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-steam" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Steam</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:obsidiandragon2016@gmail.com" target="_blank" rel="noopener" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/friendly-links"
                            
                            title="友情链接"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-link" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">友情链接</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/book-recommend"
                            
                            title="图书推荐"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-book" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">图书推荐</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/">
                            MIT6.828操作系统工程Lab3-User Environments实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-02-23T19:12:13+08:00">
	
		    2月 23, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <blockquote>
<p>Lab3 - User Environments需要实现基本的内核功能，使得一个受保护的用户环境（进程）可以运行。在本实验中，需要让内核设置数据结构以追踪用户环境，创建一个单用户环境，加载程序镜像并执行。此外，内核还需要能处理用户环境的系统调用以及引发的异常。</p>
</blockquote>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>根据官网，我们切换到分支lab3并且合并分支lab2，在合并的过程中，发生了冲突。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user% git checkout -b lab3 origin/lab3</div><div class="line">user% git merge lab2</div></pre></td></tr></table></figure>
<p>根据提示，是<code>kern/monitor.c</code>中发生了冲突，因为仅有一处冲突，手动编辑<code>kern/monitor.c</code>文件，并commit，即可解决冲突并合并分支。</p>
<p>实验三包括如下的新文件：</p>
<ul>
<li>inc/env.h 用户模式环境的公有定义</li>
<li>inc/trap.h 陷阱处理的公有定义</li>
<li>inc/syscall.h 用户环境对内核的系统调用的公有定义</li>
<li>inc/lib.h 用户模式支持的库公有定义</li>
<li>kern/env.h 用户模式环境的内核私有定义</li>
<li>kern/env.c 用户模式环境的内核代码实现</li>
<li>kern/trap.h 内核私有的陷阱处理定义</li>
<li>kern/trap.c 陷阱处理代码</li>
<li>kern/trapentry.S 汇编语言的陷阱处理程序入口</li>
<li>kern/syscall.h 系统调用处理的内核私有定义</li>
<li>kern/syscall.c 系统调用实现代码</li>
<li>lib/Makefrag 用户模式库obj/lib/libjos.a的Makefile</li>
<li>lib/entry.S 用户环境的汇编语言入口</li>
<li>lib/libmain.c entry.S调用的用户模式库安装代码</li>
<li>lib/syscall.c 用户模式系统调用的打桩函数</li>
<li>lib/console.c 用户模式的putchar和getchar实现，提供了控制台IO</li>
<li>lib/exit.c 用户模式的exit实现</li>
<li>lib/panic.c 用户模式的panic实现</li>
<li>user/* 检验内核实验三代码的测试程序</li>
</ul>
<p>此外，lab2中的一些文件在lab3中也被添加了新的内容，可以用<code>git diff lab2</code>查看具体的比较信息。</p>
<h4 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h4><p>本实验中可能会用到<code>GCC</code>的内联汇编特性，应当至少理解给出的代码中的内联汇编代码片段。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="第一部分-User-Environments-and-Exception-Handling-用户环境和错误处理"><a href="#第一部分-User-Environments-and-Exception-Handling-用户环境和错误处理" class="headerlink" title="第一部分 User Environments and Exception Handling - 用户环境和错误处理"></a>第一部分 User Environments and Exception Handling - 用户环境和错误处理</h3><p><code>inc/env.h</code>中给出了用户环境的基本定义。内核通过<code>struct Env</code>追踪每一个用户环境。本实验中只需要创建一个环境，然而你需要设计JOS内核实际支持多用户环境。实验四中，你将通过允许一个用户环境<code>fork</code>别的用户环境来利用多用户环境的特性。</p>
<p><code>kern/env.c</code>中可以看到，内核管理3个与环境有关的全局变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">envs</span> = <span class="title">NULL</span>;</span>		<span class="comment">// All environments</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">curenv</span> = <span class="title">NULL</span>;</span>		<span class="comment">// The current env</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span>	<span class="comment">// Free environment list</span></div></pre></td></tr></table></figure></p>
<p>当JOS成功运行之后，<code>envs</code>指针指向一个<code>struct Env</code>的数组，代表了系统中所有的环境。在设计上，JOS内核允许<code>NNEV</code>个同时激活的环境，<code>NNEV</code>在<code>inc/env.h</code>中定义。<br>JOS内核使用<code>env_free_list</code>维护所有未激活的<code>struct Env</code>，这样的设计简化的环境的分配和释放，它们仅仅需要从该链表上添加或移除。<br>JOS内核使用<code>curenv</code>去追踪在任意时刻当前正在执行的环境。在启动之后到第一个环境运行的时间段中，<code>curenv</code>被初始化为<code>NULL</code>。</p>
<h4 id="环境状态"><a href="#环境状态" class="headerlink" title="环境状态"></a>环境状态</h4><p><code>struct Env</code>在<code>inc/env.h</code>中被定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>	<span class="comment">// Saved registers</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>		<span class="comment">// Next free Env</span></div><div class="line">	<span class="keyword">envid_t</span> env_id;			<span class="comment">// Unique environment identifier</span></div><div class="line">	<span class="keyword">envid_t</span> env_parent_id;		<span class="comment">// env_id of this env's parent</span></div><div class="line">	<span class="keyword">enum</span> EnvType env_type;		<span class="comment">// Indicates special system environments</span></div><div class="line">	<span class="keyword">unsigned</span> env_status;		<span class="comment">// Status of the environment</span></div><div class="line">	<span class="keyword">uint32_t</span> env_runs;		<span class="comment">// Number of times environment has run</span></div><div class="line"></div><div class="line">	<span class="comment">// Address space</span></div><div class="line">	<span class="keyword">pde_t</span> *env_pgdir;		<span class="comment">// Kernel virtual address of page dir</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<ul>
<li>env_tf - <code>struct TrapFrame</code>在<code>inc/trap.h</code>中被定义，表示了当环境不运行时被保存的寄存器值，主要用于上下文切换。</li>
<li>env_link - 指向了<code>env_free_list</code>上的下一个<code>struct Env</code>。<code>env_free_list</code>指向了链表中的第一个空闲环境。</li>
<li>env_id - 唯一标识当前正在使用<code>struct Env</code>的环境。当环境终止后，<code>struct Env</code>可能被内核重新分配用于另一个不同的环境，但它们的env_id是不同的。</li>
<li>env_parent_id - 存储了创建该环境的环境的<code>env_id</code>，通过该方式构建一个环境树，用于安全方面的决策。</li>
<li>env_type - 用于区分特殊环境，对于大部分环境，该值为<code>ENV_TYPE_USER</code>，在后续Lab中会介绍其他的值。</li>
<li>env_status - 状态<ol>
<li>ENV_FREE - 表明<code>struct Env</code>处于空闲状态，应当位于<code>env_free_list</code>上。</li>
<li>ENV_RUNNABLE - 表明<code>struct Env</code>代表的环境正等待运行于处理器上。</li>
<li>ENV_RUNNING - 表明<code>struct Env</code>代表的环境为正在运行的环境。</li>
<li>ENV_NOT_RUNNABLE - 表明<code>struct Env</code>代表了一个正在运行的环境，但却没有准备好运行，如正在等待另一个环境的IPC（进程间通信）。</li>
<li>ENV_DYING - 表明<code>struct Env</code>代表了一个僵死环境，僵死环境将在下一次陷入内核时被释放（直到Lab4才会使用该Flag）。</li>
</ol>
</li>
<li>env_pgdir - 保存了环境的页目录的内核虚拟地址。</li>
</ul>
<p>JOS中环境的概念综合了“线程”和“地址空间”，“线程”由<code>env_tf</code>域的被保存的寄存器值定义，“地址空间”由<code>env_pgdir</code>域指向的页目录和页表定义。为了运行一个环境，内核必须用保存的寄存器值和合适的地址空间设置CPU。</p>
<p>JOS的<code>struct Env</code>和xv6的<code>struct proc</code>很像，两种结构体都持有环境的用户模式寄存器状态（通过<code>struct TrapFrame</code>），然而，JOS中，独立的环境并不具有不同的内核栈，因为JOS内核中同时只能有一个运行的JOS环境，因此JOS只需要一个内核栈。</p>
<h4 id="分配环境数组"><a href="#分配环境数组" class="headerlink" title="分配环境数组"></a>分配环境数组</h4><p>练习1的代码，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Make 'envs' point to an array of size 'NENV' of 'struct Env'.</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// get size of envs</span></div><div class="line"><span class="keyword">uint32_t</span> envs_size = <span class="keyword">sizeof</span>(struct Env) * NENV;</div><div class="line"><span class="comment">// use boot_alloc to allocate memory</span></div><div class="line">envs = (struct Env *)boot_alloc(envs_size);</div><div class="line"><span class="comment">// initialization</span></div><div class="line"><span class="built_in">memset</span>(envs, <span class="number">0</span>, envs_size);</div><div class="line"></div><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Map the 'envs' array read-only by the user at linear address UENVS</span></div><div class="line"><span class="comment">// (ie. perm = PTE_U | PTE_P).</span></div><div class="line"><span class="comment">// Permissions:</span></div><div class="line"><span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></div><div class="line"><span class="comment">//    - envs itself -- kernel RW, user NONE</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line">boot_map_region(kern_pgdir, UENVS, envs_size, PADDR(envs), PTE_U | PTE_P);</div></pre></td></tr></table></figure></p>
<h4 id="创建并运行环境"><a href="#创建并运行环境" class="headerlink" title="创建并运行环境"></a>创建并运行环境</h4><p>现在将在<code>kern/env.c</code>中编写必要的代码去运行用户环境。由于JOS内核还不支持文件系统，我们将配置内核以加载一个嵌入内核中静态二进制镜像。JOS内核将这个二进制镜像以ELF可执行镜像格式嵌入。</p>
<p>Lab3的GNU<code>Makefile</code>在<code>obj/user/</code>目录下生成了一些二进制镜像。<code>kern/Makefrag</code>下可以看到，链接器的<code>-b binary</code>选项使得这些文件以原始的未被翻译二进制文件而非普通的被编译器生成的<code>.o</code>文件的方式链接， 通过<code>-b binary</code>方式链接的二进制文件就链接器而言可以为任意类型，甚至是文本文件或是图片。</p>
<p>如果在构建内核后观察<code>obj/kern/kernel.sym</code>，可以看到链接器生成了一些“奇怪”名字的符号如<code>_binary_obj_user_hello_start</code>， <code>_binary_obj_user_hello_end</code>或 <code>_binary_obj_user_hello_size</code>。链接器通过二进制文件的名字生成了这些符号的名字，这些符号使得内核代码可以以某种方式引用这些嵌入的二进制文件。</p>
<p>练习2中遇到的问题：</p>
<ul>
<li>除了<code>env-&gt;env_tf.tf_eip</code>以外不要修改其他的值，因为其已经在<code>env_alloc()</code>中被初始化</li>
<li><code>region_alloc()</code>中笔误导致只映射了一页</li>
<li><code>load_icode()</code>中需要切换页表，之后加载每段仅用一个<code>memcpy</code>即可实现<br>练习2的代码如下，仅供参考：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In env_init():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="keyword">ssize_t</span> i;</div><div class="line"><span class="comment">// loop in reverse order to keep ascending order in env free list</span></div><div class="line"><span class="keyword">for</span> (i = NENV - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i--) &#123;</div><div class="line">    <span class="comment">// set env_status, env_id</span></div><div class="line">    envs[i].env_status = ENV_FREE;</div><div class="line">    envs[i].env_id = <span class="number">0</span>;</div><div class="line">    <span class="comment">// set env_link and insert into env_free_list</span></div><div class="line">    envs[i].env_link = env_free_list;</div><div class="line">    env_free_list = &amp;envs[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In env_setup_vm():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// set env_pgdir and generate page directory based on kern_pgdir</span></div><div class="line">e-&gt;env_pgdir = (<span class="keyword">pde_t</span> *)page2kva(p);</div><div class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</div><div class="line"><span class="comment">// increase pp_ref</span></div><div class="line">p-&gt;pp_ref++;</div><div class="line"></div><div class="line"><span class="comment">// In region_alloc():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// (But only if you need it for load_icode.)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></div><div class="line"><span class="comment">//   'va' and 'len' values that are not page-aligned.</span></div><div class="line"><span class="comment">//   You should round va down, and round (va + len) up.</span></div><div class="line"><span class="comment">//   (Watch out for corner-cases!)</span></div><div class="line"></div><div class="line"><span class="comment">// round va and va + len</span></div><div class="line"><span class="keyword">uintptr_t</span> start = (<span class="keyword">uintptr_t</span>)ROUNDDOWN(va, PGSIZE);</div><div class="line"><span class="keyword">uintptr_t</span> end = (<span class="keyword">uintptr_t</span>)ROUNDUP(va + len, PGSIZE);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (; start &lt; end ; start += PGSIZE) &#123;</div><div class="line">    <span class="comment">// alloc page</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">p</span>;</span></div><div class="line">    p = page_alloc(ALLOC_ZERO);</div><div class="line">    <span class="keyword">if</span> (!p) &#123;</div><div class="line">        panic(<span class="string">"out of memory when allocating region!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// insert page into environment's page directory</span></div><div class="line">    <span class="keyword">if</span> (page_insert(e-&gt;env_pgdir, p, (<span class="keyword">char</span> *)start , PTE_W | PTE_U | PTE_P) &lt; <span class="number">0</span>) &#123;</div><div class="line">        panic(<span class="string">"out of memory when allocating region!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In load_icode():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// switch address space for loading program segments</span></div><div class="line">lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> * <span class="title">elf</span> = (<span class="title">struct</span> <span class="title">Elf</span> *)<span class="title">binary</span>;</span></div><div class="line"><span class="comment">// check elf magic</span></div><div class="line"><span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123;</div><div class="line">    panic(<span class="string">"invalid elf format!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// set the program entry for env</span></div><div class="line">e-&gt;env_tf.tf_eip = elf-&gt;e_entry;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> * <span class="title">ph</span>, *<span class="title">eph</span>;</span></div><div class="line"></div><div class="line"><span class="comment">// get the start and end of program header entry</span></div><div class="line">ph = (struct Proghdr *)(binary + elf-&gt;e_phoff);</div><div class="line">eph = ph + elf-&gt;e_phnum;</div><div class="line"><span class="keyword">for</span>(; ph &lt; eph ; ph++) &#123;</div><div class="line">    <span class="keyword">if</span> (ph-&gt;p_type == ELF_PROG_LOAD) &#123; <span class="comment">// if the segment is to be loaded</span></div><div class="line">        <span class="comment">// alloc corresponding region(clear zero)</span></div><div class="line">        region_alloc(e, (<span class="keyword">char</span> *)ph-&gt;p_va, ph-&gt;p_memsz);</div><div class="line">        <span class="comment">// copy from ELF header to virtual addresses directly</span></div><div class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span> *)ph-&gt;p_va, (<span class="keyword">char</span> *)binary + ph-&gt;p_offset, ph-&gt;p_filesz);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// switch back</span></div><div class="line">lcr3(PADDR(kern_pgdir));</div><div class="line"></div><div class="line"><span class="comment">// Now map one page for the program's initial stack</span></div><div class="line"><span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// allocate a page and insert it into env's page directory</span></div><div class="line"><span class="comment">// panic when page_alloc or page_insert failed</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">stack_page</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></div><div class="line"><span class="keyword">if</span> (!stack_page) &#123;</div><div class="line">    panic(<span class="string">"out of memory when alloc program's stack!"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (page_insert(e-&gt;env_pgdir, stack_page, (<span class="keyword">char</span> *)(USTACKTOP - PGSIZE), PTE_W | PTE_U | PTE_P) &lt; <span class="number">0</span>) &#123;</div><div class="line">    panic(<span class="string">"failed to set program's stack!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In env_create():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">env</span>;</span></div><div class="line"><span class="comment">// allocate new env with parent ID 0</span></div><div class="line"><span class="keyword">if</span> (env_alloc(&amp;env, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">    panic(<span class="string">"failed to allocate env!"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// load elf binary and set env_type</span></div><div class="line">load_icode(env, binary);</div><div class="line">env-&gt;env_type = type;</div><div class="line"></div><div class="line"><span class="comment">// In env_run():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="keyword">if</span> (curenv != <span class="literal">NULL</span>) &#123; <span class="comment">// context switch</span></div><div class="line">    <span class="keyword">if</span> (curenv-&gt;env_status == ENV_RUNNING) &#123;</div><div class="line">        <span class="comment">// change to runnable if current status is running</span></div><div class="line">        <span class="comment">// for not runnable, is not necessary to do this</span></div><div class="line">        curenv-&gt;env_status = ENV_RUNNABLE;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// set new curenv, update status and counter</span></div><div class="line">curenv = e;</div><div class="line">e-&gt;env_status = ENV_RUNNING;</div><div class="line">e-&gt;env_runs++;</div><div class="line"><span class="comment">// address space switch</span></div><div class="line"><span class="comment">// reference from inc/x86.h</span></div><div class="line">lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line"><span class="comment">// drop into user mode</span></div><div class="line">env_pop_tf(&amp;(e-&gt;env_tf));</div><div class="line"></div><div class="line"><span class="comment">// panic("env_run not yet implemented");</span></div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>成功进入用户环境后，若用户环境尝试使用<code>int</code>指令进行系统调用时，将产生错误，因为JOS没有设置任何从用户空间进入内核的方式。<br>当CPU发现无法处理系统中断调用后，会产生一个通用保护错误，发现无法处理它，然后生成一个二重错误，最终因无法处理而生成一个三重错误并放弃，然后系统重启。但是为了便于调试，patch的<code>qemu</code>不会重启。<br>关于重启的理由可以参考<a href="https://blogs.msdn.microsoft.com/larryosterman/2005/02/08/faster-syscall-trap-redux/" target="_blank" rel="external">这里</a>。</p>
</blockquote>
<p>完成后经过测试，程序在<code>int $0x30</code>处Triple Fault，可知本部分代码基本正确。</p>
<h4 id="处理中断和异常"><a href="#处理中断和异常" class="headerlink" title="处理中断和异常"></a>处理中断和异常</h4><p>练习3要求阅读Intel 80386编程手册中的<a href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/c09.htm" target="_blank" rel="external">第九章：异常和中断</a>。</p>
<p>本实验中我们将沿用Intel关于中断和异常的术语。中断是由处理器以外的异步事件引发的，而异常是由当前正在执行的指令同步引发的。</p>
<h4 id="保护控制转移基础"><a href="#保护控制转移基础" class="headerlink" title="保护控制转移基础"></a>保护控制转移基础</h4><p>异常和中断均为“保护控制转移”，会引发处理器从用户到内核模式（CPL=0），从而避免给用户模式的代码干扰内核或是其他环境的机会。这要求了引发中断或者是异常的代码不能选择进入内核的地点或方式。<br>在x86中，主要有两种机制一起保证了内核总是在受保护的情况下进入，这两种机制为中断描述符表（Interrupt Descriptor Table）和任务状态段（Task State Segment）。</p>
<p>中断描述符表中，处理器保证了异常和中断仅能导致内核在若干个具体的、由内核明确定义好的入口执行，而不是在中断和异常发生时运行的代码。<br>x86允许最多设立256个不同的中断或异常入口，每一个入口都具有一个中断向量。中断向量为0-255的数字，中断向量由中断来源决定：不同的设备，错误条件和应用程序对内核的请求会产生不同向量的中断。CPU使用中断向量作为处理器的中断描述符表的索引。中断描述符表在内核私有的内存中建立。<br>处理器从该表中加载送入EIP寄存器的值（处理程序的入口），以及送入CS段寄存器的值（包括了特权级，在JOS中，所有的异常均在内核模式执行，即特权级0）。</p>
<p>任务状态段。处理器需要在唤醒处理程序前将在中断或异常发生前的旧的处理器状态保存起来，如旧的EIP寄存器值和旧的CS段寄存器值，以便处理程序之后能恢复现场，从中断或异常发生的地方继续执行。然而，保存旧的处理器状态的区域必须对于非特权的用户模式代码处于被保护的状态。否则，错误的或是恶意的用户代码可能会破坏内核。<br>因此，当x86处理器从用户模式特权级切换到内核模式时，其也会切换到内核内存中的一个栈。任务状态段指定了相应的段寄存器以及相应栈的地址。处理器将<code>SS</code>, <code>EFLAGS</code>, <code>CS</code>, <code>EIP</code>以及一个可选的错误码压入这个新栈中。然后从中断描述符中读取相应的<code>CS</code>和<code>EIP</code>，并设置<code>ESP</code>和<code>SS</code>指向新的栈。<br>尽管<code>TSS</code>有着多种作用，JOS仅用它来定义从用户模式切换到内核模式时的内核栈。因为JOS中的内核模式为x86的特权级0，故处理器仅使用<code>TSS</code>的<code>ESP0</code>和<code>SS0</code>域。</p>
<h4 id="异常和中断的类型"><a href="#异常和中断的类型" class="headerlink" title="异常和中断的类型"></a>异常和中断的类型</h4><p>x86处理器能产生的所有同步异常均使用了0-31的中断向量，映射为<code>IDT</code>的0-31号入口。超过31的中断向量仅供由<code>int</code>指令或是由异步硬件中断产生的“软中断”使用。</p>
<h4 id="嵌套异常和中断"><a href="#嵌套异常和中断" class="headerlink" title="嵌套异常和中断"></a>嵌套异常和中断</h4><p>处理器能同时处理内核模式和用户模式的异常。在内核模式中的异常不需要切换栈，因此，不需要压入旧的<code>SS</code>和<code>ESP</code>值。通过这种方式，内核可以优雅地处理内核产生的嵌套异常和中断。该能力对于实现保护是非常重要的。</p>
<p>若处理器已经在内核模式中并且接受了一个异常并且无法将旧值压入内核栈中时（如内存不足），那么，处理器将无论如何也无法恢复，只能重启。内核必须设计良好以避免这种情况发生。</p>
<h4 id="建立IDT表"><a href="#建立IDT表" class="headerlink" title="建立IDT表"></a>建立IDT表</h4><p>由于JOS中使用的为IA_32的陷阱码，更推荐参考<a href="https://pdos.csail.mit.edu/6.828/2017/readings/ia32/IA32-3A.pdf" target="_blank" rel="external">IA_32的第五章</a>。</p>
<p>练习4中遇到的问题如下：</p>
<ul>
<li>设置陷阱门时段选择子应当为<code>GD_KT</code>而不是<code>GD_KD</code>，因为错误处理函数均被链接至了内核的<code>text</code>段。</li>
<li>已存在<code>page_fault_handler</code>的函数，命名时需避免重名。</li>
<li>不能直接用立即数设置段寄存器。</li>
</ul>
<p>练习4的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In trapentry.S:</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Lab 3: Your code here for generating entry points for the different traps.</div><div class="line"> */</div><div class="line"></div><div class="line">TRAPHANDLER_NOEC(divide_error_handler, T_DIVIDE)</div><div class="line">TRAPHANDLER_NOEC(debug_exception_handler, T_DEBUG)</div><div class="line">TRAPHANDLER_NOEC(non_maskable_interrupt_handler, T_NMI)</div><div class="line">TRAPHANDLER_NOEC(breakpoint_handler, T_BRKPT)</div><div class="line">TRAPHANDLER_NOEC(overflow_handler, T_OFLOW)</div><div class="line">TRAPHANDLER_NOEC(bounds_check_handler, T_BOUND)</div><div class="line">TRAPHANDLER_NOEC(invalid_opcode_handler, T_ILLOP)</div><div class="line">TRAPHANDLER_NOEC(device_not_available_handler, T_DEVICE)</div><div class="line">TRAPHANDLER(double_fault_handler, T_DBLFLT)</div><div class="line">TRAPHANDLER(invalid_tss_handler, T_TSS)</div><div class="line">TRAPHANDLER(segment_not_present_handler, T_SEGNP)</div><div class="line">TRAPHANDLER(stack_exception_handler, T_STACK)</div><div class="line">TRAPHANDLER(general_protection_fault_handler, T_GPFLT)</div><div class="line">TRAPHANDLER(pagefault_handler, T_PGFLT)</div><div class="line">TRAPHANDLER_NOEC(floating_point_error_handler, T_FPERR)</div><div class="line">TRAPHANDLER(alignment_check_handler, T_ALIGN)</div><div class="line">TRAPHANDLER_NOEC(machine_check_handler, T_MCHK)</div><div class="line">TRAPHANDLER_NOEC(simd_floating_point_error_handler, T_SIMDERR)</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Lab 3: Your code here for _alltraps</div><div class="line"> */</div><div class="line"></div><div class="line">_alltraps:</div><div class="line"><span class="comment">// push ds and es and general registers</span></div><div class="line">push %ds</div><div class="line">push %es</div><div class="line">pushal</div><div class="line"></div><div class="line"><span class="comment">// load ds and es with GD_KD, for kernel stack locates in data</span></div><div class="line">mov $GD_KD, %ax</div><div class="line">mov %ax, %ds</div><div class="line">mov %ax, %es</div><div class="line"></div><div class="line"><span class="comment">// pass tf as an argument</span></div><div class="line">pushl %esp</div><div class="line"></div><div class="line"><span class="comment">// call trap and no need to return</span></div><div class="line">call trap</div><div class="line"></div><div class="line"><span class="comment">// In trap.c, trap_init():</span></div><div class="line"></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// declare of exception handler</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide_error_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug_exception_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">non_maskable_interrupt_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">breakpoint_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bounds_check_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalid_opcode_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_not_available_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">double_fault_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalid_tss_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">segment_not_present_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">stack_exception_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">general_protection_fault_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pagefault_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">floating_point_error_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">alignment_check_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">machine_check_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">simd_floating_point_error_handler</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// set up trap gate descriptor</span></div><div class="line">SETGATE(idt[T_DIVIDE],	 <span class="number">1</span>, GD_KT, divide_error_handler,           	   <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_DEBUG],    <span class="number">1</span>, GD_KT, debug_exception_handler,            <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_NMI],      <span class="number">1</span>, GD_KT, non_maskable_interrupt_handler,     <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_BRKPT],    <span class="number">1</span>, GD_KT, breakpoint_handler,                 <span class="number">3</span>);</div><div class="line">SETGATE(idt[T_OFLOW],    <span class="number">1</span>, GD_KT, overflow_handler,                   <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_BOUND],    <span class="number">1</span>, GD_KT, bounds_check_handler,               <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_ILLOP],    <span class="number">1</span>, GD_KT, invalid_opcode_handler,             <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_DEVICE],   <span class="number">1</span>, GD_KT, device_not_available_handler,       <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_DBLFLT],   <span class="number">1</span>, GD_KT, double_fault_handler,               <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_TSS],      <span class="number">1</span>, GD_KT, invalid_tss_handler,                <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_SEGNP],    <span class="number">1</span>, GD_KT, segment_not_present_handler,        <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_STACK],    <span class="number">1</span>, GD_KT, stack_exception_handler,            <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_GPFLT],    <span class="number">1</span>, GD_KT, general_protection_fault_handler,   <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_PGFLT],    <span class="number">1</span>, GD_KT, pagefault_handler,                  <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_FPERR],    <span class="number">1</span>, GD_KT, floating_point_error_handler,       <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_ALIGN],    <span class="number">1</span>, GD_KT, alignment_check_handler,            <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_MCHK],     <span class="number">1</span>, GD_KT, machine_check_handler,              <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_SIMDERR],  <span class="number">1</span>, GD_KT, simd_floating_point_error_handler,  <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>问题1：<br>若是使用同一个处理程序，将无法限制调用错误处理程序的代码的特权级，也无法得知中断向量的值。</p>
<p>问题2：<br>仅有内核代码允许执行页错误处理程序，尽管调用了<code>int $14</code>，仍然因为保护机制而生成了中断向量13。如果内核允许<code>int $14</code>唤醒页错误处理程序，那么恶意的程序可以因此而随意触发缺页错误，导致系统无法正常工作。</p>
<h3 id="第二部分-Page-Faults-Breakpoints-Exceptions-and-System-Calls-页错误，断点异常和系统调用"><a href="#第二部分-Page-Faults-Breakpoints-Exceptions-and-System-Calls-页错误，断点异常和系统调用" class="headerlink" title="第二部分 Page Faults, Breakpoints Exceptions, and System Calls - 页错误，断点异常和系统调用"></a>第二部分 Page Faults, Breakpoints Exceptions, and System Calls - 页错误，断点异常和系统调用</h3><h4 id="处理页错误"><a href="#处理页错误" class="headerlink" title="处理页错误"></a>处理页错误</h4><p>页错误的中断向量号为14，是非常重要的异常。当处理器接收一个页错误时，会将引发页错误的线性地址存储在处理器控制寄存器<code>CR2</code>中。</p>
<p>练习5的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In trap_dispatch():</span></div><div class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_PGFLT) &#123;</div><div class="line">    <span class="comment">// dispatch page fault exceptions</span></div><div class="line">    page_fault_handler(tf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="断点异常"><a href="#断点异常" class="headerlink" title="断点异常"></a>断点异常</h4><p>断点异常的中断向量号为3，通常被调试器用作向程序代码中添加断点，原理是将程序中的某一条指令暂时改为1字节的<code>int3</code>的软中断指令。在JOS中，我们将大量使用这一异常来实现一个原始的伪系统调用，使得用户环境可以使用它来环境JOS内核监视器，可以把内核监视器看做一个原始的调试器。<br>用户模式的<code>panic</code>，就是通过显示panic消息后执行<code>int3</code>实现的。</p>
<p>练习6的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_BRKPT) &#123;</div><div class="line">    <span class="comment">// dispatch breakpoint exceptions</span></div><div class="line">    monitor(tf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>问题3：<br>若是用特权级0初始化断点异常的IDT，那么会触发通用保护错误，这是因为用户模式的代码无法执行特权级0（内核模式）的处理程序，需要用特权级3初始化断点异常的IDT，这样才能使得断点测试正确通过。</p>
<p>问题4：<br>这些措施都是为了保护内核和用户环境的相互独立，使得用户环境仅能在收到允许的情况下执行某些内核的代码，保证了恶意程序不会破坏内核，窃取数据。同时也能保证用户环境能从内核得到必要的功能支持。</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>用户进程通过系统调用请求内核为它工作。当用户进程唤醒系统调用时，处理器进入内核模式，处理器和内核合作保存用户进程状态，内核执行合适的代码完成系统调用，并恢复至用户进程。系统调用的具体实现随平台不同而不同。</p>
<p>JOS内核使用<code>int $0x30</code>作为系统调用。需要建立相关的中断描述符，注意中断向量<code>0x30</code>不可能由硬件生成，毫无疑问应该允许用户执行对应的处理程序。</p>
<p>应用程序会将系统调用号和系统调用参数存入寄存器中。避免了内核访问用户环境栈或是指令流。系统调用号放在寄存器<code>%eax</code>中，最多五个参数分别被相应地放在寄存器<code>%edx</code>, <code>%ecx</code>, <code>%ebx</code>, <code>%edi</code>和<code>%esi</code>中。内核将返回值放在寄存器<code>%eax</code>中。唤醒系统调用的汇编代码已经提供为<code>lib/syscall.c</code>中的<code>syscall()</code>。</p>
<p>练习7中遇到的问题如下：</p>
<ul>
<li>syscall作为软中断不会压入错误码</li>
<li>调用syscall函数时应当使用保存的栈帧中的寄存器值而非实际的寄存器值，原因是在函数调用间某些寄存器的值会发生改变</li>
<li>练习7需要参考<code>lib/syscall.c</code>中得知参数的位置关系</li>
</ul>
<p>练习7的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In trapentry.S:</span></div><div class="line">TRAPHANDLER_NOEC(syscall_handler, T_SYSCALL)</div><div class="line"></div><div class="line"><span class="comment">// In trap.c, trap_init():</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_handler</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">SETGATE(idt[T_SYSCALL],  <span class="number">0</span>, GD_KT, syscall_handler,                    <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="comment">// In kern/syscall.c, syscall():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"></div><div class="line"><span class="comment">// panic("syscall not implemented");</span></div><div class="line"></div><div class="line"><span class="keyword">switch</span> (syscallno) &#123;</div><div class="line"><span class="keyword">case</span> SYS_cputs:</div><div class="line">    <span class="comment">// call sys_cputs</span></div><div class="line">    sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, (<span class="keyword">size_t</span>)a2);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> SYS_cgetc:</div><div class="line">    <span class="comment">// cll sys_cgetc</span></div><div class="line">    <span class="keyword">return</span> sys_cgetc();</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> SYS_getenvid:</div><div class="line">    <span class="comment">// call sys_getenvid</span></div><div class="line">    <span class="keyword">return</span> sys_getenvid();</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> SYS_env_destroy:</div><div class="line">    <span class="comment">// call sys_env_destroy</span></div><div class="line">    <span class="keyword">return</span> sys_env_destroy((<span class="keyword">envid_t</span>)a1);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">default</span>:</div><div class="line">    <span class="keyword">return</span> -E_INVAL;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// will not reach here</span></div><div class="line"><span class="keyword">return</span> -E_UNSPECIFIED;</div></pre></td></tr></table></figure></p>
<h4 id="用户模式启动"><a href="#用户模式启动" class="headerlink" title="用户模式启动"></a>用户模式启动</h4><p>一个用户在<code>lib/entry.S</code>的顶部开始运行，经过某些设置后，代码调用<code>lib/libmain.c</code>。你应当修改<code>libmain()</code>以初始化指向当前环境的<code>struct Env</code>指针<code>thisenv</code>（注意到<code>lib/entry.S</code>已经定义了指向你在第一部分映射的<code>UENVS</code>的<code>envs</code>）。</p>
<p><code>libmain()</code>然后调用<code>umain</code>，对于hello程序而言，位于<code>user/hello.c</code>中。在打印<code>hello, world</code>后，它尝试访问<code>thisenv-&gt;env_id</code>。这也是为什么hello程序会出现<code>fault</code>。</p>
<p>练习8中遇到的问题如下：</p>
<ul>
<li>可以使用宏<code>ENVX</code>从<code>envid</code>得到<code>env</code>在<code>envs</code>中的偏移量，而无需遍历整个<code>envs</code></li>
<li>Lab2中<code>pgdir_walk</code>未设置<code>PTE_U</code>导致访问时出现了页错误（仅有PTE项中设置<code>PTE_U</code>是不足的）。</li>
</ul>
<p>练习8的答案如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In libmain.c, libmain():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// get env id use system call and use ENVX to get index</span></div><div class="line">thisenv = envs + ENVX(sys_getenvid());</div></pre></td></tr></table></figure></p>
<h4 id="页错误和内存保护"><a href="#页错误和内存保护" class="headerlink" title="页错误和内存保护"></a>页错误和内存保护</h4><p>内存保护是操作系统的重要特性，保证了一个程序的错误不会毁坏内核或是其他的程序。<br>操作系统通常和硬件一起实现内存保护。操作系统负责告知硬件哪些虚拟地址是有效的、哪些是无效的。当一个程序试图去访问一个无效的地址或是一个没有权限的地址时，处理器在引起错误的指令处停止程序，然后带着相应的信息陷入内核。若错误可修复，则内核修复该错误并继续执行程序；若错误不可恢复，则程序无法继续运行。<br>现在考虑系统调用，系统调用允许用户程序向内核传递指针，内核在处理系统调用时将指针解引用，会出现以下两种问题：</p>
<ol>
<li>内核的缺页错误潜在地比用户程序的缺页更加严重。若内核在操作私有的数据结构时发生缺页，那么将是内核自己的漏洞，错误处理程序应当panic内核。然而当内核解引用用户程序传递的指针时，需要某种方式标记由解引用导致的缺页实际上代表的是用户程序的利益。</li>
<li>内核比用户程序具有更多的权限。在这种情况下，用户程序可能传递给内核一个指针，该指针指向的内存只能被内核读写而不能被用户程序读写。在这种情况下，内核不能对该指针解引用，这么做会暴露私有数据或是破坏内核完整性。</li>
</ol>
<p>当内核处理用户程序传递的指针时必须非常小心。内核必须检查用户传入的指针。</p>
<p>练习9和练习10遇到的问题如下</p>
<ul>
<li>需要获取段寄存器的最低两位以得到段特权级</li>
</ul>
<p>练习9和练习10的答案如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In kern/trap.c, page_fault_handler():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// code that causes page fault in kernel mode</span></div><div class="line">    panic(<span class="string">"page fault in kernel!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In kern/pmap.c, user_mem_check():</span></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">user_mem_check</span><span class="params">(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= ULIM) &#123;</div><div class="line">        <span class="comment">// condition 1 - below ULIM violated</span></div><div class="line">        user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va;</div><div class="line">        <span class="keyword">return</span> -E_FAULT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">uintptr_t</span> va_start = (<span class="keyword">uintptr_t</span>)ROUNDDOWN(va, PGSIZE);</div><div class="line">    <span class="keyword">uintptr_t</span> va_end = (<span class="keyword">uintptr_t</span>)ROUNDUP(va + len, PGSIZE);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (; va_start &lt; va_end ; va_start += PGSIZE) &#123;</div><div class="line">        <span class="comment">// note we set page directory entry with less restrict</span></div><div class="line">        <span class="comment">// we will only test page table entry here</span></div><div class="line">        <span class="keyword">pte_t</span> * pgtable_entry_ptr = pgdir_walk(env-&gt;env_pgdir, (<span class="keyword">char</span> *)va_start, <span class="literal">false</span>);</div><div class="line">        <span class="keyword">if</span> ((*pgtable_entry_ptr &amp; (perm | PTE_P)) != (perm | PTE_P)) &#123;</div><div class="line">            <span class="comment">// condition 2 - permission violated</span></div><div class="line">            <span class="keyword">if</span> (va_start &lt;= (<span class="keyword">uintptr_t</span>)va) &#123;</div><div class="line">                <span class="comment">// va lie in the first page and not aligned, return va</span></div><div class="line">                user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (va_start &gt;= (<span class="keyword">uintptr_t</span>)va + len) &#123;</div><div class="line">                <span class="comment">// va lie in the last page and exceed va + len, return va + len</span></div><div class="line">                user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va + len;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// return corresponding page's initial address</span></div><div class="line">                user_mem_check_addr = va_start;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> -E_FAULT;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// pass user memory check</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In kern/syscall.c, syscall():</span></div><div class="line"><span class="keyword">case</span> SYS_cputs:</div><div class="line">    <span class="comment">// checks memory before use sys_cputs to dereference a1</span></div><div class="line">    user_mem_assert(curenv, (<span class="keyword">char</span> *)a1, (<span class="keyword">size_t</span>)a2, PTE_U);</div><div class="line">    <span class="comment">// call sys_cputs</span></div><div class="line">    sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, (<span class="keyword">size_t</span>)a2);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line"><span class="comment">// In kern/kdebug.c, debuginfo_eip():</span></div><div class="line"><span class="comment">// Make sure this memory is valid.</span></div><div class="line"><span class="comment">// Return -1 if it is not.  Hint: Call user_mem_check.</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="keyword">if</span> (user_mem_check(curenv, usd, <span class="keyword">sizeof</span>(struct UserStabData *), PTE_U) &lt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Make sure the STABS and string table memory is valid.</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="keyword">if</span> ((user_mem_check(curenv, stabs, stab_end - stabs, PTE_U) &lt; <span class="number">0</span>) ||</div><div class="line">    (user_mem_check(curenv, stabstr, stabstr_end - stabstr, PTE_U) &lt; <span class="number">0</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发生了页错误的原因还要观察<code>memlayout.h</code>，在<code>USTACKTOP</code>上方有一个位于<code>0xeebff000</code>的<code>User Exception Stack</code>，该虚拟地址没有映射任何的物理页。而在<code>mon_backtrace</code>的最后，访问到了位于此处的虚拟地址，因而导致了一个不可处理的页错误。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/02/20/MIT6-828操作系统工程Lab2-Memory-Management实验报告/">
                            MIT6.828操作系统工程Lab2-Memory Management实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-02-20T22:12:33+08:00">
	
		    2月 20, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <blockquote>
<p>寒假在家终于有时间继续处理上学期没有做完的Labs，虽然效率偏低但总不是完全没有进展。<br>Lab2 - Memory Management主要包括了操作系统的内存管理，具体来说可以分为两部分。第一部分需要编写内核的物理内存分配器（Physical memory allocator），这会允许内核分配和释放内存。第二部分需要修改JOS的代码去实现一个虚拟内存，将虚拟地址映射到物理内存中。</p>
</blockquote>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>根据实验官网的提示，我们依次切换到分支lab2并且合并分支lab1，在合并的过程中，没有发生冲突。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user% git checkout -b lab2 origin/lab2</div><div class="line">user% git merge lab1</div></pre></td></tr></table></figure>
<p>实验二包括如下的新文件：</p>
<ul>
<li>inc/memlayout.h 描述了虚拟地址空间的结构</li>
<li>kern/pmap.c 需要修改、添加代码以完成实验</li>
<li>kern/pmap.h 定义了PageInfo结构 用来管理物理页状态</li>
<li>kern/kclock.h</li>
<li>kern/kclock.c 操作电池供电的时钟以及CMOS RAM硬件</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="第一部分-Physical-Page-Management-物理页管理"><a href="#第一部分-Physical-Page-Management-物理页管理" class="headerlink" title="第一部分 Physical Page Management - 物理页管理"></a>第一部分 Physical Page Management - 物理页管理</h3><p>操作系统必须追踪物理内存以得知哪些内存是空闲的，以及哪些内存是正在被使用的。JOS使用页粒度管理PC的物理内存以便利用MMU映射和保护每一片被分配的内存。</p>
<p>实验的第一部分需要完成一个物理页面分配器，该分配器维护了一个<code>struct PageInfo</code>的链表来追踪空闲的物理页面（也就是空闲链表），空闲链表我已经在CSAPP中有所了解，这里不再赘述。</p>
<p>具体来说，需要完成kern/pmap.c中实现以下的函数：</p>
<ul>
<li>boot_alloc()</li>
<li>mem_init() （完成直到check_page_free_list(1)为止）</li>
<li>page_init()</li>
<li>page_alloc()</li>
<li>page_free()</li>
</ul>
<p>完成后可以启动JOS去观察<code>check_page_free_list()</code>以及<code>check_page_alloc()</code>函数是否成功以检查编写的分配器的正确性。</p>
<p>第一部分的物理页面分配器总体来说难度不大，因为编写的分配器不像CSAPP中的malloc一样，需要处理空闲内存的合并以及拆分，分配器只需要以物理页面为固定的粒度管理所有的内存即可。</p>
<p>在实际的Linux系统中，内核使用Buddy System快速地管理内存。</p>
<p>练习1的代码如下，仅供参考:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In boot_alloc():</span></div><div class="line"><span class="comment">// Allocate a chunk large enough to hold 'n' bytes, then update</span></div><div class="line"><span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></div><div class="line"><span class="comment">// to a multiple of PGSIZE.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// LAB 2: Your code here.</span></div><div class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// return the address of next free page</span></div><div class="line">    <span class="keyword">return</span> nextfree;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// round up size to a multiple of PGSIZE</span></div><div class="line">    <span class="keyword">size_t</span> size = ROUNDUP(n, PGSIZE);</div><div class="line">    <span class="keyword">char</span> * addr = nextfree;</div><div class="line">    <span class="comment">// update address of next free page(still multiple of PGSIZE)</span></div><div class="line">    nextfree += size;</div><div class="line">    <span class="comment">// nextfree is a kernel virtual address, out out memory when it exceeds 4 MB</span></div><div class="line">	<span class="keyword">if</span> (nextfree &gt;= (<span class="keyword">char</span> *)KADDR(<span class="number">0x400000</span>)) &#123;</div><div class="line">        panic(<span class="string">"out of memory when booting!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// return address</span></div><div class="line">    <span class="keyword">return</span> addr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In mem_init():</span></div><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.</span></div><div class="line"><span class="comment">// The kernel uses this array to keep track of physical pages: for</span></div><div class="line"><span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></div><div class="line"><span class="comment">// array.  'npages' is the number of physical pages in memory.  Use memset</span></div><div class="line"><span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></div><div class="line"><span class="comment">// Your code goes here:</span></div><div class="line"><span class="comment">// get size of pages</span></div><div class="line"><span class="keyword">uint32_t</span> pages_size = <span class="keyword">sizeof</span>(struct PageInfo) * npages;</div><div class="line"><span class="comment">// use boot_alloc to allocate memory</span></div><div class="line">pages = (struct PageInfo *) boot_alloc(pages_size);</div><div class="line"><span class="comment">// initialization</span></div><div class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, pages_size);</div><div class="line"></div><div class="line"><span class="comment">// In page_init():</span></div><div class="line"><span class="keyword">size_t</span> i;</div><div class="line"></div><div class="line"><span class="comment">// initialize from page 1 to page npages_basemem - 1</span></div><div class="line"><span class="comment">// set pp_ref to 0, set pp_link to last page_free_list</span></div><div class="line"><span class="comment">// and then update page_free_list</span></div><div class="line"><span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; npages_basemem ; i++) &#123;</div><div class="line">    pages[i].pp_ref = <span class="number">0</span>;</div><div class="line">    pages[i].pp_link = page_free_list;</div><div class="line">    page_free_list = &amp;pages[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// calculate next free page and initialize corresponding pages entry</span></div><div class="line"><span class="comment">// convert from kernel virtual address to physical address</span></div><div class="line"><span class="keyword">size_t</span> next_free_page = PADDR(boot_alloc(<span class="number">0</span>)) / PGSIZE;</div><div class="line">pages[next_free_page].pp_link = &amp;pages[npages_basemem - <span class="number">1</span>];</div><div class="line">page_free_list = &amp;pages[next_free_page];</div><div class="line"></div><div class="line"><span class="comment">// initialize remaining pages entry</span></div><div class="line"><span class="keyword">for</span> (i = next_free_page + <span class="number">1</span> ; i &lt; npages ; i++) &#123;</div><div class="line">    pages[i].pp_ref = <span class="number">0</span>;</div><div class="line">    pages[i].pp_link = page_free_list;</div><div class="line">    page_free_list = &amp;pages[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In page_alloc():</span></div><div class="line"><span class="function">struct PageInfo *</span></div><div class="line"><span class="title">page_alloc</span><span class="params">(<span class="keyword">int</span> alloc_flags)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// get first element in free list</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">page_ptr</span> = <span class="title">page_free_list</span>;</span></div><div class="line">	<span class="keyword">if</span> (page_ptr != <span class="literal">NULL</span>) &#123;</div><div class="line">		<span class="comment">// NOT out of memory</span></div><div class="line">		<span class="comment">// update free list</span></div><div class="line">		page_free_list = page_free_list-&gt;pp_link;</div><div class="line">		<span class="comment">// get kernal virtual address from given page</span></div><div class="line">		<span class="keyword">char</span> * addr = page2kva(page_ptr);</div><div class="line">		<span class="comment">// set pp_link to NULL to allow double-free bugs check</span></div><div class="line">		page_ptr-&gt;pp_link = <span class="literal">NULL</span>;</div><div class="line">		<span class="comment">// ALLOC_ZERO set, use memset to initialze physical page</span></div><div class="line">		<span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO) &#123;</div><div class="line">			<span class="built_in">memset</span>(addr, <span class="number">0</span>, PGSIZE);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// return page</span></div><div class="line">		<span class="keyword">return</span> page_ptr;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In page_free():</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">page_free</span><span class="params">(struct PageInfo *pp)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// Fill this function in</span></div><div class="line">	<span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></div><div class="line">	<span class="comment">// pp-&gt;pp_link is not NULL.</span></div><div class="line"></div><div class="line">	<span class="comment">//check pp_ref and pp_link</span></div><div class="line">	<span class="keyword">if</span> (pp-&gt;pp_ref != <span class="number">0</span>) &#123;</div><div class="line">		panic(<span class="string">"page's reference count is non-zero!"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (pp-&gt;pp_link != <span class="literal">NULL</span>) &#123;</div><div class="line">		panic(<span class="string">"double free error when free page!"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// return page to free list</span></div><div class="line">	pp-&gt;pp_link = page_free_list;</div><div class="line">	page_free_list = pp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们启动JOS，在终端观察到如下输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Physical memory: 131072K available, base = 640K, extended = 130432K</div><div class="line">check_page_free_list() succeeded!</div><div class="line">check_page_alloc() succeeded!</div></pre></td></tr></table></figure></p>
<p>证明内存分配器工作正常。</p>
<h3 id="第二部分-Virtual-Memory-虚拟内存"><a href="#第二部分-Virtual-Memory-虚拟内存" class="headerlink" title="第二部分 Virtual Memory - 虚拟内存"></a>第二部分 Virtual Memory - 虚拟内存</h3><p>练习2：阅读<a href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/toc.htm" target="_blank" rel="external">Intel 80386 Reference Manual</a>的第五章和第六章。主要阅读页翻译和页保护机制的部分。同时，也要对x86的分段机制有所了解。</p>
<h4 id="虚拟地址、线性地址和物理地址"><a href="#虚拟地址、线性地址和物理地址" class="headerlink" title="虚拟地址、线性地址和物理地址"></a>虚拟地址、线性地址和物理地址</h4><p>在x86中，虚拟地址由段选择子和段内偏移组成，通过段翻译机制，得到线性地址。线性地址经过页翻译机制，得到物理地址。物理地址就是实际的内存位置。</p>
<p>在实验1中，我们已经将线性地址<code>0-4M</code>映射到了虚拟地址<code>0-4M</code>和<code>KERNBASE-KERNBASE+4M</code>。在本实验中，我们要将物理内存的低256M映射到从<code>KERNBASE</code>开始的虚拟地址。此外，我们还要映射其他几个虚拟地址空间。（<code>KERNBASE</code>为<code>0xf0000000</code>）</p>
<p>练习3：在QEMU监视器中使用<code>xp</code>命令检查物理内存<code>0x00100000</code>处的字，在gdb中使用<code>x</code>命令检查虚拟内存<code>0xf0100000</code>处的字，观察结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(qemu) xp 0x00100000</div><div class="line">0000000000100000: 0x1badb002</div><div class="line">(gdb) x/x 0xf0100000</div><div class="line">0xf0100000 &lt;_start+4026531828&gt;: 0x1badb002</div></pre></td></tr></table></figure><br>可以得出，物理地址0x00100000和虚拟地址0xf0100000上具有相同的数据。</p>
<p><code>info pg</code>和<code>info mem</code>的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">(qemu) info pg</div><div class="line">VPN range     Entry         Flags        Physical page</div><div class="line">[00000-003ff]  PDE[000]     ----A----P</div><div class="line">  [00000-00000]  PTE[000]     --------WP 00000</div><div class="line">  [00001-0009f]  PTE[001-09f] ---DA---WP 00001-0009f</div><div class="line">  [000a0-000b7]  PTE[0a0-0b7] --------WP 000a0-000b7</div><div class="line">  [000b8-000b8]  PTE[0b8]     ---DA---WP 000b8</div><div class="line">  [000b9-000ff]  PTE[0b9-0ff] --------WP 000b9-000ff</div><div class="line">  [00100-00103]  PTE[100-103] ----A---WP 00100-00103</div><div class="line">  [00104-00119]  PTE[104-119] --------WP 00104-00119</div><div class="line">  [0011a-0011a]  PTE[11a]     ---DA---WP 0011a</div><div class="line">  [0011b-0011c]  PTE[11b-11c] --------WP 0011b-0011c</div><div class="line">  [0011d-003ff]  PTE[11d-3ff] ---DA---WP 0011d-003ff</div><div class="line">[f0000-f03ff]  PDE[3c0]     ----A---WP</div><div class="line">  [f0000-f0000]  PTE[000]     --------WP 00000</div><div class="line">  [f0001-f009f]  PTE[001-09f] ---DA---WP 00001-0009f</div><div class="line">  [f00a0-f00b7]  PTE[0a0-0b7] --------WP 000a0-000b7</div><div class="line">  [f00b8-f00b8]  PTE[0b8]     ---DA---WP 000b8</div><div class="line">  [f00b9-f00ff]  PTE[0b9-0ff] --------WP 000b9-000ff</div><div class="line">  [f0100-f0103]  PTE[100-103] ----A---WP 00100-00103</div><div class="line">  [f0104-f0119]  PTE[104-119] --------WP 00104-00119</div><div class="line">  [f011a-f011a]  PTE[11a]     ---DA---WP 0011a</div><div class="line">  [f011b-f011c]  PTE[11b-11c] --------WP 0011b-0011c</div><div class="line">  [f011d-f03ff]  PTE[11d-3ff] ---DA---WP 0011d-003ff</div><div class="line"></div><div class="line">  (qemu) info mem</div><div class="line">  0000000000000000-0000000000400000 0000000000400000 -r-</div><div class="line">  00000000f0000000-00000000f0400000 0000000000400000 -rw</div></pre></td></tr></table></figure></p>
<p>在JOS内核中，<code>uintptr_t</code>代表虚拟地址，<code>physaddr_t</code>代表物理地址，它们都只是<code>uint32_t</code>的别名。因此，不能直接对其（int类型）解引用，需要先将其转换成指针类型。<br>对物理地址的解引用是错误的，因为MMU会将其当做虚拟地址，你将无法得到正确的内存内容。</p>
<p>问题1：<br>x的类型应当为<code>uintptr_t</code>，因为对其进行了解引用操作，所以x应当为虚拟地址。</p>
<p>有些时候，内核必须要处理物理地址，这也是要把0-4M映射到KERNBASE-KERNBASE+4M的理由。<br>为了能使内核读写物理地址，必须要加上KERNBASE，可以通过宏KADDR(pa)实现。<br>同理，有时候需要能通过虚拟地址找到物理地址，需要减去KERNBASE，可以通过宏PADDR(va)实现。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>在未来的实验中我们很可能将同样的物理页映射到多个虚拟地址，你需要在<code>struct PageInfo</code>的<code>pp_ref</code>域中保持物理页被引用的次数，当引用计数归0，页面不再被使用，可以被释放。<br>总的来说，引用计数应当等于物理页面在<code>UTOP</code>之下出现的次数（<code>UTOP</code>之上的物理页面大多在启动时被内核分配并且永远不应当被释放，所以不需要对其进行引用计数）。<br>我们也会用引用计数来追踪指向页目录页的指针数，以及页目录对页表页的引用数。</p>
<p>在使用<code>page_alloc()</code>时应当小心，返回页的<code>pp_ref</code>应当很快被递增，如被别的函数如(<code>page_insert()</code>)递增，在某些情况下，调用<code>page_insert()</code>的函数必须手动增加引用计数。</p>
<p>在练习4中遇到的问题总结如下：</p>
<ul>
<li>pgdir_walk在设置页表项时应当使用物理地址，在返回指针时应当返回虚拟地址。这是因为此时实际的二级页表还未被设置应用，且0-4M被映射为只读，而KERNBASE-KERNBASE+4M被映射为可读可写。需要使用给出的宏而不要自己加减</li>
<li>将PTE_P笔误成PTE_G</li>
<li>在page_insert中提前将引用计数pp_ref自增就可以避免边界情况的错误</li>
<li>pgdir_walk中对于页目录的设置可以更宽松，否则可能会对之后的实验产生影响</li>
</ul>
<p>练习4的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In pgdir_walk():</span></div><div class="line"><span class="keyword">pte_t</span> *</div><div class="line">pgdir_walk(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</div><div class="line">&#123;</div><div class="line">	<span class="comment">// get page directory index and page directory entry</span></div><div class="line">	<span class="keyword">size_t</span> pgdir_index = PDX(va);</div><div class="line">	<span class="keyword">pde_t</span> pgdir_entry = pgdir[pgdir_index];</div><div class="line">	<span class="comment">// get page table index</span></div><div class="line">	<span class="keyword">size_t</span> pgtable_index = PTX(va);</div><div class="line">	<span class="keyword">if</span> ((pgdir_entry &amp; PTE_P) == <span class="number">1</span>) &#123;</div><div class="line">		<span class="comment">// page table page exists</span></div><div class="line">		<span class="comment">// get address of page table</span></div><div class="line">		<span class="keyword">pte_t</span> * pgtable = KADDR(PTE_ADDR(pgdir_entry));</div><div class="line">		<span class="keyword">return</span> (<span class="keyword">pte_t</span> *)(pgtable + pgtable_index);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// page table page doesn't exist</span></div><div class="line">		<span class="keyword">if</span> (create == <span class="literal">false</span>) &#123;</div><div class="line">			<span class="comment">// create flag is false, returns NULL</span></div><div class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// allocate a new page table page</span></div><div class="line">			struct PageInfo * page = page_alloc(ALLOC_ZERO);</div><div class="line">			<span class="keyword">if</span> (page == <span class="literal">NULL</span>) &#123;</div><div class="line">				<span class="comment">// allocation fails</span></div><div class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="comment">// increase physical page's reference count</span></div><div class="line">				page-&gt;pp_ref++;</div><div class="line">				<span class="comment">// get physical address of physical page</span></div><div class="line">				<span class="keyword">physaddr_t</span> page_pa = page2pa(page);</div><div class="line">				<span class="comment">// insert page table into page directory</span></div><div class="line">				pgdir[pgdir_index] = page_pa | PTE_W | PTE_U | PTE_P;</div><div class="line">				<span class="comment">// NB: returns KERNEL VIRTUAL ADDRESS here, for 0-4M is NOT writable</span></div><div class="line">				<span class="keyword">return</span> (<span class="keyword">pte_t</span> *)page2kva(page) + pgtable_index;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In boot_map_region():</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">boot_map_region</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// round up size</span></div><div class="line">	size = ROUNDUP(size, PGSIZE);</div><div class="line">	<span class="comment">// get the number of pages to be mapped</span></div><div class="line">	<span class="keyword">size_t</span> page_num = PGNUM(size);</div><div class="line"></div><div class="line">	<span class="keyword">size_t</span> i;</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; page_num ; i++) &#123;</div><div class="line">		<span class="comment">// iterate through to get each pte_t * through pgdir_walk given virtual address</span></div><div class="line">		<span class="keyword">pte_t</span> * pgtable_entry_ptr = pgdir_walk(pgdir,(<span class="keyword">char</span> *)(va + i * PGSIZE), <span class="literal">true</span>);</div><div class="line">		<span class="comment">// set pte_t according to physical address and permission flags</span></div><div class="line">		*pgtable_entry_ptr = (pa + i * PGSIZE) | perm | PTE_P;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In page_lookup():</span></div><div class="line"><span class="function">struct PageInfo *</span></div><div class="line"><span class="title">page_lookup</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va, <span class="keyword">pte_t</span> **pte_store)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// Fill this function in</span></div><div class="line">	<span class="keyword">pte_t</span> * pgtable_entry_ptr = pgdir_walk(pgdir, va, <span class="literal">false</span>);</div><div class="line">	<span class="keyword">if</span> (pgtable_entry_ptr &amp;&amp; ((*pgtable_entry_ptr) &amp; PTE_P) == <span class="number">1</span>) &#123;</div><div class="line">		<span class="keyword">if</span> (pte_store != <span class="literal">NULL</span>) &#123;</div><div class="line">			<span class="comment">// pte_store not zero, store the address of pte of the page in it</span></div><div class="line">			*pte_store = pgtable_entry_ptr;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// converts from pa to page and returns</span></div><div class="line">		<span class="keyword">physaddr_t</span> pa = PTE_ADDR(*pgtable_entry_ptr);</div><div class="line">		<span class="keyword">return</span> pa2page(pa);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// no page mapped at va</span></div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In page_remove():</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">page_remove</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// Fill this function in</span></div><div class="line">	<span class="keyword">pte_t</span> * pgtable_entry_ptr = <span class="literal">NULL</span>;</div><div class="line">	<span class="comment">// use page_lookup to get struct PageInfo</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">page</span> = <span class="title">page_lookup</span>(<span class="title">pgdir</span>, <span class="title">va</span>, &amp;<span class="title">pgtable_entry_ptr</span>);</span></div><div class="line">	<span class="keyword">if</span> (page &amp;&amp; pgtable_entry_ptr) &#123;</div><div class="line">		<span class="comment">// if page mapped at va</span></div><div class="line">		<span class="comment">// decrease and try to free page</span></div><div class="line">		page_decref(page);</div><div class="line">		<span class="comment">// set page table entry to 0</span></div><div class="line">		*pgtable_entry_ptr = <span class="number">0</span>;</div><div class="line">		<span class="comment">// invalidate tlb</span></div><div class="line">		tlb_invalidate(pgdir, va);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In page_insert():</span></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">page_insert</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// Fill this function in</span></div><div class="line">	<span class="comment">// try to get pointer to page table entry, created if needed</span></div><div class="line">	<span class="keyword">pte_t</span> * pgtable_entry_ptr = pgdir_walk(pgdir, va, <span class="literal">true</span>);</div><div class="line">	<span class="keyword">if</span> (!pgtable_entry_ptr) &#123;</div><div class="line">		<span class="comment">// page table cannot be allocated</span></div><div class="line">		<span class="keyword">return</span> -E_NO_MEM;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// increase reference ahead of insertion to process CORNER CASE</span></div><div class="line">	pp-&gt;pp_ref++;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (((*pgtable_entry_ptr) &amp; PTE_P) != <span class="number">0</span>) &#123;</div><div class="line">		<span class="comment">// exists page mapped at va</span></div><div class="line">		<span class="comment">// remove page and invalidate tlb</span></div><div class="line">		page_remove(pgdir, va);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// get physical address of page</span></div><div class="line">	<span class="keyword">physaddr_t</span> pa = page2pa(pp);</div><div class="line">	<span class="comment">// insert page into page table</span></div><div class="line">	*pgtable_entry_ptr = pa | perm | PTE_P;</div><div class="line"></div><div class="line">	<span class="comment">// update permission flags of corresponding page directory</span></div><div class="line">	pgdir[PDX(va)] = pgdir[PDX(va)] | perm;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="第三部分-Kernel-Address-Space-内核地址空间"><a href="#第三部分-Kernel-Address-Space-内核地址空间" class="headerlink" title="第三部分 Kernel Address Space - 内核地址空间"></a>第三部分 Kernel Address Space - 内核地址空间</h3><p>JOS将32位的地址空间划为了两部分——用户环境（在Lab3中加载和运行）将控制低地址空间、而内核总是完全地控制高地址空间，由ULIM显式地划分地址空间。内核将占据约256M的地址空间。</p>
<p>尽管内核和用户内存位于同一地址空间，我们仍然要在x86的页表中使用权限位去保证用户代码仅能访问低地址空间。否则用户代码可能会覆写内核数据，导致故障。此外，用户代码还可能能从窃取其他用户、内核的私有数据。<br>在JOS中，用户环境将不具有ULIM以上任何内存的权限；只有内核可以读写这些内存。对于[UTOP, ULIM)，内核和用户都仅能读而不能写，该段内存主要用于向用户暴露某些内核的只读数据结构；最后，UTOP以下的地址空间由用户环境使用，由用户环境自行设置这些内存的权限。</p>
<p>练习5的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Now we set up virtual memory</span></div><div class="line"></div><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Map 'pages' read-only by the user at linear address UPAGES</span></div><div class="line"><span class="comment">// Permissions:</span></div><div class="line"><span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></div><div class="line"><span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></div><div class="line"><span class="comment">//    - pages itself -- kernel RW, user NONE</span></div><div class="line"><span class="comment">// Your code goes here:</span></div><div class="line">boot_map_region(kern_pgdir, UPAGES, pages_size, PADDR(pages), PTE_U | PTE_P);</div><div class="line"></div><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Use the physical memory that 'bootstack' refers to as the kernel</span></div><div class="line"><span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></div><div class="line"><span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></div><div class="line"><span class="comment">// to be the kernel stack, but break this into two pieces:</span></div><div class="line"><span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></div><div class="line"><span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></div><div class="line"><span class="comment">//       the kernel overflows its stack, it will fault rather than</span></div><div class="line"><span class="comment">//       overwrite memory.  Known as a "guard page".</span></div><div class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></div><div class="line"><span class="comment">// Your code goes here:</span></div><div class="line">boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W | PTE_P);</div><div class="line"></div><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Map all of physical memory at KERNBASE.</span></div><div class="line"><span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></div><div class="line"><span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></div><div class="line"><span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></div><div class="line"><span class="comment">// we just set up the mapping anyway.</span></div><div class="line"><span class="comment">// Permissions: kernel RW, user NONE</span></div><div class="line"><span class="comment">// Your code goes here:</span></div><div class="line">boot_map_region(kern_pgdir, KERNBASE, <span class="number">0xffffffff</span> - KERNBASE, <span class="number">0</span>, PTE_W | PTE_P);</div></pre></td></tr></table></figure></p>
<p>问题2：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Enrty</th>
<th style="text-align:center">Base Virtual Address</th>
<th style="text-align:center">Points to (logically)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1023</td>
<td style="text-align:center">0xFFC00000</td>
<td style="text-align:center">Physical Memory</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">……….</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">960</td>
<td style="text-align:center">0xF0000000</td>
<td style="text-align:center">First 4 MB on Physical Memory</td>
</tr>
<tr>
<td style="text-align:center">959</td>
<td style="text-align:center">0xEFC00000</td>
<td style="text-align:center">Kernel Stack</td>
</tr>
<tr>
<td style="text-align:center">957</td>
<td style="text-align:center">0xEF400000</td>
<td style="text-align:center">Kernel Page Directory</td>
</tr>
<tr>
<td style="text-align:center">956</td>
<td style="text-align:center">0xEF000000</td>
<td style="text-align:center">Pages</td>
</tr>
</tbody>
</table>
<p>问题3：<br>页保护机制实现了这一点，用户将不能访问未设置<code>PTE_U</code>的页（对于页目录和页表皆是如此）。</p>
<p>问题4：<br>注意到pages最多只有4MB，而一个<code>struct PageInfo</code>为8字节（对齐），所以实际上最多只有512K个项，总大小为2GB。</p>
<p>问题5：<br>使用了页表来管理虚拟内存，页表完整地映射了4GB的地址空间。使用pages追踪物理页面的情况，由于最初只映射了4MB，使得内存被限制在了2GB。</p>
<p>问题6：<br>执行转换的代码在<code>entry.S</code>中，和32位保护模式时相似：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mov	$relocated, %eax</div><div class="line">jmp	*%eax</div></pre></td></tr></table></figure><br>实际的跳转是通过一次<code>jmp</code>实现的，得以继续执行的原因是我们不仅将0-4M映射到了<code>KERNBASE-KERNBASE+4M</code>的读写，同时也映射到了<code>0-4M</code>的只读。不这么做的话将出现无法处理的<code>SIGTRAP</code>信号而导致系统Triple Fault。<br>不通过转换就无法在高地址执行内核代码，将内核映射在高地址主要是为了完整地映射内核的约256M空间。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/20/MIT6-828操作系统工程Lab2-Memory-Management实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/">
                            MIT6.828操作系统工程Lab1-Booting a PC实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-12-09T03:32:48+08:00">
	
		    12月 09, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <blockquote>
<p>本学期开设了操作系统的专业课。根据老师的介绍，下个学期的操作系统课设就是MIT的6.828的Labs，再加上团队老学长/同学的推荐，打算先在这个学期完成6.828，加深对于系统的理解。<br>Lab1 - Booting a PC是比较简单的实验，主要包括了引导、内核、控制台输出、以及栈。尽管如此，由于相关知识的缺失，我断断续续做了2周（2017年10月26日）才完成该实验。<br>2017年12月9日，完成了实验的提高部分并写完了报告。</p>
</blockquote>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>首先需要完成实验环境的搭建。实验环境主要由两个部分组成：QEMU用来模拟运行内核，以及一条编译工具链用于编译和测试内核。这里我使用的系统是64位的ArchLinux。</p>
<blockquote>
<p>本部分可以参考MIT 6.828官网的<a href="https://pdos.csail.mit.edu/6.828/2017/tools.html" target="_blank" rel="external">Tools</a>。</p>
</blockquote>
<h3 id="编译工具链"><a href="#编译工具链" class="headerlink" title="编译工具链"></a>编译工具链</h3><p>编译工具链包含了C编译器、汇编器、连接器，用于从源代码生成可执行二进制文件。本实验的目标代码是32位的Intel架构（x86），可执行文件格式为ELF。</p>
<p>在Arch Linux下，若是在安装时选择了base-devel包组，则gcc应该是系统自带的编译工具链。但是，该gcc默认不能编译生成32位的可执行文件。需要我们手动开启<a href="https://wiki.archlinux.org/index.php/multilib" target="_blank" rel="external">multilib</a>并安装gcc-multilib以及相关的软件包。</p>
<h4 id="GCC版本降级说明"><a href="#GCC版本降级说明" class="headerlink" title="GCC版本降级说明"></a>GCC版本降级说明</h4><p>在我和华田的Arch下，使用gcc 7.1.1-3之后的版本编译生成的JOS kernel均无法使用。在无法查明原因的情况下，推荐将gcc降级至7.1.1-3完成6.828的实验。</p>
<p>有关于Arch下软件包降级的教程请看<a href="https://wiki.archlinux.org/index.php/downgrading_packages" target="_blank" rel="external">这里</a>。</p>
<h3 id="Qemu模拟器"><a href="#Qemu模拟器" class="headerlink" title="Qemu模拟器"></a>Qemu模拟器</h3><p>QEMU是一个现代并且快速的PC模拟器，但是为了与实验兼容，MIT推荐使用他们patched过的QEMU版本。我们按照Tools上的教程从源码编译并安装QEMU。</p>
<p>注意：提供的QEMU并不支持make uninstall，需要手动卸载QEMU。如果您于手动编译并安装可能存在的<strong>后果</strong>抱有顾虑，推荐使用包管理软件安装QEMU</p>
<h4 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h4><ol>
<li>所需要的库名可以在arch官网上通过搜索软件包的方式找到；</li>
<li>configure的时候加上–disable-werror以保证不会因出现编译警告而终止编译；</li>
<li><p>出现如下错误：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Unescaped left brace <span class="keyword">in</span> regex is illegal here <span class="keyword">in</span> regex; marked by &lt;-- HERE <span class="keyword">in</span> m/^\@strong&#123; &lt;-- HERE (.*)&#125;$/ at /home/guest/qemu/scripts/texi2pod.pl line 320.</div><div class="line"></div><div class="line">make: *** [Makefile:474：qemu.1] 错误 255。</div></pre></td></tr></table></figure>
<p> 该错误是由于perl版本更新后正则表达式语法的变动造成的，直接修改安装脚本的<code>/home/chenzhihao/qemu/scripts/texi2pod.pl line 320</code>，将<code>{</code>改成 <code>\{</code>即可；</p>
</li>
<li>configure时可能需要指定python版本为2以避免调用python3出现错误，参数为<code>--python=/usr/bin/python2.7</code>。</li>
</ol>
<h2 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h2><p>实验1总共分为3个部分：</p>
<ul>
<li>第1部分主要关注x86汇编语言、QEMU x86模拟器以及PC的上电启动流程；</li>
<li>第2部分主要关注6.828内核的引导程序；</li>
<li>第3部分开始挖掘6.828内核的最初模板 - JOS。</li>
</ul>
<p>实验使用Git进行版本管理，我们需要从MIT的Git克隆最开始的仓库，有关这一部分的具体说明请自行参考<a href="https://pdos.csail.mit.edu/6.828/2017/labs/lab1/" target="_blank" rel="external">Lab1实验讲义</a>。</p>
<p>有关于Git的教程推荐<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的官方博客</a>或者是<a href="https://www.gitbook.com/book/bingohuang/progit2/details" target="_blank" rel="external">Pro Git 2</a>。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="第一部分-PC-Bootstrap-PC引导"><a href="#第一部分-PC-Bootstrap-PC引导" class="headerlink" title="第一部分 PC Bootstrap - PC引导"></a>第一部分 PC Bootstrap - PC引导</h3><h4 id="x86汇编"><a href="#x86汇编" class="headerlink" title="x86汇编"></a>x86汇编</h4><p>本实验需要熟悉x86汇编，8086汇编我已经在王爽的《汇编语言》中学习过，x86_64汇编我也已经在《深入理解计算机系统》中有所涉猎。本实验中使用的是i386汇编。这里不再赘述。</p>
<h4 id="模拟x86"><a href="#模拟x86" class="headerlink" title="模拟x86"></a>模拟x86</h4><p>在本实验中使用QEMU作为模拟器。尽管QEMU内置的监控只能提供少量的调试支持，但是QEMU却可以作为GNU-Debugging（GDB）的远程调试目标。</p>
<p>根据实验指导使用make编译生成内核并且用make qemu或者是make qemu-nox启动QEMU。我们可以看到，当前的内核仅支持两条命令help和kerninfo。</p>
<h4 id="PC的物理地址空间"><a href="#PC的物理地址空间" class="headerlink" title="PC的物理地址空间"></a>PC的物理地址空间</h4><p>PC的物理地址空间有着如下的布局：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</div><div class="line">|      32-bit      |</div><div class="line">|  memory mapped   |</div><div class="line">|     devices      |</div><div class="line">|                  |</div><div class="line">/\/\/\/\/\/\/\/\/\/\</div><div class="line"></div><div class="line">/\/\/\/\/\/\/\/\/\/\</div><div class="line">|                  |</div><div class="line">|      Unused      |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- depends on amount of RAM</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">| Extended Memory  |</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- 0x00100000 (1MB)</div><div class="line">|     BIOS ROM     |</div><div class="line">+------------------+  &lt;- 0x000F0000 (960KB)</div><div class="line">|  16-bit devices, |</div><div class="line">|  expansion ROMs  |</div><div class="line">+------------------+  &lt;- 0x000C0000 (768KB)</div><div class="line">|   VGA Display    |</div><div class="line">+------------------+  &lt;- 0x000A0000 (640KB)</div><div class="line">|                  |</div><div class="line">|    Low Memory    |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- 0x00000000</div></pre></td></tr></table></figure>
<p>最初的PC基于Intel的16位8088处理器，仅能够支持2^20B = 2^10KB = 1MB的寻址，早期的地址空间从0x00000开始到0xFFFFF结束。</p>
<ul>
<li>0x00000到0xA0000（640KB）被称作低内存，是早期PC能用的唯一的RAM；</li>
<li>0xA0000到0xFFFFF（384KB）被硬件保留作特殊用途如视频缓冲区或是固件，该部分最重要的区域是从0xF0000到0xFFFFF（64KB）的基本输入输出系统（BIOS）。BIOS用作执行最基本的系统初始化如激活显卡、检查内存等。在初始化完成后，BIOS从软盘、硬盘、光驱或是网络中读取操作系统，并且将机器控制权转移给操作系统。</li>
</ul>
<p>从Intel的80286到80386，处理器能够支持16MB和4GB的地址空间。但为了后向兼容性，硬件设计者保留了低1M内存的布局。<br>现代PC因此在0x000A0000到0x00100000的内存中有一个“洞”，这个洞将内存分为了低内存/保留内存（Low Memory）（低640KB）以及扩展内存（Extended Memory）（其他内存）。除此以外，32位PC的地址空间的最上方，常常被BIOS保留用作32位的PCI设备。</p>
<p>最新的x86处理器能够支持超过4GB的物理内存，因此内存可以超过0xFFFFFFFF。因此BIOS需要预留出第二个“洞”以保证那些32位的PCI设备的地址可以被正确的映射。</p>
<p>由于JOS只会使用256M内存，在此假设仅PC具有32位的地址空间。</p>
<h4 id="ROM-BIOS"><a href="#ROM-BIOS" class="headerlink" title="ROM BIOS"></a>ROM BIOS</h4><p>根据实验指导，进行QEMU和GDB的联合调试。我们会发现从上电开始，IBM PC从0x000ffff0开始执行指令。该处位于为BIOS预留的64kb的空间的顶层。此时CS = 0xf000 IP = 0xfff0。且第1条指令是一个jmp指令，跳转至CS = 0xf000 IP = 0xe05b。</p>
<p>这些都是早期的8088处理器的设计者设计的。这样的设计保证了BIOS总能控制机器。因为在刚上电的时候，在内存中并不存在能够执行的代码。</p>
<blockquote>
<p>此处需要理解8086的分段式寻址，即通过两个16位寄存器的值构造20位地址。实际地址为CS × 16 + IP = 0xf000 × 16 + 0xfff0 = 0xffff0。</p>
</blockquote>
<h3 id="第二部分-引导"><a href="#第二部分-引导" class="headerlink" title="第二部分 引导"></a>第二部分 引导</h3><p>软盘和硬盘被分为了512Bytes的区域 - 扇区（Sector）。一个扇区是磁盘传输的最小粒度：每一个读操作和写操作必须是一个或是一个以上的扇区，并且必须要对齐到扇区。</p>
<p>如果一个磁盘是可引导的，那么它的第一个扇区就被称作引导扇区，引导代码就存储在引导扇区中。如果BIOS发现了一个可引导的硬件，那么它就将这个扇区从磁盘读取至内存的0x7c00到0x7dff处，并且使用一个jmp指令设置CS：IP = 0000:7C00，将控制传递给引导。和BIOS读取地址一样，这个地址对于PC来说是固定和标准化的。</p>
<blockquote>
<p>从光盘引导的情形更加复杂，因为光盘的一个扇区为2048Byte，BIOS可以从硬盘读取一个更大的引导镜像到内存中。</p>
</blockquote>
<p>在6.828中，使用硬盘的传统引导机制。这意味这引导必须满足512个Bytes的限制。引导由一个汇编文件boot/boot.S，以及一个C语言文件boot/main.c组成。</p>
<hr>
<p>为了理解boot.S，需要以下的知识储备。</p>
<h4 id="实模式和保护模式"><a href="#实模式和保护模式" class="headerlink" title="实模式和保护模式"></a>实模式和保护模式</h4><h5 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h5><p>实模式是为了与8086兼容而设置的。在实模式下，处理器相当于一个快速的8086处理器。当处理器被加电或者复位时以实模式启动。</p>
<ul>
<li>实模式下各寄存器以实模式的初始化值工作；</li>
<li>实模式的地址空间总共为20位（1MB）；</li>
<li>实模式下不支持内存分页机制；</li>
<li>实模式下各内存段均是可读、可写、可执行的，不支持指令优先级，所有的指令均运行在特权级；</li>
<li>实模式不支持多任务切换；</li>
<li>实模式的中断处理也和8086相同，使用中断向量表来定位中断服务程序。</li>
</ul>
<p>在保护模式下，处理器的所有功能都是可用的。具体来说：</p>
<ul>
<li>保护模式提供了完全的32位地址空间，寻址空间为4GB；</li>
<li>保护模式支持内存分页机制，提供了对虚拟内存的硬件支持；</li>
<li>保护模式的处理器支持多任务（上下文切换）；</li>
<li>保护模式的处理器支持指令和数据的特权级，配合边界检查等机制，既可以共享数据也可以隔离各个任务。</li>
</ul>
<p>为了保证后向兼容性，x86的处理器启动时默认是实模式，需要手动从实模式切换至保护模式。但是切换至保护模式之前需要做一些必要的准备工作，如打开A20和建立全局描述符表等。</p>
<h4 id="A20地址线"><a href="#A20地址线" class="headerlink" title="A20地址线"></a>A20地址线</h4><p>在早期的PC上处理器仅支持20位的地址空间，任何超过20位的地址都会被卷回。<br>例如：0xFFFF+0xFFFF = 0x1FFFE -&gt; 0xFFFE</p>
<p>然而，从80286开始，Intel支持了24位的地址空间，上例的地址相加将不会发生卷回。<br>为了保证与早期PC的完全兼容，Intel采用了“黑魔法” - 将A20（第21根）地址线与键盘控制器的一个输出进行了与运算。进而控制A20地址线的值。</p>
<p>默认情况下，A20是置0的，PC将只能访问1M、3M、5M…这样的奇数段。进入保护模式前我们需要先打开A20以获得完全的寻址能力。</p>
<p>JOS内核通过端口的方式与键盘控制器进行通信并打开A20。可以参考Reference中的<a href="http://www.computer-engineering.org/ps2keyboard/" target="_blank" rel="external">PS/2 Keyboard Interface</a>。</p>
<ul>
<li>8042有一个1 Byte的输入缓冲区，一个1 Byte的输出缓冲区、一个1 Byte的状态寄存器、以及一个1 Byte的控制寄存器。前三个寄存器可以直接从0x60和0x64端口进行访问。最后一个寄存器通过“Read Command Byte”命令进行读，通过“Write Command Byte”命令进行写。</li>
<li>对0x60端口读会读输入缓冲区；对0x60端口写会写输出缓冲区；对0x64端口读会读状态寄存器；对0x64端口写会发送命令。</li>
<li>状态寄存器的Bit1为IBF - Input Buffer Full，当该Bit为1时，输入缓冲区满，不能对0x60端口或0x64端口写。</li>
<li>对0x64端口写0xd1发送的命令是“Write Output Port”写输出端口，表明将参数写入输出端口（0x60端口写）。</li>
<li>A20使用的是键盘控制器输出的Bit 1，向输出端口写入0xdf可以打开A20；向输出端口写入0xdd则会关闭A20。</li>
</ul>
<h4 id="分段机制与全局描述符表"><a href="#分段机制与全局描述符表" class="headerlink" title="分段机制与全局描述符表"></a>分段机制与全局描述符表</h4><p>x86处理器提供了分段机制和分页机制两种内存管理模式。如果要进入保护模式，就必须要先启动分段机制。（分页机制不是必须的）</p>
<p>分段机制将内存划分为若干个段，每个段都由段基址、段界限和段属性组成。由一个段描述符表（可以理解为一个数组）描述所有段的信息。段描述符表可以是全局的也可以是局部的。</p>
<p>简化的说，程序首先将对应的段选择子（可以理解为数组的索引）加载进入段寄存器中。然后在执行程序时，根据指令的内容确定应该使用的段寄存器，根据段寄存器中的段选择子确定应该使用的段描述符。再结合段描述符中包含的信息加上指令自身的地址构造出实际的物理地址。最终将该地址发送到地址总线上，到物理内存中寻址，并取回相应的数据。这之中我们简化了有关特权级、边界检查的相关内容，但足以描述分段机制的基本原理。</p>
<p>分段机制将虚拟地址转换成了线性地址。</p>
<h5 id="全局描述符表寄存器"><a href="#全局描述符表寄存器" class="headerlink" title="全局描述符表寄存器"></a>全局描述符表寄存器</h5><p>x86处理器提供了专门的全局描述符表寄存器（Global Descriptor Table Register）用于保存全局描述符表的表基址和表限长。GDTR由2个字节的表限长（limit）和4个字节的表基址（base）组成。其中表基址指定了全局描述符表的起始地址，表限长指定了全局描述符表的大小。其C结构体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdtr</span> &#123;</span></div><div class="line">	u16 limite;</div><div class="line">	u32 base;</div><div class="line">&#125; __attribute__ ((packed));</div></pre></td></tr></table></figure></p>
<p>在机器刚加电或者是处理器复位后，表基址默认被置为0，表限长则默认被置为0xFFFF。在保护模式初始化的过程中，必须给GDTR加载新的值。我们可以使用lgdt指令为GDTR加载新值。</p>
<h5 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h5><p>段选择子（2个字节）用于选择特定的描述符表以及表中的特定描述符。段选择子一般被放置于段寄存器中，段选择子由13位的索引、1位的表指示位和2位的请求特权级三部分组成。其中索引指定了描述符，表指示位选择应该访问的描述符表 - 0代表全局描述符表，1代表局部描述符表，请求特权级用于段级的保护机制，自0到4分别代表ring 0到ring 3。其C结构体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">selector</span> &#123;</span></div><div class="line">    u16 index:<span class="number">13</span>;</div><div class="line">    u16 ti:<span class="number">1</span>;</div><div class="line">    u16 rpl:<span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h5><p>段描述符（8个字节）是段描述符表这个“数组”的“元素”。用C结构体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdtdesc</span> &#123;</span></div><div class="line">	u16 lim0_15;</div><div class="line">	u16 base0_15;</div><div class="line">	u8 base16_23;</div><div class="line">	u8 acces;</div><div class="line">	u8 lim16_19:<span class="number">4</span>;</div><div class="line">	u8 other:<span class="number">4</span>;</div><div class="line">	u8 base24_31;</div><div class="line">&#125; __attribute__ ((packed));</div></pre></td></tr></table></figure></p>
<p>其中总共包含了32位的段基址、20位的段界限、以及12位的类型。<br>段基址规定了段的起始地址。段界限规定了段的大小。而类型用于区别不同类型的描述符。包括描述符特权级、段存在位、已访问位等等。</p>
<h4 id="boot-S代码详解"><a href="#boot-S代码详解" class="headerlink" title="boot.S代码详解"></a>boot.S代码详解</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">#include &lt;<span class="keyword">inc</span>/mmu.h&gt;</div><div class="line"></div><div class="line"># Start the <span class="meta">CPU</span>: switch to <span class="number">32</span>-bit protected mode, jump <span class="keyword">into</span> C.</div><div class="line"># The BIOS loads this code from the first sector of the hard disk <span class="keyword">into</span></div><div class="line"># memory <span class="meta">at</span> physical address <span class="number">0x7c00</span> <span class="keyword">and</span> starts executing <span class="keyword">in</span> real mode</div><div class="line"># with %cs=<span class="number">0</span> %ip=7c00.</div><div class="line"># boot.S 主要将<span class="meta">CPU</span>切换至<span class="number">32</span>位保护模式，并且跳转进入C代码</div><div class="line"><span class="meta"></span></div><div class="line">.set PROT_MODE_CSEG, <span class="number">0x8</span>         # kernel code <span class="meta">segment</span> selector</div><div class="line"><span class="meta">.set</span> PROT_MODE_DSEG, <span class="number">0x10</span>        # kernel data <span class="meta">segment</span> selector</div><div class="line"><span class="meta">.set</span> CR0_PE_ON,      <span class="number">0x1</span>         # protected mode enable flag</div><div class="line"><span class="meta"></span></div><div class="line">.globl start</div><div class="line"><span class="symbol">start:</span>                        # 程序入口</div><div class="line"><span class="meta">  .code16</span>                     # Assemble for <span class="number">16</span>-bit mode 指导生成<span class="number">16</span>位汇编代码</div><div class="line">  <span class="keyword">cli</span>                         # Disable interrupts 关中断</div><div class="line">  <span class="keyword">cld</span>                         # String operations increment 设置串传递顺序递增</div><div class="line"></div><div class="line">  # Set <span class="meta">up</span> the important data <span class="meta">segment</span> registers (<span class="built_in">DS</span>, <span class="built_in">ES</span>, <span class="built_in">SS</span>). 设置重要的段寄存器为<span class="number">0</span></div><div class="line">  xorw    %ax,%ax             # <span class="meta">Segment</span> number <span class="meta">zero</span></div><div class="line">  movw    %ax,%ds             # -&gt; Data <span class="meta">Segment</span></div><div class="line">  movw    %ax,%es             # -&gt; Extra <span class="meta">Segment</span></div><div class="line">  movw    %ax,%ss             # -&gt; Stack <span class="meta">Segment</span></div><div class="line"></div><div class="line">  # Enable A20:</div><div class="line">  #   For backwards compatibility with the earliest PCs, physical</div><div class="line">  #   address line <span class="number">20</span> is tied low, so that addresses higher than</div><div class="line">  #   1MB wrap around to <span class="meta">zero</span> by <span class="meta">default</span>.  This code undoes this.</div><div class="line">  # 开启A20：</div><div class="line">  #   A20的介绍已经给出，不再赘述。</div><div class="line"><span class="symbol">seta20.1:</span></div><div class="line">  inb     <span class="number">$0</span>x64,%al               # Wait for <span class="keyword">not</span> busy 等待缓冲区可用</div><div class="line">  testb   <span class="number">$0</span>x2,%al                # <span class="keyword">Test</span> for bit1 - if bit1 = <span class="number">1</span> then buffer is full</div><div class="line">  <span class="keyword">jnz</span>     seta20<span class="meta">.1</span></div><div class="line"></div><div class="line">  movb    <span class="number">$0</span>xd1,%al               # <span class="number">0xd1</span> -&gt; port <span class="number">0x64</span></div><div class="line">  outb    %al,<span class="number">$0</span>x64               # Prepare to write output port 准备写入输出端口</div><div class="line"><span class="symbol"></span></div><div class="line">seta20.2:</div><div class="line">  inb     <span class="number">$0</span>x64,%al               # Wait for <span class="keyword">not</span> busy 等待缓冲区可用</div><div class="line">  testb   <span class="number">$0</span>x2,%al</div><div class="line">  <span class="keyword">jnz</span>     seta20<span class="meta">.2</span>                # The same as above 同上</div><div class="line"></div><div class="line">  movb    <span class="number">$0</span>xdf,%al               # <span class="number">0xdf</span> -&gt; port <span class="number">0x60</span></div><div class="line">  outb    %al,<span class="number">$0</span>x60               # <span class="number">0xdf</span> -&gt; A20 gate enable command 打开A20</div><div class="line"></div><div class="line">  # Switch from real to protected mode, using a bootstrap GDT</div><div class="line">  # <span class="keyword">and</span> <span class="meta">segment</span> translation that makes virtual addresses</div><div class="line">  # identical to their physical addresses, so that the</div><div class="line">  # effective memory map does <span class="keyword">not</span> change during the switch.</div><div class="line">  <span class="keyword">lgdt</span>    gdtdesc                # Load gdt size/base to gdtr 设置全局描述符表</div><div class="line">  movl    %cr0, %eax             # Control register <span class="number">0</span>, bit0 is protected enable bit 读取控制寄存器<span class="number">0</span>的值，其Bit0为允许保护模式位</div><div class="line">  orl     $CR0_PE_ON, %eax       # Set PE 将允许保护模式位置<span class="number">1</span></div><div class="line">  movl    %eax, %cr0             # Update Control register <span class="number">0</span> 设置控制寄存器<span class="number">0</span></div><div class="line"></div><div class="line">  # Jump to next instruction, but <span class="keyword">in</span> <span class="number">32</span>-bit code <span class="meta">segment</span>.</div><div class="line">  # Switches processor <span class="keyword">into</span> <span class="number">32</span>-bit mode.</div><div class="line">  ljmp    $PROT_MODE_CSEG, $protcseg # 通过ljmp指令（跳转至下一条指令）进入保护模式</div><div class="line"><span class="meta"></span></div><div class="line">  .code32                     # Assemble for <span class="number">32</span>-bit mode 指导生成<span class="number">32</span>位汇编代码</div><div class="line"><span class="symbol">protcseg:</span></div><div class="line">  # Set <span class="meta">up</span> the protected-mode data <span class="meta">segment</span> registers 设置保护模式的数据段寄存器</div><div class="line">  movw    $PROT_MODE_DSEG, %ax    # Our data <span class="meta">segment</span> selector</div><div class="line">  movw    %ax, %ds                # -&gt; <span class="built_in">DS</span>: Data <span class="meta">Segment</span></div><div class="line">  movw    %ax, %es                # -&gt; <span class="built_in">ES</span>: Extra <span class="meta">Segment</span></div><div class="line">  movw    %ax, %fs                # -&gt; <span class="built_in">FS</span></div><div class="line">  movw    %ax, %gs                # -&gt; <span class="built_in">GS</span></div><div class="line">  movw    %ax, %ss                # -&gt; <span class="built_in">SS</span>: Stack <span class="meta">Segment</span></div><div class="line"></div><div class="line">  # Set <span class="meta">up</span> the stack pointer <span class="keyword">and</span> <span class="keyword">call</span> <span class="keyword">into</span> C. 设置栈指针并且调用C</div><div class="line">  movl    $start, %esp  # Stack has the opposite extension direction than Code 注意栈的延伸方向和代码段相反</div><div class="line">  <span class="keyword">call</span> bootmain #调用main.c中的bootmain函数</div><div class="line"></div><div class="line">  # If bootmain returns (it shouldn<span class="string">'t), loop.</span></div><div class="line">spin:</div><div class="line">  jmp spin</div><div class="line"></div><div class="line"># Bootstrap GDT 引导GDT</div><div class="line">.p2align 2                                # force 4 byte alignment</div><div class="line">gdt:</div><div class="line">  SEG_NULL				# null seg 默认第一个段描述符为空</div><div class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)	# code seg 设置代码段描述符</div><div class="line">  SEG(STA_W, 0x0, 0xffffffff)	        # data seg 设置数据段描述符</div><div class="line">  # 关于SEG宏可以参考mmu.h</div><div class="line"></div><div class="line">gdtdesc:                                  # 用于设置全局段描述符寄存器</div><div class="line">  .word   0x17                            # sizeof(gdt) - 1 # Size of gdt</div><div class="line">  .long   gdt                             # address gdt # Base address of gdt</div></pre></td></tr></table></figure>
<hr>
<p>为了理解main.c，我们需要如下的知识储备。</p>
<h4 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h4><p>可执行和可链接格式（Executable and Linkable Format）是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。</p>
<p>ELF文件可以分为两种组成 - 链接视图（Linking View）和执行视图（Execution View）。这里我们只讨论执行视图。</p>
<p>执行视图的结构如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">+--------------------+</div><div class="line">|     ELF Header     |</div><div class="line">+--------------------+</div><div class="line">|Program Header Table|</div><div class="line">+--------------------+</div><div class="line">|      Segment 1     |</div><div class="line">+--------------------+</div><div class="line">|      Segment 2     |</div><div class="line">+--------------------+</div><div class="line">|         ...        |</div><div class="line">+--------------------+</div><div class="line">|Section Header Table|</div><div class="line">|       optinal      |</div><div class="line">+--------------------+</div></pre></td></tr></table></figure></p>
<p>ELF文件格式主要由ELF头（ELF Header）、程序头部表（Program Header Table）和节头部表（Section Header Table）组成。在执行视图中，节头部表是可选的。</p>
<p>有关于这些数据结构的C语言定义可以参考头文件<inc elf.h="">。</inc></p>
<ul>
<li>ELF头主要包含了ELF魔数、文件类型、程序头部表偏移和大小、程序入口等信息；</li>
<li>程序头部表可以看做一个数据结构的数组，每一个元素都描述了一个段。主要包含了段的偏移、段的虚拟地址、段的物理地址、段的大小等信息。</li>
</ul>
<h4 id="磁盘控制器"><a href="#磁盘控制器" class="headerlink" title="磁盘控制器"></a>磁盘控制器</h4><p>磁盘是电脑主要的存储媒介。磁盘是由盘片构成的。每个盘片有两面或者称为表面，表面覆盖着磁性记录材料。盘片中央有一个可以旋转的主轴，它使得盘片以固定的旋转速率旋转，通常是5400-15000转每分钟（Revolution Per Minute）。磁盘通常包含一个或多个这样的盘片，并封装在一个密封的容器内。</p>
<p>每一个表面是由一组称为磁道的同心圆组成。每个磁道被划分为一组扇区。每个扇区包含相等数量的数据位（通常是512字节），这些数据编码在扇区上的磁性材料中。扇区之间由一些间隙分隔开，这些间隙中不存储数据位。间隙用来标识扇区的格式化位。</p>
<p>磁盘的柱面是所有盘片表面上到主轴中心距离相等的磁道的集合。</p>
<p>对于磁盘的寻址通常分为CHS和LBA两种。</p>
<ol>
<li>CHS即柱面（cylinder）-磁头（head）-扇区（sector）寻址。每个盘片都对应着一个磁头，每一个盘片都被划分成柱面，每一个柱面都被划分成多个段。磁盘的最小存储单元是段。早期的IBM PC架构上采用CHS进行磁盘寻址。CHS是一个三元组，包括10bit的柱面号，8bit的磁头号以及6bit的扇区号。这样CHS的最大寻址范围为2^10 × 2^8 × 2^6 × 512 = 8GB。</li>
<li>随着磁盘容量的不断扩大，CHS的8GB寻址范围已经不能满足需要，现在的磁盘普遍采用逻辑区块地址（Logical Block Adress）的方式进行寻址来进行抽象。LBA是一个整数，代表磁盘上的一个逻辑区块编号，通过将这个整数转换成CHS格式来完成磁盘的具体寻址。LBA为48个bit，最大寻址范围为128PB。在本实验中，LBA按照旧的规范采用28个bit。</li>
</ol>
<p>IDE硬盘控制器（IDE Hard Drive Controller）的0x1F7端口读为磁盘0状态寄存器。<br>其Bit6为RDY Bit，当其置1表明磁盘上电完成。在对于磁盘做任何操作（除了复位）之前务必要保证该Bit为1。<br>其Bit7为BSY Bit，当其置1表明磁盘忙。在你向磁盘发送任何指令前务必保证该Bit为0。</p>
<p>通过IDE硬盘控制器读取扇区需要如下的步骤：</p>
<ol>
<li>向0x1F2端口写入待操作的扇区数目；</li>
<li>向0x1F3-0x1F5端口依次写入LBA的低24位；</li>
<li>向0x1F6端口的低4位写入LBA的高4位，向0x1F6端口的高4位写入驱动器地址；</li>
<li>向0x1F7端口写入读命令0x20。</li>
</ol>
<p>0x1F6寄存器又称Drive/Head寄存器。其低4位是LBA的高4位。其Bit5和Bit7一般是1。其Bit6为LBA位，当置1时表示启用LBA寻址。其Bit4为DRV位。用来选择驱动器，Master驱动器为0，Slave驱动器为1。这里我们将高4位置为0x1110</p>
<p>在使用读命令0x20之前需要完整的设置柱面/磁头/扇区。当这个命令完成，你可以从磁盘的数据寄存器（0x1F0端口）读取256个字（16Bits）。</p>
<h4 id="main-c代码详解"><a href="#main-c代码详解" class="headerlink" title="main.c代码详解"></a>main.c代码详解</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/x86.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/elf.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/**********************************************************************</span></div><div class="line"> * This a dirt simple boot loader, whose sole job is to boot</div><div class="line"> * an ELF kernel image from the first IDE hard disk.</div><div class="line"> *</div><div class="line"> * DISK LAYOUT</div><div class="line"> *  * This program(boot.S and main.c) is the bootloader.  It should</div><div class="line"> *    be stored in the first sector of the disk.</div><div class="line"> *</div><div class="line"> *  * The 2nd sector onward holds the kernel image.</div><div class="line"> *</div><div class="line"> *  * The kernel image must be in ELF format.</div><div class="line"> *</div><div class="line"> * BOOT UP STEPS</div><div class="line"> *  * when the CPU boots it loads the BIOS into memory and executes it</div><div class="line"> *</div><div class="line"> *  * the BIOS intializes devices, sets of the interrupt routines, and</div><div class="line"> *    reads the first sector of the boot device(e.g., hard-drive)</div><div class="line"> *    into memory and jumps to it.</div><div class="line"> *</div><div class="line"> *  * Assuming this boot loader is stored in the first sector of the</div><div class="line"> *    hard-drive, this code takes over...</div><div class="line"> *</div><div class="line"> *  * control starts in boot.S -- which sets up protected mode,</div><div class="line"> *    and a stack so C code then run, then calls bootmain()</div><div class="line"> *</div><div class="line"> *  * bootmain() in this file takes over, reads in the kernel and jumps to it.</div><div class="line"> **********************************************************************/</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTSIZE	512</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELFHDR		((struct Elf *) 0x10000) <span class="comment">// scratch space</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">uint32_t</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readseg</span><span class="params">(<span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">bootmain</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></div><div class="line"></div><div class="line">	<span class="comment">// read 1st page off disk 从磁盘上读取第一页</span></div><div class="line">	readseg((<span class="keyword">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="comment">// is this a valid ELF? 通过ELF魔数确认ELF有效</span></div><div class="line">	<span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</div><div class="line">		<span class="keyword">goto</span> bad;</div><div class="line"></div><div class="line">	<span class="comment">// load each program segment (ignores ph flags) 读取各个段</span></div><div class="line">	ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff); <span class="comment">// 程序头部表的起始地址</span></div><div class="line">	eph = ph + ELFHDR-&gt;e_phnum; <span class="comment">// 程序头部表的结束地址</span></div><div class="line">	<span class="keyword">for</span> (; ph &lt; eph; ph++)</div><div class="line">		<span class="comment">// p_pa is the load address of this segment (as well</span></div><div class="line">		<span class="comment">// as the physical address)</span></div><div class="line">        <span class="comment">// p_pa是加载地址也是物理地址</span></div><div class="line">		readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</div><div class="line"></div><div class="line">	<span class="comment">// call the entry point from the ELF header 从ELF头调用程序入口</span></div><div class="line">	<span class="comment">// note: does not return!</span></div><div class="line">	((<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) (ELFHDR-&gt;e_entry))();</div><div class="line"></div><div class="line">bad:</div><div class="line">	<span class="comment">// stops simulation and breaks into the debug console</span></div><div class="line">	outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</div><div class="line">	outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</div><div class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</div><div class="line">		<span class="comment">/* do nothing */</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Read 'count' bytes at 'offset' from kernel into physical address 'pa'. 从内核的offset处读取count个字节到物理地址pa处</span></div><div class="line"><span class="comment">// Might copy more than asked 可能会读取超过count个（扇区对齐）</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">readseg</span><span class="params">(<span class="keyword">uint32_t</span> pa, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">uint32_t</span> end_pa;</div><div class="line"></div><div class="line">	end_pa = pa + count; <span class="comment">// 结束物理地址</span></div><div class="line"></div><div class="line">	<span class="comment">// round down to sector boundary 对齐到扇区</span></div><div class="line">	pa &amp;= ~(SECTSIZE - <span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="comment">// translate from bytes to sectors, and kernel starts at sector 1</span></div><div class="line">	offset = (offset / SECTSIZE) + <span class="number">1</span>; <span class="comment">// 算出扇区数 注意扇区从1开始（0为引导扇区）</span></div><div class="line"></div><div class="line">	<span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></div><div class="line">	<span class="comment">// We'd write more to memory than asked, but it doesn't matter --</span></div><div class="line">	<span class="comment">// we load in increasing order.</span></div><div class="line">    <span class="comment">// 在实际中我们往往将多个扇区一起读出以提高效率。</span></div><div class="line">	<span class="keyword">while</span> (pa &lt; end_pa) &#123;</div><div class="line">		<span class="comment">// Since we haven't enabled paging yet and we're using</span></div><div class="line">		<span class="comment">// an identity segment mapping (see boot.S), we can</span></div><div class="line">		<span class="comment">// use physical addresses directly.  This won't be the</span></div><div class="line">		<span class="comment">// case once JOS enables the MMU.</span></div><div class="line">        <span class="comment">// 考虑到我们没有开启分页以及boot.S中使用了一一对应的映射规则，加载地址和物理地址是一致的。</span></div><div class="line">		readsect((<span class="keyword">uint8_t</span>*) pa, offset);</div><div class="line">		pa += SECTSIZE;</div><div class="line">		offset++;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">waitdisk</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// wait for disk reaady 等待磁盘准备完毕。</span></div><div class="line">	<span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</div><div class="line">		<span class="comment">/* do nothing */</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> offset)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// wait for disk to be ready</span></div><div class="line">	waitdisk();</div><div class="line"></div><div class="line">	outb(<span class="number">0x1F2</span>, <span class="number">1</span>);		<span class="comment">// count = 1 0x1F2 Disk 0 sector count</span></div><div class="line">	<span class="comment">// Read one sector each time</span></div><div class="line">	outb(<span class="number">0x1F3</span>, offset); <span class="comment">// Disk 0 sector number (CHS Mode)</span></div><div class="line">	<span class="comment">// First sector's number</span></div><div class="line">	outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>); <span class="comment">// Cylinder low (CHS Mode)</span></div><div class="line">	outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>); <span class="comment">// Cylinder high (CHS Mode)</span></div><div class="line">	<span class="comment">// Cylinder number</span></div><div class="line">	outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>); <span class="comment">// Disk 0 drive/head</span></div><div class="line">	<span class="comment">// MASK 11100000</span></div><div class="line">	<span class="comment">// Drive/Head Register: bit 7 and bit 5 should be set to 1</span></div><div class="line">	<span class="comment">// Bit6: 1 LBA mode, 0 CHS mode</span></div><div class="line">	outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);	<span class="comment">// cmd 0x20 - read sectors</span></div><div class="line">    <span class="comment">/*20H       Read sector with retry. NB: 21H = read sector</span></div><div class="line">                without retry. For this command you have to load</div><div class="line">                the complete circus of cylinder/head/sector</div><div class="line">                first. When the command completes (DRQ goes</div><div class="line">                active) you can read 256 words (16-bits) from the</div><div class="line">                disk's data register. */</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">// wait for disk to be ready</span></div><div class="line">	waitdisk();</div><div class="line"></div><div class="line">	<span class="comment">// read a sector</span></div><div class="line">	insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</div><div class="line">	<span class="comment">// Data register: data exchange with 8/16 bits</span></div><div class="line">	<span class="comment">// insl port addr cnt: read cnt dwords from the input port</span></div><div class="line">	<span class="comment">// specified by port into the supplied output array addr.</span></div><div class="line">	<span class="comment">// dword: 4 bytes = 16 bits</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>练习3：</p>
<ol>
<li>0x7c2d: ljmp  $0x8, $0x7c32 从这句汇编指令之后处理器开始执行32位指令。ljmp指令导致了16位指令到32位指令的转变。</li>
<li>引导最后执行的指令是call *0x10018，内核的第一条指令是movw $0x1234,0x472。</li>
<li>内核的第一条指令位于0x10000c。</li>
<li>引导从程序头部表中得到段的数目以及每个段的大小，以此决定要从磁盘上读出多少个扇区。</li>
</ol>
<h4 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h4><p>本部分主要需要了解.text段.rodata段和.data段，并且使用objdump读取ELF格式的信息。</p>
<p>boot/Makefrag文件中指定了引导的text段的位置为0x7c00。</p>
<p>练习5：<br>修改了text段的加载地址使得汇编代码中的跳转地址出现错误，进而导致整个引导因为错误提前终止。</p>
<p>练习6：<br>结果是非常显然的，因为引导的作用就是将内核从磁盘加载进入内存中。使用objdump -h obj/kern/kernel我们可以看到如下的信息：<br>0 .text         00001809  f0100000  00100000  00001000  2**4<br>                CONTENTS, ALLOC, LOAD, READONLY, CODE<br>我们可以直到内核的text段会被加载至内存中0x100000（物理地址）处。</p>
<h3 id="第三部分-内核"><a href="#第三部分-内核" class="headerlink" title="第三部分 内核"></a>第三部分 内核</h3><h4 id="使用虚拟内存去解决位置依赖"><a href="#使用虚拟内存去解决位置依赖" class="headerlink" title="使用虚拟内存去解决位置依赖"></a>使用虚拟内存去解决位置依赖</h4><p>可以发现内核将自己链接至了非常高的虚拟地址，比如0xf0100000，为了将处理器虚拟地址的较低部分给用户程序去使用。将在下一个实验介绍这一现象。</p>
<p>实际上，许多的机器在物理内存中并没有0xf0100000这样的高地址。实际上由处理器的内存管理硬件将虚拟地址0xf0100000映射到了实际内存中的物理地址0x100000。</p>
<p>这涉及了分页机制以及页表。<br>在kern/entry.S设置CR0_PG标记之前，内存引用被当做线性地址。实际上，由于我们在boot/boot.S设置了线性地址到物理地址的一致映射，所以线性地址在这里可以等同于物理地址。<br>当CR0_PG标记被设置了之后，所有的内存引用都被当作虚拟地址。虚拟地址通过虚拟内存硬件被翻译成物理地址。<br>kern/entrypgdir.c将0xf0000000到0xf0400000的虚拟地址翻译为物理地址的0x000000到0x400000，也将0x00000000到0x00400000的虚拟地址翻译为物理地址的0x00000000到0x00400000。<br>引用这些地址范围以外的虚拟地址将会抛出缺页的异常。<br>但我们还没有为该异常设置中断处理程序。这会导致QEMU导出机器状态并退出。</p>
<p>练习7：<br>在movl %eax, %cr0指令（启动页表）之前，0x00100000出的内存不为空，0xf0100000出的内存全为0。<br>当stepi之后，0xf0100000处的内存和0x00100000处的内存完全一样。这表明我们已经成功启用了页表，并且完成了地址的映射。</p>
<h4 id="控制台的格式化字符串"><a href="#控制台的格式化字符串" class="headerlink" title="控制台的格式化字符串"></a>控制台的格式化字符串</h4><p>练习8：<br>缺失的代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</div><div class="line">	num = getuint(&amp;ap, lflag);</div><div class="line">base = <span class="number">8</span></div><div class="line"><span class="keyword">goto</span> number;</div></pre></td></tr></table></figure></p>
<ol>
<li>console.c提供了基本的I/O操作，同时封装了cputchar、getchar等函数供printf.c中的printf使用。printf使用了vprintfmt去解析格式化字符串并提供可变参数的特性。</li>
<li>这段代码主要实现了换行。其首先检查了当前的光标是否超过了最大值，如果是，则证明需要进行换行。其将第1行到第MAX-1行的内容复制到第0行到第MAX-2行所在的内存中，然后将第MAX-1行置空。最后将光标设置到新一行的开始。</li>
<li>fmt指向了格式化字符串”x %d, y %x, z %d\n”<br>ap指向了局部变量并且初始值为1<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">vcprintf(<span class="number">0xf0102449</span>, <span class="number">0xf0110e14</span>); <span class="number">0xf0102449</span> -&gt; <span class="string">"x %d, y %x, z %d\n"</span> <span class="number">0xf0110e14</span> -&gt; <span class="number">1</span></div><div class="line">cons_putc(<span class="number">120</span>);</div><div class="line">cons_putc(<span class="number">32</span>);</div><div class="line">va_arg(<span class="number">0xf0110dbc</span>, <span class="keyword">int</span>); Before: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e14</span> -&gt; <span class="number">1</span> After: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e18</span> -&gt; <span class="number">3</span></div><div class="line">cons_putc(<span class="number">49</span>);</div><div class="line">cons_putc(<span class="number">44</span>);</div><div class="line">cons_putc(<span class="number">32</span>);</div><div class="line">cons_putc(<span class="number">121</span>);</div><div class="line">cons_putc(<span class="number">32</span>);</div><div class="line">va_arg(<span class="number">0xf0110dbc</span>, <span class="keyword">int</span>); Before: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e18</span> -&gt; <span class="number">3</span> After: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e1c</span> -&gt; <span class="number">4</span></div><div class="line">cons_putc(<span class="number">51</span>);</div><div class="line">cons_putc(<span class="number">44</span>);</div><div class="line">cons_putc(<span class="number">32</span>);</div><div class="line">cons_putc(<span class="number">122</span>);</div><div class="line">cons_put(<span class="number">32</span>);</div><div class="line">va_arg(<span class="number">0xf0110dbc</span>, <span class="keyword">int</span>); Before: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e1c</span> -&gt; <span class="number">4</span> After: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e20</span> -&gt; <span class="number">536870922</span></div><div class="line">cons_put(<span class="number">52</span>);</div><div class="line">cons_put(<span class="number">10</span>);</div></pre></td></tr></table></figure>
注意这里va_arg是宏而不是函数，不能通过加断点的方式跟踪。我采用的方法是在调用va_arg的地方添加断点并跟踪。<br>在GNUmakefile中的C_FLAGS -O1会重排C代码，导致了追踪va_arg变得困难。所以，仅在此处将-O1变成-O0，尽管这会导致在backtrace时kernel panic。</li>
<li>57616 = 0xe110。此外，根据x86的小端序，&amp;i指向了byte序列0x72、0x6c、0x64、0x00。这等同于字符串”rld”。所以，最终的输出为”He110 World”。<br>需要将i改为0x726c6400。不需要修改57616。</li>
<li>这是由于程序从格式化字符串中推断出了应当有3个参数，所以程序会从cprintf的栈中多读取一个参数。但我们知道，实际上只有2个参数。所以最后一个参数是未指定的。</li>
<li>vcprintf(…, const char * fmt)。</li>
</ol>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>练习9：<br>f0100034:    bc 00 00 11 f0           mov    $0xf0110000,%esp<br>这一条指令初始化了引导栈，它位于0xf0110000处。内核仅通过设置esp寄存器的值为栈预留空间。栈指针指向高地址，并且栈自高地址向低地址延伸。</p>
<p>练习10：<br>本题考察了x86架构下的栈帧与函数调用。<br>函数调用时先将返回地址压栈，然后跳转至目标函数的起始地址；在目标函数内先将ebp寄存器的值（栈底）压栈保存，然后再将栈顶指针设置为新的栈底；<br>在函数中调用函数需要使用栈来传递参数，即将函数的参数以此压入栈中；<br>test_backtrace函数的汇编中使用了ebx寄存器，该寄存器为被调用者保存的寄存器，在使用的时候也要先压栈保存，再函数返回时恢复；<br>函数返回的时候通过先操作esp释放栈资源，然后恢复相应的被调用者保存的寄存器的值，最后调用汇编指令leave、ret返回；<br>leave指令先将esp的值置为ebp，然后再从栈中取出被保存的ebp的旧值；ret从栈中取出返回地址并跳转。</p>
<p>练习10-12：<br>mon_backtrace的实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mon_backtrace</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">uint32_t</span> ebp, eip, args[<span class="number">5</span>];</div><div class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></div><div class="line"></div><div class="line">	cprintf(<span class="string">"Stack backtrace:\n"</span>);</div><div class="line">	<span class="keyword">for</span> (ebp = read_ebp() ; ebp != <span class="number">0</span> ; ebp = *((<span class="keyword">uint32_t</span> *)ebp)) &#123;</div><div class="line">		eip = *((<span class="keyword">uint32_t</span> *)ebp + <span class="number">1</span>);</div><div class="line"></div><div class="line">		debuginfo_eip(eip, &amp;info);</div><div class="line"></div><div class="line">		args[<span class="number">0</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">2</span>);</div><div class="line">		args[<span class="number">1</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">3</span>);</div><div class="line">		args[<span class="number">2</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">4</span>);</div><div class="line">		args[<span class="number">3</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">5</span>);</div><div class="line">		args[<span class="number">4</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">6</span>);</div><div class="line">		cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>, ebp, eip, args[<span class="number">0</span>], args[<span class="number">1</span>], args[<span class="number">2</span>], args[<span class="number">3</span>], args[<span class="number">4</span>]);</div><div class="line"> 		cprintf(<span class="string">"      %s:%d: %.*s+%d\n"</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, eip - info.eip_fn_addr);</div><div class="line"> 	&#125;</div><div class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>查阅STABS文档可以知道表示行号的成员是n_desc，所以debuginfo_eip的缺失的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">	stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</div><div class="line"><span class="keyword">if</span> (lline &lt;= rline) &#123;</div><div class="line">	info-&gt;eip_line = stabs[lline].n_desc;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>修改后的commands结构体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span> <span class="title">commands</span>[] = &#123;</span></div><div class="line">&#123; <span class="string">"help"</span>, <span class="string">"Display this list of commands"</span>, mon_help &#125;,</div><div class="line">&#123; <span class="string">"kerninfo"</span>, <span class="string">"Display information about the kernel"</span>, mon_kerninfo &#125;,</div><div class="line">&#123; <span class="string">"backtrace"</span>, <span class="string">"Display information about the stack frames"</span>, mon_backtrace &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="提高-允许控制台输出不同颜色的文本"><a href="#提高-允许控制台输出不同颜色的文本" class="headerlink" title="提高 - 允许控制台输出不同颜色的文本"></a>提高 - 允许控制台输出不同颜色的文本</h4><p>要求能增强控制台的功能使得控制台可以输出不同颜色的字体。这里使用了传统的实现，解析嵌入在文本字符串中的ANSI转义序列来实现题目的要求。</p>
<p>在王爽的《汇编语言》中，已经接触过了字符的“属性字节”，一个字符的自低到高的第2个字节可以作为属性字节，用来指示字符的属性如闪烁、高亮、前景色、背景色等。<br>有关于ANSI转义序列的相关知识可以参考<a href="http://rrbrandt.dee.ufcg.edu.br/en/docs/ansi/" target="_blank" rel="external">这里</a>。</p>
<p>出于简化考虑，只部分实现ANSI转义序列中的<code>ESC[Ps;...;Psm</code>。</p>
<p>实现的思路是实现<code>&lt;kern/printf.c&gt;</code>中的punch函数的替代版本attribute_punch，来实现对于ANSI转义序列的解析，并且相应地设置字符的属性字节。</p>
<p>解析所需要的状态机具有三个状态：A_NORM代表正常的输出字符的状态、A_TRANS代表接收到[ESC]开始，从正常状态到解析转义序列的过渡状态、A_ESCAPE代表解析转义序列的状态。它们之间的状态转换图如图所示：</p>
<img src="/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/ansi_stm.png" alt="ansi_stm.png" title="">
<p>value用来存储每一个解析到的值，temp代表了解析过程中临时的属性字节，attribute代表了当前打印字符时附加的属性字节。</p>
<p>具体的实现代码在<kern printf.c="">中：</kern></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// state for ANSI escape sequence interpretation</span></div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">	A_NORM = <span class="number">0</span>,</div><div class="line">	A_TRANS,</div><div class="line">	A_ESCAPE</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// colormap - number (x - 30/40)[0, 7] -&gt; attribute byte</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> colormap[<span class="number">8</span>] =</div><div class="line">&#123;</div><div class="line">	<span class="number">0x0000</span>, <span class="number">0x4400</span>, <span class="number">0x2200</span>, <span class="number">0x6600</span>,</div><div class="line">	<span class="number">0x1100</span>, <span class="number">0x5500</span>, <span class="number">0x3300</span>, <span class="number">0x7700</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">attribute_punch</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> *cnt)</span> &#123;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">0</span>; <span class="comment">// value</span></div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> state = A_NORM; <span class="comment">// current state</span></div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> temp = <span class="number">0x0000</span>, attribute = <span class="number">0x0000</span>; <span class="comment">// temp attribute, current attribute</span></div><div class="line"></div><div class="line">	<span class="keyword">switch</span>(state) &#123; <span class="comment">// state machine</span></div><div class="line">		<span class="keyword">case</span> A_NORM:</div><div class="line">			<span class="keyword">if</span> (ch == <span class="number">0x1B</span>) &#123; <span class="comment">// [ESC]</span></div><div class="line">				state = A_TRANS; <span class="comment">// transfer from A_NORM to A_TRANS</span></div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				cputchar((attribute &amp; <span class="number">0xFF00</span>) | ch); <span class="comment">// put character with attribute</span></div><div class="line">				*cnt++;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> A_TRANS:</div><div class="line">			<span class="keyword">if</span> (ch == <span class="string">'['</span>) &#123; <span class="comment">// [</span></div><div class="line">				state = A_ESCAPE; <span class="comment">// transfer from A_TRANS to A_ESCAPE</span></div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				state = A_NORM; <span class="comment">// transfer from A_TRANS to A_NORM</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> A_ESCAPE:</div><div class="line">			<span class="keyword">if</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123; <span class="comment">// digit - update value</span></div><div class="line">				value = value * <span class="number">10</span> + ch - <span class="string">'0'</span>;</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">';'</span> || ch == <span class="string">'m'</span>) &#123; <span class="comment">// ; or m set temp and clear value</span></div><div class="line">				<span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</div><div class="line">					temp  = colormap[<span class="number">0</span>];</div><div class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == <span class="number">5</span>) &#123;</div><div class="line">					temp |= <span class="number">0x8000</span>;</div><div class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="number">30</span> &amp;&amp; value &lt;= <span class="number">38</span>) &#123;</div><div class="line">					temp |= colormap[value - <span class="number">30</span>] &amp; <span class="number">0x0700</span>; <span class="comment">// look up in color map</span></div><div class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="number">40</span> &amp;&amp; value &lt;= <span class="number">48</span>) &#123;</div><div class="line">					temp |= colormap[value - <span class="number">40</span>] &amp; <span class="number">0x7000</span>; <span class="comment">// avoid complex cases</span></div><div class="line">				&#125;</div><div class="line">				value = <span class="number">0</span>;</div><div class="line">				<span class="keyword">if</span> (ch == <span class="string">'m'</span>) &#123; <span class="comment">// m needed extra work - update attribute</span></div><div class="line">					attribute = temp;</div><div class="line">					temp = <span class="number">0x0000</span>;</div><div class="line">					state = A_NORM; <span class="comment">// transfer from A_ESCAPE to A_NORM</span></div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// non_digit nor m</span></div><div class="line">				state = A_NORM; <span class="comment">// transfer from A_ESCAPE to A_NORM</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">vcprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="comment">// vprintfmt((void*)putch, &amp;cnt, fmt, ap);</span></div><div class="line">	<span class="comment">// use attribute_punch rather than punch</span></div><div class="line">	vprintfmt((<span class="keyword">void</span> *)attribute_punch, &amp;cnt, fmt, ap);</div><div class="line">	<span class="keyword">return</span> cnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们在monitor.c中添加相关cprintf代码，并重新编译测试。最终如图所示：</p>
<img src="/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/lab1_final.png" alt="lab1_final.png" title="">
<p>有关于实验指导中提到的打开vga硬件的graphics mode使得控制台绘制文本到图形帧缓冲区的实现，由于时间和难度原因，这里暂时跳过。</p>
<h2 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h2><p>第一个实验总体来说更偏重于概念的理解、工具的使用而不是实际的代码。</p>
<p>尽管如此，大量的概念也浪费了我很多时间去理解。MIT的6.828同清华的ucore操作系统实验相比提供了相当多的reference（ucore的阅读材料几乎都是现成的），这也对文档阅读和信息检索能力有了更高的要求。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/12/12/OSTEP学习笔记1/">
                            OSTEP学习笔记1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-12-12T22:54:45+08:00">
	
		    12月 12, 2016
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <blockquote>
<p>最近开始看Operating Systems: Three Easy Pieces这本书，感觉光看书还是不够，还是需要将学习到的东西整理和归纳，以加深自己对于操作系统的理解。</p>
</blockquote>
<h2 id="CPU的虚拟化"><a href="#CPU的虚拟化" class="headerlink" title="CPU的虚拟化"></a>CPU的虚拟化</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程(Process)是操作系统对于一个正在运行的程序的抽象</p>
<h4 id="进程API"><a href="#进程API" class="headerlink" title="进程API"></a>进程API</h4><p>大体上可以分为创建(Create)，销毁(Destroy)，等待(Wait)，杂项控制(Miscellaneous Control)包括挂起等以及状态查询(Status)。</p>
<h5 id="Unix下的进程API"><a href="#Unix下的进程API" class="headerlink" title="Unix下的进程API"></a>Unix下的进程API</h5><p>fork() wait() 以及 exec()</p>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>进程的状态大体上可以分为运行(Running)，就绪(Ready)以及阻塞(Blocked)。</p>
<ul>
<li>运行(Running)，进程正在被处理器运行，这意味着，处理器正在执行指令。</li>
<li>就绪(Ready)，进程已经准备好去运行，但是出于某种原因，操作系统决定不在当前的时刻运行该进程。</li>
<li>阻塞(Blocked)，在阻塞状态，进程已经执行了某种其他的操作以至于在该操作完成前该进程不能就绪，如：进程对于磁盘的IO请求。</li>
</ul>
<h4 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a>进程表</h4><p>操作系统通常会使用进程表管理所有的进程，包括追踪每一个进程的寄存器，起始内存，内存大小，PID，父进程，已打开的文件，进程状态等。</p>
<h3 id="机制-Limited-Direct-Execution-LDE"><a href="#机制-Limited-Direct-Execution-LDE" class="headerlink" title="机制:Limited Direct Execution(LDE)"></a>机制:Limited Direct Execution(LDE)</h3><p>直接执行即系统直接将进程运行在CPU上以最大化效率，限制即不能直接让进程取得对硬件以及系统所有的控制。</p>
<h4 id="限制操作"><a href="#限制操作" class="headerlink" title="限制操作"></a>限制操作</h4><p>当进程需要执行IO请求等限制操作时，不应该使得进程获得整个操作系统的控制权限。因此引入了Protected Control Transfer的概念。</p>
<h5 id="Protected-Control-Transfer"><a href="#Protected-Control-Transfer" class="headerlink" title="Protected Control Transfer"></a>Protected Control Transfer</h5><p>引入两种处理器模式：<strong>User Mode</strong>和<strong>Kernal Mode</strong></p>
<ul>
<li>User Mode - 在User Mode下，运行在该模式下的代码受到了严格的限制。比如，在该模式下，进程无法发起IO请求，并且也无法执行所有的限制指令。</li>
<li>Kernal Mode - 在Kernal Mode下，由操作系统执行指令，执行的指令没有任何限制，包括IO请求以及所有的限制指令都可以被执行。</li>
</ul>
<p><strong>System Call</strong> - 用户程序通过执行System Call去执行限制指令如访问文件系统，与其他进程通信或是分配内存。<br>为了执行System Call，用户程序需要执行一个特殊的Trap指令，Trap指令同时地跳转至内核并且提升至Kernal Mode，一旦进入了内核，系统就可以执行任何限制指令，并且完成调用进程需要完成的任务。完成后，系统调用一个特殊的Return-From-Trap指令，跳转回用户程序并且降低至User Mode。</p>
<blockquote>
<p>在执行Trap指令时，系统需要额外的开销以保证执行Return-From-Trap指令时跳转正确，例如，在x86下，系统会将PC及其他几个寄存器存入每个进程的内核栈。</p>
</blockquote>
<p>此外，内核需要在引导时建立<strong>Trap Table</strong>以保证用户程序程序执行Trap指令后能跳转至对应的指令。操作系统通知硬件<strong>Trap Handlers</strong>的位置，通知之后，直到下次引导之前，硬件都会知道对应handlers的位置，这样，当System Call或是其他异常被抛出时，硬件能对应作出正确的反应。</p>
<blockquote>
<p>显然，建立Trap Table的指令也是限制指令。</p>
</blockquote>
<h4 id="进程间切换"><a href="#进程间切换" class="headerlink" title="进程间切换"></a>进程间切换</h4><p>进程的切换需要操作系统的介入，但是当用户程序在CPU上执行时，操作系统并不在运行，那么，操作系统要如何重新获得对CPU的控制呢？</p>
<h5 id="合作方法：等待System-Calls"><a href="#合作方法：等待System-Calls" class="headerlink" title="合作方法：等待System Calls"></a>合作方法：等待System Calls</h5><p>在这种方法下，操作系统相信系统进程能正确的执行，长时间运行的进程理应周期性的放弃CPU，从而操作系统能决定运行其他的任务。</p>
<p>大多数进程通过发起System Calls的方法转移CPU的控制权 - 在发起System Call，执行了Trap指令后，操作系统就获得了CPU的控制权。</p>
<blockquote>
<p>那么，当程序错误的执行死循环之后，操作系统还能拿到CPU的控制权吗？</p>
</blockquote>
<h5 id="非合作方法：系统直接控制CPU"><a href="#非合作方法：系统直接控制CPU" class="headerlink" title="非合作方法：系统直接控制CPU"></a>非合作方法：系统直接控制CPU</h5><p><strong>Timer Interrupt</strong> - 通过对定时器装置编程使得其每隔特定的时间（通常是毫秒级）发起中断。在这种情况下，当前执行的进程会被停止，并且操作系统中一个预先配置的<strong>Interrupt Handler</strong>会被执行，这样，操作系统就重新取得了对CPU的控制。</p>
<h5 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h5><p>通常，当系统决定切换进程时，操作系统会执行一段底层代码(<strong>Context Switch</strong>)。从概念上来说，Context Switch会保存当前进程的若干寄存器的值，并且恢复待执行的进程的寄存器的值（例如，从内核栈中），这样，当Return-From-Trap指令执行时，系统得以恢复另一个进程的运行。</p>
<p>在Timer Interrupt的LDE Protocal中（例如），存在着两种类型的寄存器保存／恢复，在中断产生时，由硬件隐式的将寄存器的值存入当前进程的内核栈中，而在操作系统决定从当前进程切换至待执行进程时，由软件（操作系统）显式的将当前进程的寄存器的值（如PC，栈指针）存入当前进程的进程结构中（例如，进程控制块），并且从带切换进程的进程结构中恢复对应寄存器的值，这样，当执行Return-From-Trap指令后，由硬件隐式的从切换进程的内核栈中恢复寄存器的值，就好像刚才的Trap是由切换后进程执行的一样。</p>
<h4 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h4><blockquote>
<p>如果当一个System Call被发起时，发生了一个Timer Interrupt怎么办？</p>
</blockquote>
<p>简单的做法是，在处理中断时，禁止其他中断的传入。更加复杂的机制留至并发行部分讨论。</p>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><h5 id="负载假设"><a href="#负载假设" class="headerlink" title="负载假设"></a>负载假设</h5><p>将正在运行在系统上的进程称为负载。为了简化调度过程，首先做出如下的假设：</p>
<ul>
<li>每一个任务(<strong>Job</strong>)运行同样的时间</li>
<li>所有的任务都在同样的时间到达</li>
<li>所有的任务都仅使用CPU(不执行I/O)</li>
<li>每一个任务的运行时间都已知</li>
</ul>
<p>我们会在稍后的讨论中放宽这些限制</p>
<h5 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a>调度指标</h5><p>我们用调度指标衡量调度器的好坏，我们将使用以下两个指标：</p>
<ul>
<li>周转时间(<strong>Turnaround Time</strong>) 周转时间是指完成时间与到达时间的差，周转时间是衡量性能性能的指标。</li>
<li>响应时间(<strong>Response Time</strong>) 响应时间是指任务第一次运行的时间与到达时间的差，响应时间是衡量公平性的指标。</li>
</ul>
<h4 id="先进先出-First-In-First-Out"><a href="#先进先出-First-In-First-Out" class="headerlink" title="先进先出(First In First Out)"></a>先进先出(First In First Out)</h4><p>该调度方法有时又被称作<strong>先到先得</strong>(<strong>First Come First Served</strong>)，即先到达的方法先被CPU运行。</p>
<p>假设有3个任务，每个任务都运行10s，那么它们的平均周转时间为(10+20+30)/3=20s<br>下面我们放宽假设1，即现在每一个任务运行的时间不必相同。</p>
<p>同样地，假设有3个任务，A运行100s而B和C运行10s，如果A先运行，然后运行B，最后运行C，那么现在的平均周转时间为(100+110+120)/3=110s，这就是<strong>护送效应</strong>(<strong>Convoy Effect</strong>)，即由于A的运行时间过长，而导致运行时间较短的B和C需要等待较长的时间。</p>
<p>提出如下的新规则——</p>
<h4 id="最短任务优先-Shortest-Job-First"><a href="#最短任务优先-Shortest-Job-First" class="headerlink" title="最短任务优先(Shortest Job First)"></a>最短任务优先(Shortest Job First)</h4><p>为此，我们提出一种新的规则称为最短任务优先，该规则同样易于理解，即首先执行最短的任务，然后次短的任务，以此类推。</p>
<p>同样地假设A、B、C三个任务，其中A运行100s，而B和C运行10s，在SJF下，系统会先运行B和C，再运行A，平均周转时间为(10+20+120)/3=50s，远好于FIFO下相同假设的结果。</p>
<p>下面我们放宽假设2，即每一个任务有可能在任意时间到达。</p>
<p>假设A、B、C三个任务，其中A运行100s，在0s时到达，B和C运行10s，在10s时到达，在SJF下，平均周转时间为(100+(110-10)+(120-10))/3=103.33s，这是我们不愿意看到的结果，我们仍然需要改进调度算法——</p>
<h4 id="最短完成时间优先-Shortest-Time-to-Completion-First"><a href="#最短完成时间优先-Shortest-Time-to-Completion-First" class="headerlink" title="最短完成时间优先(Shortest Time-to-Completion First)"></a>最短完成时间优先(Shortest Time-to-Completion First)</h4><p>SJF是一种<strong>非抢占</strong>(<strong>Non-preemptive</strong>)的调度器，而STCF是一种允许抢占的调度器，在上述的例子中，当B或者C到达时，调度器允许B或者C抢占A——即操作系统从任务A切换至任务B或者任务C（通过上下文切换），从而达到提升性能的目的。</p>
<p>在上例中，若采用STCF，平均周转时间为((120-0)+(20-10)+(30-10))/3=50s，远好于103.33s这一结果。</p>
<p>事实上，如果任务长度已知，任务仅使用CPU资源，且周转时间是唯一指标的话，STCF是最佳的调度算法，下面我们来讨论另一个指标——响应时间。</p>
<p>考虑到响应时间，上述的算法表现都不尽如人意，在上例中，用户要至少要等待10s才能得到任务C的响应，而这显然是对于交互不友好的，我们需要引入新的调度算法来解决这个问题——</p>
<h4 id="轮循-Round-Robin"><a href="#轮循-Round-Robin" class="headerlink" title="轮循(Round Robin)"></a>轮循(Round Robin)</h4><p>轮循的基本思想按照<strong>时间分片</strong>(<strong>Time Slice</strong>)或者说<strong>调度量子</strong>(<strong>Scheduling Quantum</strong>)来循环执行任务而不是运行任务直到完成。</p>
<p>假设有A、B、C三个任务，它们同时到达系统而且均运行5s，假设时间分片为1s，在这种情况下，操作系统首先运行A，1s后切换到B，B运行1s后再切换到C，然后再循环回A。这样，平均响应时间为(0+1+2)/3=1s；而在SJF下，平均响应时间为(0+5+10)/3=5s。</p>
<blockquote>
<p>需要权衡时间分片的大小，如果时间分片过小，那么操作系统执行上下文切换的开销会显著增加。</p>
</blockquote>
<p>在RR下，平均周转时间会变得非常糟糕。事实上，公平性和性能在调度中是矛盾的，任何注重公平性的调度算法（即拥有良好的响应时间）在性能上（即周转时间）都会表现的很差。这是固有的权衡，<strong>鱼和熊掌不可兼得</strong>。</p>
<h4 id="合并I-O"><a href="#合并I-O" class="headerlink" title="合并I/O"></a>合并I/O</h4><p>接下来我们放宽假设3，即任务除了使用CPU外，还可能执行I/O请求，在发起了I/O请求后，任务将不会使用CPU，并且将处于阻塞的状态以等待I/O完成。</p>
<p>调度器需要决定I/O请求启动时是否切换至另一个任务，以及I/O完成时是执行当前任务还是切换回之前阻塞的任务。</p>
<p>假设我们正试图建立一个STCF调度器，假设A和B两个任务均运行50ms，并且A每10ms会发起一个花费10ms的I/O请求。在这种情况下，通常的解决方法是将A划分为5个独立的子任务，这样，当A发起I/O请求并且阻塞之后，B就可以被执行，而当I/O完成后，新的A的子任务会抢占B而继续执行。</p>
<p>上述的做法允许了<strong>重叠</strong>(<strong>Overlap</strong>)的发生，系统得以更好的利用处理器资源。</p>
<h4 id="多级反馈队列-Multi-Level-Feedback-Queue"><a href="#多级反馈队列-Multi-Level-Feedback-Queue" class="headerlink" title="多级反馈队列(Multi-Level Feedback Queue)"></a>多级反馈队列(Multi-Level Feedback Queue)</h4><p>最后，我们将放宽限制4，即系统不知道每个任务的运行时间。在这种情况下，我们将引入最有名的调度器之一——多级反馈队列来解决该问题。多级反馈队列试图在提升性能（即缩短平均周转时间）的同时最小化任务的响应时间。首先，我们将介绍有关多级反馈队列的最基本的概念。</p>
<h5 id="MLFQ-基本规则"><a href="#MLFQ-基本规则" class="headerlink" title="MLFQ:基本规则"></a>MLFQ:基本规则</h5><p>多级反馈队列(MLFQ)具有一系列相互独立的<strong>队列</strong>(<strong>Queue</strong>)，每一个队列都对应着不同的<strong>优先级</strong>(<strong>Priority Level</strong>)，在同一时间，一个任务只会处在一个队列中。</p>
<p>MLFQ根据优先级决定运行哪一个任务：即具有更高优先级的任务会被运行。</p>
<p>同时，考虑到可能会有多个任务处于同一个队列，即有可能出现相同优先级的情况，在这种情况下，MLFQ以轮循的方式运行这些任务。</p>
<p>因此我们得到了如下的基本规则：</p>
<ul>
<li>如果A的优先级大于B的优先级，运行A(B不运行)</li>
<li>如果A和B的优先级相同，以轮循的方式运行A和B</li>
</ul>
<p>假设两个任务A和B，A和B位于最高的优先级，而C和D位于次高的优先级，那么我们会发现，A和B会一直被运行，而C和D将永远无法被运行。</p>
<h5 id="尝试1-如何改变优先级"><a href="#尝试1-如何改变优先级" class="headerlink" title="尝试1:如何改变优先级"></a>尝试1:如何改变优先级</h5><p>MLFQ依据已经观察到的结果确定一个任务的优先级：如果一个任务在一个相当长的周期内一直在使用CPU，那么MLFQ会降低它的优先级，如果一个任务周期性的放弃CPU而等待用户的输入，那么MLFQ会维持它的优先级，因为这样的任务是一个活跃的任务。</p>
<p>因此我们得到了如下的规则：</p>
<ul>
<li>当一个任务进入系统时，它将会被放置在优先级最高的队列</li>
<li>a如果一个任务在运行中占用了一个完整的时间分片，那么它的优先级会被降低</li>
<li>b如果一个任务在时间分片用完前放弃了CPU，那么它的优先级维持不变</li>
</ul>
<p>在上述的规则中，我们考虑如下的两个问题：</p>
<ul>
<li>如果有太多的活跃任务，那么他们会占用所有的CPU时间，那么，长时间运行的任务将永远不会得到任何的CPU时间。</li>
<li>程序可以以在时间分片用完前“故意”地放弃CPU以欺骗操作系统而使得其保持高优先级</li>
</ul>
<h5 id="尝试2-优先级提高"><a href="#尝试2-优先级提高" class="headerlink" title="尝试2:优先级提高"></a>尝试2:优先级提高</h5><p>我们引入如下的规则来解决上面提到的问题1：</p>
<ul>
<li>在某个时间周期S之后，将系统中所有的任务提升至优先级最高的队列</li>
</ul>
<p>通过该规则，过多的活跃进程并不会完全占用CPU的时间，此外，当一个程序从不活跃转变为活跃时也能够及时得得到响应的CPU时间。</p>
<h5 id="尝试3-更好的计量"><a href="#尝试3-更好的计量" class="headerlink" title="尝试3:更好的计量"></a>尝试3:更好的计量</h5><p>我们引入如下的规则来解决上面提到的问题2:</p>
<ul>
<li>一旦某个任务用完了在给定优先级下的分配时间，无论它已经放弃了多少次CPU，降低它的优先级。</li>
</ul>
<p>这么做避免了一个任务欺骗操作系统，避免了其通过不公正的手段分享CPU的时间。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2016/12/12/OSTEP学习笔记1/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 页 共 1 页</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 CoSidian. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">CoSidian</h4>
        
            <div id="about-card-bio"><p>码龙黑曜 - iOS开发者/计算机科学/兽人控</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>本科在读</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                HUST, Wuhan, China
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-i7zzex3jvqnxdf0lp2pg3bcyurjikigtrw9ljle5skc4mit2m7a13rwuyp8g.min.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
