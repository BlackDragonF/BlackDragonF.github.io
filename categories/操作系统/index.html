
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="码龙的窝">
    <title>分类: 操作系统 - 码龙的窝</title>
    <meta name="author" content="CoSidian">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="/* 0与1之风吹遍山谷 */">
<meta property="og:type" content="blog">
<meta property="og:title" content="码龙的窝">
<meta property="og:url" content="http://blog.codedragon.tech/categories/操作系统/index.html">
<meta property="og:site_name" content="码龙的窝">
<meta property="og:description" content="/* 0与1之风吹遍山谷 */">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="码龙的窝">
<meta name="twitter:description" content="/* 0与1之风吹遍山谷 */">
    
    
        
    
    
        <meta property="og:image" content="http://blog.codedragon.tech/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-gtvt1lbvzeqmr99zec4y42qrxw5ogq1gul5orw7somyh6cv5ckqsrl4abr9a.min.css">
    <!--STYLES END-->
    
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-108458894-1', 'auto');
        ga('send', 'pageview');
    </script>


    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">码龙的窝</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">CoSidian</h4>
                
                    <h5 class="sidebar-profile-bio"><p>码龙黑曜 - iOS开发者/计算机科学/兽人控</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="首页"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="分类"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="标签"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="归档"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/projects"
                            
                            title="项目"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-code" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">项目</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/about"
                            
                            title="关于"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/BlackDragonF" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://t.me/Cosidian" target="_blank" rel="noopener" title="Telegram">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-paper-plane" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Telegram</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://steamcommunity.com/id/BlackDragonF/" target="_blank" rel="noopener" title="Steam">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-steam" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Steam</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:obsidiandragon2016@gmail.com" target="_blank" rel="noopener" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/friendly-links"
                            
                            title="友情链接"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-link" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">友情链接</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/book-recommend"
                            
                            title="图书推荐"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-book" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">图书推荐</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/">
                            MIT6.828操作系统工程Lab4-Preemptive Multitasking实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-02-26T16:52:56+08:00">
	
		    2月 26, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <blockquote>
<p>Lab4 - Preemptive Multitasking需要在多个同时激活的用户模式环境中实现抢占式多任务。<br>实验分为三个部分。第一部分要求为JOS添加多处理器支持，并实现论询调度以及基本的环境管理系统调用；第二部分需要实现一个Unix-like的fork函数，使得用户环境可以创建一份自己的拷贝；第三部分需要实现进程间通讯功能，允许不同的用户环境显式地互相通信和同步。同时还需要实现对于硬件时钟中断和抢占的支持。<br>2018年3月2日，完成了实验并写完了报告。</p>
</blockquote>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p> 根据官网，切换到分支lab4并合并分支lab3。在合并的过程中，发生了冲突。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user% git checkout -b lab3 origin/lab3</div><div class="line">user% git merge lab3</div></pre></td></tr></table></figure>
<p> 根据提示，是<code>conf/lab.mk</code>中发生了冲突。打开后可以发现是其中记录的时间和实验数发生了变化，直接采用分支lab4的版本即可，然后提交，分支合并完成。</p>
<p> 实验四包括如下的新文件：</p>
<ul>
<li>kern/cpu.h 内核私有的关于多处理器的支持</li>
<li>kern/mpconfig.c 读取多处理器配置的代码</li>
<li>kern/lapic.c 内核驱动每个处理的的APIC（高级可编程中断控制器）的代码</li>
<li>kern/mpentry.S 非引导CPU的汇编入口代码</li>
<li>kern/spinlock.h 内核私有的自旋锁定义，包括大内核锁</li>
<li>kern/spinlock.c 内核实现自旋锁的代码</li>
<li>kern/sched.c 需要实现的调度器的代码框架</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="第一部分-Multiprocessor-Support-and-Cooperative-Multitasking-多处理器支和写作式多任务"><a href="#第一部分-Multiprocessor-Support-and-Cooperative-Multitasking-多处理器支和写作式多任务" class="headerlink" title="第一部分 Multiprocessor Support and Cooperative Multitasking - 多处理器支和写作式多任务"></a>第一部分 Multiprocessor Support and Cooperative Multitasking - 多处理器支和写作式多任务</h3><p>在第一部分中，需要使JOS运行在一个多处理器系统上，并且实现新的JOS内核系统调用去允许用户级别的环境创建额外的新环境。还需要实现协同式的论询调度，允许内核当旧的用户环境自愿放弃CPU或退出时切换至一个新的用户环境。</p>
<h4 id="多处理器支持"><a href="#多处理器支持" class="headerlink" title="多处理器支持"></a>多处理器支持</h4><p>需要使JOS支持“对称多处理”（Symmetric Multiprocessing），在该模型下，所有的CPU都有着对系统资源（内存、IO总线等）的平等访问权。尽管在SMP下所有的CPU在功能上均等价，在启动时仍然分为两种类型——引导处理器（Bootstrap Processor或是BSP）负责初始化系统并且引导操作系统；应用处理器（Application Processors或是APs）仅在系统启动运行后被BSP激活。BSP处理器由硬件和BIOS决定。在此刻，所有已有的代码已经运行在了BSP上。</p>
<p>在SMP中，每一个CPU都有一个相伴的本地APIC（LAPIC）单元。LAPIC单元负责在整个系统中传递中断。LAPIC为相连的CPU提供了一个唯一标识。在本实验中，将利用LAPIC的一下功能（在<code>kern/lapic.c</code>中）：</p>
<ul>
<li>读取LAPIC标识（APIC ID）以告知CPU代码运行在哪一个CPU上（参考<code>cpunum()</code>）</li>
<li>从BSP向APs发送STARTUP处理器间中断（Interprocessor interrupt或IPI）以唤醒其他CPU（参考<code>lapic_startup()</code>）</li>
<li>在第三部分中，通过编程LAPIC内置的计时器去引发时钟中断以实现抢占式多任务（参考<code>apic_init()</code></li>
</ul>
<p>处理器通过内存映射IO（Memory-mapped I/O 或是MMIO）访问LAPIC。在MMIO中，一部分物理内存被硬连接至某些IO设备的寄存器。所以相同的访问内存的<code>load/store</code>指令可以被用来访问设备寄存器。你可能已经见过了存在于物理地址<code>0xA0000</code>中IO洞（以此来写VGA显示缓存）。LAPIC存在于物理地址从<code>0xFE000000</code>（4064M）开始的洞中。该地址太高以至于无法在KERNBASE的直接映射访问。JOS的虚拟内存映射在<code>MMIOBASE</code>处留下了4MB的空隙。在之后的实验中会引入更多的<code>MMIO</code>区域，所以应当写一个简单的函数从该区域分配空间并映射内存。</p>
<p>练习1的答案如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In kern/pmap.c, mmio_map_region():</span></div><div class="line"><span class="comment">// Your code here:</span></div><div class="line">size = ROUNDUP(size, PGSIZE);</div><div class="line"><span class="keyword">if</span> (base + size &gt; MMIOLIM) &#123;</div><div class="line">    <span class="comment">// reservation overflog MMIOLIM</span></div><div class="line">    panic(<span class="string">"reservation bytes overflows!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// use boot_map_region to map [pa, pa + size) to [base, base + size)</span></div><div class="line">boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_PWT);</div><div class="line"></div><div class="line"><span class="comment">// update base and return</span></div><div class="line"><span class="keyword">uintptr_t</span> saved_base = base;</div><div class="line">base += size;</div><div class="line"><span class="keyword">return</span> (<span class="keyword">char</span> *)saved_base;</div><div class="line"></div><div class="line"><span class="comment">// panic("mmio_map_region not implemented");</span></div></pre></td></tr></table></figure></p>
<h5 id="应用处理器引导"><a href="#应用处理器引导" class="headerlink" title="应用处理器引导"></a>应用处理器引导</h5><p>BSP在引导APs之前应当首先收集多处理器系统的信息，如总CPU数，APIC IDs以及LAPIC单元的内存映射IO地址等。<code>kern/mpconfig.c</code>中的<code>mp_init()</code>函数通过读取BIOS内存中的MP配置表获取相应的信息。<br>在<code>kern/init.c</code>中的<code>boot_aps()</code>函数驱动AP引导过程。APs在实模式中启动，所以<code>boot_aps()</code>从<code>kern/mpentry.S</code>中拷贝AP入口代码到一个实模式可寻址的位置。可以在一定程度上控制AP执行开始代码的位置。在本实验中，将入口代码拷贝至<code>0x7000</code>（MPENTRY_PADDR），但实际上任何640KB以下的、页对齐的和未使用的物理地址均可使用。<br>然后，<code>boot_aps()</code>通过向对应AP的LAPIC单元发送STARTUP处理器间中断和初始的CS:IP地址（本实验中为MPENTRY_PADDR），依次激活APs。在简单的设置后，将AP启动分页，使得AP进入保护模式，然后调用启动例程<code>mp_main()</code>（在<code>kern/init.c</code>中。<code>boot_aps()</code>在唤醒下一个AP之前先等待当前AP在<code>struct CpuInfo</code>的<code>cpu_status</code>域中发送一个<code>CPU_STARTED</code>标记。<br>AP引导的汇编代码和C代码同实验一BSP的引导代码相似，可以比对异同。</p>
<p>练习2的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In kern/pmap.c, page_init():</span></div><div class="line"><span class="comment">// code MODIFIED</span></div><div class="line"><span class="keyword">size_t</span> i;</div><div class="line"></div><div class="line"><span class="comment">// initialize from page 1 to page npages_basemem - 1</span></div><div class="line"><span class="comment">// set pp_ref to 0, set pp_link to last page_free_list</span></div><div class="line"><span class="comment">// and then update page_free_list</span></div><div class="line"></div><div class="line"><span class="comment">// Lab 4: remove page at MPENTRY_PADDR</span></div><div class="line"><span class="keyword">size_t</span> mp_entry_page = PGNUM(MPENTRY_PADDR);</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; npages_basemem ; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (i == mp_entry_page) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    pages[i].pp_ref = <span class="number">0</span>;</div><div class="line">    pages[i].pp_link = page_free_list;</div><div class="line">    page_free_list = &amp;pages[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>问题1：<br>宏<code>MPBOOTPHYS</code>作用是将给定的内核虚拟地址（在<code>mpentry.S</code>中）转换成相应的加载后的物理地址。这么做的原因是在<code>mpentry.S</code>中，保护模式与分页机制尚未开启，设置分段等需要知道相应的物理地址。</p>
<h5 id="每CPU状态和初始化"><a href="#每CPU状态和初始化" class="headerlink" title="每CPU状态和初始化"></a>每CPU状态和初始化</h5><p>当编写多处理器操作系统时，区分对于每个处理器而言私有的每CPU状态以及整个系统共享的全局状态是很重要的。<code>kern/cpu.h</code>定义了大部分每CPU状态，包括了存储了每CPU变量的<code>struct CpuInfo</code>。<code>cpunum()</code>总是返回调用它的CPU ID，能用来索引例如<code>cpus</code>的数组。宏<code>thiscpu</code>是当前CPU的<code>struct CpuInfo</code>的简写。</p>
<p>以下是你需要注意的每CPU状态：</p>
<ul>
<li>每CPU内核栈 - 多个CPU可能会同时陷入内核，因此每个处理器需要独立的内核栈以避免互相干扰。<code>percpu_kstacks[NCPU][KSTKSIZE]</code>为<code>NCPU</code>个内核栈预留空间。在实验二中，将<code>bootstack</code>指向的物理内存作为BSP的栈映射在了KSTACKTOP下面。相似地，本实验中，需要将每个CPU的内核栈映射到该区域同时分配保护页作为它们之间的缓冲。CPU 0的栈将从KSTACKTOP开始向下增长；CPU 1的栈将从CPU 0栈下方间隔KSTKGAP处开始增长。<code>inc/memlayout.h</code>展示了映射约束。</li>
<li>每CPU的TSS和TSS描述符 - 每CPU的任务状态段同样用来致命每个CPU内核栈的位置。CPU i的TSS被存储于<code>cpus[i].cpu_ts</code>中，相应的TSS描述符在GDT入口<code>gdt[(GD_TSS0 &gt;&gt; 3) + i]</code>处被定义。<code>kern/trap.c</code>中定义的<code>ts</code>将不再有效。</li>
<li>每CPU的当前环境指针 - 由于每个CPU都能同步地执行不同的用户环境。重新将<code>curenv</code>定义为指向当前CPU（当前代码正在执行的CPU）正在执行的环境的<code>cpus[cpunum()].cpu_env</code>（或是<code>thiscpu-&gt;cpu_env</code>）。</li>
<li>每CPU的系统寄存器 - 包括系统寄存器在内的所有寄存器都属于CPU私有。因此初始化这些寄存器的指令如<code>lcr3</code>, <code>ltr</code>, ‘lgdt’等，必须在每个CPU上都被执行。函数<code>env_init_percpu()</code>以及<code>trap_init_percpu</code>正是为此而被定义。</li>
</ul>
<p>除此之外任何额外的用来CPU初始化的所有每CPU状态都应该在每个CPU处重复。</p>
<p>练习3中遇到的问题：</p>
<ul>
<li>在使用boot_map_region映射内存时忘记将kstacktop_i减去KSTKSIZE，导致未通过检查</li>
</ul>
<p>练习3的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LAB 4: Your code here:</span></div><div class="line"><span class="keyword">size_t</span> i;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</div><div class="line">    <span class="comment">// traverser through 0 to NCPU to use boot_map_region to map</span></div><div class="line">    <span class="comment">// per-CPU's kernel stack to corresponding va</span></div><div class="line">    <span class="keyword">uintptr_t</span> kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);</div><div class="line">    boot_map_region(kern_pgdir, kstacktop_i - KSTKSIZE, KSTKSIZE,</div><div class="line">                    PADDR(percpu_kstacks[i]), PTE_W | PTE_P);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>练习4中遇到的问题：</p>
<ul>
<li>使用ltr加载任务段选择子时，每个CPU应当使用不同的选择子，<code>inc/memlayout.c</code>中的GD_TSS0为CPU0的任务段选择子，应该加上i &lt;&lt; 3的偏移</li>
<li>完成<code>trap_init_percpu()</code>后，旧的使用<code>ts</code>的代码应当被注释</li>
</ul>
<p>练习4的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LAB 4: Your code here:</span></div><div class="line"><span class="comment">// trap_init_percpu() is called by all CPUs</span></div><div class="line"><span class="comment">// set esp0 and ss0 of task state segment to provide</span></div><div class="line"><span class="comment">// per-CPU's kernel stack access</span></div><div class="line">thiscpu-&gt;cpu_ts.ts_esp0 = (<span class="keyword">uintptr_t</span>)percpu_kstacks[cpunum()];</div><div class="line">thiscpu-&gt;cpu_ts.ts_ss0  = GD_KD;</div><div class="line"><span class="comment">// set IO map base address to prevent unauthorized environments</span></div><div class="line"><span class="comment">// this line works together as we'll set TSS segment limit later</span></div><div class="line"><span class="comment">// so all ports in address space have no corresponding IOPB</span></div><div class="line">thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</div><div class="line"></div><div class="line"><span class="comment">// set TSS in gdt</span></div><div class="line"><span class="comment">// 0 means RPL and sd_s = 0 means system segment</span></div><div class="line">gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>)(&amp;(thiscpu-&gt;cpu_ts)),</div><div class="line">                                       <span class="keyword">sizeof</span>(struct Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpunum()].sd_s = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// Load TSS selector</span></div><div class="line">ltr(GD_TSS0 + (cpunum() &lt;&lt; <span class="number">3</span>));</div><div class="line"></div><div class="line"><span class="comment">// load the IDT</span></div><div class="line">lidt(&amp;idt_pd);</div></pre></td></tr></table></figure></p>
<h5 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h5><p>当前的代码在<code>mp_main()</code>中初始化完AP之后忙等待。在继续下一步之前，首先得解决多个CPU同时执行内核代码时的竞争条件。最简答的方式是使用一个“大”内核锁，大内核锁在从用户模式进入内核模式时被获取，在从环境返回用户模式时被释放。在这种模型下，用户模式环境可以在任意多个CPU上运行，但同时只能有一个环境能在内核中运行，其他想在内核中运行的环境被强制等待。</p>
<p><code>kern/spinlock.h</code>声明了内核锁，同时提供了<code>lock_kernel</code>提供加锁的功能；<code>unlock_kernel</code>提供解锁的功能，你应当在如下4个地方应用内核锁：</p>
<ul>
<li>在<code>i386_init()</code>中，在BSP唤醒其他CPU之前加锁</li>
<li>在<code>mp_main()</code>中，在初始化AP后加锁，然后调用<code>sched_yield()</code>去在当前AP上执行环境</li>
<li>在<code>trap()</code>中，当从用户模式陷入的时候加锁，通过检查tf_cs的低位判断陷阱发生于用户模式还是内核模式</li>
<li>在<code>env_run()</code>中，在“刚好”切换回用户模式之前解锁。太早或太晚解锁会导致严重的竞争和死锁</li>
</ul>
<p>练习5的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In i386_init():</span></div><div class="line"><span class="comment">// Acquire the big kernel lock before waking up APs</span></div><div class="line"><span class="comment">// Your code here:</span></div><div class="line">lock_kernel();</div><div class="line"></div><div class="line"><span class="comment">// In mp_main():</span></div><div class="line"><span class="comment">// Now that we have finished some basic setup, call sched_yield()</span></div><div class="line"><span class="comment">// to start running processes on this CPU.  But make sure that</span></div><div class="line"><span class="comment">// only one CPU can enter the scheduler at a time!</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Your code here:</span></div><div class="line"><span class="comment">// lock the kernel and start running enviroments</span></div><div class="line">lock_kernel();</div><div class="line">sched_yield();</div><div class="line"></div><div class="line"><span class="comment">// In trap():</span></div><div class="line"><span class="comment">// Trapped from user mode.</span></div><div class="line"><span class="comment">// Acquire the big kernel lock before doing any</span></div><div class="line"><span class="comment">// serious kernel work.</span></div><div class="line"><span class="comment">// LAB 4: Your code here.</span></div><div class="line">lock_kernel();</div><div class="line"></div><div class="line"><span class="comment">// In env_run():</span></div><div class="line"><span class="comment">// address space switch</span></div><div class="line"><span class="comment">// reference from inc/x86.h</span></div><div class="line">lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line"><span class="comment">// release kernel lock here</span></div><div class="line">unlock_kernel(); <span class="comment">// newly added code</span></div><div class="line"><span class="comment">// drop into user mode</span></div><div class="line">env_pop_tf(&amp;(e-&gt;env_tf));</div></pre></td></tr></table></figure></p>
<p>问题2：<br>即使受到内核锁的保护，CPU之间仍然需要独立的内核栈。假设CPU0因中断陷入内核并在内核栈中保留了相关的信息，此时若CPU1也发生中断而陷入内核，在同一个内核栈的情况下，CPU0中的信息将会被覆盖从而导致出现错误。</p>
<h4 id="论询调度"><a href="#论询调度" class="headerlink" title="论询调度"></a>论询调度</h4><p>下一个任务是改变JOS内核使得其能按照“论询”的方式在多个环境中切换。在JOS中，论询调度按如下方式工作：</p>
<ul>
<li>‘kern/sched.c’中的<code>sched_yield()</code>负责选择一个新环境执行。其循环按顺序遍历<code>envs</code>数组，从上一次运行的环境（如果没有之前运行的环境，则从第一个环境）开始，找到第一个具有状态ENV_RUNNABLE的环境，调用<code>env_run()</code>执行。</li>
<li><code>sched_yield()</code>绝对不能同时在两个CPU上运行相同的环境。其会告知环境当前已经正在运行在某CPU上（很可能是当前环境），因为该环境的状态将为ENV_RUNNING。</li>
<li>将实现一个新的系统调用<code>sys_yield()</code>，用户环境可以通过该系统调用唤醒<code>sched_yield()</code>函数以主动放弃CPU。</li>
</ul>
<p>练习6中遇到的问题：</p>
<ul>
<li>在实现<code>sched_yield()</code>的时候没有检查<code>thiscpu-&gt;cpu_env</code>是否为空，对空指针的访问导致了缺页错误</li>
<li>一开始的实现弄错了获取env_index和自增的顺序，参考代码中第一个<code>if</code>处的<code>else</code>分支的注释</li>
<li>练习6结束后需要将<code>init.c</code>中<code>mp_main()</code>的最后一行注释</li>
</ul>
<p>练习6的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In kern/sched.c, sched_yield():</span></div><div class="line"><span class="comment">// LAB 4: Your code here.</span></div><div class="line"><span class="comment">// get index from current CPU's env</span></div><div class="line"><span class="keyword">size_t</span> env_index;</div><div class="line"><span class="comment">// set curenv_flag to default true</span></div><div class="line"><span class="keyword">int</span> curenv_flag = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="keyword">size_t</span> i;</div><div class="line"><span class="keyword">if</span> (thiscpu-&gt;cpu_env == <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="comment">// no previous running environment</span></div><div class="line">    <span class="comment">// start at beginning of envs array</span></div><div class="line">    i         = <span class="number">0</span>;</div><div class="line">    env_index = NENV - <span class="number">1</span>;</div><div class="line">    <span class="comment">// mark curenv_flag as true</span></div><div class="line">    curenv_flag = <span class="literal">false</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// start at previous running environment</span></div><div class="line">    env_index = ENVX(thiscpu-&gt;cpu_env-&gt;env_id);</div><div class="line">    <span class="comment">// NB: don't mess with code order here, must first retrieve</span></div><div class="line">    <span class="comment">// env_index then increment</span></div><div class="line">    i = (env_index == NENV - <span class="number">1</span>) ? <span class="number">0</span> : env_index + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// traverse through envs list to find first ENV_RUNNABLE</span></div><div class="line"><span class="comment">// env</span></div><div class="line"><span class="keyword">for</span> (; i != env_index; i = ((i == NENV - <span class="number">1</span>) ? <span class="number">0</span> : i + <span class="number">1</span>)) &#123;</div><div class="line">    <span class="keyword">if</span> (envs[i].env_status == ENV_RUNNABLE) &#123;</div><div class="line">        <span class="comment">// found, set idle and break from loop</span></div><div class="line">        idle = &amp;envs[i];</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// if idle is NULL and curenv_flag is true,</span></div><div class="line"><span class="comment">// means no envs are runnable and last previous running env is ENV_RUNNING</span></div><div class="line"><span class="comment">// check if last previous environment is ENV_RUNNING,</span></div><div class="line"><span class="comment">// if so, choose it.</span></div><div class="line"><span class="keyword">if</span> (!idle &amp;&amp; curenv_flag &amp;&amp; envs[env_index].env_status == ENV_RUNNING) &#123;</div><div class="line">    idle = &amp;envs[env_index];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (idle) &#123;</div><div class="line">    <span class="comment">// idle env choosed, run it directly</span></div><div class="line">    env_run(idle);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// failed to choose idle env, halt CPU</span></div><div class="line">    <span class="comment">// sched_halt never returns</span></div><div class="line">    sched_halt();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In kern/syscall.c, syscall():</span></div><div class="line"><span class="comment">// code added:</span></div><div class="line"><span class="keyword">case</span> SYS_yield:</div><div class="line">    <span class="comment">// call sys_yield</span></div><div class="line">    sys_yield();</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line"><span class="comment">// In kern/init.c, i386_init():</span></div><div class="line"><span class="comment">// code modified:</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(TEST)</span></div><div class="line">    <span class="comment">// Don't touch -- used by grading script!</span></div><div class="line">    ENV_CREATE(TEST, ENV_TYPE_USER);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="comment">// Touch all you want.</span></div><div class="line">    <span class="comment">// create three user_yield</span></div><div class="line">    <span class="comment">// code MODIFIED here</span></div><div class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</div><div class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</div><div class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>    <span class="comment">// TEST*</span></span></div></pre></td></tr></table></figure></p>
<p>问题3：<br>地址切换前后的页表中，<code>e</code>指向的虚拟地址都被同一块物理页映射。出现这种情况的原因在于<code>env</code>的<code>env_pgdir</code>是以<code>kern_pgdir</code>为原型产生的，<code>e</code>出于UTOP之上的地址，而UTOP以上的地址的映射关系在两个页表中是一样的。</p>
<p>问题4：<br>当发生地址转换时一定是从用户陷入内核之后，无论以何种方式陷入内核，必须要经过<code>kern/trap.c</code>中的<code>trap()</code>函数。观察该函数，可以发现，当从用户模式陷入内核时，代码将内核栈中的<code>tf</code>（包括页表和寄存器等）拷贝至内核间共享的对应的<code>env</code>中，所以之后寄存器状态才能恢复。</p>
<h4 id="环境创建的系统调用"><a href="#环境创建的系统调用" class="headerlink" title="环境创建的系统调用"></a>环境创建的系统调用</h4><p>尽管内核已经可以运行并在不同环境间切换了，但内核任然被限制了只能执行内核初始设置的用户环境。<br>需要实现必要的系统调用使得JOS可以允许用户环境创建和启动其他的用户环境。</p>
<p>Unix提供了<code>fork()</code>作为它的进程创建原语。Unix的<code>fork()</code>拷贝调用进程（父进程）的整个地址空间以创建子进程。<br>从用户空间来看，父子进程唯一可观察的差异就是它们的进程ID和父进程ID（通过<code>gitpid()</code>和<code>getppid()</code>返回。在父进程中，<code>fork()</code>返回子进程ID；在子进程中，<code>fork()</code>返回0。默认情况下，每个进程均获得其私有的地址空间，并且任意一个进程对于内存的修改对于其他进程都是不可见的。</p>
<p>将要实现一个不同的、更加原始的JOS系统调用原语集合去创建新的用户模式环境，通过这些系统调用，除了其他类型的环境创建以外，将能够在用户空间实现一个完整的类Unix<code>fork()</code>系统调用。需要实现的系统调用为：</p>
<ul>
<li><code>sys_exofork</code> - 创建一个几乎空白的新环境：在地址空间没有任何的用户映射，并且也无法运行。新环境将会有和父环境在执行<code>sys_exofork</code>系统调用时完全一致的寄存器状态。在父进程中，<code>sys_exofork</code>会返回新创建环境的<code>envid_t</code>（若环境创建错误则返回一个错误码）；子进程则会返回0（因为子进程最初被标记为不可运行，直到父进程通过显式标记子进程可运行之后，<code>sys_exofork</code>返回。</li>
<li><code>sys_env_set_status</code> - 设置指定的环境的状态为ENV_RUNNABLE或是ENV_NOT_RUNNABLE。该系统调用通常在一个新环境的地址空间和寄存器状态完全初始化之后标记其为可运行。</li>
<li><code>sys_page_alloc</code> - 分配一页的物理内存并将其映射到给定环境地址空间的给定虚拟地址。</li>
<li><code>sys_page_alloc</code> - 将一页映射（而不是实际的页内容）从一个环境的地址空间拷贝至另一个，共享内存使得新映射和旧映射指向同一页物理内存。</li>
<li><code>sys_page_unmap</code> - 将给定环境的给定虚拟地址的页面解除映射。</li>
</ul>
<p>上述所有的系统调用接受环境ID，内核支持将0到“当前环境”转换，在<code>kern/env.c</code>中的<code>envid2env()</code>实现。</p>
<p>已经在<code>user/dumpfork.c</code>中提供了非常原始的类Unix的<code>fork()</code>实现。测试程序用上述系统调用创建并运行一个当前地址空间拷贝的子进程，然后两个环境使用<code>sys_yield()</code>来回切换。父进程在10次迭代后退出；子进程在20次迭代后退出。</p>
<p>练习7的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In sys_exofork():</span></div><div class="line"><span class="comment">// Allocate a new environment.</span></div><div class="line"><span class="comment">// Returns envid of new environment, or &lt; 0 on error.  Errors are:</span></div><div class="line"><span class="comment">//  -E_NO_FREE_ENV if no free environment is available.</span></div><div class="line"><span class="comment">//  -E_NO_MEM on memory exhaustion.</span></div><div class="line"><span class="function"><span class="keyword">static</span> envid_t <span class="title">sys_exofork</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="comment">// Create the new environment with env_alloc(), from kern/env.c.</span></div><div class="line">    <span class="comment">// It should be left as env_alloc created it, except that</span></div><div class="line">    <span class="comment">// status is set to ENV_NOT_RUNNABLE, and the register set is copied</span></div><div class="line">    <span class="comment">// from the current environment -- but tweaked so sys_exofork</span></div><div class="line">    <span class="comment">// will appear to return 0.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// get env_id of current environment</span></div><div class="line">    <span class="keyword">envid_t</span> parent_id = thiscpu-&gt;cpu_env-&gt;env_id;</div><div class="line"></div><div class="line">    <span class="comment">// use env_alloc to create new environment and</span></div><div class="line">    <span class="comment">// do some basic setup(status and register set)</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span> = <span class="title">NULL</span>;</span></div><div class="line">    <span class="keyword">if</span> (env_alloc(&amp;env, parent_id) &lt; <span class="number">0</span>) &#123; panic(<span class="string">"sys_exofork failed!"</span>); &#125;</div><div class="line">    env-&gt;env_status = ENV_NOT_RUNNABLE;</div><div class="line">    env-&gt;env_tf     = thiscpu-&gt;cpu_env-&gt;env_tf;</div><div class="line"></div><div class="line">    <span class="comment">// do the trick to set eax register of newly</span></div><div class="line">    <span class="comment">// alloc environment to 0</span></div><div class="line">    env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// return new environment's ID</span></div><div class="line">    <span class="keyword">return</span> env-&gt;env_id;</div><div class="line"></div><div class="line">    <span class="comment">// panic("sys_exofork not implemented");</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In sys_env_set_status():</span></div><div class="line"><span class="comment">// Set envid's env_status to status, which must be ENV_RUNNABLE</span></div><div class="line"><span class="comment">// or ENV_NOT_RUNNABLE.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></div><div class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist,</span></div><div class="line"><span class="comment">//		or the caller doesn't have permission to change envid.</span></div><div class="line"><span class="comment">//  -E_INVAL if status is not a valid status for an environment.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_env_set_status</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status)</span> </span>&#123;</div><div class="line">    <span class="comment">// Hint: Use the 'envid2env' function from kern/env.c to translate an</span></div><div class="line">    <span class="comment">// envid to a struct Env.</span></div><div class="line">    <span class="comment">// You should set envid2env's third argument to 1, which will</span></div><div class="line">    <span class="comment">// check whether the current environment has permission to set</span></div><div class="line">    <span class="comment">// envid's status.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// check status passed in</span></div><div class="line">    <span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) &#123;</div><div class="line">        <span class="comment">// invalid status</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></div><div class="line">    <span class="comment">// call envid2env to translate envid passed in</span></div><div class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">true</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// bad environment</span></div><div class="line">        <span class="keyword">return</span> -E_BAD_ENV;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// set status</span></div><div class="line">    env-&gt;env_status = status;</div><div class="line"></div><div class="line">    <span class="comment">// panic("sys_env_set_status not implemented");</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In sys_page_alloc():</span></div><div class="line"><span class="comment">// Allocate a page of memory and map it at 'va' with permission</span></div><div class="line"><span class="comment">// 'perm' in the address space of 'envid'.</span></div><div class="line"><span class="comment">// The page's contents are set to 0.</span></div><div class="line"><span class="comment">// If a page is already mapped at 'va', that page is unmapped as a</span></div><div class="line"><span class="comment">// side effect.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set,</span></div><div class="line"><span class="comment">//         but no other bits may be set.  See PTE_SYSCALL in inc/mmu.h.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></div><div class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist,</span></div><div class="line"><span class="comment">//      or the caller doesn't have permission to change envid.</span></div><div class="line"><span class="comment">//  -E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></div><div class="line"><span class="comment">//  -E_INVAL if perm is inappropriate (see above).</span></div><div class="line"><span class="comment">//  -E_NO_MEM if there's no memory to allocate the new page,</span></div><div class="line"><span class="comment">//      or to allocate any necessary page tables.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_page_alloc</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span> </span>&#123;</div><div class="line">    <span class="comment">// Hint: This function is a wrapper around page_alloc() and</span></div><div class="line">    <span class="comment">//   page_insert() from kern/pmap.c.</span></div><div class="line">    <span class="comment">//   Most of the new code you write should be to check the</span></div><div class="line">    <span class="comment">//   parameters for correctness.</span></div><div class="line">    <span class="comment">//   If page_insert() fails, remember to free the page you</span></div><div class="line">    <span class="comment">//   allocated!</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></div><div class="line">    <span class="comment">// check and get env</span></div><div class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">true</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// envid not exist or permission error</span></div><div class="line">        <span class="keyword">return</span> -E_BAD_ENV;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// check va</span></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= UTOP || PGOFF(va) != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// va above UTOP or va is not page-aligned</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// check perm</span></div><div class="line">    <span class="keyword">if</span> ((perm &amp; (~PTE_SYSCALL)) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P)) &#123;</div><div class="line">        <span class="comment">// invalid perm</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// allocate page and then insert it</span></div><div class="line">    <span class="comment">// check if out of memory</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span>;</span></div><div class="line">    <span class="keyword">if</span> ((page = page_alloc(ALLOC_ZERO)) == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="comment">// failed to allocate page</span></div><div class="line">        <span class="keyword">return</span> -E_NO_MEM;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (page_insert(env-&gt;env_pgdir, page, va, perm) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// page table couldn't be allocated</span></div><div class="line">        <span class="comment">// free ununsed page</span></div><div class="line">        page_free(page);</div><div class="line">        <span class="keyword">return</span> -E_NO_MEM;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// panic("sys_page_alloc not implemented");</span></div><div class="line"></div><div class="line">    <span class="comment">// page successfully allocated</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In sys_page_map():</span></div><div class="line"><span class="comment">// Map the page of memory at 'srcva' in srcenvid's address space</span></div><div class="line"><span class="comment">// at 'dstva' in dstenvid's address space with permission 'perm'.</span></div><div class="line"><span class="comment">// Perm has the same restrictions as in sys_page_alloc, except</span></div><div class="line"><span class="comment">// that it also must not grant write access to a read-only</span></div><div class="line"><span class="comment">// page.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></div><div class="line"><span class="comment">//  -E_BAD_ENV if srcenvid and/or dstenvid doesn't currently exist,</span></div><div class="line"><span class="comment">//      or the caller doesn't have permission to change one of them.</span></div><div class="line"><span class="comment">//  -E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,</span></div><div class="line"><span class="comment">//      or dstva &gt;= UTOP or dstva is not page-aligned.</span></div><div class="line"><span class="comment">//  -E_INVAL is srcva is not mapped in srcenvid's address space.</span></div><div class="line"><span class="comment">//  -E_INVAL if perm is inappropriate (see sys_page_alloc).</span></div><div class="line"><span class="comment">//  -E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid's</span></div><div class="line"><span class="comment">//      address space.</span></div><div class="line"><span class="comment">//  -E_NO_MEM if there's no memory to allocate any necessary page tables.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_page_map</span><span class="params">(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva, <span class="keyword">envid_t</span> dstenvid,</span></span></div><div class="line">                        <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm) &#123;</div><div class="line">    <span class="comment">// Hint: This function is a wrapper around page_lookup() and</span></div><div class="line">    <span class="comment">//   page_insert() from kern/pmap.c.</span></div><div class="line">    <span class="comment">//   Again, most of the new code you write should be to check the</span></div><div class="line">    <span class="comment">//   parameters for correctness.</span></div><div class="line">    <span class="comment">//   Use the third argument to page_lookup() to</span></div><div class="line">    <span class="comment">//   check the current permissions on the page.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srcenv</span>, *<span class="title">dstenv</span>;</span></div><div class="line">    <span class="comment">// check environment</span></div><div class="line">    <span class="keyword">if</span> ((envid2env(srcenvid, &amp;srcenv, <span class="literal">true</span>) &lt; <span class="number">0</span>) ||</div><div class="line">        (envid2env(dstenvid, &amp;dstenv, <span class="literal">true</span>) &lt; <span class="number">0</span>)) &#123;</div><div class="line">        <span class="comment">// srcenvid or dstenvid doesn't exist or</span></div><div class="line">        <span class="comment">// caller doesn't have permissions</span></div><div class="line">        <span class="keyword">return</span> -E_BAD_ENV;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// check srcva and dstva about address and page-aligned</span></div><div class="line">    <span class="comment">// get srcenv and dstenv</span></div><div class="line">    <span class="keyword">if</span> (((<span class="keyword">uintptr_t</span>)srcva &gt;= UTOP) || ((<span class="keyword">uintptr_t</span>)dstva &gt;= UTOP) ||</div><div class="line">        (PGOFF(srcva) != <span class="number">0</span>) || (PGOFF(dstva) != <span class="number">0</span>)) &#123;</div><div class="line">        <span class="comment">// addresses above UTOP or addresses not page_aligned</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">srcpage</span>;</span></div><div class="line">    <span class="keyword">pte_t</span> *          scrpte_ptr;</div><div class="line">    <span class="comment">// use page look up to get source page and corresponding pte_t *</span></div><div class="line">    <span class="keyword">if</span> ((srcpage = page_lookup(srcenv-&gt;env_pgdir, srcva, &amp;scrpte_ptr)) ==</div><div class="line">        <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="comment">// srcva not mapped in srcenvid's address space</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// check perm passed in</span></div><div class="line">    <span class="keyword">if</span> ((perm &amp; (~PTE_SYSCALL)) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P)) &#123;</div><div class="line">        <span class="comment">// invalid perm</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// check if srcva is writable if perm has PTE_W</span></div><div class="line">    <span class="keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; (!((*scrpte_ptr) &amp; PTE_W))) &#123;</div><div class="line">        <span class="comment">// perm has PTE_W while srcva ISN'T writable</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// insert source page into dstenv's pgdir with perm</span></div><div class="line">    <span class="comment">// check if out of memory</span></div><div class="line">    <span class="keyword">if</span> (page_insert(dstenv-&gt;env_pgdir, srcpage, dstva, perm) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// out of memory to allocate page table</span></div><div class="line">        <span class="keyword">return</span> -E_NO_MEM;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// panic("sys_page_map not implemented");</span></div><div class="line"></div><div class="line">    <span class="comment">// page successfully mapped</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In sys_page_unmap():</span></div><div class="line"><span class="comment">// Unmap the page of memory at 'va' in the address space of 'envid'.</span></div><div class="line"><span class="comment">// If no page is mapped, the function silently succeeds.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></div><div class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist,</span></div><div class="line"><span class="comment">//      or the caller doesn't have permission to change envid.</span></div><div class="line"><span class="comment">//  -E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_page_unmap</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va)</span> </span>&#123;</div><div class="line">    <span class="comment">// Hint: This function is a wrapper around page_remove().</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></div><div class="line">    <span class="comment">// check and get env</span></div><div class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">true</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// envid not exist or permission error</span></div><div class="line">        <span class="keyword">return</span> -E_BAD_ENV;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// check va</span></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= UTOP || PGOFF(va) != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// va above UTOP or va is not page-aligned</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// call page_remove to unmap page</span></div><div class="line">    page_remove(env-&gt;env_pgdir, va);</div><div class="line"></div><div class="line">    <span class="comment">// panic("sys_page_unmap not implemented");</span></div><div class="line"></div><div class="line">    <span class="comment">// page successfully unmapped</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In syscall():</span></div><div class="line"><span class="comment">// new code added</span></div><div class="line"><span class="keyword">case</span> SYS_exofork:</div><div class="line">    <span class="comment">// call sys_exofork</span></div><div class="line">    <span class="keyword">return</span> sys_exofork();</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> SYS_env_set_status:</div><div class="line">    <span class="comment">// call sys_env_set_status</span></div><div class="line">    <span class="keyword">return</span> sys_env_set_status((<span class="keyword">envid_t</span>)a1, (<span class="keyword">int</span>)a2);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> SYS_page_alloc:</div><div class="line">    <span class="comment">// call sys_page_alloc</span></div><div class="line">    <span class="keyword">return</span> sys_page_alloc((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2, (<span class="keyword">int</span>)a3);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> SYS_page_map:</div><div class="line">    <span class="comment">// call sys_page_map</span></div><div class="line">    <span class="keyword">return</span> sys_page_map((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2, (<span class="keyword">envid_t</span>)a3, (<span class="keyword">void</span> *)a4,</div><div class="line">                        (<span class="keyword">int</span>)a5);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> SYS_page_unmap:</div><div class="line">    <span class="comment">// call sys_page_unmap</span></div><div class="line">    <span class="keyword">return</span> sys_page_unmap((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2);</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<h3 id="第二部分-Copy-on-Write-Fork-写时复制Fork"><a href="#第二部分-Copy-on-Write-Fork-写时复制Fork" class="headerlink" title="第二部分 Copy-on-Write Fork - 写时复制Fork"></a>第二部分 Copy-on-Write Fork - 写时复制Fork</h3><p>Unix提供了一个<code>fork()</code>系统调用作为其原始的进程创建原语。<code>fork()</code>系统调用将调用进程的整个地址空间拷贝以创建子进程。</p>
<p>xv6通过将父进程页中的所有数据复制到子进程中的新页中来实现<code>fork()</code>，这本质上就是<code>dumbfowk()</code>采用的方法。对于父进程地址空间的拷贝是整个<code>fork()</code>操作中最“贵”的部分。</p>
<p>然而，对于fork()的调用通常紧跟着一个对子进程的<code>exec()</code>系统调用，该系统调用用一个新程序替换子进程的内存，这就是一个典型的shell所做的。在这种情况下，花费的用于复制父进程的地址空间的时间是被浪费的，因为子进程在调用<code>exec()</code>前只会使用很少的内存。</p>
<p>出于以上的原因，Unix之后的版本利用了虚拟内存硬件去允许父进程和子进程共享映射到各自地址空间的内存，直到其中一个进程实际修改为止。该技术又被称作写时复制。<br>为了实现写时复制，在<code>fork()</code>中内核仅仅从父进程拷贝地址的映射而非实际映射的页面到子进程，并且在同时将共享的页面标记为只读。<br>当两个进程之一尝试写入其中一个共享页面时，该过程触发页面错误。<br>内核意识到该页面实际上是一个“虚拟”或是“写时复制”页面，所以其会创建一个错误页面的新的，私有的，可写的页副本。<br>通过这种方式，直到实际写入时，独立页面的内容才被复制。<br>该过程使得紧接着<code>exec()</code>的<code>fork()</code>调用更加节约：子进程在调用<code>exec()</code>很可能只会复制一页（栈的当前页）。</p>
<p>本实验的下一个部分要求完成一个合适的类Unix的<code>fork()</code>的写时复制的实现（作为用户空间库例程）。在用户空间实现<code>fork()</code>并且支持写时复制使得内核能保留相对简洁，因此更不容易出现严重的错误。这同样可以允许独立的用户模式程序实现自己的<code>fork()</code>语义。</p>
<h4 id="用户级别的页错误处理"><a href="#用户级别的页错误处理" class="headerlink" title="用户级别的页错误处理"></a>用户级别的页错误处理</h4><p>用户级别的写时复制<code>fork()</code>实现需要知道写保护页面的页错误。写时复制只是用户级别的页错误处理的诸多可能用处之一。</p>
<p>通常的做法是设置一个地址空间以便页错误指示何时需要采取某些行动。大多数Unix内核通常只会为新进程的栈区域分配一页，随着进程栈逐渐增长直至访问到了还未被映射的栈地址，触发页错误，然后内核会“按需”分配更多的栈页面。<br>典型的Unix内核必须追踪进程的空间中的不同区域发生页错误时所采取的行动。栈区域的页错误通常会导致新页的分配和映射。BSS区域的页错误通常会导致分配一个新页，填充0，并映射。对于具有按需分页的可执行文件的系统，text段的页错误会导致内核从磁盘上的二进制文件读取相应的页面并映射。</p>
<p>内核需要追踪大量的信息。与传统的Unix方法不同，本实验需要用户决定如何处理用户空间中的每个页面错误，而这些错误的损害通常不大。这种设计还为程序定义存储区域带来了极大的灵活性。之后将会应用用户级别的错误处理程序来映射和访问基于磁盘的文件系统上的文件。</p>
<h5 id="设置页错误处理程序"><a href="#设置页错误处理程序" class="headerlink" title="设置页错误处理程序"></a>设置页错误处理程序</h5><p>为了处理用户环境自己的页错误，用户环境必须向JOS内核注册一个页错误处理程序入口。用户环境通过<code>sys_env_set_pgfault_upcall()</code>的“上行”系统调用注册自己的错误处理程序入口。已经向<code>struct Env</code>添加了新的域<code>env_pgfault_upcall</code>来记录该信息。</p>
<p>练习8的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In sys_env_set_pgfault_upcall():</span></div><div class="line"><span class="comment">// Set the page fault upcall for 'envid' by modifying the corresponding struct</span></div><div class="line"><span class="comment">// Env's 'env_pgfault_upcall' field.  When 'envid' causes a page fault, the</span></div><div class="line"><span class="comment">// kernel will push a fault record onto the exception stack, then branch to</span></div><div class="line"><span class="comment">// 'func'.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></div><div class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist,</span></div><div class="line"><span class="comment">//      or the caller doesn't have permission to change envid.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_env_set_pgfault_upcall</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *func)</span> </span>&#123;</div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></div><div class="line">    <span class="comment">// check and translate the envid</span></div><div class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">true</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// envid not exist or permission error</span></div><div class="line">        <span class="keyword">return</span> -E_BAD_ENV;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// set func</span></div><div class="line">    env-&gt;env_pgfault_upcall = func;</div><div class="line"></div><div class="line">    <span class="comment">// panic("sys_env_set_pgfault_upcall not implemented");</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In syscall():</span></div><div class="line"><span class="comment">// new code added</span></div><div class="line"><span class="keyword">case</span> SYS_env_set_pgfault_upcall:</div><div class="line">    <span class="comment">// call sys_env_set_pgfault_upcall</span></div><div class="line">    <span class="keyword">return</span> sys_env_set_pgfault_upcall((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2);</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<h5 id="用户环境中的正常栈和异常栈"><a href="#用户环境中的正常栈和异常栈" class="headerlink" title="用户环境中的正常栈和异常栈"></a>用户环境中的正常栈和异常栈</h5><p>在正常执行时，JOS中的用户环境会在正常栈中执行：正常栈的ESP寄存器指向USTACKTOP，并且压入的栈数据会存放于USTACKTOP - PGSIZE到USTACKTOP - 1的闭区域。<br>然而，当一个页错误在用户模式发生时，内核将重启用户环境，在一个另外的栈上运行一个特定的用户级别的页错误处理程序，该栈被称为用户异常栈。<br>实际上，将使JOS代表用户环境自动执行“栈切换”，就像x86处理器在用户模式转换到内核模式时已经代表JOS实现了栈切换一样。</p>
<p>JOS用户异常栈的大小也为一个页面大，栈顶被定义为指向虚拟地址UXSTACKTOP，用户异常栈的有效字节为UXSTACKTOP - PGSIZE到UXSTACKTOP - 1的闭区域。<br>当运行于异常栈上时，用户级别的页错误处理程序可以使用JOS的常规系统调用映射新的页或是调整页映射以修复任何可能导致页错误的问题。<br>然后用户级别的页错误处理程序通过汇编语言存根返回至原始栈上的错误代码处。</p>
<p>每一个想要支持用户级别页错误处理程序的用户环境需要自己为其异常栈通过<code>sys_page_alloc()</code>分配内存。</p>
<h5 id="唤醒用户页错误处理程序"><a href="#唤醒用户页错误处理程序" class="headerlink" title="唤醒用户页错误处理程序"></a>唤醒用户页错误处理程序</h5><p>现在需要改变<code>kern/trap.c</code>中的页错误处理程序按特定的方式处理用户模式的页错误。<br>将错误时的用户环境状态叫做陷阱时状态。</p>
<p>若是没有页面错误处理函数被注册，则JOS内核会和之前一样，摧毁用户环境并输出一条消息。否则，内核会在异常栈设置在<code>inc/trap.h</code>中如<code>struct UTrapFrame</code>定义的陷阱帧。</p>
<p>然后内核会安排用户环境以页错误处理程序以上述栈帧在异常栈上恢复执行。<code>fault_va</code>是导致也错误的虚拟地址。</p>
<p>如果当异常发生时用户环境已经在用户异常栈上运行，则错误处理程序自身发生了错误。在这种情况下，你应当在当前的<code>tf-&gt;tf_esp</code>中而非UXSTACKTOP中重新启动栈帧。你应当首先压入一个4字节的字，然后一个<code>struct UTrapFrame</code>。</p>
<p>检查tf-&gt;tf_esp是否在UXSTACKTOP - PGSIZE到UXSTACKTOP - 1的闭区间内来判断其是否已经在用户异常栈上。</p>
<p>练习9中遇到的问题：</p>
<ul>
<li><code>curenv</code>已经被重新定义为<code>thiscpu-&gt;cpu_env</code>，因此可以使用</li>
<li>判断tf-&gt;tf_esp的if语句中，将与写成了或</li>
</ul>
<p>练习9的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In trap.c, page_fault_handler():</span></div><div class="line"><span class="comment">// LAB 4: Your code here.</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> *<span class="title">utf</span>;</span></div><div class="line"><span class="keyword">uintptr_t</span>          utf_addr;</div><div class="line"></div><div class="line"><span class="comment">// check tf-&gt;tf_esp's location to calculate utf's address</span></div><div class="line"><span class="keyword">if</span> ((tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE) &amp;&amp; (tf-&gt;tf_esp &lt; UXSTACKTOP)) &#123;</div><div class="line">    <span class="comment">// recursive case</span></div><div class="line">    <span class="comment">// reason why here needs to substract a 4-byte word</span></div><div class="line">    <span class="comment">// is to reserve space for reset eip/esp</span></div><div class="line">    utf_addr = tf-&gt;tf_esp - <span class="keyword">sizeof</span>(struct UTrapframe) - <span class="number">4</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// non-recursive case, set utf_addr to the top of</span></div><div class="line">    <span class="comment">// user exception stack</span></div><div class="line">    utf_addr = UXSTACKTOP - <span class="keyword">sizeof</span>(struct UTrapframe);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (curenv-&gt;env_pgfault_upcall) &#123;</div><div class="line">    <span class="comment">// page fault upcall exist</span></div><div class="line"></div><div class="line">    <span class="comment">// use mem assert to check environment allocates the exception</span></div><div class="line">    <span class="comment">// stack and has write permission to it, and stack ISN'T overflow</span></div><div class="line">    <span class="comment">// combine three case with only one user_mem_assert to check utf_addr</span></div><div class="line">    <span class="comment">// NB: curenv HAS been redefined as thiscpu-&gt;cpu_env</span></div><div class="line">    user_mem_assert(curenv, (<span class="keyword">void</span> *)utf_addr, <span class="keyword">sizeof</span>(struct UTrapframe),</div><div class="line">                    PTE_U | PTE_W | PTE_P);</div><div class="line"></div><div class="line">    <span class="comment">// set user stack frame</span></div><div class="line">    utf               = (struct UTrapframe *)utf_addr;</div><div class="line">    utf-&gt;utf_fault_va = fault_va;</div><div class="line">    utf-&gt;utf_err      = tf-&gt;tf_err;</div><div class="line">    utf-&gt;utf_regs     = tf-&gt;tf_regs;</div><div class="line">    utf-&gt;utf_eip      = tf-&gt;tf_eip;</div><div class="line">    utf-&gt;utf_eflags   = tf-&gt;tf_eflags;</div><div class="line">    utf-&gt;utf_esp      = tf-&gt;tf_esp;</div><div class="line"></div><div class="line">    <span class="comment">// modify stack frame to set entry for env_pgfault_upcall</span></div><div class="line">    <span class="comment">// and set address for user exception stack</span></div><div class="line">    tf-&gt;tf_eip = (<span class="keyword">uintptr_t</span>)curenv-&gt;env_pgfault_upcall;</div><div class="line">    tf-&gt;tf_esp = utf_addr;</div><div class="line"></div><div class="line">    env_run(curenv);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="用户模式页错误入口"><a href="#用户模式页错误入口" class="headerlink" title="用户模式页错误入口"></a>用户模式页错误入口</h5><p>然后需要实现汇编例程，该例程调用C页错误处理程序，然后在恢复在原始的错误指令处的执行。该例程就是被<code>sys_env_set_pgfault_upcall()</code>注册的例程。</p>
<p>最后需要在C用户库实现用户模式的页错误处理机制。</p>
<p>练习10中遇到的问题：</p>
<ul>
<li>需要想清楚思路，即先将eip“压入”陷阱时栈中，使用一个sub后接一个mov指令来模拟该压栈过程，若为递归过程，则会将eip填入之前留下的空白。然后依次恢复寄存器以及eflags。最后pop %esp以切换栈并调用ret返回</li>
</ul>
<p>练习10的代码如下，仅供参考：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// <span class="keyword">In</span> pfentry.S:</div><div class="line">// LAB <span class="number">4</span>: Your code here.</div><div class="line">// <span class="keyword">push</span> trap-time %eip to trap-time stack</div><div class="line">// <span class="keyword">mov</span> utf_eip to %eax</div><div class="line">movl <span class="number">0x28</span>(%esp), %eax</div><div class="line">// use <span class="keyword">sub</span> <span class="keyword">and</span> <span class="keyword">mov</span> to *simulate* <span class="keyword">push</span></div><div class="line">subl <span class="number">$0</span>x4, <span class="number">0x30</span>(%esp)</div><div class="line">movl <span class="number">0x30</span>(%esp), %ebp</div><div class="line">movl %eax, (%ebp)</div><div class="line">// <span class="keyword">pop</span> the unused fault_va <span class="keyword">and</span> err</div><div class="line">popl %eax</div><div class="line">popl %eax</div><div class="line"></div><div class="line">// Restore the trap-time registers.  After you <span class="built_in">do</span> this, you</div><div class="line">// can no longer modify any general-purpose registers.</div><div class="line">// LAB <span class="number">4</span>: Your code here.</div><div class="line">popal</div><div class="line"></div><div class="line">// Restore eflags from the stack.  After you <span class="built_in">do</span> this, you can</div><div class="line">// no longer use arithmetic operations <span class="keyword">or</span> anything else that</div><div class="line">// modifies eflags.</div><div class="line">// LAB <span class="number">4</span>: Your code here.</div><div class="line">addl <span class="number">$0</span>x4, %esp</div><div class="line">popfl</div><div class="line"></div><div class="line">// Switch back to the adjusted trap-time stack.</div><div class="line">// LAB <span class="number">4</span>: Your code here.</div><div class="line">popl %esp</div><div class="line"></div><div class="line">// Return to re-execute the instruction that faulted.</div><div class="line">// LAB <span class="number">4</span>: Your code here.</div><div class="line"><span class="keyword">ret</span></div></pre></td></tr></table></figure></p>
<p>练习11中遇到的问题：</p>
<ul>
<li>注意描述，要使用<code>_pgfault_upcall()</code>（汇编例程包装）来注册用户页处理函数而非传入的那个函数</li>
</ul>
<p>练习11的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In set_pgfault_handler():</span></div><div class="line"><span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// First time through!</span></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// alloc one page for user exception stack</span></div><div class="line">    <span class="comment">// and register user-level page fault upcall</span></div><div class="line">    <span class="keyword">if</span> (sys_page_alloc(thisenv-&gt;env_id, (<span class="keyword">void</span> *)(UXSTACKTOP - PGSIZE),</div><div class="line">                       PTE_U | PTE_W | PTE_P) &lt; <span class="number">0</span>) &#123;</div><div class="line">        panic(<span class="string">"failed to alloc page for user exception stack!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (sys_env_set_pgfault_upcall(thisenv-&gt;env_id, _pgfault_upcall) &lt; <span class="number">0</span>) &#123;</div><div class="line">        panic(<span class="string">"failed to register page fault upcall!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// panic("set_pgfault_handler not implemented");</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>faultalloc能成功而faultallocbad失败的原因在于faultallocbad直接使用系统调用输出，该输出会使用先使用内存检查而失败；而faultalloc使用了用户库中的<code>cprintf</code>，该函数在使用系统调用输出之前已经尝试对错误地址进行了解引用，触发了用户级别的缺页错误，在实际执行系统调用时，错误的地址已经被分配了页面，因此能通过内存检查。</p>
<h4 id="实现写时复制"><a href="#实现写时复制" class="headerlink" title="实现写时复制"></a>实现写时复制</h4><p>已经拥有了在用户空间中完整实现写时复制<code>fork()</code>的内核设施基础。</p>
<p>现在已经在<code>lib/fork.c</code>中给出了<code>fork()</code>的框架。同<code>dumbfork()</code>相似，<code>fork()</code>首先创建了一个新环境，然后扫描父进程的地址空间并在子进程中建立相同的页映射。核心区别在于<code>dumbfork()</code>复制页，而<code>fork()</code>只实现页映射的复制。<code>fork()</code>直到某环境尝试写时在复制对应的页。</p>
<p><code>fork()</code>的基本控制流为：</p>
<ol>
<li>父进程设置<code>pgfault()</code>作为C级别的页错误处理程序，使用实现了的<code>set_pgfault_handler()</code>函数</li>
<li>父进程调用<code>sys_exofork()</code>去创建子环境</li>
<li>对于地址空间中每一个在UTOP下的可写的或是写时复制的页面，父进程调用<code>duppage()</code>，该函数将该页面以写时复制映射进子进程然后在父进程的地址空间中重新映射该页面为写时复制（顺序很重要）。<code>duppage()</code>同时设置PTE，所以页面将不可写。通过avail域的PTE_COW区分写时复制页面和真正的只读页面。然而，异常栈却不按该方式重映射。需要为子进程分配一个新页面作为异常栈。由于页处理程序实际执行了页复制并且页处理程序运行于异常栈上，异常栈不能写时复制。<code>fork()</code>也需要处理存在但既不是写时复制也不是可写的页面。</li>
<li>父进程为子进程设置用户页错误入口。</li>
<li>子进程已经准备好运行了，有父进程将其标记为可运行。</li>
</ol>
<p>每一次环境尝试向一个还不可写的写时复制的页面写入时，将出现页错误，用户页错误处理程序的控制流为：</p>
<ol>
<li>内核将页错误传递给页错误上行调用，即调用了<code>fork()</code>的页错误处理程序。</li>
<li><code>pgfault()</code>检查错误为写入导致并且相应页面的PTE被标记为写时复制，否则使内核恐慌。</li>
<li><code>pgfault()</code>分配一个新的页面，映射至一个临时位置，然后复制错误页面的内容到新分配的页面，最后将新页面以读写权限映射到合适的地址，替代旧的只读页。</li>
</ol>
<p>用户级别的<code>lib/fork.c</code>代码必须查询环境的页表（如查询某页面的PTE被标记为写时复制）。内核将环境的页表映射在UVPT正是为了这个目的。内核通过将页目录的指针指向自己的映射技巧使得可以为用户代码快速查找PTEs，<code>lib/entry.S</code>已经设置了<code>uvpd</code>和<code>uvpd</code>，你可以快速在<code>lib/fork.c</code>中查找页表信息。</p>
<p>练习12中遇到的问题：</p>
<ul>
<li>注意在<code>pgfault()</code>和<code>duppage()</code>中，必须使用0而不是<code>thisenv-&gt;env_id</code>，原因已经在代码注释中标出</li>
<li>在<code>fork()</code>中需要显式地判断用户异常页并跳过<code>duppage()</code></li>
<li>阅读给出的uvpt技巧，需要在代码中使用</li>
<li>为了简化错误处理，避免重复代码，使用了<code>goto</code></li>
<li>假定先将父进程的用户栈标记为COW，然后再尝试将子进程的用户栈标记为COW之前，可能会出现父进程的用户栈已经被写入的情况而触发缺页错误，因此<code>fork()</code>会立刻分配新页，拷贝内容并重新映射。子进程被标记COW时复制的页映射已经不是原来的页映射了，因此，后来对父进程做的改动会反映在子进程上，这显然是错误的</li>
<li>fork后必须修改thisenv的值以保证用户程序行为正确</li>
</ul>
<p>练习12的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In lib/fork.c, fork():</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// User-level fork with copy-on-write.</span></div><div class="line"><span class="comment">// Set up our page fault handler appropriately.</span></div><div class="line"><span class="comment">// Create a child.</span></div><div class="line"><span class="comment">// Copy our address space and page fault handler setup to the child.</span></div><div class="line"><span class="comment">// Then mark the child as runnable and return.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Returns: child's envid to the parent, 0 to the child, &lt; 0 on error.</span></div><div class="line"><span class="comment">// It is also OK to panic on error.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Hint:</span></div><div class="line"><span class="comment">//   Use uvpd, uvpt, and duppage.</span></div><div class="line"><span class="comment">//   Remember to fix "thisenv" in the child process.</span></div><div class="line"><span class="comment">//   Neither user exception stack should ever be marked copy-on-write,</span></div><div class="line"><span class="comment">//   so you must allocate a new page for the child's user exception stack.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">envid_t</span> fork(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="keyword">int</span> r;</div><div class="line"></div><div class="line">    <span class="comment">// use set_pgfault_handler to install pgfault() as page fault handler</span></div><div class="line">    set_pgfault_handler(pgfault);</div><div class="line"></div><div class="line">    <span class="comment">// use system call to create new blank child environment</span></div><div class="line">    <span class="keyword">envid_t</span> child_env_id = sys_exofork();</div><div class="line">    <span class="keyword">if</span> (child_env_id == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// must update thisenv to make sure user program behave</span></div><div class="line">        <span class="comment">// normally</span></div><div class="line">        thisenv = envs + ENVX(sys_getenvid());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (child_env_id &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// error when create new environment, simply return</span></div><div class="line">        <span class="keyword">return</span> child_env_id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// traverse through parent's address space and use duppage</span></div><div class="line">    <span class="comment">// to copy address mappings</span></div><div class="line">    <span class="keyword">uintptr_t</span> addr;</div><div class="line">    <span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; UTOP; addr += PGSIZE) &#123;</div><div class="line">        <span class="keyword">if</span> ((((<span class="keyword">pde_t</span> *)uvpd)[PDX(addr)] &amp; PTE_P) &amp;&amp;</div><div class="line">            (((<span class="keyword">pte_t</span> *)uvpt)[PGNUM(addr)] &amp; PTE_P)) &#123;</div><div class="line">            <span class="comment">// if both page directory entry and page table entry</span></div><div class="line">            <span class="comment">// exist for one address(page-aligned), then call duppage</span></div><div class="line">            <span class="keyword">if</span> (addr == (UXSTACKTOP - PGSIZE)) &#123;</div><div class="line">                <span class="comment">// ignore user exception stack</span></div><div class="line">                <span class="comment">// for we will map a page for user exception later</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> ((r = duppage(child_env_id, PGNUM(addr))) &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// duppage failed</span></div><div class="line">                <span class="comment">// destroy child environment and return</span></div><div class="line">                <span class="keyword">goto</span> error_handle;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// child must have its own exception stack</span></div><div class="line">    <span class="comment">// so alloc page and map it for child here</span></div><div class="line">    <span class="keyword">if</span> ((r = sys_page_alloc(child_env_id, (<span class="keyword">void</span> *)(UXSTACKTOP - PGSIZE),</div><div class="line">                            PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// failed to set child environment's exception stack</span></div><div class="line">        <span class="comment">// destroy child environment and return</span></div><div class="line">        <span class="keyword">goto</span> error_handle;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// set child's page fault handler so that parent</span></div><div class="line">    <span class="comment">// and child looks the same</span></div><div class="line">    <span class="comment">// use sys_env_set_pgfault_upcall system call</span></div><div class="line">    <span class="keyword">extern</span> <span class="keyword">void</span> _pgfault_upcall(<span class="keyword">void</span>);</div><div class="line">    <span class="keyword">if</span> ((r = sys_env_set_pgfault_upcall(child_env_id, _pgfault_upcall)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// failed to set child's page fault upcall</span></div><div class="line">        <span class="comment">// destroy child environment and return</span></div><div class="line">        <span class="keyword">goto</span> error_handle;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// now child is ready to run, set child to ENV_RUNNABLE</span></div><div class="line">    <span class="comment">// use sys_env_set_status system call</span></div><div class="line">    <span class="keyword">if</span> ((r = sys_env_set_status(child_env_id, ENV_RUNNABLE)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// failed to change child environment's running status</span></div><div class="line">        <span class="comment">// destroy child environment and return</span></div><div class="line">        <span class="keyword">goto</span> error_handle;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// panic("fork not implemented");</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> child_env_id;</div><div class="line"></div><div class="line"><span class="comment">// use goto to avoid meaningless error_handle code</span></div><div class="line"><span class="comment">// copy and paste everywhere</span></div><div class="line">error_handle:</div><div class="line">    <span class="keyword">if</span> (sys_env_destroy(child_env_id) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// failed either, panic then</span></div><div class="line">        panic(<span class="string">"failed to destroy child environment!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> r;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In lib/fork.c, duppage():</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Map our virtual page pn (address pn*PGSIZE) into the target envid</span></div><div class="line"><span class="comment">// at the same virtual address.  If the page is writable or copy-on-write,</span></div><div class="line"><span class="comment">// the new mapping must be created copy-on-write, and then our mapping must be</span></div><div class="line"><span class="comment">// marked copy-on-write as well.  (Exercise: Why do we need to mark ours</span></div><div class="line"><span class="comment">// copy-on-write again if it was already copy-on-write at the beginning of</span></div><div class="line"><span class="comment">// this function?)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Returns: 0 on success, &lt; 0 on error.</span></div><div class="line"><span class="comment">// It is also OK to panic on error.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">duppage</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> r;</div><div class="line"></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="keyword">int</span> perm = PTE_P | PTE_U;</div><div class="line">    <span class="keyword">if</span> ((((<span class="keyword">pte_t</span> *)uvpt)[pn] &amp; (PTE_W | PTE_COW))) &#123;</div><div class="line">        <span class="comment">// check for writable or copy-on-write page</span></div><div class="line">        <span class="comment">// and add perm with PTE_COW</span></div><div class="line">        perm |= PTE_COW;</div><div class="line">        <span class="comment">// NB: we also use 0 to replace thisenv-&gt;env_id</span></div><div class="line">        <span class="comment">// for in unix-like fork() implementation, we will copy</span></div><div class="line">        <span class="comment">// address space from parent process to child process</span></div><div class="line">        <span class="comment">// at current time, thisenv-&gt;env_id IS ABSOLUTELY WRONG</span></div><div class="line"></div><div class="line">        <span class="comment">// map from parent environment to child environment</span></div><div class="line">        <span class="keyword">if</span> (sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)(pn * PGSIZE), envid, (<span class="keyword">void</span> *)(pn * PGSIZE),</div><div class="line">                         perm) &lt; <span class="number">0</span>) &#123;</div><div class="line">            panic(<span class="string">"failed to map page from parent to child!"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// remap parent's environment</span></div><div class="line">        <span class="keyword">if</span> (sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)(pn * PGSIZE), <span class="number">0</span>, (<span class="keyword">void</span> *)(pn * PGSIZE),</div><div class="line">                         perm) &lt; <span class="number">0</span>) &#123;</div><div class="line">            panic(<span class="string">"failed to remap page in parent!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// for other pages, simply map from</span></div><div class="line">        <span class="comment">// parent environment to child environment</span></div><div class="line">        <span class="keyword">if</span> (sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)(pn * PGSIZE), envid, (<span class="keyword">void</span> *)(pn * PGSIZE),</div><div class="line">                         perm) &lt; <span class="number">0</span>) &#123;</div><div class="line">            panic(<span class="string">"failed to map page from parent to child!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// panic("duppage not implemented");</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In lib/fork.c, pgfault():</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Custom page fault handler - if faulting page is copy-on-write,</span></div><div class="line"><span class="comment">// map in our own private writable copy.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pgfault</span><span class="params">(struct UTrapframe *utf)</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> *   addr = (<span class="keyword">void</span> *)utf-&gt;utf_fault_va;</div><div class="line">    <span class="keyword">uint32_t</span> err  = utf-&gt;utf_err;</div><div class="line">    <span class="keyword">int</span>      r;</div><div class="line"></div><div class="line">    <span class="comment">// Check that the faulting access was (1) a write, and (2) to a</span></div><div class="line">    <span class="comment">// copy-on-write page.  If not, panic.</span></div><div class="line">    <span class="comment">// Hint:</span></div><div class="line">    <span class="comment">//   Use the read-only page table mappings at uvpt</span></div><div class="line">    <span class="comment">//   (see &lt;inc/memlayout.h&gt;).</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// use uvpt to get PTE and check premissions</span></div><div class="line">    <span class="keyword">if</span> (!(err &amp; FEC_WR) || !(((<span class="keyword">pte_t</span> *)uvpt)[PGNUM(addr)] &amp; PTE_COW)) &#123;</div><div class="line">        panic(<span class="string">"fault isn't write or PTE is not marked as PTE_COW or both!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span></div><div class="line">    <span class="comment">// copy the data from the old page to the new page, then move the new</span></div><div class="line">    <span class="comment">// page to the old page's address.</span></div><div class="line">    <span class="comment">// Hint:</span></div><div class="line">    <span class="comment">//   You should make three system calls.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// allocate a page and map it at PFTEMP</span></div><div class="line">    <span class="comment">// use sys_page_alloc system call</span></div><div class="line">    <span class="comment">// NB: use 0 instead of thisenv-&gt;env_id</span></div><div class="line">    <span class="comment">// for normally when child environment scheduled by JOS</span></div><div class="line">    <span class="comment">// first it tries to store 0(return value of fork()) to</span></div><div class="line">    <span class="comment">// local variable child_env_id on the stack</span></div><div class="line">    <span class="comment">// which will take a page fault and kernel will trasfer control</span></div><div class="line">    <span class="comment">// to pgfault here</span></div><div class="line">    <span class="comment">// thisenv-&gt;env_id IS ABSOLUTELY WRONG here, so use 0</span></div><div class="line">    <span class="comment">// and let kernel convert from 0 to correct env_id</span></div><div class="line">    <span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, (<span class="keyword">void</span> *)PFTEMP, PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        panic(<span class="string">"failed to allocate page at temp location - %e, %x!"</span>, r,</div><div class="line">              thisenv-&gt;env_id);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    addr = ROUNDDOWN(addr, PGSIZE);</div><div class="line">    <span class="comment">// use memcpy to copy from fault address's page to PFTEMP's newly</span></div><div class="line">    <span class="comment">// allocated page</span></div><div class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)PFTEMP, addr, PGSIZE);</div><div class="line"></div><div class="line">    <span class="comment">// use sys_page_map system call to map newly allocated</span></div><div class="line">    <span class="comment">// page at PFTEMP at addr with read/write permissions</span></div><div class="line">    <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)PFTEMP, <span class="number">0</span>, addr, PTE_P | PTE_U | PTE_W)) &lt;</div><div class="line">        <span class="number">0</span>) &#123;</div><div class="line">        panic(<span class="string">"failed to map new page - %e!"</span>, r);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// use sys_page_unmap system call to unmap page at</span></div><div class="line">    <span class="comment">// temp location PFTEMP</span></div><div class="line">    <span class="keyword">if</span> ((r = sys_page_unmap(<span class="number">0</span>, (<span class="keyword">void</span> *)PFTEMP)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        panic(<span class="string">"failed to unmap page at PFTEMP - %e!"</span>, r);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// panic("pgfault not implemented");</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="第三部分-Preemptive-Multitasking-and-Inter-Process-communication-IPC-抢占式多任务和进程间通信"><a href="#第三部分-Preemptive-Multitasking-and-Inter-Process-communication-IPC-抢占式多任务和进程间通信" class="headerlink" title="第三部分 - Preemptive Multitasking and Inter-Process communication (IPC) 抢占式多任务和进程间通信"></a>第三部分 - Preemptive Multitasking and Inter-Process communication (IPC) 抢占式多任务和进程间通信</h3><p>最后一部分要求你修改内核，实现抢占式非协作环境以及允许环境显式传递信息。</p>
<h4 id="时钟中断和抢占"><a href="#时钟中断和抢占" class="headerlink" title="时钟中断和抢占"></a>时钟中断和抢占</h4><p>运行<code>user/spin</code>测试程序，该测试程序<code>fork</code>一个用户环境，生成的子环境一旦获得了CPU，就会执行一个无限循环，无论是父环境还是内核都无法重新获得CPU。<br>对于从错误和恶意代码中保护系统而言，这不是一个理想的情况，因为任何用户环境都可以通过一个无限循环以及永不放弃使得整个系统停机。为了允许内核抢占一个用户环境并强制从该环境处获取CPU的控制，需要扩展JOS内核以支持时钟硬件的外部硬件中断。</p>
<h5 id="中断规则"><a href="#中断规则" class="headerlink" title="中断规则"></a>中断规则</h5><p>外部中断（如设备中断）被称为IRQs（Interrupt request）。总共有16种可能的IRQs，分别从0编号到15。从IRQ号到IDT入口的映射并不固定。<code>picirq.c</code>中的<code>pic_init()</code>将IRQs从0到15映射到了IRQ_OFFSET到IRQ_OFFSET + 15。</p>
<p>在<code>inc/trap.h</code>中，IRQ_OFFSET被定义为32，因此IDT入口32-47对应于IRQ的0-15。例如，始终中断是IRQ 0。因此，IDT[IRQ_OFFSET + 0]包含了内核中时钟中断处理程序的地址。IRQ_OFFSET设置为32后，设备中断将不会和处理器异常号重叠。</p>
<p>同xv6 Unix相比，JOS内核提供了一个关键性简化。在内核中时，外部设备中断永远是被禁止的（但是在用户环境中是被允许的）。外部中断被%eflags寄存器的FL_IF标记控制。当该bit被设置时，外部中断被允许。尽管有若干种方式可以修改该bit位，将在进入和退出用户模式时通过保存和恢复%eflags寄存器的过程来处理它。</p>
<p>必须确保在用户环境中FL_IF标记被设置，这样当中断到达后，并且将中断传递给处理器，并由内核中的中断处理程序处理。否则中断会被屏蔽和忽略之道中断重新被允许。在引导程序的第一条指定就屏蔽了外部设备中断，并且直到目前为止，还没有重新启用。</p>
<p>练习13中遇到的问题：</p>
<ul>
<li>注意到简化规则要求中说明必须在陷入内核时将IF置0，所以必须修改之前的代码，将所有门都改为中断门</li>
</ul>
<p>练习13的代码如下，仅供参考：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// In kern/trapentry.S:</div><div class="line">// externel interrupts</div><div class="line">TRAPHANDLER_NOEC(irq_0_handler,  IRQ_OFFSET + 0);</div><div class="line">TRAPHANDLER_NOEC(irq_1_handler,  IRQ_OFFSET + 1);</div><div class="line">TRAPHANDLER_NOEC(irq_2_handler,  IRQ_OFFSET + 2);</div><div class="line">TRAPHANDLER_NOEC(irq_3_handler,  IRQ_OFFSET + 3);</div><div class="line">TRAPHANDLER_NOEC(irq_4_handler,  IRQ_OFFSET + 4);</div><div class="line">TRAPHANDLER_NOEC(irq_5_handler,  IRQ_OFFSET + 5);</div><div class="line">TRAPHANDLER_NOEC(irq_6_handler,  IRQ_OFFSET + 6);</div><div class="line">TRAPHANDLER_NOEC(irq_7_handler,  IRQ_OFFSET + 7);</div><div class="line">TRAPHANDLER_NOEC(irq_8_handler,  IRQ_OFFSET + 8);</div><div class="line">TRAPHANDLER_NOEC(irq_9_handler,  IRQ_OFFSET + 9);</div><div class="line">TRAPHANDLER_NOEC(irq_10_handler, IRQ_OFFSET + 10);</div><div class="line">TRAPHANDLER_NOEC(irq_11_handler, IRQ_OFFSET + 11);</div><div class="line">TRAPHANDLER_NOEC(irq_12_handler, IRQ_OFFSET + 12);</div><div class="line">TRAPHANDLER_NOEC(irq_13_handler, IRQ_OFFSET + 13);</div><div class="line">TRAPHANDLER_NOEC(irq_14_handler, IRQ_OFFSET + 14);</div><div class="line">TRAPHANDLER_NOEC(irq_15_handler, IRQ_OFFSET + 15);</div><div class="line"></div><div class="line">// In kern/trap.c, trap_init():</div><div class="line">// set up interupt gate descriptor</div><div class="line">SETGATE(idt[IRQ_OFFSET + 0],  0, GD_KT, irq_0_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 1],  0, GD_KT, irq_1_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 2],  0, GD_KT, irq_2_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 3],  0, GD_KT, irq_3_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 4],  0, GD_KT, irq_4_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 5],  0, GD_KT, irq_5_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 6],  0, GD_KT, irq_6_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 7],  0, GD_KT, irq_7_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 8],  0, GD_KT, irq_8_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 9],  0, GD_KT, irq_9_handler,  0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 10], 0, GD_KT, irq_10_handler, 0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 11], 0, GD_KT, irq_11_handler, 0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 12], 0, GD_KT, irq_12_handler, 0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 13], 0, GD_KT, irq_13_handler, 0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 14], 0, GD_KT, irq_14_handler, 0);</div><div class="line">SETGATE(idt[IRQ_OFFSET + 15], 0, GD_KT, irq_15_handler, 0);</div><div class="line"></div><div class="line">// In kern/env.c, env_alloc():</div><div class="line">// Enable interrupts while in user mode.</div><div class="line">// LAB 4: Your code here.</div><div class="line">// simply use bit or to set FL_IF</div><div class="line">e-&gt;env_tf.tf_eflags |= FL_IF;</div><div class="line"></div><div class="line">// In kern/sched.c, sched_halt():</div><div class="line">// Reset stack pointer, enable interrupts and then halt.</div><div class="line">asm volatile (</div><div class="line">    "movl $0, %%ebp\n"</div><div class="line">    "movl %0, %%esp\n"</div><div class="line">    "pushl $0\n"</div><div class="line">    "pushl $0\n"</div><div class="line">    // Uncomment the following line after completing exercise 13</div><div class="line">    "sti\n"</div><div class="line">    "1:\n"</div><div class="line">    "hlt\n"</div><div class="line">    "jmp 1b\n"</div><div class="line">: : "a" (thiscpu-&gt;cpu_ts.ts_esp0));</div></pre></td></tr></table></figure></p>
<h5 id="处理时钟中断"><a href="#处理时钟中断" class="headerlink" title="处理时钟中断"></a>处理时钟中断</h5><p>在<code>user/spin</code>程序中，在子环境第一次运行后，会陷入无限循环，而内核将无法得到控制权，需要对硬件编程以定时产生时钟中断，该终端会将控制权强行切回CPU，然后可以将控制权交给另一个用户环境。</p>
<p>对于<code>lapic_init()</code>和<code>pic_init()</code>的调用已经写好，它们会设置时钟并且终端控制器会定时生成中断。需要完成代码处理这些中断。</p>
<p>练习14中遇到的问题：</p>
<ul>
<li>首先需要调用<code>lapic_eoi()</code>以确认接收到了中断，否则会一直卡住</li>
</ul>
<p>练习14的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in kern/trap.c, trap_dispatch():</span></div><div class="line"><span class="comment">// new code added</span></div><div class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</div><div class="line">    <span class="comment">// dispatch clock interupts</span></div><div class="line">    <span class="comment">// call sched_yield() to find and run a different environment</span></div><div class="line">    <span class="comment">// NB: should first call lapic_eoi() to ACKNOWLEDGE interupt</span></div><div class="line">    lapic_eoi();</div><div class="line">    sched_yield();</div><div class="line">    <span class="comment">// sched_yield() might not return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h4><p>到目前位置实验一直关注于操作系统的独立部分，操作系统通过虚拟化提供了一种每个环境都独占整个机器的“错觉”。然而操作系统的另一项服务是允许程序在必要的时候通讯，该功能非常强大，Unix管道就是一个典型的例子。</p>
<p>有许多进程间通讯的模型，即使是现在也有许多关于哪一种模型是最好的争论。我们不参与争论。相反，我们将实现一个简单的IPC模型。</p>
<h5 id="JOS中的IPC"><a href="#JOS中的IPC" class="headerlink" title="JOS中的IPC"></a>JOS中的IPC</h5><p>你将实现一些额外的JOS内核系统调用，这些调用共同提供一个简单的进程间通讯机制。具体的系统调用为<code>sys_ipc_recv()</code>和<code>sys_ipc_try_send()</code>，然后你将实现两个库包装<code>ipc_recv()</code>和<code>ipc_send()</code>。</p>
<p>用户环境通过JOS的IPC机制向其他环境互相发送的信息包括两部分，一个32-bit的值和一个可选的单页映射。允许环境传递页映射提供了一个比传递一个32-bit的整数更有效的数据交换方式，这也可以较为方便的设置共享内存。</p>
<h5 id="发送和接收消息"><a href="#发送和接收消息" class="headerlink" title="发送和接收消息"></a>发送和接收消息</h5><p>环境调用<code>sys_ipc_recv()</code>去接受消息。该系统调用取消调度当前环境并且直到一条消息被收到后才会被继续运行。当一个环境等待接收消息时，任何其他的环境可以向其发送一条消息 - 并不限于特定的环境，也不限于父子进程间传递消息，换言之，你在第一部分中实现的权限检查将不适用于IPC，因为IPC系统调用经过精心设计以保证安全，环境不会通过简单地发送消息而导致其他环境出现错误（除非目标环境也有错误）。</p>
<p>环境调用<code>sys_ipc_try_send()</code>去尝试发送一个值（并附带上接受者的环境ID），如果指定的环境实际上正在接受该值（已调用<code>sys_ipc_recv()</code>并且尚未获得值），则值成功发送并返回0。否则，返回-E_IPC_NOT_RECV表示目标环境当前不期望接收值。</p>
<p>用户空间的库函数<code>ipc_recv()</code>将负责调用<code>sys_ipc_recv()</code>并在当前环境的<code>struct Env</code>中查找接收值的信息。</p>
<p>用户空间的库函数<code>ipc_send()</code>将负责反复调用<code>sys_ipc_try_send()</code>直到发送成功。</p>
<h5 id="传输页"><a href="#传输页" class="headerlink" title="传输页"></a>传输页</h5><p>当一个环境以一个有效的<code>dstva</code>参数（小于UTOP）调用<code>sys_ipc_recv()</code>时，环境改变状态以表明想要接受一个页映射。如果发送者发送了一个页，那么该页将会被映射到接收者地址空间的<code>dstva</code>处。如果接收者已经在<code>dstva</code>映射了一页，那么之前的页会被解映射。</p>
<p>当一个环境以一个有效的<code>srcva</code>参数（小于UTOP）调用<code>sys_ipc_try_send()</code>时，表明发送者想要将当前映射在<code>srcva</code>的页发送给接收者，并且带有权限<code>perm</code>。在一次成功的IPC之后，发送者在其地址空间保留在<code>srcva</code>处原有的页映射，但是接收者也持有最开始由发送者指定的相同的物理页面在<code>dstva</code>的映射。最终，该页面在发送者和接收者之间共享。</p>
<p>如果发送者和接收者两者之一没有表明要传输页面，那么将不会有页面被传输。在任意一次IPC之后将接收者的<code>struct Env</code>中新的域<code>env_ipc_perm</code>设置为接受页面的权限，如果没有收到页面，则为0。</p>
<h5 id="实现IPC"><a href="#实现IPC" class="headerlink" title="实现IPC"></a>实现IPC</h5><p>练习15中遇到的问题：</p>
<ul>
<li>在<code>sys_ipc_try_send()</code>和<code>sys_ipc_recv()</code>中，均不将超过UTOP的地址标记为错误，超过UTOP的地址是无效的，但并不会导致系统调用失败</li>
<li>在<code>sys_ipc_recv()</code>中在接收到消息前将环境状态置为不可运行，那么在收到消息后，应当恢复到可运行的状态</li>
<li>在<code>sys_ipc_try_send()</code>中调用<code>page_lookup()</code>时，要记住检查的是源地址的映射，因此应当使用当前环境的页表而非接收者环境的页表</li>
</ul>
<p>练习15的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In kern/syscall.c, sys_ipc_recv():</span></div><div class="line"><span class="comment">// Block until a value is ready.  Record that you want to receive</span></div><div class="line"><span class="comment">// using the env_ipc_recving and env_ipc_dstva fields of struct Env,</span></div><div class="line"><span class="comment">// mark yourself not runnable, and then give up the CPU.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// If 'dstva' is &lt; UTOP, then you are willing to receive a page of data.</span></div><div class="line"><span class="comment">// 'dstva' is the virtual address at which the sent page should be mapped.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// This function only returns on error, but the system call will eventually</span></div><div class="line"><span class="comment">// return 0 on success.</span></div><div class="line"><span class="comment">// Return &lt; 0 on error.  Errors are:</span></div><div class="line"><span class="comment">//  -E_INVAL if dstva &lt; UTOP but dstva is not page-aligned.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_ipc_recv</span><span class="params">(<span class="keyword">void</span> *dstva)</span> </span>&#123;</div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// similar to sys_ipc_try_send, will not mark an error</span></div><div class="line">    <span class="comment">// if dstva &gt;= UTOP</span></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)dstva &lt; UTOP &amp;&amp; PGOFF(dstva) != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// if dstva &lt; UTOP but dstva is not page-aligned</span></div><div class="line">        <span class="comment">// NB: &amp;&amp; rather than ||, we won't report error</span></div><div class="line">        <span class="comment">// when dstva &gt;= UTOP</span></div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// mark calling environment as not runnable</span></div><div class="line">    curenv-&gt;env_status = ENV_NOT_RUNNABLE;</div><div class="line">    <span class="comment">// update status to mark receiver is willing to receive message</span></div><div class="line">    curenv-&gt;env_ipc_recving = <span class="literal">true</span>;</div><div class="line">    curenv-&gt;env_ipc_dstva   = dstva;</div><div class="line"></div><div class="line">    <span class="comment">// give up cpu</span></div><div class="line">    sys_yield();</div><div class="line"></div><div class="line">    <span class="comment">// panic("sys_ipc_recv not implemented");</span></div><div class="line"></div><div class="line">    <span class="comment">// ipc succeeds</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In kern/syscall.c, sys_ipc_try_send():</span></div><div class="line"><span class="comment">// Try to send 'value' to the target env 'envid'.</span></div><div class="line"><span class="comment">// If srcva &lt; UTOP, then also send page currently mapped at 'srcva',</span></div><div class="line"><span class="comment">// so that receiver gets a duplicate mapping of the same page.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// The send fails with a return value of -E_IPC_NOT_RECV if the</span></div><div class="line"><span class="comment">// target is not blocked, waiting for an IPC.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// The send also can fail for the other reasons listed below.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Otherwise, the send succeeds, and the target's ipc fields are</span></div><div class="line"><span class="comment">// updated as follows:</span></div><div class="line"><span class="comment">//    env_ipc_recving is set to 0 to block future sends;</span></div><div class="line"><span class="comment">//    env_ipc_from is set to the sending envid;</span></div><div class="line"><span class="comment">//    env_ipc_value is set to the 'value' parameter;</span></div><div class="line"><span class="comment">//    env_ipc_perm is set to 'perm' if a page was transferred, 0 otherwise.</span></div><div class="line"><span class="comment">// The target environment is marked runnable again, returning 0</span></div><div class="line"><span class="comment">// from the paused sys_ipc_recv system call.  (Hint: does the</span></div><div class="line"><span class="comment">// sys_ipc_recv function ever actually return?)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// If the sender wants to send a page but the receiver isn't asking for one,</span></div><div class="line"><span class="comment">// then no page mapping is transferred, but no error occurs.</span></div><div class="line"><span class="comment">// The ipc only happens when no errors occur.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.</span></div><div class="line"><span class="comment">// Errors are:</span></div><div class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist.</span></div><div class="line"><span class="comment">//      (No need to check permissions.)</span></div><div class="line"><span class="comment">//  -E_IPC_NOT_RECV if envid is not currently blocked in sys_ipc_recv,</span></div><div class="line"><span class="comment">//      or another environment managed to send first.</span></div><div class="line"><span class="comment">//  -E_INVAL if srcva &lt; UTOP but srcva is not page-aligned.</span></div><div class="line"><span class="comment">//  -E_INVAL if srcva &lt; UTOP and perm is inappropriate</span></div><div class="line"><span class="comment">//      (see sys_page_alloc).</span></div><div class="line"><span class="comment">//  -E_INVAL if srcva &lt; UTOP but srcva is not mapped in the caller's</span></div><div class="line"><span class="comment">//      address space.</span></div><div class="line"><span class="comment">//  -E_INVAL if (perm &amp; PTE_W), but srcva is read-only in the</span></div><div class="line"><span class="comment">//      current environment's address space.</span></div><div class="line"><span class="comment">//  -E_NO_MEM if there's not enough memory to map srcva in envid's</span></div><div class="line"><span class="comment">//      address space.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_ipc_try_send</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">uint32_t</span> value, <span class="keyword">void</span> *srcva,</span></span></div><div class="line">                            <span class="keyword">unsigned</span> perm) &#123;</div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// check for existence of env with envid</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></div><div class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">false</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// environment envid doesn't currently exist</span></div><div class="line">        <span class="keyword">return</span> -E_BAD_ENV;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// check receiver's status</span></div><div class="line">    <span class="keyword">if</span> (!env-&gt;env_ipc_recving) &#123;</div><div class="line">        <span class="comment">// envid is not currently blocked in sys_ipc_recv</span></div><div class="line">        <span class="comment">// or another environment managed to send first</span></div><div class="line">        <span class="keyword">return</span> -E_IPC_NOT_RECV;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)srcva &lt; UTOP) &#123;</div><div class="line">        <span class="comment">// srcva is valid</span></div><div class="line">        <span class="comment">// check srcva is page-aligned</span></div><div class="line">        <span class="keyword">if</span> (PGOFF(srcva) != <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// srcva is not page-aligned</span></div><div class="line">            <span class="keyword">return</span> -E_INVAL;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// check perm passed in</span></div><div class="line">        <span class="keyword">if</span> ((perm &amp; (~PTE_SYSCALL)) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P)) &#123;</div><div class="line">            <span class="comment">// invalid perm</span></div><div class="line">            <span class="keyword">return</span> -E_INVAL;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// check srcva actually be mapped</span></div><div class="line">        <span class="keyword">pte_t</span> *          pgtable_entry;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span>;</span></div><div class="line">        <span class="keyword">if</span> ((page = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;pgtable_entry)) ==</div><div class="line">            <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="comment">// NB: check for SRCVA here, so use curenv-&gt;env_pgdir</span></div><div class="line">            <span class="comment">// srcva is not mapped at caller's address space</span></div><div class="line">            <span class="keyword">return</span> -E_INVAL;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// check PTE_W between sender and receiver</span></div><div class="line">        <span class="keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; (!((*pgtable_entry) &amp; PTE_W))) &#123;</div><div class="line">            <span class="comment">// if perm has PTE_W while srcva is read-only in</span></div><div class="line">            <span class="comment">// current environment's address space</span></div><div class="line">            <span class="keyword">return</span> -E_INVAL;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)(env-&gt;env_ipc_dstva) &lt; UTOP) &#123;</div><div class="line">            <span class="comment">// receiver also expects page to be transferred</span></div><div class="line">            <span class="comment">// call page_insert to actually transer the page</span></div><div class="line">            <span class="keyword">if</span> (page_insert(env-&gt;env_pgdir, page, env-&gt;env_ipc_dstva, perm) &lt;</div><div class="line">                <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// out of memory when try to insert page</span></div><div class="line">                <span class="keyword">return</span> -E_NO_MEM;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// page successfully transferred</span></div><div class="line">            env-&gt;env_ipc_perm = perm;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// srcva &gt;= UTOP</span></div><div class="line">        <span class="comment">// invalid srcva, but we won't return error here</span></div><div class="line">        <span class="comment">// ipc_send will panic if we do so</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// update receiver's information</span></div><div class="line">    env-&gt;env_ipc_recving = <span class="literal">false</span>;</div><div class="line">    env-&gt;env_ipc_from    = curenv-&gt;env_id;</div><div class="line">    env-&gt;env_ipc_value   = value;</div><div class="line">    <span class="comment">// mark receiver to be runnable to match what we do in sys_ipc_recv</span></div><div class="line">    env-&gt;env_status = ENV_RUNNABLE;</div><div class="line">    <span class="comment">// modify trapframe's eax register to `update' return value</span></div><div class="line">    env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// panic("sys_ipc_try_send not implemented");</span></div><div class="line"></div><div class="line">    <span class="comment">// ipc succeeds</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In lib/ipc.c, ipc_recv():</span></div><div class="line"><span class="comment">// Receive a value via IPC and return it.</span></div><div class="line"><span class="comment">// If 'pg' is nonnull, then any page sent by the sender will be mapped at</span></div><div class="line"><span class="comment">//	that address.</span></div><div class="line"><span class="comment">// If 'from_env_store' is nonnull, then store the IPC sender's envid in</span></div><div class="line"><span class="comment">//	*from_env_store.</span></div><div class="line"><span class="comment">// If 'perm_store' is nonnull, then store the IPC sender's page permission</span></div><div class="line"><span class="comment">//	in *perm_store (this is nonzero if a page was successfully</span></div><div class="line"><span class="comment">//	transferred to 'pg').</span></div><div class="line"><span class="comment">// If the system call fails, then store 0 in *fromenv and *perm (if</span></div><div class="line"><span class="comment">//	they're nonnull) and return the error.</span></div><div class="line"><span class="comment">// Otherwise, return the value sent by the sender</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Hint:</span></div><div class="line"><span class="comment">//   Use 'thisenv' to discover the value and who sent it.</span></div><div class="line"><span class="comment">//   If 'pg' is null, pass sys_ipc_recv a value that it will understand</span></div><div class="line"><span class="comment">//   as meaning "no page".  (Zero is not the right value, since that's</span></div><div class="line"><span class="comment">//   a perfectly valid place to map a page.)</span></div><div class="line"><span class="keyword">int32_t</span> ipc_recv(<span class="keyword">envid_t</span> *from_env_store, <span class="keyword">void</span> *pg, <span class="keyword">int</span> *perm_store) &#123;</div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// check pg, if pg is null, then should set it to UTOP,</span></div><div class="line">    <span class="comment">// for only if dstva is below UTOP, sender knows that</span></div><div class="line">    <span class="comment">// receiver wants a page to be transferred</span></div><div class="line">    <span class="keyword">if</span> (!pg) &#123; pg = (<span class="keyword">void</span> *)UTOP; &#125;</div><div class="line">    <span class="keyword">int</span> r;</div><div class="line">    <span class="keyword">if</span> ((r = sys_ipc_recv(pg)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// system call fails</span></div><div class="line">        <span class="comment">// store from env and perm if corresponding pointer is not null</span></div><div class="line">        <span class="keyword">if</span> (from_env_store) &#123; *from_env_store = <span class="number">0</span>; &#125;</div><div class="line">        <span class="keyword">if</span> (perm_store) &#123; *perm_store = <span class="number">0</span>; &#125;</div><div class="line">        <span class="comment">// return the error</span></div><div class="line">        <span class="keyword">return</span> r;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// system call succeeds</span></div><div class="line">    <span class="comment">// extract information from thisenv's IPC fields</span></div><div class="line">    <span class="keyword">if</span> (from_env_store) &#123;</div><div class="line">        <span class="comment">// store IPC sender's envid into *from_env_store</span></div><div class="line">        *from_env_store = thisenv-&gt;env_ipc_from;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (perm_store) &#123;</div><div class="line">        <span class="comment">// store IPC sender's page permission</span></div><div class="line">        *perm_store = thisenv-&gt;env_ipc_perm;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// panic("ipc_recv not implemented");</span></div><div class="line"></div><div class="line">    <span class="comment">// return the value send by the sender</span></div><div class="line">    <span class="keyword">return</span> thisenv-&gt;env_ipc_value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In kern/syscall.c, syscall():</span></div><div class="line"><span class="comment">// new code added</span></div><div class="line"><span class="keyword">case</span> SYS_ipc_recv:</div><div class="line">    <span class="comment">// call sys_ipc_recv</span></div><div class="line">    <span class="keyword">return</span> sys_ipc_recv((<span class="keyword">void</span> *)a1);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> SYS_ipc_try_send:</div><div class="line">    <span class="comment">// call sys_ipc_try_send</span></div><div class="line">    <span class="keyword">return</span> sys_ipc_try_send((<span class="keyword">envid_t</span>)a1, (<span class="keyword">uint32_t</span>)a2, (<span class="keyword">void</span> *)a3,</div><div class="line">                            (<span class="keyword">unsigned</span>)a4);</div><div class="line"></div><div class="line"><span class="comment">// In lib/ipc.c, ipc_send():</span></div><div class="line"><span class="comment">// Send 'val' (and 'pg' with 'perm', if 'pg' is nonnull) to 'toenv'.</span></div><div class="line"><span class="comment">// This function keeps trying until it succeeds.</span></div><div class="line"><span class="comment">// It should panic() on any error other than -E_IPC_NOT_RECV.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Hint:</span></div><div class="line"><span class="comment">//   Use sys_yield() to be CPU-friendly.</span></div><div class="line"><span class="comment">//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand</span></div><div class="line"><span class="comment">//   as meaning "no page".  (Zero is not the right value.)</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ipc_send</span><span class="params">(<span class="keyword">envid_t</span> to_env, <span class="keyword">uint32_t</span> val, <span class="keyword">void</span> *pg, <span class="keyword">int</span> perm)</span> </span>&#123;</div><div class="line">    <span class="comment">// LAB 4: Your code here.</span></div><div class="line">    <span class="comment">// check pg, if pg is null, then should set it to UTOP(invalid value</span></div><div class="line">    <span class="comment">// but won't result in panic)</span></div><div class="line">    <span class="keyword">if</span> (!pg) &#123; pg = (<span class="keyword">void</span> *)UTOP; &#125;</div><div class="line">    <span class="keyword">int</span> r;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        <span class="comment">// keeps trying until succeeds or panic</span></div><div class="line">        r = sys_ipc_try_send(to_env, val, pg, perm);</div><div class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// message successfully sent, return</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (r != -E_IPC_NOT_RECV) &#123;</div><div class="line">            <span class="comment">// error when sending, should panic</span></div><div class="line">            panic(<span class="string">"failed to send messages - %e!"</span>, r);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// use sys_yield to avoid waste on CPU</span></div><div class="line">        sys_yield();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// panic("ipc_send not implemented");</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h2><p>最终执行<code>make grade</code>，评分脚本的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">dumbfork:</div><div class="line">$ make run-dumbfork-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.6s)</div><div class="line">Part A score: 5/5</div><div class="line">faultread:</div><div class="line">$ make run-faultread-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">faultwrite:</div><div class="line">$ make run-faultwrite-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">faultdie:</div><div class="line">$ make run-faultdie-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">faultregs:</div><div class="line">$ make run-faultregs-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.1s)</div><div class="line">faultalloc:</div><div class="line">$ make run-faultalloc-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (4.6s)</div><div class="line">faultallocbad:</div><div class="line">$ make run-faultallocbad-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.3s)</div><div class="line">faultnostack:</div><div class="line">$ make run-faultnostack-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.8s)</div><div class="line">faultbadhandler:</div><div class="line">$ make run-faultbadhandler-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.2s)</div><div class="line">faultevilhandler:</div><div class="line">$ make run-faultevilhandler-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">forktree:</div><div class="line">$ make run-forktree-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.4s)</div><div class="line">Part B score: 50/50</div><div class="line">spin:</div><div class="line">$ make run-spin-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (0.7s)</div><div class="line">stresssched:</div><div class="line">$ make run-stresssched-nox-gdb CPUS=4 QEMUEXTRA+=-snapshot</div><div class="line">OK (3.0s)</div><div class="line">sendpage:</div><div class="line">$ make run-sendpage-nox-gdb CPUS=2 QEMUEXTRA+=-snapshot</div><div class="line">OK (1.7s)</div><div class="line">pingpong:</div><div class="line">$ make run-pingpong-nox-gdb CPUS=4 QEMUEXTRA+=-snapshot</div><div class="line">OK (2.1s)</div><div class="line">primes:</div><div class="line">$ make run-primes-nox-gdb CPUS=4 QEMUEXTRA+=-snapshot</div><div class="line">OK (4.5s)</div><div class="line">Part C score: 25/25</div><div class="line">Score: 80/80</div></pre></td></tr></table></figure><br>至此，实验四结束。</p>
<p>第四个实验是第一到第四个实验中难度最大、代码量最多的一个实验，在前三个实验中任何的代码错误（尽管可能在当时的实验评分中没有反映出来）都会导致实验四出现难以调试的错误。</p>
<p>实验四中每个练习遇到的问题我都已经在报告中总结，此外，也在代码中以NB标明。其中大部分都是一些小错误，还有少部分是没有将问题考虑全面导致的。尽管如此，几乎每一个错误我都花费了至少几十分钟去调试。</p>
<p>操作系统的调试不仅仅困难（Triple Fault会导致不打补丁的qemu重启），任何一个小错误都会导致系统崩溃。现代操作系统如Linux的鲁棒性可见一斑。</p>
<p>本学期的事情比起上学期只增不减，加上课程设计只要求完成四个实验，实验四结束后，MIT-6.828系列就告一段落了。</p>
<p>希望我的这四篇实验报告能对正在写实验的你产生些许的启发，也欢迎找我交流相关的问题。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/">
                            MIT6.828操作系统工程Lab3-User Environments实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-02-23T19:12:13+08:00">
	
		    2月 23, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <blockquote>
<p>Lab3 - User Environments需要实现基本的内核功能，使得一个受保护的用户环境（进程）可以运行。在本实验中，需要让内核设置数据结构以追踪用户环境，创建一个单用户环境，加载程序镜像并执行。此外，内核还需要能处理用户环境的系统调用以及引发的异常。<br>2018年2月26日，完成了实验并写完了报告。</p>
</blockquote>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>根据官网，切换到分支lab3并且合并分支lab2。在合并的过程中，发生了冲突。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user% git checkout -b lab3 origin/lab3</div><div class="line">user% git merge lab2</div></pre></td></tr></table></figure>
<p>根据提示，是<code>kern/monitor.c</code>中发生了冲突，因为仅有一处冲突，手动编辑<code>kern/monitor.c</code>文件，并commit，即可解决冲突并合并分支。</p>
<p>实验三包括如下的新文件：</p>
<ul>
<li>inc/env.h 用户模式环境的公有定义</li>
<li>inc/trap.h 陷阱处理的公有定义</li>
<li>inc/syscall.h 用户环境对内核的系统调用的公有定义</li>
<li>inc/lib.h 用户模式支持的库公有定义</li>
<li>kern/env.h 用户模式环境的内核私有定义</li>
<li>kern/env.c 用户模式环境的内核代码实现</li>
<li>kern/trap.h 内核私有的陷阱处理定义</li>
<li>kern/trap.c 陷阱处理代码</li>
<li>kern/trapentry.S 汇编语言的陷阱处理程序入口</li>
<li>kern/syscall.h 系统调用处理的内核私有定义</li>
<li>kern/syscall.c 系统调用实现代码</li>
<li>lib/Makefrag 用户模式库obj/lib/libjos.a的Makefile</li>
<li>lib/entry.S 用户环境的汇编语言入口</li>
<li>lib/libmain.c entry.S调用的用户模式库安装代码</li>
<li>lib/syscall.c 用户模式系统调用的打桩函数</li>
<li>lib/console.c 用户模式的putchar和getchar实现，提供了控制台IO</li>
<li>lib/exit.c 用户模式的exit实现</li>
<li>lib/panic.c 用户模式的panic实现</li>
<li>user/* 检验内核实验三代码的测试程序</li>
</ul>
<p>此外，lab2中的一些文件在lab3中也被添加了新的内容，可以用<code>git diff lab2</code>查看具体的比较信息。</p>
<h4 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h4><p>本实验中可能会用到<code>GCC</code>的内联汇编特性，应当至少理解给出的代码中的内联汇编代码片段。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="第一部分-User-Environments-and-Exception-Handling-用户环境和错误处理"><a href="#第一部分-User-Environments-and-Exception-Handling-用户环境和错误处理" class="headerlink" title="第一部分 User Environments and Exception Handling - 用户环境和错误处理"></a>第一部分 User Environments and Exception Handling - 用户环境和错误处理</h3><p><code>inc/env.h</code>中给出了用户环境的基本定义。内核通过<code>struct Env</code>追踪每一个用户环境。本实验中只需要创建一个环境，然而你需要设计JOS内核实际支持多用户环境。实验四中，你将通过允许一个用户环境<code>fork</code>别的用户环境来利用多用户环境的特性。</p>
<p><code>kern/env.c</code>中可以看到，内核管理3个与环境有关的全局变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *       <span class="title">envs</span>   = <span class="title">NULL</span>;</span>    <span class="comment">// All environments</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *       <span class="title">curenv</span> = <span class="title">NULL</span>;</span>    <span class="comment">// The current env</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span>    <span class="comment">// Free environment list</span></div></pre></td></tr></table></figure></p>
<p>当JOS成功运行之后，<code>envs</code>指针指向一个<code>struct Env</code>的数组，代表了系统中所有的环境。在设计上，JOS内核允许NNEV个同时激活的环境，NNEV在<code>inc/env.h</code>中定义。<br>JOS内核使用<code>env_free_list</code>维护所有未激活的<code>struct Env</code>，这样的设计简化的环境的分配和释放，它们仅仅需要从该链表上添加或移除。<br>JOS内核使用<code>curenv</code>去追踪在任意时刻当前正在执行的环境。在启动之后到第一个环境运行的时间段中，<code>curenv</code>被初始化为<code>NULL</code>。</p>
<h4 id="环境状态"><a href="#环境状态" class="headerlink" title="环境状态"></a>环境状态</h4><p><code>struct Env</code>在<code>inc/env.h</code>中被定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>	<span class="comment">// Saved registers</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>		<span class="comment">// Next free Env</span></div><div class="line">	<span class="keyword">envid_t</span> env_id;			<span class="comment">// Unique environment identifier</span></div><div class="line">	<span class="keyword">envid_t</span> env_parent_id;		<span class="comment">// env_id of this env's parent</span></div><div class="line">	<span class="keyword">enum</span> EnvType env_type;		<span class="comment">// Indicates special system environments</span></div><div class="line">	<span class="keyword">unsigned</span> env_status;		<span class="comment">// Status of the environment</span></div><div class="line">	<span class="keyword">uint32_t</span> env_runs;		<span class="comment">// Number of times environment has run</span></div><div class="line"></div><div class="line">	<span class="comment">// Address space</span></div><div class="line">	<span class="keyword">pde_t</span> *env_pgdir;		<span class="comment">// Kernel virtual address of page dir</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<ul>
<li>env_tf - <code>struct TrapFrame</code>在<code>inc/trap.h</code>中被定义，表示了当环境不运行时被保存的寄存器值，主要用于上下文切换</li>
<li>env_link - 指向了<code>env_free_list</code>上的下一个<code>struct Env</code>。<code>env_free_list</code>指向了链表中的第一个空闲环境</li>
<li>env_id - 唯一标识当前正在使用<code>struct Env</code>的环境。当环境终止后，<code>struct Env</code>可能被内核重新分配用于另一个不同的环境，但它们的env_id是不同的</li>
<li>env_parent_id - 存储了创建该环境的环境的<code>env_id</code>，通过该方式构建一个环境树，用于安全方面的决策</li>
<li>env_type - 用于区分特殊环境，对于大部分环境，该值为<code>ENV_TYPE_USER</code>，在后续Lab中会介绍其他的值</li>
<li>env_status - 状态<ul>
<li>ENV_FREE - 表明<code>struct Env</code>处于空闲状态，应当位于<code>env_free_list</code>上</li>
<li>ENV_RUNNABLE - 表明<code>struct Env</code>代表的环境正等待运行于处理器上</li>
<li>ENV_RUNNING - 表明<code>struct Env</code>代表的环境为正在运行的环境</li>
<li>ENV_NOT_RUNNABLE - 表明<code>struct Env</code>代表了一个正在运行的环境，但却没有准备好运行，如正在等待另一个环境的IPC（进程间通信）</li>
<li>ENV_DYING - 表明<code>struct Env</code>代表了一个僵死环境，僵死环境将在下一次陷入内核时被释放（直到Lab4才会使用该Flag）</li>
</ul>
</li>
<li>env_pgdir - 保存了环境的页目录的内核虚拟地址</li>
</ul>
<p>JOS中环境的概念综合了“线程”和“地址空间”，“线程”由<code>env_tf</code>域的被保存的寄存器值定义，“地址空间”由<code>env_pgdir</code>域指向的页目录和页表定义。为了运行一个环境，内核必须用保存的寄存器值和合适的地址空间设置CPU。</p>
<p>JOS的<code>struct Env</code>和xv6的<code>struct proc</code>很像，两种结构体都持有环境的用户模式寄存器状态（通过<code>struct TrapFrame</code>），然而，JOS中，独立的环境并不具有不同的内核栈，因为JOS内核中同时只能有一个运行的JOS环境，因此JOS只需要一个内核栈。</p>
<h4 id="分配环境数组"><a href="#分配环境数组" class="headerlink" title="分配环境数组"></a>分配环境数组</h4><p>练习1的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Make 'envs' point to an array of size 'NENV' of 'struct Env'.</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// get size of envs</span></div><div class="line"><span class="keyword">uint32_t</span> envs_size = <span class="keyword">sizeof</span>(struct Env) * NENV;</div><div class="line"><span class="comment">// use boot_alloc to allocate memory</span></div><div class="line">envs = (struct Env *)boot_alloc(envs_size);</div><div class="line"><span class="comment">// initialization</span></div><div class="line"><span class="built_in">memset</span>(envs, <span class="number">0</span>, envs_size);</div><div class="line"></div><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Map the 'envs' array read-only by the user at linear address UENVS</span></div><div class="line"><span class="comment">// (ie. perm = PTE_U | PTE_P).</span></div><div class="line"><span class="comment">// Permissions:</span></div><div class="line"><span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></div><div class="line"><span class="comment">//    - envs itself -- kernel RW, user NONE</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line">boot_map_region(kern_pgdir, UENVS, envs_size, PADDR(envs), PTE_U | PTE_P);</div></pre></td></tr></table></figure></p>
<h4 id="创建并运行环境"><a href="#创建并运行环境" class="headerlink" title="创建并运行环境"></a>创建并运行环境</h4><p>现在将在<code>kern/env.c</code>中编写必要的代码去运行用户环境。由于JOS内核还不支持文件系统，所以只能配置内核以加载一个嵌入内核中静态二进制镜像。JOS内核将这个二进制镜像以ELF可执行镜像格式嵌入。</p>
<p>Lab3的GNU<code>Makefile</code>在<code>obj/user/</code>目录下生成了一些二进制镜像。<code>kern/Makefrag</code>下可以看到，链接器的<code>-b binary</code>选项使得这些文件以原始的未被翻译二进制文件而非普通的被编译器生成的<code>.o</code>文件的方式链接， 通过<code>-b binary</code>方式链接的二进制文件就链接器而言可以为任意类型，甚至是文本文件或是图片。</p>
<p>如果在构建内核后观察<code>obj/kern/kernel.sym</code>，可以看到链接器生成了一些“奇怪”名字的符号如<code>_binary_obj_user_hello_start</code>， <code>_binary_obj_user_hello_end</code>或 <code>_binary_obj_user_hello_size</code>。链接器通过二进制文件的名字生成了这些符号的名字，这些符号使得内核代码可以以某种方式引用这些嵌入的二进制文件。</p>
<p>练习2中遇到的问题：</p>
<ul>
<li>除了<code>env-&gt;env_tf.tf_eip</code>以外不要修改其他的值，因为其已经在<code>env_alloc()</code>中被初始化</li>
<li><code>region_alloc()</code>中笔误导致只映射了一页</li>
<li><code>load_icode()</code>中需要切换页表，之后加载每段仅用一个<code>memcpy</code>即可实现</li>
</ul>
<p>练习2的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In env_init():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="keyword">ssize_t</span> i;</div><div class="line"><span class="comment">// loop in reverse order to keep ascending order in env free list</span></div><div class="line"><span class="keyword">for</span> (i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">    <span class="comment">// set env_status, env_id</span></div><div class="line">    envs[i].env_status = ENV_FREE;</div><div class="line">    envs[i].env_id     = <span class="number">0</span>;</div><div class="line">    <span class="comment">// set env_link and insert into env_free_list</span></div><div class="line">    envs[i].env_link = env_free_list;</div><div class="line">    env_free_list    = &amp;envs[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In env_setup_vm():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// set env_pgdir and generate page directory based on kern_pgdir</span></div><div class="line">e-&gt;env_pgdir = (<span class="keyword">pde_t</span> *)page2kva(p);</div><div class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</div><div class="line"><span class="comment">// increase pp_ref</span></div><div class="line">p-&gt;pp_ref++;</div><div class="line"></div><div class="line"><span class="comment">// In region_alloc():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// (But only if you need it for load_icode.)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></div><div class="line"><span class="comment">//   'va' and 'len' values that are not page-aligned.</span></div><div class="line"><span class="comment">//   You should round va down, and round (va + len) up.</span></div><div class="line"><span class="comment">//   (Watch out for corner-cases!)</span></div><div class="line"></div><div class="line"><span class="comment">// round va and va + len</span></div><div class="line"><span class="keyword">uintptr_t</span> start = (<span class="keyword">uintptr_t</span>)ROUNDDOWN(va, PGSIZE);</div><div class="line"><span class="keyword">uintptr_t</span> end   = (<span class="keyword">uintptr_t</span>)ROUNDUP(va + len, PGSIZE);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (; start &lt; end; start += PGSIZE) &#123;</div><div class="line">    <span class="comment">// alloc page</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span>;</span></div><div class="line">    p = page_alloc(ALLOC_ZERO);</div><div class="line">    <span class="keyword">if</span> (!p) &#123; panic(<span class="string">"out of memory when allocating region!"</span>); &#125;</div><div class="line">    <span class="comment">// insert page into environment's page directory</span></div><div class="line">    <span class="keyword">if</span> (page_insert(e-&gt;env_pgdir, p, (<span class="keyword">char</span> *)start, PTE_W | PTE_U | PTE_P) &lt;</div><div class="line">        <span class="number">0</span>) &#123;</div><div class="line">        panic(<span class="string">"out of memory when allocating region!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In load_icode():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// switch address space for loading program segments</span></div><div class="line">lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elf</span> = (<span class="title">struct</span> <span class="title">Elf</span> *)<span class="title">binary</span>;</span></div><div class="line"><span class="comment">// check elf magic</span></div><div class="line"><span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123; panic(<span class="string">"invalid elf format!"</span>); &#125;</div><div class="line"></div><div class="line"><span class="comment">// set the program entry for env</span></div><div class="line">e-&gt;env_tf.tf_eip = elf-&gt;e_entry;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></div><div class="line"></div><div class="line"><span class="comment">// get the start and end of program header entry</span></div><div class="line">ph  = (struct Proghdr *)(binary + elf-&gt;e_phoff);</div><div class="line">eph = ph + elf-&gt;e_phnum;</div><div class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</div><div class="line">    <span class="keyword">if</span> (ph-&gt;p_type == ELF_PROG_LOAD) &#123;    <span class="comment">// if the segment is to be loaded</span></div><div class="line">        <span class="comment">// alloc corresponding region(clear zero)</span></div><div class="line">        region_alloc(e, (<span class="keyword">char</span> *)ph-&gt;p_va, ph-&gt;p_memsz);</div><div class="line">        <span class="comment">// copy from ELF header to virtual addresses directly</span></div><div class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span> *)ph-&gt;p_va, (<span class="keyword">char</span> *)binary + ph-&gt;p_offset, ph-&gt;p_filesz);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// switch back</span></div><div class="line">lcr3(PADDR(kern_pgdir));</div><div class="line"></div><div class="line"><span class="comment">// Now map one page for the program's initial stack</span></div><div class="line"><span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// allocate a page and insert it into env's page directory</span></div><div class="line"><span class="comment">// panic when page_alloc or page_insert failed</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">stack_page</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></div><div class="line"><span class="keyword">if</span> (!stack_page) &#123; panic(<span class="string">"out of memory when alloc program's stack!"</span>); &#125;</div><div class="line"><span class="keyword">if</span> (page_insert(e-&gt;env_pgdir, stack_page, (<span class="keyword">char</span> *)(USTACKTOP - PGSIZE),</div><div class="line">                PTE_W | PTE_U | PTE_P) &lt; <span class="number">0</span>) &#123;</div><div class="line">    panic(<span class="string">"failed to set program's stack!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In env_create():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></div><div class="line"><span class="comment">// allocate new env with parent ID 0</span></div><div class="line"><span class="keyword">if</span> (env_alloc(&amp;env, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123; panic(<span class="string">"failed to allocate env!"</span>); &#125;</div><div class="line"><span class="comment">// load elf binary and set env_type</span></div><div class="line">load_icode(env, binary);</div><div class="line">env-&gt;env_type = type;</div><div class="line"></div><div class="line"><span class="comment">// In env_run():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="keyword">if</span> (curenv != <span class="literal">NULL</span>) &#123;    <span class="comment">// context switch</span></div><div class="line">    <span class="keyword">if</span> (curenv-&gt;env_status == ENV_RUNNING) &#123;</div><div class="line">        <span class="comment">// change to runnable if current status is running</span></div><div class="line">        <span class="comment">// for not runnable, is not necessary to do this</span></div><div class="line">        curenv-&gt;env_status = ENV_RUNNABLE;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// set new curenv, update status and counter</span></div><div class="line">curenv        = e;</div><div class="line">e-&gt;env_status = ENV_RUNNING;</div><div class="line">e-&gt;env_runs++;</div><div class="line"><span class="comment">// address space switch</span></div><div class="line"><span class="comment">// reference from inc/x86.h</span></div><div class="line">lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line"><span class="comment">// drop into user mode</span></div><div class="line">env_pop_tf(&amp;(e-&gt;env_tf));</div><div class="line"></div><div class="line"><span class="comment">// panic("env_run not yet implemented");</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>成功进入用户环境后，若用户环境尝试使用<code>int</code>指令进行系统调用时，将产生错误，因为JOS没有设置任何从用户空间进入内核的方式。<br>当CPU发现无法处理系统中断调用后，会产生一个通用保护错误，发现无法处理它，然后生成一个二重错误，最终因无法处理而生成一个三重错误并放弃，然后系统重启。但是为了便于调试，patch的<code>qemu</code>不会重启。<br>关于重启的理由可以参考<a href="https://blogs.msdn.microsoft.com/larryosterman/2005/02/08/faster-syscall-trap-redux/" target="_blank" rel="external">这里</a>。</p>
</blockquote>
<p>完成后经过测试，程序在<code>int $0x30</code>处Triple Fault，可知本部分代码基本正确。</p>
<h4 id="处理中断和异常"><a href="#处理中断和异常" class="headerlink" title="处理中断和异常"></a>处理中断和异常</h4><p>练习3要求阅读Intel 80386编程手册中的<a href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/c09.htm" target="_blank" rel="external">第九章：异常和中断</a>。</p>
<p>本实验中将沿用Intel关于中断和异常的术语。中断是由处理器以外的异步事件引发的，而异常是由当前正在执行的指令同步引发的。</p>
<h4 id="保护控制转移基础"><a href="#保护控制转移基础" class="headerlink" title="保护控制转移基础"></a>保护控制转移基础</h4><p>异常和中断均为“保护控制转移”，会引发处理器从用户到内核模式（CPL=0），从而避免给用户模式的代码干扰内核或是其他环境的机会。这要求了引发中断或者是异常的代码不能选择进入内核的地点或方式。<br>在x86中，主要有两种机制一起保证了内核总是在受保护的情况下进入，这两种机制为中断描述符表（Interrupt Descriptor Table）和任务状态段（Task State Segment）。</p>
<p>中断描述符表中，处理器保证了异常和中断仅能导致内核在若干个具体的、由内核明确定义好的入口执行，而不是在中断和异常发生时运行的代码。<br>x86允许最多设立256个不同的中断或异常入口，每一个入口都具有一个中断向量。中断向量为0-255的数字，中断向量由中断来源决定：不同的设备，错误条件和应用程序对内核的请求会产生不同向量的中断。CPU使用中断向量作为处理器的中断描述符表的索引。中断描述符表在内核私有的内存中建立。<br>处理器从该表中加载送入EIP寄存器的值（处理程序的入口），以及送入CS段寄存器的值（包括了特权级，在JOS中，所有的异常均在内核模式执行，即特权级0）。</p>
<p>任务状态段。处理器需要在唤醒处理程序前将在中断或异常发生前的旧的处理器状态保存起来，如旧的EIP寄存器值和旧的CS段寄存器值，以便处理程序之后能恢复现场，从中断或异常发生的地方继续执行。然而，保存旧的处理器状态的区域必须对于非特权的用户模式代码处于被保护的状态。否则，错误的或是恶意的用户代码可能会破坏内核。<br>因此，当x86处理器从用户模式特权级切换到内核模式时，其也会切换到内核内存中的一个栈。任务状态段指定了相应的段寄存器以及相应栈的地址。处理器将<code>SS</code>, <code>EFLAGS</code>, <code>CS</code>, <code>EIP</code>以及一个可选的错误码压入这个新栈中。然后从中断描述符中读取相应的<code>CS</code>和<code>EIP</code>，并设置<code>ESP</code>和<code>SS</code>指向新的栈。<br>尽管<code>TSS</code>有着多种作用，JOS仅用它来定义从用户模式切换到内核模式时的内核栈。因为JOS中的内核模式为x86的特权级0，故处理器仅使用<code>TSS</code>的<code>ESP0</code>和<code>SS0</code>域。</p>
<h4 id="异常和中断的类型"><a href="#异常和中断的类型" class="headerlink" title="异常和中断的类型"></a>异常和中断的类型</h4><p>x86处理器能产生的所有同步异常均使用了0-31的中断向量，映射为<code>IDT</code>的0-31号入口。超过31的中断向量仅供由<code>int</code>指令或是由异步硬件中断产生的“软中断”使用。</p>
<h4 id="嵌套异常和中断"><a href="#嵌套异常和中断" class="headerlink" title="嵌套异常和中断"></a>嵌套异常和中断</h4><p>处理器能同时处理内核模式和用户模式的异常。在内核模式中的异常不需要切换栈，因此，不需要压入旧的<code>SS</code>和<code>ESP</code>值。通过这种方式，内核可以优雅地处理内核产生的嵌套异常和中断。该能力对于实现保护是非常重要的。</p>
<p>若处理器已经在内核模式中并且接受了一个异常并且无法将旧值压入内核栈中时（如内存不足），那么，处理器将无论如何也无法恢复，只能重启。内核必须设计良好以避免这种情况发生。</p>
<h4 id="建立IDT表"><a href="#建立IDT表" class="headerlink" title="建立IDT表"></a>建立IDT表</h4><p>由于JOS中使用的为IA_32的陷阱码，更推荐参考<a href="https://pdos.csail.mit.edu/6.828/2017/readings/ia32/IA32-3A.pdf" target="_blank" rel="external">IA_32的第五章</a>。</p>
<p>练习4中遇到的问题如下：</p>
<ul>
<li>设置陷阱门时段选择子应当为<code>GD_KT</code>而不是<code>GD_KD</code>，因为错误处理函数均被链接至了内核的<code>text</code>段。</li>
<li>已存在<code>page_fault_handler</code>的函数，命名时需避免重名。</li>
<li>不能直接用立即数设置段寄存器。</li>
</ul>
<p>练习4的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In trapentry.S:</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Lab 3: Your code here for generating entry points for the different traps.</div><div class="line"> */</div><div class="line"></div><div class="line">TRAPHANDLER_NOEC(divide_error_handler, T_DIVIDE)</div><div class="line">TRAPHANDLER_NOEC(debug_exception_handler, T_DEBUG)</div><div class="line">TRAPHANDLER_NOEC(non_maskable_interrupt_handler, T_NMI)</div><div class="line">TRAPHANDLER_NOEC(breakpoint_handler, T_BRKPT)</div><div class="line">TRAPHANDLER_NOEC(overflow_handler, T_OFLOW)</div><div class="line">TRAPHANDLER_NOEC(bounds_check_handler, T_BOUND)</div><div class="line">TRAPHANDLER_NOEC(invalid_opcode_handler, T_ILLOP)</div><div class="line">TRAPHANDLER_NOEC(device_not_available_handler, T_DEVICE)</div><div class="line">TRAPHANDLER(double_fault_handler, T_DBLFLT)</div><div class="line">TRAPHANDLER(invalid_tss_handler, T_TSS)</div><div class="line">TRAPHANDLER(segment_not_present_handler, T_SEGNP)</div><div class="line">TRAPHANDLER(stack_exception_handler, T_STACK)</div><div class="line">TRAPHANDLER(general_protection_fault_handler, T_GPFLT)</div><div class="line">TRAPHANDLER(pagefault_handler, T_PGFLT)</div><div class="line">TRAPHANDLER_NOEC(floating_point_error_handler, T_FPERR)</div><div class="line">TRAPHANDLER(alignment_check_handler, T_ALIGN)</div><div class="line">TRAPHANDLER_NOEC(machine_check_handler, T_MCHK)</div><div class="line">TRAPHANDLER_NOEC(simd_floating_point_error_handler, T_SIMDERR)</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Lab 3: Your code here for _alltraps</div><div class="line"> */</div><div class="line"></div><div class="line">_alltraps:</div><div class="line"><span class="comment">// push ds and es and general registers</span></div><div class="line">push %ds</div><div class="line">push %es</div><div class="line">pushal</div><div class="line"></div><div class="line"><span class="comment">// load ds and es with GD_KD, for kernel stack locates in data</span></div><div class="line">mov $GD_KD, %ax</div><div class="line">mov %ax, %ds</div><div class="line">mov %ax, %es</div><div class="line"></div><div class="line"><span class="comment">// pass tf as an argument</span></div><div class="line">pushl %esp</div><div class="line"></div><div class="line"><span class="comment">// call trap and no need to return</span></div><div class="line">call trap</div><div class="line"></div><div class="line"><span class="comment">// In trap.c, trap_init():</span></div><div class="line"></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// declare of exception handler</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide_error_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug_exception_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">non_maskable_interrupt_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">breakpoint_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bounds_check_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalid_opcode_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_not_available_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">double_fault_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalid_tss_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">segment_not_present_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">stack_exception_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">general_protection_fault_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pagefault_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">floating_point_error_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">alignment_check_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">machine_check_handler</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">simd_floating_point_error_handler</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// set up trap gate descriptor</span></div><div class="line">SETGATE(idt[T_DIVIDE],	 <span class="number">1</span>, GD_KT, divide_error_handler,           	   <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_DEBUG],    <span class="number">1</span>, GD_KT, debug_exception_handler,            <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_NMI],      <span class="number">1</span>, GD_KT, non_maskable_interrupt_handler,     <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_BRKPT],    <span class="number">1</span>, GD_KT, breakpoint_handler,                 <span class="number">3</span>);</div><div class="line">SETGATE(idt[T_OFLOW],    <span class="number">1</span>, GD_KT, overflow_handler,                   <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_BOUND],    <span class="number">1</span>, GD_KT, bounds_check_handler,               <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_ILLOP],    <span class="number">1</span>, GD_KT, invalid_opcode_handler,             <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_DEVICE],   <span class="number">1</span>, GD_KT, device_not_available_handler,       <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_DBLFLT],   <span class="number">1</span>, GD_KT, double_fault_handler,               <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_TSS],      <span class="number">1</span>, GD_KT, invalid_tss_handler,                <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_SEGNP],    <span class="number">1</span>, GD_KT, segment_not_present_handler,        <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_STACK],    <span class="number">1</span>, GD_KT, stack_exception_handler,            <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_GPFLT],    <span class="number">1</span>, GD_KT, general_protection_fault_handler,   <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_PGFLT],    <span class="number">1</span>, GD_KT, pagefault_handler,                  <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_FPERR],    <span class="number">1</span>, GD_KT, floating_point_error_handler,       <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_ALIGN],    <span class="number">1</span>, GD_KT, alignment_check_handler,            <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_MCHK],     <span class="number">1</span>, GD_KT, machine_check_handler,              <span class="number">0</span>);</div><div class="line">SETGATE(idt[T_SIMDERR],  <span class="number">1</span>, GD_KT, simd_floating_point_error_handler,  <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>问题1：<br>若是使用同一个处理程序，将无法限制调用错误处理程序的代码的特权级，也无法得知中断向量的值。</p>
<p>问题2：<br>仅有内核代码允许执行页错误处理程序，尽管调用了<code>int $14</code>，仍然因为保护机制而生成了中断向量13。如果内核允许<code>int $14</code>唤醒页错误处理程序，那么恶意的程序可以因此而随意触发缺页错误，导致系统无法正常工作。</p>
<h3 id="第二部分-Page-Faults-Breakpoints-Exceptions-and-System-Calls-页错误，断点异常和系统调用"><a href="#第二部分-Page-Faults-Breakpoints-Exceptions-and-System-Calls-页错误，断点异常和系统调用" class="headerlink" title="第二部分 Page Faults, Breakpoints Exceptions, and System Calls - 页错误，断点异常和系统调用"></a>第二部分 Page Faults, Breakpoints Exceptions, and System Calls - 页错误，断点异常和系统调用</h3><h4 id="处理页错误"><a href="#处理页错误" class="headerlink" title="处理页错误"></a>处理页错误</h4><p>页错误的中断向量号为14，是非常重要的异常。当处理器接收一个页错误时，会将引发页错误的线性地址存储在处理器控制寄存器<code>CR2</code>中。</p>
<p>练习5的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In trap_dispatch():</span></div><div class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_PGFLT) &#123;</div><div class="line">    <span class="comment">// dispatch page fault exceptions</span></div><div class="line">    page_fault_handler(tf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="断点异常"><a href="#断点异常" class="headerlink" title="断点异常"></a>断点异常</h4><p>断点异常的中断向量号为3，通常被调试器用作向程序代码中添加断点，原理是将程序中的某一条指令暂时改为1字节的<code>int3</code>的软中断指令。在JOS中，将大量使用这一异常来实现一个原始的伪系统调用，使得用户环境可以使用它来环境JOS内核监视器，可以把内核监视器看做一个原始的调试器。<br>用户模式的<code>panic</code>，就是通过显示panic消息后执行<code>int3</code>实现的。</p>
<p>练习6的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_BRKPT) &#123;</div><div class="line">    <span class="comment">// dispatch breakpoint exceptions</span></div><div class="line">    monitor(tf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>问题3：<br>若是用特权级0初始化断点异常的IDT，那么会触发通用保护错误，这是因为用户模式的代码无法执行特权级0（内核模式）的处理程序，需要用特权级3初始化断点异常的IDT，这样才能使得断点测试正确通过。</p>
<p>问题4：<br>这些措施都是为了保护内核和用户环境的相互独立，使得用户环境仅能在收到允许的情况下执行某些内核的代码，保证了恶意程序不会破坏内核，窃取数据。同时也能保证用户环境能从内核得到必要的功能支持。</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>用户进程通过系统调用请求内核为它工作。当用户进程唤醒系统调用时，处理器进入内核模式，处理器和内核合作保存用户进程状态，内核执行合适的代码完成系统调用，并恢复至用户进程。系统调用的具体实现随平台不同而不同。</p>
<p>JOS内核使用<code>int $0x30</code>作为系统调用。需要建立相关的中断描述符，注意中断向量<code>0x30</code>不可能由硬件生成，毫无疑问应该允许用户执行对应的处理程序。</p>
<p>应用程序会将系统调用号和系统调用参数存入寄存器中。避免了内核访问用户环境栈或是指令流。系统调用号放在寄存器<code>%eax</code>中，最多五个参数分别被相应地放在寄存器<code>%edx</code>, <code>%ecx</code>, <code>%ebx</code>, <code>%edi</code>和<code>%esi</code>中。内核将返回值放在寄存器<code>%eax</code>中。唤醒系统调用的汇编代码已经提供为<code>lib/syscall.c</code>中的<code>syscall()</code>。</p>
<p>练习7中遇到的问题如下：</p>
<ul>
<li>syscall作为软中断不会压入错误码</li>
<li>调用syscall函数时应当使用保存的栈帧中的寄存器值而非实际的寄存器值，原因是在函数调用间某些寄存器的值会发生改变</li>
<li>练习7需要参考<code>lib/syscall.c</code>中得知参数的位置关系</li>
</ul>
<p>练习7的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In trapentry.S:</span></div><div class="line">TRAPHANDLER_NOEC(syscall_handler, T_SYSCALL)</div><div class="line"></div><div class="line"><span class="comment">// In trap.c, trap_init():</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_handler</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KT, syscall_handler, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="comment">// In kern/syscall.c, syscall():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"></div><div class="line"><span class="comment">// panic("syscall not implemented");</span></div><div class="line"></div><div class="line"><span class="keyword">switch</span> (syscallno) &#123;</div><div class="line">    <span class="keyword">case</span> SYS_cputs:</div><div class="line">        <span class="comment">// call sys_cputs</span></div><div class="line">        sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, (<span class="keyword">size_t</span>)a2);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> SYS_cgetc:</div><div class="line">        <span class="comment">// cll sys_cgetc</span></div><div class="line">        <span class="keyword">return</span> sys_cgetc();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> SYS_getenvid:</div><div class="line">        <span class="comment">// call sys_getenvid</span></div><div class="line">        <span class="keyword">return</span> sys_getenvid();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> SYS_env_destroy:</div><div class="line">        <span class="comment">// call sys_env_destroy</span></div><div class="line">        <span class="keyword">return</span> sys_env_destroy((<span class="keyword">envid_t</span>)a1);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> -E_INVAL;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// will not reach here</span></div><div class="line"><span class="keyword">return</span> -E_UNSPECIFIED;</div></pre></td></tr></table></figure></p>
<h4 id="用户模式启动"><a href="#用户模式启动" class="headerlink" title="用户模式启动"></a>用户模式启动</h4><p>一个用户在<code>lib/entry.S</code>的顶部开始运行，经过某些设置后，代码调用<code>lib/libmain.c</code>。你应当修改<code>libmain()</code>以初始化指向当前环境的<code>struct Env</code>指针<code>thisenv</code>（注意到<code>lib/entry.S</code>已经定义了指向你在第一部分映射的<code>UENVS</code>的<code>envs</code>）。</p>
<p><code>libmain()</code>然后调用<code>umain</code>，对于hello程序而言，位于<code>user/hello.c</code>中。在打印<code>hello, world</code>后，它尝试访问<code>thisenv-&gt;env_id</code>。这也是为什么hello程序会出现<code>fault</code>。</p>
<p>练习8中遇到的问题如下：</p>
<ul>
<li>可以使用宏<code>ENVX</code>从<code>envid</code>得到<code>env</code>在<code>envs</code>中的偏移量，而无需遍历整个<code>envs</code></li>
<li>Lab2中<code>pgdir_walk</code>未设置<code>PTE_U</code>导致访问时出现了页错误（仅有PTE项中设置<code>PTE_U</code>是不足的）。</li>
</ul>
<p>练习8的答案如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In libmain.c, libmain():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="comment">// get env id use system call and use ENVX to get index</span></div><div class="line">thisenv = envs + ENVX(sys_getenvid());</div></pre></td></tr></table></figure></p>
<h4 id="页错误和内存保护"><a href="#页错误和内存保护" class="headerlink" title="页错误和内存保护"></a>页错误和内存保护</h4><p>内存保护是操作系统的重要特性，保证了一个程序的错误不会毁坏内核或是其他的程序。<br>操作系统通常和硬件一起实现内存保护。操作系统负责告知硬件哪些虚拟地址是有效的、哪些是无效的。当一个程序试图去访问一个无效的地址或是一个没有权限的地址时，处理器在引起错误的指令处停止程序，然后带着相应的信息陷入内核。若错误可修复，则内核修复该错误并继续执行程序；若错误不可恢复，则程序无法继续运行。<br>现在考虑系统调用，系统调用允许用户程序向内核传递指针，内核在处理系统调用时将指针解引用，会出现以下两种问题：</p>
<ol>
<li>内核的缺页错误潜在地比用户程序的缺页更加严重。若内核在操作私有的数据结构时发生缺页，那么将是内核自己的漏洞，错误处理程序应当panic内核。然而当内核解引用用户程序传递的指针时，需要某种方式标记由解引用导致的缺页实际上代表的是用户程序的利益。</li>
<li>内核比用户程序具有更多的权限。在这种情况下，用户程序可能传递给内核一个指针，该指针指向的内存只能被内核读写而不能被用户程序读写。在这种情况下，内核不能对该指针解引用，这么做会暴露私有数据或是破坏内核完整性。</li>
</ol>
<p>当内核处理用户程序传递的指针时必须非常小心。内核必须检查用户传入的指针。</p>
<p>练习9和练习10遇到的问题如下：</p>
<ul>
<li>需要获取段寄存器的最低两位以得到段特权级</li>
</ul>
<p>练习9和练习10的答案如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In kern/trap.c, page_fault_handler():</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// code that causes page fault in kernel mode</span></div><div class="line">    panic(<span class="string">"page fault in kernel!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In kern/pmap.c, user_mem_check():</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">user_mem_check</span><span class="params">(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span> </span>&#123;</div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= ULIM) &#123;</div><div class="line">        <span class="comment">// condition 1 - below ULIM violated</span></div><div class="line">        user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va;</div><div class="line">        <span class="keyword">return</span> -E_FAULT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">uintptr_t</span> va_start = (<span class="keyword">uintptr_t</span>)ROUNDDOWN(va, PGSIZE);</div><div class="line">    <span class="keyword">uintptr_t</span> va_end   = (<span class="keyword">uintptr_t</span>)ROUNDUP(va + len, PGSIZE);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (; va_start &lt; va_end; va_start += PGSIZE) &#123;</div><div class="line">        <span class="comment">// note we set page directory entry with less restrict</span></div><div class="line">        <span class="comment">// we will only test page table entry here</span></div><div class="line">        <span class="keyword">pte_t</span> *pgtable_entry_ptr =</div><div class="line">            pgdir_walk(env-&gt;env_pgdir, (<span class="keyword">char</span> *)va_start, <span class="literal">false</span>);</div><div class="line">        <span class="keyword">if</span> ((*pgtable_entry_ptr &amp; (perm | PTE_P)) != (perm | PTE_P)) &#123;</div><div class="line">            <span class="comment">// condition 2 - permission violated</span></div><div class="line">            <span class="keyword">if</span> (va_start &lt;= (<span class="keyword">uintptr_t</span>)va) &#123;</div><div class="line">                <span class="comment">// va lie in the first page and not aligned, return va</span></div><div class="line">                user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (va_start &gt;= (<span class="keyword">uintptr_t</span>)va + len) &#123;</div><div class="line">                <span class="comment">// va lie in the last page and exceed va + len, return va + len</span></div><div class="line">                user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va + len;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// return corresponding page's initial address</span></div><div class="line">                user_mem_check_addr = va_start;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> -E_FAULT;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// pass user memory check</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In kern/syscall.c, syscall():</span></div><div class="line"><span class="keyword">case</span> SYS_cputs:</div><div class="line">    <span class="comment">// checks memory before use sys_cputs to dereference a1</span></div><div class="line">    user_mem_assert(curenv, (<span class="keyword">char</span> *)a1, (<span class="keyword">size_t</span>)a2, PTE_U);</div><div class="line">    <span class="comment">// call sys_cputs</span></div><div class="line">    sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, (<span class="keyword">size_t</span>)a2);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line"><span class="comment">// In kern/kdebug.c, debuginfo_eip():</span></div><div class="line"><span class="comment">// Make sure this memory is valid.</span></div><div class="line"><span class="comment">// Return -1 if it is not.  Hint: Call user_mem_check.</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="keyword">if</span> (user_mem_check(curenv, usd, <span class="keyword">sizeof</span>(struct UserStabData), PTE_U) &lt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Make sure the STABS and string table memory is valid.</span></div><div class="line"><span class="comment">// LAB 3: Your code here.</span></div><div class="line"><span class="keyword">if</span> ((user_mem_check(curenv, stabs, stab_end - stabs, PTE_U) &lt; <span class="number">0</span>) ||</div><div class="line">    (user_mem_check(curenv, stabstr, stabstr_end - stabstr, PTE_U) &lt; <span class="number">0</span>)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发生了页错误的原因还要观察<code>memlayout.h</code>，在<code>USTACKTOP</code>上方有一个位于<code>0xeebfd000</code>的<code>Empty Memory</code>，该虚拟地址没有映射任何的物理页。而在<code>mon_backtrace</code>的最后，访问到了位于此处的虚拟地址，因而导致了一个不可处理的页错误。</p>
<h2 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h2><p>最终执行<code>make grade</code>，评分脚本的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">divzero:</div><div class="line">$ make run-divzero-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.3s)</div><div class="line">softint:</div><div class="line">$ make run-softint-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">badsegment:</div><div class="line">$ make run-badsegment-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">Part A score: 30/30</div><div class="line">faultread:</div><div class="line">$ make run-faultread-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">faultreadkernel:</div><div class="line">$ make run-faultreadkernel-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (0.9s)</div><div class="line">faultwrite:</div><div class="line">$ make run-faultwrite-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">faultwritekernel:</div><div class="line">$ make run-faultwritekernel-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">breakpoint:</div><div class="line">$ make run-breakpoint-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (2.0s)</div><div class="line">testbss:</div><div class="line">$ make run-testbss-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (2.1s)</div><div class="line">hello:</div><div class="line">$ make run-hello-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.0s)</div><div class="line">buggyhello:</div><div class="line">$ make run-buggyhello-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.8s)</div><div class="line">buggyhello2:</div><div class="line">$ make run-buggyhello2-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (2.1s)</div><div class="line">evilhello:</div><div class="line">$ make run-evilhello-nox-gdb QEMUEXTRA+=-snapshot</div><div class="line">OK (1.1s)</div><div class="line">Part B score: 50/50</div><div class="line">Score: 80/80</div></pre></td></tr></table></figure><br>至此，实验三结束。</p>
<p>第三个实验的难度明显比实验一和实验二大。<br>用户环境的管理相对简单，而设置陷阱和中断的部分涉及大量的x86硬件知识，需要大量参考Intel手册，要求直接写汇编代码设置栈帧也颇有挑战。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/02/20/MIT6-828操作系统工程Lab2-Memory-Management实验报告/">
                            MIT6.828操作系统工程Lab2-Memory Management实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-02-20T22:12:33+08:00">
	
		    2月 20, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <blockquote>
<p>寒假在家终于有时间继续处理上学期没有做完的Labs，虽然效率偏低但总不是完全没有进展。<br>Lab2 - Memory Management主要包括了操作系统的内存管理，具体来说可以分为两部分。第一部分需要编写内核的物理内存分配器（Physical memory allocator），这会允许内核分配和释放内存。第二部分需要修改JOS的代码去实现一个虚拟内存，将虚拟地址映射到物理内存中。<br>2018年2月23日，完成了实验并写完了报告。</p>
</blockquote>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>根据实验官网的提示，依次切换到分支lab2并且合并分支lab1，在合并的过程中，没有发生冲突。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user% git checkout -b lab2 origin/lab2</div><div class="line">user% git merge lab1</div></pre></td></tr></table></figure>
<p>实验二包括如下的新文件：</p>
<ul>
<li>inc/memlayout.h 描述了虚拟地址空间的结构</li>
<li>kern/pmap.c 需要修改、添加代码以完成实验</li>
<li>kern/pmap.h 定义了PageInfo结构 用来管理物理页状态</li>
<li>kern/kclock.h</li>
<li>kern/kclock.c 操作电池供电的时钟以及CMOS RAM硬件</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="第一部分-Physical-Page-Management-物理页管理"><a href="#第一部分-Physical-Page-Management-物理页管理" class="headerlink" title="第一部分 Physical Page Management - 物理页管理"></a>第一部分 Physical Page Management - 物理页管理</h3><p>操作系统必须追踪物理内存以得知哪些内存是空闲的，以及哪些内存是正在被使用的。JOS使用页粒度管理PC的物理内存以便利用MMU映射和保护每一片被分配的内存。</p>
<p>实验的第一部分需要完成一个物理页面分配器，该分配器维护了一个<code>struct PageInfo</code>的链表来追踪空闲的物理页面（也就是空闲链表），空闲链表已经在CSAPP中有所了解，这里不再赘述。</p>
<p>具体来说，需要完成kern/pmap.c中实现以下的函数：</p>
<ul>
<li>boot_alloc()</li>
<li>mem_init() （完成直到check_page_free_list(1)为止）</li>
<li>page_init()</li>
<li>page_alloc()</li>
<li>page_free()</li>
</ul>
<p>完成后可以启动JOS去观察<code>check_page_free_list()</code>以及<code>check_page_alloc()</code>函数是否成功以检查编写的分配器的正确性。</p>
<p>第一部分的物理页面分配器总体来说难度不大，因为编写的分配器不像CSAPP中的<code>malloc()</code>一样，需要处理空闲内存的合并以及拆分，分配器只需要以物理页面为固定的粒度管理所有的内存即可。</p>
<p>在实际的Linux系统中，内核使用Buddy System快速地管理内存。</p>
<p>练习1的代码如下，仅供参考:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In boot_alloc():</span></div><div class="line"><span class="comment">// Allocate a chunk large enough to hold 'n' bytes, then update</span></div><div class="line"><span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></div><div class="line"><span class="comment">// to a multiple of PGSIZE.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// LAB 2: Your code here.</span></div><div class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// return the address of next free page</span></div><div class="line">    <span class="keyword">return</span> nextfree;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// round up size to a multiple of PGSIZE</span></div><div class="line">    <span class="keyword">size_t</span> size = ROUNDUP(n, PGSIZE);</div><div class="line">    <span class="keyword">char</span> * addr = nextfree;</div><div class="line">    <span class="comment">// update address of next free page(still multiple of PGSIZE)</span></div><div class="line">    nextfree += size;</div><div class="line">    <span class="comment">// nextfree is a kernel virtual address, out out memory when it exceeds 4 MB</span></div><div class="line">	<span class="keyword">if</span> (nextfree &gt;= (<span class="keyword">char</span> *)KADDR(<span class="number">0x400000</span>)) &#123;</div><div class="line">        panic(<span class="string">"out of memory when booting!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// return address</span></div><div class="line">    <span class="keyword">return</span> addr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In mem_init():</span></div><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.</span></div><div class="line"><span class="comment">// The kernel uses this array to keep track of physical pages: for</span></div><div class="line"><span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></div><div class="line"><span class="comment">// array.  'npages' is the number of physical pages in memory.  Use memset</span></div><div class="line"><span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></div><div class="line"><span class="comment">// Your code goes here:</span></div><div class="line"><span class="comment">// get size of pages</span></div><div class="line"><span class="keyword">uint32_t</span> pages_size = <span class="keyword">sizeof</span>(struct PageInfo) * npages;</div><div class="line"><span class="comment">// use boot_alloc to allocate memory</span></div><div class="line">pages = (struct PageInfo *) boot_alloc(pages_size);</div><div class="line"><span class="comment">// initialization</span></div><div class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, pages_size);</div><div class="line"></div><div class="line"><span class="comment">// In page_init():</span></div><div class="line"><span class="keyword">size_t</span> i;</div><div class="line"></div><div class="line"><span class="comment">// initialize from page 1 to page npages_basemem - 1</span></div><div class="line"><span class="comment">// set pp_ref to 0, set pp_link to last page_free_list</span></div><div class="line"><span class="comment">// and then update page_free_list</span></div><div class="line"><span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; npages_basemem ; i++) &#123;</div><div class="line">    pages[i].pp_ref = <span class="number">0</span>;</div><div class="line">    pages[i].pp_link = page_free_list;</div><div class="line">    page_free_list = &amp;pages[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// calculate next free page and initialize corresponding pages entry</span></div><div class="line"><span class="comment">// convert from kernel virtual address to physical address</span></div><div class="line"><span class="keyword">size_t</span> next_free_page = PADDR(boot_alloc(<span class="number">0</span>)) / PGSIZE;</div><div class="line">pages[next_free_page].pp_link = &amp;pages[npages_basemem - <span class="number">1</span>];</div><div class="line">page_free_list = &amp;pages[next_free_page];</div><div class="line"></div><div class="line"><span class="comment">// initialize remaining pages entry</span></div><div class="line"><span class="keyword">for</span> (i = next_free_page + <span class="number">1</span> ; i &lt; npages ; i++) &#123;</div><div class="line">    pages[i].pp_ref = <span class="number">0</span>;</div><div class="line">    pages[i].pp_link = page_free_list;</div><div class="line">    page_free_list = &amp;pages[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In page_alloc():</span></div><div class="line"><span class="function">struct PageInfo *</span></div><div class="line"><span class="title">page_alloc</span><span class="params">(<span class="keyword">int</span> alloc_flags)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// get first element in free list</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">page_ptr</span> = <span class="title">page_free_list</span>;</span></div><div class="line">	<span class="keyword">if</span> (page_ptr != <span class="literal">NULL</span>) &#123;</div><div class="line">		<span class="comment">// NOT out of memory</span></div><div class="line">		<span class="comment">// update free list</span></div><div class="line">		page_free_list = page_free_list-&gt;pp_link;</div><div class="line">		<span class="comment">// get kernal virtual address from given page</span></div><div class="line">		<span class="keyword">char</span> * addr = page2kva(page_ptr);</div><div class="line">		<span class="comment">// set pp_link to NULL to allow double-free bugs check</span></div><div class="line">		page_ptr-&gt;pp_link = <span class="literal">NULL</span>;</div><div class="line">		<span class="comment">// ALLOC_ZERO set, use memset to initialze physical page</span></div><div class="line">		<span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO) &#123;</div><div class="line">			<span class="built_in">memset</span>(addr, <span class="number">0</span>, PGSIZE);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// return page</span></div><div class="line">		<span class="keyword">return</span> page_ptr;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In page_free():</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">page_free</span><span class="params">(struct PageInfo *pp)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// Fill this function in</span></div><div class="line">	<span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></div><div class="line">	<span class="comment">// pp-&gt;pp_link is not NULL.</span></div><div class="line"></div><div class="line">	<span class="comment">//check pp_ref and pp_link</span></div><div class="line">	<span class="keyword">if</span> (pp-&gt;pp_ref != <span class="number">0</span>) &#123;</div><div class="line">		panic(<span class="string">"page's reference count is non-zero!"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (pp-&gt;pp_link != <span class="literal">NULL</span>) &#123;</div><div class="line">		panic(<span class="string">"double free error when free page!"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// return page to free list</span></div><div class="line">	pp-&gt;pp_link = page_free_list;</div><div class="line">	page_free_list = pp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后启动JOS，在终端观察到如下输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Physical memory: 131072K available, base = 640K, extended = 130432K</div><div class="line">check_page_free_list() succeeded!</div><div class="line">check_page_alloc() succeeded!</div></pre></td></tr></table></figure></p>
<p>证明内存分配器工作正常。</p>
<h3 id="第二部分-Virtual-Memory-虚拟内存"><a href="#第二部分-Virtual-Memory-虚拟内存" class="headerlink" title="第二部分 Virtual Memory - 虚拟内存"></a>第二部分 Virtual Memory - 虚拟内存</h3><p>练习2：阅读<a href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/toc.htm" target="_blank" rel="external">Intel 80386 Reference Manual</a>的第五章和第六章。主要阅读页翻译和页保护机制的部分。同时，也要对x86的分段机制有所了解。</p>
<h4 id="虚拟地址、线性地址和物理地址"><a href="#虚拟地址、线性地址和物理地址" class="headerlink" title="虚拟地址、线性地址和物理地址"></a>虚拟地址、线性地址和物理地址</h4><p>在x86中，虚拟地址由段选择子和段内偏移组成，通过段翻译机制，得到线性地址。线性地址经过页翻译机制，得到物理地址。物理地址就是实际的内存位置。</p>
<p>在实验1中，已经将线性地址<code>0-4M</code>映射到了虚拟地址<code>0-4M</code>和<code>KERNBASE-KERNBASE+4M</code>。在本实验中，要将物理内存的低256M映射到从<code>KERNBASE</code>开始的虚拟地址。此外，还要映射其他几个虚拟地址空间。（<code>KERNBASE</code>为<code>0xf0000000</code>）</p>
<p>练习3：在QEMU监视器中使用<code>xp</code>命令检查物理内存<code>0x00100000</code>处的字，在gdb中使用<code>x</code>命令检查虚拟内存<code>0xf0100000</code>处的字，观察结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(qemu) xp 0x00100000</div><div class="line">0000000000100000: 0x1badb002</div><div class="line">(gdb) x/x 0xf0100000</div><div class="line">0xf0100000 &lt;_start+4026531828&gt;: 0x1badb002</div></pre></td></tr></table></figure><br>可以得出，物理地址0x00100000和虚拟地址0xf0100000上具有相同的数据。</p>
<p><code>info pg</code>和<code>info mem</code>的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">(qemu) info pg</div><div class="line">VPN range     Entry         Flags        Physical page</div><div class="line">[00000-003ff]  PDE[000]     ----A----P</div><div class="line">  [00000-00000]  PTE[000]     --------WP 00000</div><div class="line">  [00001-0009f]  PTE[001-09f] ---DA---WP 00001-0009f</div><div class="line">  [000a0-000b7]  PTE[0a0-0b7] --------WP 000a0-000b7</div><div class="line">  [000b8-000b8]  PTE[0b8]     ---DA---WP 000b8</div><div class="line">  [000b9-000ff]  PTE[0b9-0ff] --------WP 000b9-000ff</div><div class="line">  [00100-00103]  PTE[100-103] ----A---WP 00100-00103</div><div class="line">  [00104-00119]  PTE[104-119] --------WP 00104-00119</div><div class="line">  [0011a-0011a]  PTE[11a]     ---DA---WP 0011a</div><div class="line">  [0011b-0011c]  PTE[11b-11c] --------WP 0011b-0011c</div><div class="line">  [0011d-003ff]  PTE[11d-3ff] ---DA---WP 0011d-003ff</div><div class="line">[f0000-f03ff]  PDE[3c0]     ----A---WP</div><div class="line">  [f0000-f0000]  PTE[000]     --------WP 00000</div><div class="line">  [f0001-f009f]  PTE[001-09f] ---DA---WP 00001-0009f</div><div class="line">  [f00a0-f00b7]  PTE[0a0-0b7] --------WP 000a0-000b7</div><div class="line">  [f00b8-f00b8]  PTE[0b8]     ---DA---WP 000b8</div><div class="line">  [f00b9-f00ff]  PTE[0b9-0ff] --------WP 000b9-000ff</div><div class="line">  [f0100-f0103]  PTE[100-103] ----A---WP 00100-00103</div><div class="line">  [f0104-f0119]  PTE[104-119] --------WP 00104-00119</div><div class="line">  [f011a-f011a]  PTE[11a]     ---DA---WP 0011a</div><div class="line">  [f011b-f011c]  PTE[11b-11c] --------WP 0011b-0011c</div><div class="line">  [f011d-f03ff]  PTE[11d-3ff] ---DA---WP 0011d-003ff</div><div class="line"></div><div class="line">  (qemu) info mem</div><div class="line">  0000000000000000-0000000000400000 0000000000400000 -r-</div><div class="line">  00000000f0000000-00000000f0400000 0000000000400000 -rw</div></pre></td></tr></table></figure></p>
<p>在JOS内核中，<code>uintptr_t</code>代表虚拟地址，<code>physaddr_t</code>代表物理地址，它们都只是<code>uint32_t</code>的别名。因此，不能直接对其（int类型）解引用，需要先将其转换成指针类型。<br>对物理地址的解引用是错误的，因为MMU会将其当做虚拟地址，你将无法得到正确的内存内容。</p>
<p>问题1：<br>x的类型应当为<code>uintptr_t</code>，因为对其进行了解引用操作，所以x应当为虚拟地址。</p>
<p>有些时候，内核必须要处理物理地址，这也是要把0-4M映射到KERNBASE-KERNBASE+4M的理由。<br>为了能使内核读写物理地址，必须要加上KERNBASE，可以通过宏KADDR(pa)实现。<br>同理，有时候需要能通过虚拟地址找到物理地址，需要减去KERNBASE，可以通过宏PADDR(va)实现。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>在未来的实验中很可能将同样的物理页映射到多个虚拟地址，你需要在<code>struct PageInfo</code>的<code>pp_ref</code>域中保持物理页被引用的次数，当引用计数归0，页面不再被使用，可以被释放。<br>总的来说，引用计数应当等于物理页面在<code>UTOP</code>之下出现的次数（<code>UTOP</code>之上的物理页面大多在启动时被内核分配并且永远不应当被释放，所以不需要对其进行引用计数）。<br>引用计数也会被用来追踪指向页目录页的指针数，以及页目录对页表页的引用数。</p>
<p>在使用<code>page_alloc()</code>时应当小心，返回页的<code>pp_ref</code>应当很快被递增，如被别的函数如(<code>page_insert()</code>)递增，在某些情况下，调用<code>page_insert()</code>的函数必须手动增加引用计数。</p>
<h4 id="页表管理"><a href="#页表管理" class="headerlink" title="页表管理"></a>页表管理</h4><p>需要编写管理页表的例程：插入和删除线性地址到物理地址的映射，当需要时创建页表等。</p>
<p>在练习4中遇到的问题总结如下：</p>
<ul>
<li>pgdir_walk在设置页表项时应当使用物理地址，在返回指针时应当返回虚拟地址。这是因为此时实际的二级页表还未被设置应用，且0-4M被映射为只读，而KERNBASE-KERNBASE+4M被映射为可读可写。需要使用给出的宏而不要自己加减</li>
<li>将PTE_P笔误成PTE_G</li>
<li>在page_insert中提前将引用计数pp_ref自增就可以避免边界情况的错误</li>
<li>pgdir_walk中对于页目录的设置可以更宽松，否则可能会对之后的实验产生影响</li>
</ul>
<p>练习4的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In pgdir_walk():</span></div><div class="line"><span class="keyword">pte_t</span> *pgdir_walk(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create) &#123;</div><div class="line">    <span class="comment">// get page directory index and page directory entry</span></div><div class="line">    <span class="keyword">size_t</span> pgdir_index = PDX(va);</div><div class="line">    <span class="keyword">pde_t</span>  pgdir_entry = pgdir[pgdir_index];</div><div class="line">    <span class="comment">// get page table index</span></div><div class="line">    <span class="keyword">size_t</span> pgtable_index = PTX(va);</div><div class="line">    <span class="keyword">if</span> ((pgdir_entry &amp; PTE_P) == <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// page table page exists</span></div><div class="line">        <span class="comment">// get address of page table</span></div><div class="line">        <span class="keyword">pte_t</span> *pgtable = KADDR(PTE_ADDR(pgdir_entry));</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">pte_t</span> *)(pgtable + pgtable_index);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// page table page doesn't exist</span></div><div class="line">        <span class="keyword">if</span> (create == <span class="literal">false</span>) &#123;</div><div class="line">            <span class="comment">// create flag is false, returns NULL</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// allocate a new page table page</span></div><div class="line">            struct PageInfo *page = page_alloc(ALLOC_ZERO);</div><div class="line">            <span class="keyword">if</span> (page == <span class="literal">NULL</span>) &#123;</div><div class="line">                <span class="comment">// allocation fails</span></div><div class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// increase physical page's reference count</span></div><div class="line">                page-&gt;pp_ref++;</div><div class="line">                <span class="comment">// get physical address of physical page</span></div><div class="line">                <span class="keyword">physaddr_t</span> page_pa = page2pa(page);</div><div class="line">                <span class="comment">// insert page table into page directory</span></div><div class="line">                pgdir[pgdir_index] = page_pa | PTE_W | PTE_U | PTE_P;</div><div class="line">                <span class="comment">// NB: returns KERNEL VIRTUAL ADDRESS here, for 0-4M is NOT</span></div><div class="line">                <span class="comment">// writable</span></div><div class="line">                <span class="keyword">return</span> (<span class="keyword">pte_t</span> *)page2kva(page) + pgtable_index;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In boot_map_region():</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">boot_map_region</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size,</span></span></div><div class="line">                            <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm) &#123;</div><div class="line">    <span class="comment">// round up size</span></div><div class="line">    size = ROUNDUP(size, PGSIZE);</div><div class="line">    <span class="comment">// get the number of pages to be mapped</span></div><div class="line">    <span class="keyword">size_t</span> page_num = PGNUM(size);</div><div class="line"></div><div class="line">    <span class="keyword">size_t</span> i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; page_num; i++) &#123;</div><div class="line">        <span class="comment">// iterate through to get each pte_t * through pgdir_walk given virtual</span></div><div class="line">        <span class="comment">// address</span></div><div class="line">        <span class="keyword">pte_t</span> *pgtable_entry_ptr =</div><div class="line">            pgdir_walk(pgdir, (<span class="keyword">char</span> *)(va + i * PGSIZE), <span class="literal">true</span>);</div><div class="line">        <span class="comment">// set pte_t according to physical address and permission flags</span></div><div class="line">        *pgtable_entry_ptr = (pa + i * PGSIZE) | perm | PTE_P;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In page_lookup():</span></div><div class="line"><span class="function">struct PageInfo *<span class="title">page_lookup</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va, <span class="keyword">pte_t</span> **pte_store)</span> </span>&#123;</div><div class="line">    <span class="comment">// Fill this function in</span></div><div class="line">    <span class="keyword">pte_t</span> *pgtable_entry_ptr = pgdir_walk(pgdir, va, <span class="literal">false</span>);</div><div class="line">    <span class="keyword">if</span> (pgtable_entry_ptr &amp;&amp; ((*pgtable_entry_ptr) &amp; PTE_P) == <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (pte_store != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="comment">// pte_store not zero, store the address of pte of the page in it</span></div><div class="line">            *pte_store = pgtable_entry_ptr;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// converts from pa to page and returns</span></div><div class="line">        <span class="keyword">physaddr_t</span> pa = PTE_ADDR(*pgtable_entry_ptr);</div><div class="line">        <span class="keyword">return</span> pa2page(pa);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// no page mapped at va</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In page_remove():</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">page_remove</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span> </span>&#123;</div><div class="line">    <span class="comment">// Fill this function in</span></div><div class="line">    <span class="keyword">pte_t</span> *pgtable_entry_ptr = <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">// use page_lookup to get struct PageInfo</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span> = <span class="title">page_lookup</span>(<span class="title">pgdir</span>, <span class="title">va</span>, &amp;<span class="title">pgtable_entry_ptr</span>);</span></div><div class="line">    <span class="keyword">if</span> (page &amp;&amp; pgtable_entry_ptr) &#123;</div><div class="line">        <span class="comment">// if page mapped at va</span></div><div class="line">        <span class="comment">// decrease and try to free page</span></div><div class="line">        page_decref(page);</div><div class="line">        <span class="comment">// set page table entry to 0</span></div><div class="line">        *pgtable_entry_ptr = <span class="number">0</span>;</div><div class="line">        <span class="comment">// invalidate tlb</span></div><div class="line">        tlb_invalidate(pgdir, va);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In page_insert():</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">page_insert</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span> </span>&#123;</div><div class="line">    <span class="comment">// Fill this function in</span></div><div class="line">    <span class="comment">// try to get pointer to page table entry, created if needed</span></div><div class="line">    <span class="keyword">pte_t</span> *pgtable_entry_ptr = pgdir_walk(pgdir, va, <span class="literal">true</span>);</div><div class="line">    <span class="keyword">if</span> (!pgtable_entry_ptr) &#123;</div><div class="line">        <span class="comment">// page table cannot be allocated</span></div><div class="line">        <span class="keyword">return</span> -E_NO_MEM;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// increase reference ahead of insertion to process CORNER CASE</span></div><div class="line">    pp-&gt;pp_ref++;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (((*pgtable_entry_ptr) &amp; PTE_P) != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// exists page mapped at va</span></div><div class="line">        <span class="comment">// remove page and invalidate tlb</span></div><div class="line">        page_remove(pgdir, va);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// get physical address of page</span></div><div class="line">    <span class="keyword">physaddr_t</span> pa = page2pa(pp);</div><div class="line">    <span class="comment">// insert page into page table</span></div><div class="line">    *pgtable_entry_ptr = pa | perm | PTE_P;</div><div class="line"></div><div class="line">    <span class="comment">// update permission flags of corresponding page directory</span></div><div class="line">    pgdir[PDX(va)] = pgdir[PDX(va)] | perm;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="第三部分-Kernel-Address-Space-内核地址空间"><a href="#第三部分-Kernel-Address-Space-内核地址空间" class="headerlink" title="第三部分 Kernel Address Space - 内核地址空间"></a>第三部分 Kernel Address Space - 内核地址空间</h3><p>JOS将32位的地址空间划为了两部分——用户环境（在Lab3中加载和运行）将控制低地址空间、而内核总是完全地控制高地址空间，由ULIM显式地划分地址空间。内核将占据约256M的地址空间。</p>
<p>尽管内核和用户内存位于同一地址空间，仍需要在x86的页表中使用权限位去保证用户代码仅能访问低地址空间。否则用户代码可能会覆写内核数据，导致故障。此外，用户代码还可能能从窃取其他用户、内核的私有数据。<br>在JOS中，用户环境将不具有ULIM以上任何内存的权限；只有内核可以读写这些内存。对于[UTOP, ULIM)，内核和用户都仅能读而不能写，该段内存主要用于向用户暴露某些内核的只读数据结构；最后，UTOP以下的地址空间由用户环境使用，由用户环境自行设置这些内存的权限。</p>
<p>练习5的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Now we set up virtual memory</span></div><div class="line"></div><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Map 'pages' read-only by the user at linear address UPAGES</span></div><div class="line"><span class="comment">// Permissions:</span></div><div class="line"><span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></div><div class="line"><span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></div><div class="line"><span class="comment">//    - pages itself -- kernel RW, user NONE</span></div><div class="line"><span class="comment">// Your code goes here:</span></div><div class="line">boot_map_region(kern_pgdir, UPAGES, pages_size, PADDR(pages), PTE_U | PTE_P);</div><div class="line"></div><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Use the physical memory that 'bootstack' refers to as the kernel</span></div><div class="line"><span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></div><div class="line"><span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></div><div class="line"><span class="comment">// to be the kernel stack, but break this into two pieces:</span></div><div class="line"><span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></div><div class="line"><span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></div><div class="line"><span class="comment">//       the kernel overflows its stack, it will fault rather than</span></div><div class="line"><span class="comment">//       overwrite memory.  Known as a "guard page".</span></div><div class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></div><div class="line"><span class="comment">// Your code goes here:</span></div><div class="line">boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack),</div><div class="line">                PTE_W | PTE_P);</div><div class="line"></div><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Map all of physical memory at KERNBASE.</span></div><div class="line"><span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></div><div class="line"><span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></div><div class="line"><span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></div><div class="line"><span class="comment">// we just set up the mapping anyway.</span></div><div class="line"><span class="comment">// Permissions: kernel RW, user NONE</span></div><div class="line"><span class="comment">// Your code goes here:</span></div><div class="line">boot_map_region(kern_pgdir, KERNBASE, <span class="number">0xffffffff</span> - KERNBASE, <span class="number">0</span>, PTE_W | PTE_P);</div></pre></td></tr></table></figure></p>
<p>问题2：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Enrty</th>
<th style="text-align:center">Base Virtual Address</th>
<th style="text-align:center">Points to (logically)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1023</td>
<td style="text-align:center">0xFFC00000</td>
<td style="text-align:center">Physical Memory</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">……….</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">960</td>
<td style="text-align:center">0xF0000000</td>
<td style="text-align:center">First 4 MB on Physical Memory</td>
</tr>
<tr>
<td style="text-align:center">959</td>
<td style="text-align:center">0xEFC00000</td>
<td style="text-align:center">Kernel Stack</td>
</tr>
<tr>
<td style="text-align:center">957</td>
<td style="text-align:center">0xEF400000</td>
<td style="text-align:center">Kernel Page Directory</td>
</tr>
<tr>
<td style="text-align:center">956</td>
<td style="text-align:center">0xEF000000</td>
<td style="text-align:center">Pages</td>
</tr>
</tbody>
</table>
<p>问题3：<br>页保护机制实现了这一点，用户将不能访问未设置<code>PTE_U</code>的页（对于页目录和页表皆是如此）。</p>
<p>问题4：<br>注意到pages最多只有4MB，而一个<code>struct PageInfo</code>为8字节（对齐），所以实际上最多只有512K个项，总大小为2GB。</p>
<p>问题5：<br>使用了页表来管理虚拟内存，页表完整地映射了4GB的地址空间。使用pages追踪物理页面的情况，由于最初只映射了4MB，使得内存被限制在了2GB。</p>
<p>问题6：<br>执行转换的代码在<code>entry.S</code>中，和32位保护模式时相似：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span>	$relocated, %eax</div><div class="line"><span class="keyword">jmp</span>	*%eax</div></pre></td></tr></table></figure><br>实际的跳转是通过一次<code>jmp</code>实现的，得以继续执行的原因是引导时不仅将0-4M映射到了<code>KERNBASE-KERNBASE+4M</code>的读写，同时也映射到了<code>0-4M</code>的只读。不这么做的话将出现无法处理的<code>SIGTRAP</code>信号而导致系统Triple Fault。<br>不通过转换就无法在高地址执行内核代码，将内核映射在高地址主要是为了完整地映射内核的约256M空间。</p>
<h2 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h2><p>最终执行<code>make grade</code>，评分脚本的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">running JOS:</div><div class="line">$ make qemu-nox-gdb</div><div class="line">(1.3s)</div><div class="line">  Physical page allocator: OK</div><div class="line">  Page management: OK</div><div class="line">  Kernel page directory: OK</div><div class="line">  Page management 2: OK</div><div class="line">Score: 70/70</div></pre></td></tr></table></figure><br>至此，实验二结束。</p>
<p>第二个实验主要关注于操作系统的内存管理的基本概念，使用的也是简单的分配器，但是完整地描述了操作系统从引导直至内核初始化完毕是如何一步步设置页表，管理内存的。</p>
<p>由于已经在CSAPP（CMU 15213）中接触过相关的内存概念，本实验难度并不是很大。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/20/MIT6-828操作系统工程Lab2-Memory-Management实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/">
                            MIT6.828操作系统工程Lab1-Booting a PC实验报告
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-12-09T03:32:48+08:00">
	
		    12月 09, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <blockquote>
<p>本学期开设了操作系统的专业课。根据老师的介绍，下个学期的操作系统课设就是MIT的6.828的Labs，再加上团队老学长/同学的推荐，打算先在这个学期完成6.828，加深对于系统的理解。<br>Lab1 - Booting a PC是比较简单的实验，主要包括了引导、内核、控制台输出、以及栈。尽管如此，由于相关知识的缺失，我断断续续做了2周（2017年10月26日）才完成该实验。<br>2017年12月9日，完成了实验的提高部分并写完了报告。</p>
</blockquote>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>首先需要完成实验环境的搭建。实验环境主要由两个部分组成：QEMU用来模拟运行内核，以及一条编译工具链用于编译和测试内核。这里我使用的系统是64位的ArchLinux。</p>
<blockquote>
<p>本部分可以参考MIT 6.828官网的<a href="https://pdos.csail.mit.edu/6.828/2017/tools.html" target="_blank" rel="external">Tools</a>。</p>
</blockquote>
<h3 id="编译工具链"><a href="#编译工具链" class="headerlink" title="编译工具链"></a>编译工具链</h3><p>编译工具链包含了C编译器、汇编器、连接器，用于从源代码生成可执行二进制文件。本实验的目标代码是32位的Intel架构（x86），可执行文件格式为ELF。</p>
<p>在Arch Linux下，若是在安装时选择了base-devel包组，则gcc应该是系统自带的编译工具链。但是，该gcc默认不能编译生成32位的可执行文件。需要手动开启<a href="https://wiki.archlinux.org/index.php/multilib" target="_blank" rel="external">multilib</a>并安装gcc-multilib以及相关的软件包。</p>
<h4 id="GCC版本降级说明"><a href="#GCC版本降级说明" class="headerlink" title="GCC版本降级说明"></a>GCC版本降级说明</h4><p>在我和华田的Arch下，使用gcc 7.1.1-3之后的版本编译生成的JOS kernel均无法使用。在无法查明原因的情况下，推荐将gcc降级至7.1.1-3完成6.828的实验。</p>
<p>有关于Arch下软件包降级的教程请看<a href="https://wiki.archlinux.org/index.php/downgrading_packages" target="_blank" rel="external">这里</a>。</p>
<p>在后续的实验中，为了使得编译JOS内核的工具链不和系统工具链冲突以及为了保证系统工具链的最新，尝试了手动编译32位的gcc 4.6.1作为JOS专用的交叉编译工具链，并使用modules来管理环境变量，具体可以参考<a href="http://blog.codedragon.tech/2018/02/01/gcc4-6-1%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8Amodules%E7%9A%84%E4%BD%BF%E7%94%A8/">这里</a>。</p>
<h3 id="Qemu模拟器"><a href="#Qemu模拟器" class="headerlink" title="Qemu模拟器"></a>Qemu模拟器</h3><p>QEMU是一个现代并且快速的PC模拟器，但是为了与实验兼容，MIT推荐使用他们patched过的QEMU版本。需要按照Tools上的教程从源码编译并安装QEMU。</p>
<p>注意：提供的QEMU并不支持<code>make uninstall</code>，需要手动卸载QEMU。如果您对于手动编译并安装可能存在的<strong>后果</strong>抱有顾虑，推荐使用包管理软件安装QEMU，或是修改编译前缀，不要将编译好的qemu安装到<code>/usr/local/</code>下</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li>所需要的库名可以在arch官网上通过搜索软件包的方式找到；</li>
<li>configure的时候加上–disable-werror以保证不会因出现编译警告而终止编译；</li>
<li><p>出现如下错误：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Unescaped left brace <span class="keyword">in</span> regex is illegal here <span class="keyword">in</span> regex; marked by &lt;-- HERE</div><div class="line"><span class="keyword">in</span> m/^\@strong&#123; &lt;-- HERE (.*)&#125;$/ at /home/guest/qemu/scripts/texi2pod.pl</div><div class="line">line 320.</div><div class="line"></div><div class="line">make: *** [Makefile:474：qemu.1] 错误 255。</div></pre></td></tr></table></figure>
<p> 该错误是由于perl版本更新后正则表达式语法的变动造成的，直接修改安装脚本的<code>/home/chenzhihao/qemu/scripts/texi2pod.pl line 320</code>，将<code>{</code>改成 <code>\{</code>即可；</p>
</li>
<li>configure时可能需要指定python版本为2以避免调用python3出现错误，参数为<code>--python=/usr/bin/python2.7</code>。</li>
</ol>
<h2 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h2><p>实验1总共分为3个部分：</p>
<ul>
<li>第1部分主要关注x86汇编语言、QEMU x86模拟器以及PC的上电启动流程；</li>
<li>第2部分主要关注6.828内核的引导程序；</li>
<li>第3部分开始挖掘6.828内核的最初模板 - JOS。</li>
</ul>
<p>实验使用Git进行版本管理，需要从MIT的Git克隆最开始的仓库，有关这一部分的具体说明请自行参考<a href="https://pdos.csail.mit.edu/6.828/2017/labs/lab1/" target="_blank" rel="external">Lab1实验讲义</a>。</p>
<p>有关于Git的教程推荐<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的官方博客</a>或者是<a href="https://www.gitbook.com/book/bingohuang/progit2/details" target="_blank" rel="external">Pro Git 2</a>。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="第一部分-PC-Bootstrap-PC引导"><a href="#第一部分-PC-Bootstrap-PC引导" class="headerlink" title="第一部分 PC Bootstrap - PC引导"></a>第一部分 PC Bootstrap - PC引导</h3><h4 id="x86汇编"><a href="#x86汇编" class="headerlink" title="x86汇编"></a>x86汇编</h4><p>练习1：<br>本实验需要熟悉x86汇编。</p>
<p>8086汇编已经在王爽的《汇编语言》以及学院的汇编语言课程中学习过，x86_64汇编也已经在《深入理解计算机系统》中有所涉猎。本实验中使用的是i386汇编。这里不再赘述。</p>
<h4 id="模拟x86"><a href="#模拟x86" class="headerlink" title="模拟x86"></a>模拟x86</h4><p>在本实验中使用QEMU作为模拟器。尽管QEMU内置的监控只能提供少量的调试支持，但是QEMU却可以作为GNU-Debugging（GDB）的远程调试目标。</p>
<p>根据实验指导使用make编译生成内核并且用<code>make qemu</code>或者是<code>make qemu-nox</code>启动QEMU。可以看到，当前的内核仅支持两条命令help和kerninfo。</p>
<h4 id="PC的物理地址空间"><a href="#PC的物理地址空间" class="headerlink" title="PC的物理地址空间"></a>PC的物理地址空间</h4><p>PC的物理地址空间有着如下的布局：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</div><div class="line">|      32-bit      |</div><div class="line">|  memory mapped   |</div><div class="line">|     devices      |</div><div class="line">|                  |</div><div class="line">/\/\/\/\/\/\/\/\/\/\</div><div class="line"></div><div class="line">/\/\/\/\/\/\/\/\/\/\</div><div class="line">|                  |</div><div class="line">|      Unused      |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- depends on amount of RAM</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">| Extended Memory  |</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- 0x00100000 (1MB)</div><div class="line">|     BIOS ROM     |</div><div class="line">+------------------+  &lt;- 0x000F0000 (960KB)</div><div class="line">|  16-bit devices, |</div><div class="line">|  expansion ROMs  |</div><div class="line">+------------------+  &lt;- 0x000C0000 (768KB)</div><div class="line">|   VGA Display    |</div><div class="line">+------------------+  &lt;- 0x000A0000 (640KB)</div><div class="line">|                  |</div><div class="line">|    Low Memory    |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- 0x00000000</div></pre></td></tr></table></figure>
<p>最初的PC基于Intel的16位8088处理器，仅能够支持2^20B = 2^10KB = 1MB的寻址，早期的地址空间从0x00000开始到0xFFFFF结束。</p>
<ul>
<li>0x00000到0xA0000（640KB）被称作低内存，是早期PC能用的唯一的RAM；</li>
<li>0xA0000到0xFFFFF（384KB）被硬件保留作特殊用途如视频缓冲区或是固件，该部分最重要的区域是从0xF0000到0xFFFFF（64KB）的基本输入输出系统（BIOS）。BIOS用作执行最基本的系统初始化如激活显卡、检查内存等。在初始化完成后，BIOS从软盘、硬盘、光驱或是网络中读取操作系统，并且将机器控制权转移给操作系统。</li>
</ul>
<p>从Intel的80286到80386，处理器能够支持16MB和4GB的地址空间。但为了后向兼容性，硬件设计者保留了低1M内存的布局。<br>现代PC因此在0x000A0000到0x00100000的内存中有一个“洞”，这个洞将内存分为了低内存/保留内存（Low Memory）（低640KB）以及扩展内存（Extended Memory）（其他内存）。除此以外，32位PC的地址空间的最上方，常常被BIOS保留用作32位的PCI设备。</p>
<p>最新的x86处理器能够支持超过4GB的物理内存，因此内存可以超过0xFFFFFFFF。因此BIOS需要预留出第二个“洞”以保证那些32位的PCI设备的地址可以被正确的映射。</p>
<p>由于JOS只会使用256M内存，在此假设仅PC具有32位的地址空间。</p>
<h4 id="ROM-BIOS"><a href="#ROM-BIOS" class="headerlink" title="ROM BIOS"></a>ROM BIOS</h4><p>根据实验指导，进行QEMU和GDB的联合调试。会发现从上电开始，IBM PC从0x000ffff0开始执行指令。该处位于为BIOS预留的64kb的空间的顶层。此时CS = 0xf000 IP = 0xfff0。且第1条指令是一个jmp指令，跳转至CS = 0xf000 IP = 0xe05b。</p>
<p>这些都是早期的8088处理器的设计者设计的。这样的设计保证了BIOS总能控制机器。因为在刚上电的时候，在内存中并不存在能够执行的代码。</p>
<blockquote>
<p>此处需要理解8086的分段式寻址，即通过两个16位寄存器的值构造20位地址。实际地址为CS × 16 + IP = 0xf000 × 16 + 0xfff0 = 0xffff0。</p>
</blockquote>
<p>练习2：<br>使用gdb的<code>si</code>（单步调试）命令进入ROM BIOS并追踪几条指令，并猜测这些指令的作用。不需要指出指令具体的细节，只要理解BIOS一开始运行的核心思想而已。</p>
<p>BIOS执行的前若干条指令和作用如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">[f000:fff0]    <span class="number">0xffff0</span>: ljmp   <span class="number">$0</span>xf000,<span class="number">$0</span>xe05b # 跳到一个较早的位置</div><div class="line">[f000:e05b]    <span class="number">0xfe05b</span>: cmpl   <span class="number">$0</span>x0,%cs:<span class="number">0x6ac8</span></div><div class="line">[f000:e062]    <span class="number">0xfe062</span>: <span class="keyword">jne</span>    <span class="number">0xfd2e1</span>         # 测试<span class="built_in">cs</span>段的<span class="number">0x6ac8</span>字是否为<span class="number">0</span>        </div><div class="line">[f000:e066]    <span class="number">0xfe066</span>: <span class="keyword">xor</span>    %dx,%dx         # 测试为<span class="number">0</span></div><div class="line">[f000:e068]    <span class="number">0xfe068</span>: <span class="keyword">mov</span>    %dx,%ss         </div><div class="line">[f000:e06a]    <span class="number">0xfe06a</span>: <span class="keyword">mov</span>    <span class="number">$0</span>x7000,%esp    # 设置栈段寄存器和栈指针寄存器</div><div class="line">                                               # 栈的延伸方向和代码段延伸方向相反</div><div class="line">[f000:e070]    <span class="number">0xfe070</span>: <span class="keyword">mov</span>    <span class="number">$0</span>xf34c2,%edx   # 设置<span class="built_in">edx</span>寄存器值</div><div class="line">[f000:e076]    <span class="number">0xfe076</span>: <span class="keyword">jmp</span>    <span class="number">0xfd15c</span>         # 跳转</div><div class="line">[f000:d15c]    <span class="number">0xfd15c</span>: <span class="keyword">mov</span>    %eax,%ecx       </div><div class="line">[f000:d15f]    <span class="number">0xfd15f</span>: <span class="keyword">cli</span>                    # 关闭硬件中断</div><div class="line">[f000:d160]    <span class="number">0xfd160</span>: <span class="keyword">cld</span>                    # 设置串传送指令方向</div><div class="line">[f000:d161]    <span class="number">0xfd161</span>: <span class="keyword">mov</span>    <span class="number">$0</span>x8f,%eax      </div><div class="line">[f000:d167]    <span class="number">0xfd167</span>: <span class="keyword">out</span>    %al,<span class="number">$0</span>x70       # 关闭不可屏蔽中断</div><div class="line">[f000:d169]    <span class="number">0xfd169</span>: <span class="keyword">in</span>     <span class="number">$0</span>x71,%al       # 从CMOS读取选择的寄存器</div><div class="line">[f000:d16b]    <span class="number">0xfd16b</span>: <span class="keyword">in</span>     <span class="number">$0</span>x92,%al       # 读取系统控制端口A</div><div class="line">[f000:d16d]    <span class="number">0xfd16d</span>: <span class="keyword">or</span>     <span class="number">$0</span>x2,%al        </div><div class="line">[f000:d16f]    <span class="number">0xfd16f</span>: <span class="keyword">out</span>    %al,<span class="number">$0</span>x92       # 通过快速A20以启动A20</div><div class="line">[f000:d171]    <span class="number">0xfd171</span>: lidtw  %cs:<span class="number">0x6ab8</span>      # 将<span class="built_in">cs</span>:<span class="number">0x6ab8</span>加载进入IDT表</div><div class="line">[f000:d177]    <span class="number">0xfd177</span>: lgdtw  %cs:<span class="number">0x6a74</span>      # 将<span class="built_in">cs</span>:<span class="number">0x6a74</span>加载进入GDT表</div><div class="line">[f000:d17d]    <span class="number">0xfd17d</span>: <span class="keyword">mov</span>    %cr0,%eax   </div><div class="line">[f000:d180]    <span class="number">0xfd180</span>: <span class="keyword">or</span>     <span class="number">$0</span>x1,%eax       </div><div class="line">[f000:d184]    <span class="number">0xfd184</span>: <span class="keyword">mov</span>    %eax,%cr0       # 将<span class="built_in">cr0</span>寄存器的保护模式位打开</div><div class="line">[f000:d187]    <span class="number">0xfd187</span>: ljmpl  <span class="number">$0</span>x8,<span class="number">$0</span>xfd18f   # 通过ljmp指令进入保护模式</div><div class="line">=&gt; <span class="number">0xfd18f</span>:     <span class="keyword">mov</span>    <span class="number">$0</span>x10,%eax              # 设置段寄存器</div><div class="line">=&gt; <span class="number">0xfd194</span>:     <span class="keyword">mov</span>    %eax,%ds</div><div class="line">=&gt; <span class="number">0xfd196</span>:     <span class="keyword">mov</span>    %eax,%es  </div><div class="line">=&gt; <span class="number">0xfd198</span>:     <span class="keyword">mov</span>    %eax,%ss</div><div class="line">=&gt; <span class="number">0xfd19a</span>:     <span class="keyword">mov</span>    %eax,%fs</div><div class="line">=&gt; <span class="number">0xfd19c</span>:     <span class="keyword">mov</span>    %eax,%gs</div><div class="line">=&gt; <span class="number">0xfd19e</span>:     <span class="keyword">mov</span>    %ecx,%eax  </div><div class="line">=&gt; <span class="number">0xfd1a0</span>:     <span class="keyword">jmp</span>    *%edx                   # 跳转</div></pre></td></tr></table></figure></p>
<h3 id="第二部分-引导"><a href="#第二部分-引导" class="headerlink" title="第二部分 引导"></a>第二部分 引导</h3><p>软盘和硬盘被分为了512Bytes的区域 - 扇区（Sector）。一个扇区是磁盘传输的最小粒度：每一个读操作和写操作必须是一个或是一个以上的扇区，并且必须要对齐到扇区。</p>
<p>如果一个磁盘是可引导的，那么它的第一个扇区就被称作引导扇区，引导代码就存储在引导扇区中。如果BIOS发现了一个可引导的硬件，那么它就将这个扇区从磁盘读取至内存的0x7c00到0x7dff处，并且使用一个jmp指令设置CS：IP = 0000:7C00，将控制传递给引导。和BIOS读取地址一样，这个地址对于PC来说是固定和标准化的。</p>
<blockquote>
<p>从光盘引导的情形更加复杂，因为光盘的一个扇区为2048Byte，BIOS可以从硬盘读取一个更大的引导镜像到内存中。</p>
</blockquote>
<p>在6.828中，使用硬盘的传统引导机制。这意味这引导必须满足512个Bytes的限制。引导由一个汇编文件boot/boot.S，以及一个C语言文件boot/main.c组成。</p>
<p>练习3：追踪boot.S和main.C，分析每一个部分的作用。</p>
<hr>
<p>为了理解boot.S，需要以下的知识储备。</p>
<h4 id="实模式和保护模式"><a href="#实模式和保护模式" class="headerlink" title="实模式和保护模式"></a>实模式和保护模式</h4><p>实模式是为了与8086兼容而设置的。在实模式下，处理器相当于一个快速的8086处理器。当处理器被加电或者复位时以实模式启动。</p>
<ul>
<li>实模式下各寄存器以实模式的初始化值工作；</li>
<li>实模式的地址空间总共为20位（1MB）；</li>
<li>实模式下不支持内存分页机制；</li>
<li>实模式下各内存段均是可读、可写、可执行的，不支持指令优先级，所有的指令均运行在特权级；</li>
<li>实模式不支持多任务切换；</li>
<li>实模式的中断处理也和8086相同，使用中断向量表来定位中断服务程序。</li>
</ul>
<p>在保护模式下，处理器的所有功能都是可用的。具体来说：</p>
<ul>
<li>保护模式提供了完全的32位地址空间，寻址空间为4GB；</li>
<li>保护模式支持内存分页机制，提供了对虚拟内存的硬件支持；</li>
<li>保护模式的处理器支持多任务（上下文切换）；</li>
<li>保护模式的处理器支持指令和数据的特权级，配合边界检查等机制，既可以共享数据也可以隔离各个任务。</li>
</ul>
<p>为了保证后向兼容性，x86的处理器启动时默认是实模式，需要手动从实模式切换至保护模式。但是切换至保护模式之前需要做一些必要的准备工作，如打开A20和建立全局描述符表等。</p>
<h4 id="A20地址线"><a href="#A20地址线" class="headerlink" title="A20地址线"></a>A20地址线</h4><p>在早期的PC上处理器仅支持20位的地址空间，任何超过20位的地址都会被卷回。<br>例如：0xFFFF+0xFFFF = 0x1FFFE -&gt; 0xFFFE</p>
<p>然而，从80286开始，Intel支持了24位的地址空间，上例的地址相加将不会发生卷回。<br>为了保证与早期PC的完全兼容，Intel采用了“黑魔法” - 将A20（第21根）地址线与键盘控制器的一个输出进行了与运算。进而控制A20地址线的值。</p>
<p>默认情况下，A20是置0的，PC将只能访问1M、3M、5M…这样的奇数段。进入保护模式前需要先打开A20以获得完全的寻址能力。</p>
<p>JOS内核通过端口的方式与键盘控制器进行通信并打开A20。可以参考Reference中的<a href="http://www.computer-engineering.org/ps2keyboard/" target="_blank" rel="external">PS/2 Keyboard Interface</a>。</p>
<ul>
<li>8042有一个1 Byte的输入缓冲区，一个1 Byte的输出缓冲区、一个1 Byte的状态寄存器、以及一个1 Byte的控制寄存器。前三个寄存器可以直接从0x60和0x64端口进行访问。最后一个寄存器通过“Read Command Byte”命令进行读，通过“Write Command Byte”命令进行写。</li>
<li>对0x60端口读会读输入缓冲区；对0x60端口写会写输出缓冲区；对0x64端口读会读状态寄存器；对0x64端口写会发送命令。</li>
<li>状态寄存器的Bit1为IBF - Input Buffer Full，当该Bit为1时，输入缓冲区满，不能对0x60端口或0x64端口写。</li>
<li>对0x64端口写0xd1发送的命令是“Write Output Port”写输出端口，表明将参数写入输出端口（0x60端口写）。</li>
<li>A20使用的是键盘控制器输出的Bit 1，向输出端口写入0xdf可以打开A20；向输出端口写入0xdd则会关闭A20。</li>
</ul>
<h4 id="分段机制与全局描述符表"><a href="#分段机制与全局描述符表" class="headerlink" title="分段机制与全局描述符表"></a>分段机制与全局描述符表</h4><p>x86处理器提供了分段机制和分页机制两种内存管理模式。如果要进入保护模式，就必须要先启动分段机制。（分页机制不是必须的）</p>
<p>分段机制将内存划分为若干个段，每个段都由段基址、段界限和段属性组成。由一个段描述符表（可以理解为一个数组）描述所有段的信息。段描述符表可以是全局的也可以是局部的。</p>
<p>简化的说，程序首先将对应的段选择子（可以理解为数组的索引）加载进入段寄存器中。然后在执行程序时，根据指令的内容确定应该使用的段寄存器，根据段寄存器中的段选择子确定应该使用的段描述符。再结合段描述符中包含的信息加上指令自身的地址构造出实际的物理地址。最终将该地址发送到地址总线上，到物理内存中寻址，并取回相应的数据。这之中简化了有关特权级、边界检查的相关内容，但足以描述分段机制的基本原理。</p>
<p>分段机制将虚拟地址转换成了线性地址。</p>
<h5 id="全局描述符表寄存器"><a href="#全局描述符表寄存器" class="headerlink" title="全局描述符表寄存器"></a>全局描述符表寄存器</h5><p>x86处理器提供了专门的全局描述符表寄存器（Global Descriptor Table Register）用于保存全局描述符表的表基址和表限长。GDTR由2个字节的表限长（limit）和4个字节的表基址（base）组成。其中表基址指定了全局描述符表的起始地址，表限长指定了全局描述符表的大小。其C结构体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdtr</span> &#123;</span></div><div class="line">	u16 limite;</div><div class="line">	u32 base;</div><div class="line">&#125; __attribute__ ((packed));</div></pre></td></tr></table></figure></p>
<p>在机器刚加电或者是处理器复位后，表基址默认被置为0，表限长则默认被置为0xFFFF。在保护模式初始化的过程中，必须给GDTR加载新的值。可以使用lgdt指令为GDTR加载新值。</p>
<h5 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h5><p>段选择子（2个字节）用于选择特定的描述符表以及表中的特定描述符。段选择子一般被放置于段寄存器中，段选择子由13位的索引、1位的表指示位和2位的请求特权级三部分组成。其中索引指定了描述符，表指示位选择应该访问的描述符表 - 0代表全局描述符表，1代表局部描述符表，请求特权级用于段级的保护机制，自0到4分别代表ring 0到ring 3。其C结构体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">selector</span> &#123;</span></div><div class="line">    u16 index:<span class="number">13</span>;</div><div class="line">    u16 ti:<span class="number">1</span>;</div><div class="line">    u16 rpl:<span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h5><p>段描述符（8个字节）是段描述符表这个“数组”的“元素”。用C结构体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdtdesc</span> &#123;</span></div><div class="line">	u16 lim0_15;</div><div class="line">	u16 base0_15;</div><div class="line">	u8 base16_23;</div><div class="line">	u8 acces;</div><div class="line">	u8 lim16_19:<span class="number">4</span>;</div><div class="line">	u8 other:<span class="number">4</span>;</div><div class="line">	u8 base24_31;</div><div class="line">&#125; __attribute__ ((packed));</div></pre></td></tr></table></figure></p>
<p>其中总共包含了32位的段基址、20位的段界限、以及12位的类型。<br>段基址规定了段的起始地址。段界限规定了段的大小。而类型用于区别不同类型的描述符。包括描述符特权级、段存在位、已访问位等等。</p>
<h4 id="boot-S代码详解"><a href="#boot-S代码详解" class="headerlink" title="boot.S代码详解"></a>boot.S代码详解</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">#include &lt;<span class="keyword">inc</span>/mmu.h&gt;</div><div class="line"></div><div class="line"># Start the <span class="meta">CPU</span>: switch to <span class="number">32</span>-bit protected mode, jump <span class="keyword">into</span> C.</div><div class="line"># The BIOS loads this code from the first sector of the hard disk <span class="keyword">into</span></div><div class="line"># memory <span class="meta">at</span> physical address <span class="number">0x7c00</span> <span class="keyword">and</span> starts executing <span class="keyword">in</span> real mode</div><div class="line"># with %cs=<span class="number">0</span> %ip=7c00.</div><div class="line"># boot.S 主要将<span class="meta">CPU</span>切换至<span class="number">32</span>位保护模式，并且跳转进入C代码</div><div class="line"><span class="meta"></span></div><div class="line">.set PROT_MODE_CSEG, <span class="number">0x8</span>         # kernel code <span class="meta">segment</span> selector</div><div class="line"><span class="meta">.set</span> PROT_MODE_DSEG, <span class="number">0x10</span>        # kernel data <span class="meta">segment</span> selector</div><div class="line"><span class="meta">.set</span> CR0_PE_ON,      <span class="number">0x1</span>         # protected mode enable flag</div><div class="line"><span class="meta"></span></div><div class="line">.globl start</div><div class="line"><span class="symbol">start:</span>                        # 程序入口</div><div class="line"><span class="meta">  .code16</span>                     # Assemble for <span class="number">16</span>-bit mode 指导生成<span class="number">16</span>位汇编代码</div><div class="line">  <span class="keyword">cli</span>                         # Disable interrupts 关中断</div><div class="line">  <span class="keyword">cld</span>                         # String operations increment 设置串传递顺序递增</div><div class="line"></div><div class="line">  # Set <span class="meta">up</span> the important data <span class="meta">segment</span> registers (<span class="built_in">DS</span>, <span class="built_in">ES</span>, <span class="built_in">SS</span>). 设置重要的段寄存器为<span class="number">0</span></div><div class="line">  xorw    %ax,%ax             # <span class="meta">Segment</span> number <span class="meta">zero</span></div><div class="line">  movw    %ax,%ds             # -&gt; Data <span class="meta">Segment</span></div><div class="line">  movw    %ax,%es             # -&gt; Extra <span class="meta">Segment</span></div><div class="line">  movw    %ax,%ss             # -&gt; Stack <span class="meta">Segment</span></div><div class="line"></div><div class="line">  # Enable A20:</div><div class="line">  #   For backwards compatibility with the earliest PCs, physical</div><div class="line">  #   address line <span class="number">20</span> is tied low, so that addresses higher than</div><div class="line">  #   1MB wrap around to <span class="meta">zero</span> by <span class="meta">default</span>.  This code undoes this.</div><div class="line">  # 开启A20：</div><div class="line">  #   A20的介绍已经给出，不再赘述。</div><div class="line"><span class="symbol">seta20.1:</span></div><div class="line">  inb     <span class="number">$0</span>x64,%al               # Wait for <span class="keyword">not</span> busy 等待缓冲区可用</div><div class="line">  testb   <span class="number">$0</span>x2,%al                # <span class="keyword">Test</span> for bit1</div><div class="line">                                  # if bit1 = <span class="number">1</span> then buffer is full</div><div class="line">  <span class="keyword">jnz</span>     seta20<span class="meta">.1</span></div><div class="line"></div><div class="line">  movb    <span class="number">$0</span>xd1,%al               # <span class="number">0xd1</span> -&gt; port <span class="number">0x64</span></div><div class="line">  outb    %al,<span class="number">$0</span>x64               # Prepare to write output port 准备写入输出端口</div><div class="line"><span class="symbol"></span></div><div class="line">seta20.2:</div><div class="line">  inb     <span class="number">$0</span>x64,%al               # Wait for <span class="keyword">not</span> busy 等待缓冲区可用</div><div class="line">  testb   <span class="number">$0</span>x2,%al</div><div class="line">  <span class="keyword">jnz</span>     seta20<span class="meta">.2</span>                # The same as above 同上</div><div class="line"></div><div class="line">  movb    <span class="number">$0</span>xdf,%al               # <span class="number">0xdf</span> -&gt; port <span class="number">0x60</span></div><div class="line">  outb    %al,<span class="number">$0</span>x60               # <span class="number">0xdf</span> -&gt; A20 gate enable command 打开A20</div><div class="line"></div><div class="line">  # Switch from real to protected mode, using a bootstrap GDT</div><div class="line">  # <span class="keyword">and</span> <span class="meta">segment</span> translation that makes virtual addresses</div><div class="line">  # identical to their physical addresses, so that the</div><div class="line">  # effective memory map does <span class="keyword">not</span> change during the switch.</div><div class="line">  <span class="keyword">lgdt</span>    gdtdesc                # Load gdt size/base to gdtr 设置全局描述符表</div><div class="line">  movl    %cr0, %eax             # Control register <span class="number">0</span></div><div class="line">                                 # bit0 is protected enable bit</div><div class="line">                                 # 读取控制寄存器<span class="number">0</span>的值，其Bit0为允许保护模式位</div><div class="line">  orl     $CR0_PE_ON, %eax       # Set PE 将允许保护模式位置<span class="number">1</span></div><div class="line">  movl    %eax, %cr0             # Update Control register <span class="number">0</span> 设置控制寄存器<span class="number">0</span></div><div class="line"></div><div class="line">  # Jump to next instruction, but <span class="keyword">in</span> <span class="number">32</span>-bit code <span class="meta">segment</span>.</div><div class="line">  # Switches processor <span class="keyword">into</span> <span class="number">32</span>-bit mode.</div><div class="line">  ljmp    $PROT_MODE_CSEG, $protcseg # 通过ljmp指令（跳转至下一条指令）进入保护模式</div><div class="line"><span class="meta"></span></div><div class="line">  .code32                     # Assemble for <span class="number">32</span>-bit mode 指导生成<span class="number">32</span>位汇编代码</div><div class="line"><span class="symbol">protcseg:</span></div><div class="line">  # Set <span class="meta">up</span> the protected-mode data <span class="meta">segment</span> registers 设置保护模式的数据段寄存器</div><div class="line">  movw    $PROT_MODE_DSEG, %ax    # Our data <span class="meta">segment</span> selector</div><div class="line">  movw    %ax, %ds                # -&gt; <span class="built_in">DS</span>: Data <span class="meta">Segment</span></div><div class="line">  movw    %ax, %es                # -&gt; <span class="built_in">ES</span>: Extra <span class="meta">Segment</span></div><div class="line">  movw    %ax, %fs                # -&gt; <span class="built_in">FS</span></div><div class="line">  movw    %ax, %gs                # -&gt; <span class="built_in">GS</span></div><div class="line">  movw    %ax, %ss                # -&gt; <span class="built_in">SS</span>: Stack <span class="meta">Segment</span></div><div class="line"></div><div class="line">  # Set <span class="meta">up</span> the stack pointer <span class="keyword">and</span> <span class="keyword">call</span> <span class="keyword">into</span> C. 设置栈指针并且调用C</div><div class="line">  movl    $start, %esp  # Stack has the opposite extension direction than Code</div><div class="line">                        # 注意栈的延伸方向和代码段相反</div><div class="line">  <span class="keyword">call</span> bootmain #调用main.c中的bootmain函数</div><div class="line"></div><div class="line">  # If bootmain returns (it shouldn<span class="string">'t), loop.</span></div><div class="line">spin:</div><div class="line">  jmp spin</div><div class="line"></div><div class="line"># Bootstrap GDT 引导GDT</div><div class="line">.p2align 2                                # force 4 byte alignment</div><div class="line">gdt:</div><div class="line">  SEG_NULL				# null seg 默认第一个段描述符为空</div><div class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)	# code seg 设置代码段描述符</div><div class="line">  SEG(STA_W, 0x0, 0xffffffff)	        # data seg 设置数据段描述符</div><div class="line">  # 关于SEG宏可以参考mmu.h</div><div class="line"></div><div class="line">gdtdesc:                                  # 用于设置全局段描述符寄存器</div><div class="line">  .word   0x17                            # sizeof(gdt) - 1 # Size of gdt</div><div class="line">  .long   gdt                             # address gdt # Base address of gdt</div></pre></td></tr></table></figure>
<hr>
<p>为了理解main.c，需要如下的知识储备。</p>
<h4 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h4><p>可执行和可链接格式（Executable and Linkable Format）是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。</p>
<p>ELF文件可以分为两种组成 - 链接视图（Linking View）和执行视图（Execution View）。这里只讨论执行视图。</p>
<p>执行视图的结构如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">+--------------------+</div><div class="line">|     ELF Header     |</div><div class="line">+--------------------+</div><div class="line">|Program Header Table|</div><div class="line">+--------------------+</div><div class="line">|      Segment 1     |</div><div class="line">+--------------------+</div><div class="line">|      Segment 2     |</div><div class="line">+--------------------+</div><div class="line">|         ...        |</div><div class="line">+--------------------+</div><div class="line">|Section Header Table|</div><div class="line">|       optinal      |</div><div class="line">+--------------------+</div></pre></td></tr></table></figure></p>
<p>ELF文件格式主要由ELF头（ELF Header）、程序头部表（Program Header Table）和节头部表（Section Header Table）组成。在执行视图中，节头部表是可选的。</p>
<p>有关于这些数据结构的C语言定义可以参考头文件<inc elf.h="">。</inc></p>
<ul>
<li>ELF头主要包含了ELF魔数、文件类型、程序头部表偏移和大小、程序入口等信息；</li>
<li>程序头部表可以看做一个数据结构的数组，每一个元素都描述了一个段。主要包含了段的偏移、段的虚拟地址、段的物理地址、段的大小等信息。</li>
</ul>
<h4 id="磁盘控制器"><a href="#磁盘控制器" class="headerlink" title="磁盘控制器"></a>磁盘控制器</h4><p>磁盘是电脑主要的存储媒介。磁盘是由盘片构成的。每个盘片有两面或者称为表面，表面覆盖着磁性记录材料。盘片中央有一个可以旋转的主轴，它使得盘片以固定的旋转速率旋转，通常是5400-15000转每分钟（Revolution Per Minute）。磁盘通常包含一个或多个这样的盘片，并封装在一个密封的容器内。</p>
<p>每一个表面是由一组称为磁道的同心圆组成。每个磁道被划分为一组扇区。每个扇区包含相等数量的数据位（通常是512字节），这些数据编码在扇区上的磁性材料中。扇区之间由一些间隙分隔开，这些间隙中不存储数据位。间隙用来标识扇区的格式化位。</p>
<p>磁盘的柱面是所有盘片表面上到主轴中心距离相等的磁道的集合。</p>
<p>对于磁盘的寻址通常分为CHS和LBA两种。</p>
<ol>
<li>CHS即柱面（cylinder）-磁头（head）-扇区（sector）寻址。每个盘片都对应着一个磁头，每一个盘片都被划分成柱面，每一个柱面都被划分成多个段。磁盘的最小存储单元是段。早期的IBM PC架构上采用CHS进行磁盘寻址。CHS是一个三元组，包括10bit的柱面号，8bit的磁头号以及6bit的扇区号。这样CHS的最大寻址范围为2^10 × 2^8 × 2^6 × 512 = 8GB。</li>
<li>随着磁盘容量的不断扩大，CHS的8GB寻址范围已经不能满足需要，现在的磁盘普遍采用逻辑区块地址（Logical Block Adress）的方式进行寻址来进行抽象。LBA是一个整数，代表磁盘上的一个逻辑区块编号，通过将这个整数转换成CHS格式来完成磁盘的具体寻址。LBA为48个bit，最大寻址范围为128PB。在本实验中，LBA按照旧的规范采用28个bit。</li>
</ol>
<p>IDE硬盘控制器（IDE Hard Drive Controller）的0x1F7端口读为磁盘0状态寄存器。<br>其Bit6为RDY Bit，当其置1表明磁盘上电完成。在对于磁盘做任何操作（除了复位）之前务必要保证该Bit为1。<br>其Bit7为BSY Bit，当其置1表明磁盘忙。在你向磁盘发送任何指令前务必保证该Bit为0。</p>
<p>通过IDE硬盘控制器读取扇区需要如下的步骤：</p>
<ol>
<li>向0x1F2端口写入待操作的扇区数目；</li>
<li>向0x1F3-0x1F5端口依次写入LBA的低24位；</li>
<li>向0x1F6端口的低4位写入LBA的高4位，向0x1F6端口的高4位写入驱动器地址；</li>
<li>向0x1F7端口写入读命令0x20。</li>
</ol>
<p>0x1F6寄存器又称Drive/Head寄存器。其低4位是LBA的高4位。其Bit5和Bit7一般是1。其Bit6为LBA位，当置1时表示启用LBA寻址。其Bit4为DRV位。用来选择驱动器，Master驱动器为0，Slave驱动器为1。这里将高4位置为0x1110</p>
<p>在使用读命令0x20之前需要完整的设置柱面/磁头/扇区。当这个命令完成，你可以从磁盘的数据寄存器（0x1F0端口）读取256个字（16Bits）。</p>
<h4 id="main-c代码详解"><a href="#main-c代码详解" class="headerlink" title="main.c代码详解"></a>main.c代码详解</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/elf.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/x86.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/**********************************************************************</span></div><div class="line"> * This a dirt simple boot loader, whose sole job is to boot</div><div class="line"> * an ELF kernel image from the first IDE hard disk.</div><div class="line"> *</div><div class="line"> * DISK LAYOUT</div><div class="line"> *  * This program(boot.S and main.c) is the bootloader.  It should</div><div class="line"> *    be stored in the first sector of the disk.</div><div class="line"> *</div><div class="line"> *  * The 2nd sector onward holds the kernel image.</div><div class="line"> *</div><div class="line"> *  * The kernel image must be in ELF format.</div><div class="line"> *</div><div class="line"> * BOOT UP STEPS</div><div class="line"> *  * when the CPU boots it loads the BIOS into memory and executes it</div><div class="line"> *</div><div class="line"> *  * the BIOS intializes devices, sets of the interrupt routines, and</div><div class="line"> *    reads the first sector of the boot device(e.g., hard-drive)</div><div class="line"> *    into memory and jumps to it.</div><div class="line"> *</div><div class="line"> *  * Assuming this boot loader is stored in the first sector of the</div><div class="line"> *    hard-drive, this code takes over...</div><div class="line"> *</div><div class="line"> *  * control starts in boot.S -- which sets up protected mode,</div><div class="line"> *    and a stack so C code then run, then calls bootmain()</div><div class="line"> *</div><div class="line"> *  * bootmain() in this file takes over, reads in the kernel and jumps to it.</div><div class="line"> **********************************************************************/</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTSIZE 512</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELFHDR ((struct Elf *)0x10000)    <span class="comment">// scratch space</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">uint32_t</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readseg</span><span class="params">(<span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bootmain</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></div><div class="line"></div><div class="line">    <span class="comment">// read 1st page off disk 从磁盘上读取第一页</span></div><div class="line">    readseg((<span class="keyword">uint32_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// is this a valid ELF? 通过ELF魔数确认ELF有效</span></div><div class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) <span class="keyword">goto</span> bad;</div><div class="line"></div><div class="line">    <span class="comment">// load each program segment (ignores ph flags) 读取各个段</span></div><div class="line">    ph = (struct Proghdr *)((<span class="keyword">uint8_t</span> *)ELFHDR + ELFHDR-&gt;e_phoff);</div><div class="line">    <span class="comment">// 程序头部表的起始地址</span></div><div class="line">    eph = ph + ELFHDR-&gt;e_phnum;    <span class="comment">// 程序头部表的结束地址</span></div><div class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph++)</div><div class="line">        <span class="comment">// p_pa is the load address of this segment (as well</span></div><div class="line">        <span class="comment">// as the physical address)</span></div><div class="line">        <span class="comment">// p_pa是加载地址也是物理地址</span></div><div class="line">        readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</div><div class="line"></div><div class="line">    <span class="comment">// call the entry point from the ELF header 从ELF头调用程序入口</span></div><div class="line">    <span class="comment">// note: does not return!</span></div><div class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry))();</div><div class="line"></div><div class="line">bad:</div><div class="line">    <span class="comment">// stops simulation and breaks into the debug console</span></div><div class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</div><div class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">/* do nothing */</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.</span></div><div class="line"><span class="comment">// 从内核的offset处读取count个字节到物理地址pa处</span></div><div class="line"><span class="comment">// Might copy more than asked 可能会读取超过count个（扇区对齐）</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readseg</span><span class="params">(<span class="keyword">uint32_t</span> pa, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span> </span>&#123;</div><div class="line">    <span class="keyword">uint32_t</span> end_pa;</div><div class="line"></div><div class="line">    end_pa = pa + count;    <span class="comment">// 结束物理地址</span></div><div class="line"></div><div class="line">    <span class="comment">// round down to sector boundary 对齐到扇区</span></div><div class="line">    pa &amp;= ~(SECTSIZE - <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="comment">// translate from bytes to sectors, and kernel starts at sector 1</span></div><div class="line">    offset =</div><div class="line">        (offset / SECTSIZE) + <span class="number">1</span>;    <span class="comment">// 算出扇区数 注意扇区从1开始（0为引导扇区）</span></div><div class="line"></div><div class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></div><div class="line">    <span class="comment">// We'd write more to memory than asked, but it doesn't matter --</span></div><div class="line">    <span class="comment">// we load in increasing order.</span></div><div class="line">    <span class="comment">// 在实际中往往将多个扇区一起读出以提高效率。</span></div><div class="line">    <span class="keyword">while</span> (pa &lt; end_pa) &#123;</div><div class="line">        <span class="comment">// Since we haven't enabled paging yet and we're using</span></div><div class="line">        <span class="comment">// an identity segment mapping (see boot.S), we can</span></div><div class="line">        <span class="comment">// use physical addresses directly.  This won't be the</span></div><div class="line">        <span class="comment">// case once JOS enables the MMU.</span></div><div class="line">        <span class="comment">// 考虑到没有开启分页以及boot.S中使用了一一对应的映射规则，</span></div><div class="line">        <span class="comment">// 加载地址和物理地址是一致的。</span></div><div class="line">        readsect((<span class="keyword">uint8_t</span> *)pa, offset);</div><div class="line">        pa += SECTSIZE;</div><div class="line">        offset++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitdisk</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="comment">// wait for disk reaady 等待磁盘准备完毕。</span></div><div class="line">    <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>) <span class="comment">/* do nothing */</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> offset)</span> </span>&#123;</div><div class="line">    <span class="comment">// wait for disk to be ready</span></div><div class="line">    waitdisk();</div><div class="line"></div><div class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);    <span class="comment">// count = 1 0x1F2 Disk 0 sector count</span></div><div class="line">    <span class="comment">// Read one sector each time</span></div><div class="line">    outb(<span class="number">0x1F3</span>, offset);    <span class="comment">// Disk 0 sector number (CHS Mode)</span></div><div class="line">    <span class="comment">// First sector's number</span></div><div class="line">    outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>);     <span class="comment">// Cylinder low (CHS Mode)</span></div><div class="line">    outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>);    <span class="comment">// Cylinder high (CHS Mode)</span></div><div class="line">    <span class="comment">// Cylinder number</span></div><div class="line">    outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);    <span class="comment">// Disk 0 drive/head</span></div><div class="line">    <span class="comment">// MASK 11100000</span></div><div class="line">    <span class="comment">// Drive/Head Register: bit 7 and bit 5 should be set to 1</span></div><div class="line">    <span class="comment">// Bit6: 1 LBA mode, 0 CHS mode</span></div><div class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);    <span class="comment">// cmd 0x20 - read sectors</span></div><div class="line">    <span class="comment">/*20H       Read sector with retry. NB: 21H = read sector</span></div><div class="line">                without retry. For this command you have to load</div><div class="line">                the complete circus of cylinder/head/sector</div><div class="line">                first. When the command completes (DRQ goes</div><div class="line">                active) you can read 256 words (16-bits) from the</div><div class="line">                disk's data register. */</div><div class="line"></div><div class="line">    <span class="comment">// wait for disk to be ready</span></div><div class="line">    waitdisk();</div><div class="line"></div><div class="line">    <span class="comment">// read a sector</span></div><div class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);</div><div class="line">    <span class="comment">// Data register: data exchange with 8/16 bits</span></div><div class="line">    <span class="comment">// insl port addr cnt: read cnt dwords from the input port</span></div><div class="line">    <span class="comment">// specified by port into the supplied output array addr.</span></div><div class="line">    <span class="comment">// dword: 4 bytes = 16 bits</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>练习3：</p>
<ol>
<li>0x7c2d: ljmp  $0x8, $0x7c32 从这句汇编指令之后处理器开始执行32位指令。ljmp指令导致了16位指令到32位指令的转变。</li>
<li>引导最后执行的指令是call *0x10018，内核的第一条指令是movw $0x1234,0x472。</li>
<li>内核的第一条指令位于0x10000c。</li>
<li>引导从程序头部表中得到段的数目以及每个段的大小，以此决定要从磁盘上读出多少个扇区。</li>
</ol>
<h4 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h4><p>本部分主要需要了解.text段.rodata段和.data段，并且使用objdump读取ELF格式的信息。</p>
<p>boot/Makefrag文件中指定了引导的text段的位置为0x7c00。</p>
<p>练习4：<br>阅读并学习关于C语言指针的知识。下载pointer.c，编译运行并确保理解它。</p>
<p>pointer.c的代码和解释如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>  a[<span class="number">4</span>];    <span class="comment">// 含有4个元素的整形数组</span></div><div class="line">    <span class="keyword">int</span> *b =</div><div class="line">        <span class="built_in">malloc</span>(<span class="number">16</span>);    <span class="comment">// 分配16个字节的内存，并且用一个整形指针指向内存首地址</span></div><div class="line">    <span class="keyword">int</span> *c;    <span class="comment">// 一个悬挂的整形指针</span></div><div class="line">    <span class="keyword">int</span>  i;    <span class="comment">// 一个整形数</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"1: a = %p, b = %p, c = %p\n"</span>, a, b, c);</div><div class="line">    <span class="comment">// 打印a和b和c的地址，分别为0xff9bebcc, 0x566fc160和0xf7ede1e8</span></div><div class="line"></div><div class="line">    c = a;</div><div class="line">    <span class="comment">// 令c指向数组a的首地址</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) a[i] = <span class="number">100</span> + i;    <span class="comment">// 为a[0]到a[3]分配100-103</span></div><div class="line">    c[<span class="number">0</span>] = <span class="number">200</span>;                                <span class="comment">// 将c[0]也就是a[0]改为200</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>],</div><div class="line">           a[<span class="number">3</span>]);</div><div class="line">    <span class="comment">// 输出200 101 102 103</span></div><div class="line"></div><div class="line">    c[<span class="number">1</span>]     = <span class="number">300</span>;    <span class="comment">// 将c[1]也就是a[1]改为300</span></div><div class="line">    *(c + <span class="number">2</span>) = <span class="number">301</span>;    <span class="comment">//将*(c + 2)也就是a[2]改为301</span></div><div class="line">    <span class="number">3</span> [c]    = <span class="number">302</span>;    <span class="comment">// 将3[c]也就是c[3]改为302</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>],</div><div class="line">           a[<span class="number">3</span>]);</div><div class="line">    <span class="comment">// 输出200 300 301 302</span></div><div class="line"></div><div class="line">    c  = c + <span class="number">1</span>;    <span class="comment">// 令c指向a[1]</span></div><div class="line">    *c = <span class="number">400</span>;      <span class="comment">// 将a[1]改为400</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>],</div><div class="line">           a[<span class="number">3</span>]);</div><div class="line">    <span class="comment">// 输出200 400 301 302</span></div><div class="line"></div><div class="line">    c = (<span class="keyword">int</span> *)((<span class="keyword">char</span> *)c + <span class="number">1</span>);</div><div class="line">    <span class="comment">// 将c先转换为char指针指向下一个字节后再转回int指针</span></div><div class="line">    <span class="comment">// 现在a数组的字节分布为（小端）C8000000 90010000 2D010000 2E010000</span></div><div class="line">    | (c的指针)*c = <span class="number">500</span>;</div><div class="line">    <span class="comment">// 执行后的a数组字节分布（小端）C8000000 90F40100 00010000 2E010000</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>],</div><div class="line">           a[<span class="number">3</span>]);</div><div class="line">    <span class="comment">// 输出200 128144 256 302</span></div><div class="line"></div><div class="line">    b = (<span class="keyword">int</span> *)a + <span class="number">1</span>;</div><div class="line">    <span class="comment">// 将b指向a[1]</span></div><div class="line">    c = (<span class="keyword">int</span> *)((<span class="keyword">char</span> *)a + <span class="number">1</span>);</div><div class="line">    <span class="comment">// 将a先转换为char指针指向下一个字节后再转回int指针</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"6: a = %p, b = %p, c = %p\n"</span>, a, b, c);</div><div class="line">    <span class="comment">// 输出0xff9bebcc, 0xff9bebd0和0xff9bebcd</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> ac, <span class="keyword">char</span> **av)</span> </span>&#123;</div><div class="line">    <span class="comment">// 函数入口</span></div><div class="line">    f();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>练习5：<br>修改了text段的加载地址使得汇编代码中的跳转地址出现错误，进而导致整个引导因为错误提前终止。</p>
<p>练习6：<br>结果是非常显然的，因为引导的作用就是将内核从磁盘加载进入内存中。使用objdump -h obj/kern/kernel可以看到如下的信息：<br>0 .text         00001809  f0100000  00100000  00001000  2**4<br>                CONTENTS, ALLOC, LOAD, READONLY, CODE<br>可以直到内核的text段会被加载至内存中0x100000（物理地址）处。</p>
<h3 id="第三部分-内核"><a href="#第三部分-内核" class="headerlink" title="第三部分 内核"></a>第三部分 内核</h3><h4 id="使用虚拟内存去解决位置依赖"><a href="#使用虚拟内存去解决位置依赖" class="headerlink" title="使用虚拟内存去解决位置依赖"></a>使用虚拟内存去解决位置依赖</h4><p>可以发现内核将自己链接至了非常高的虚拟地址，比如0xf0100000，为了将处理器虚拟地址的较低部分给用户程序去使用。将在下一个实验介绍这一现象。</p>
<p>实际上，许多的机器在物理内存中并没有0xf0100000这样的高地址。实际上由处理器的内存管理硬件将虚拟地址0xf0100000映射到了实际内存中的物理地址0x100000。</p>
<p>这涉及了分页机制以及页表。<br>在kern/entry.S设置CR0_PG标记之前，内存引用被当做线性地址。实际上，由于在boot/boot.S设置了线性地址到物理地址的一致映射，所以线性地址在这里可以等同于物理地址。<br>当CR0_PG标记被设置了之后，所有的内存引用都被当作虚拟地址。虚拟地址通过虚拟内存硬件被翻译成物理地址。<br>kern/entrypgdir.c将0xf0000000到0xf0400000的虚拟地址翻译为物理地址的0x000000到0x400000，也将0x00000000到0x00400000的虚拟地址翻译为物理地址的0x00000000到0x00400000。<br>引用这些地址范围以外的虚拟地址将会抛出缺页的异常。<br>但是还没有为该异常设置中断处理程序。这会导致QEMU导出机器状态并退出。</p>
<p>练习7：<br>在movl %eax, %cr0指令（启动页表）之前，0x00100000出的内存不为空，0xf0100000出的内存全为0。<br>当stepi之后，0xf0100000处的内存和0x00100000处的内存完全一样。这表明已经成功启用了页表，并且完成了地址的映射。</p>
<h4 id="控制台的格式化字符串"><a href="#控制台的格式化字符串" class="headerlink" title="控制台的格式化字符串"></a>控制台的格式化字符串</h4><p>练习8：<br>缺失的代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</div><div class="line">	num = getuint(&amp;ap, lflag);</div><div class="line">base = <span class="number">8</span></div><div class="line"><span class="keyword">goto</span> number;</div></pre></td></tr></table></figure></p>
<ol>
<li>console.c提供了基本的I/O操作，同时封装了cputchar、getchar等函数供printf.c中的printf使用。printf使用了vprintfmt去解析格式化字符串并提供可变参数的特性。</li>
<li>这段代码主要实现了换行。其首先检查了当前的光标是否超过了最大值，如果是，则证明需要进行换行。其将第1行到第MAX-1行的内容复制到第0行到第MAX-2行所在的内存中，然后将第MAX-1行置空。最后将光标设置到新一行的开始。</li>
<li>fmt指向了格式化字符串”x %d, y %x, z %d\n”<br>ap指向了局部变量并且初始值为1<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">vcprintf(<span class="number">0xf0102449</span>, <span class="number">0xf0110e14</span>);</div><div class="line"><span class="number">0xf0102449</span> -&gt; <span class="string">"x %d, y %x, z %d\n"</span> <span class="number">0xf0110e14</span> -&gt; <span class="number">1</span></div><div class="line">cons_putc(<span class="number">120</span>);</div><div class="line">cons_putc(<span class="number">32</span>);</div><div class="line">va_arg(<span class="number">0xf0110dbc</span>, <span class="keyword">int</span>);</div><div class="line">Before: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e14</span> -&gt; <span class="number">1</span></div><div class="line">After: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e18</span> -&gt; <span class="number">3</span></div><div class="line">cons_putc(<span class="number">49</span>);</div><div class="line">cons_putc(<span class="number">44</span>);</div><div class="line">cons_putc(<span class="number">32</span>);</div><div class="line">cons_putc(<span class="number">121</span>);</div><div class="line">cons_putc(<span class="number">32</span>);</div><div class="line">va_arg(<span class="number">0xf0110dbc</span>, <span class="keyword">int</span>);</div><div class="line">Before: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e18</span> -&gt; <span class="number">3</span></div><div class="line">After: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e1c</span> -&gt; <span class="number">4</span></div><div class="line">cons_putc(<span class="number">51</span>);</div><div class="line">cons_putc(<span class="number">44</span>);</div><div class="line">cons_putc(<span class="number">32</span>);</div><div class="line">cons_putc(<span class="number">122</span>);</div><div class="line">cons_put(<span class="number">32</span>);</div><div class="line">va_arg(<span class="number">0xf0110dbc</span>, <span class="keyword">int</span>);</div><div class="line">Before: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e1c</span> -&gt; <span class="number">4</span></div><div class="line">After: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e20</span> -&gt; <span class="number">536870922</span></div><div class="line">cons_put(<span class="number">52</span>);</div><div class="line">cons_put(<span class="number">10</span>);</div></pre></td></tr></table></figure>
注意这里va_arg是宏而不是函数，不能通过加断点的方式跟踪。我采用的方法是在调用va_arg的地方添加断点并跟踪。<br>在GNUmakefile中的C_FLAGS -O1会重排C代码，导致了追踪va_arg变得困难。所以，仅在此处将-O1变成-O0，尽管这会导致在backtrace时kernel panic。</li>
<li>57616 = 0xe110。此外，根据x86的小端序，&amp;i指向了byte序列0x72、0x6c、0x64、0x00。这等同于字符串”rld”。所以，最终的输出为”He110 World”。<br>需要将i改为0x726c6400。不需要修改57616。</li>
<li>这是由于程序从格式化字符串中推断出了应当有3个参数，所以程序会从cprintf的栈中多读取一个参数。但实际上只有2个参数。所以最后一个参数是未指定的。</li>
<li>vcprintf(…, const char * fmt)。</li>
</ol>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>练习9：<br>f0100034:    bc 00 00 11 f0           mov    $0xf0110000,%esp<br>这一条指令初始化了引导栈，它位于0xf0110000处。内核仅通过设置esp寄存器的值为栈预留空间。栈指针指向高地址，并且栈自高地址向低地址延伸。</p>
<p>练习10：<br>本题考察了x86架构下的栈帧与函数调用。<br>函数调用时先将返回地址压栈，然后跳转至目标函数的起始地址；在目标函数内先将ebp寄存器的值（栈底）压栈保存，然后再将栈顶指针设置为新的栈底；<br>在函数中调用函数需要使用栈来传递参数，即将函数的参数以此压入栈中；<br>test_backtrace函数的汇编中使用了ebx寄存器，该寄存器为被调用者保存的寄存器，在使用的时候也要先压栈保存，再函数返回时恢复；<br>函数返回的时候通过先操作esp释放栈资源，然后恢复相应的被调用者保存的寄存器的值，最后调用汇编指令leave、ret返回；<br>leave指令先将esp的值置为ebp，然后再从栈中取出被保存的ebp的旧值；ret从栈中取出返回地址并跳转。</p>
<p>练习10-12：<br>mon_backtrace的实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mon_backtrace</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span> </span>&#123;</div><div class="line">    <span class="keyword">uint32_t</span>            ebp, eip, args[<span class="number">5</span>];</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></div><div class="line">    cprintf(<span class="string">"Stack backtrace:\n"</span>);</div><div class="line">    <span class="keyword">for</span> (ebp = read_ebp(); ebp != <span class="number">0</span>; ebp = *((<span class="keyword">uint32_t</span> *)ebp)) &#123;</div><div class="line">        eip = *((<span class="keyword">uint32_t</span> *)ebp + <span class="number">1</span>);</div><div class="line">        debuginfo_eip(eip, &amp;info);</div><div class="line">        args[<span class="number">0</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">2</span>);</div><div class="line">        args[<span class="number">1</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">3</span>);</div><div class="line">        args[<span class="number">2</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">4</span>);</div><div class="line">        args[<span class="number">3</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">5</span>);</div><div class="line">        args[<span class="number">4</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">6</span>);</div><div class="line">        cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>, ebp,</div><div class="line">                eip, args[<span class="number">0</span>], args[<span class="number">1</span>], args[<span class="number">2</span>], args[<span class="number">3</span>], args[<span class="number">4</span>]);</div><div class="line">        cprintf(<span class="string">"      %s:%d: %.*s+%d\n"</span>, info.eip_file, info.eip_line,</div><div class="line">                info.eip_fn_namelen, info.eip_fn_name, eip - info.eip_fn_addr);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>查阅STABS文档可以知道表示行号的成员是n_desc，所以debuginfo_eip的缺失的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</div><div class="line"><span class="keyword">if</span> (lline &lt;= rline) &#123;</div><div class="line">    info-&gt;eip_line = stabs[lline].n_desc;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>修改后的commands结构体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span> <span class="title">commands</span>[] = &#123;</span></div><div class="line">   &#123; <span class="string">"help"</span>, <span class="string">"Display this list of commands"</span>, mon_help &#125;,</div><div class="line">   &#123; <span class="string">"kerninfo"</span>, <span class="string">"Display information about the kernel"</span>, mon_kerninfo &#125;,</div><div class="line">   &#123; <span class="string">"backtrace"</span>, <span class="string">"Display information about the stack frames"</span>, mon_backtrace &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="提高-允许控制台输出不同颜色的文本"><a href="#提高-允许控制台输出不同颜色的文本" class="headerlink" title="提高 - 允许控制台输出不同颜色的文本"></a>提高 - 允许控制台输出不同颜色的文本</h4><p>要求能增强控制台的功能使得控制台可以输出不同颜色的字体。这里使用了传统的实现，解析嵌入在文本字符串中的ANSI转义序列来实现题目的要求。</p>
<p>在王爽的《汇编语言》中，已经接触过了字符的“属性字节”，一个字符的自低到高的第2个字节可以作为属性字节，用来指示字符的属性如闪烁、高亮、前景色、背景色等。<br>有关于ANSI转义序列的相关知识可以参考<a href="http://rrbrandt.dee.ufcg.edu.br/en/docs/ansi/" target="_blank" rel="external">这里</a>。</p>
<p>出于简化考虑，只部分实现ANSI转义序列中的<code>ESC[Ps;...;Psm</code>。</p>
<p>实现的思路是实现<code>&lt;kern/printf.c&gt;</code>中的punch函数的替代版本attribute_punch，来实现对于ANSI转义序列的解析，并且相应地设置字符的属性字节。</p>
<p>解析所需要的状态机具有三个状态：A_NORM代表正常的输出字符的状态、A_TRANS代表接收到[ESC]开始，从正常状态到解析转义序列的过渡状态、A_ESCAPE代表解析转义序列的状态。它们之间的状态转换图如图所示：</p>
<img src="/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/ansi_stm.png" alt="ansi_stm.png" title="">
<p>value用来存储每一个解析到的值，temp代表了解析过程中临时的属性字节，attribute代表了当前打印字符时附加的属性字节。</p>
<p>具体的实现代码在<kern printf.c="">中：</kern></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// state for ANSI escape sequence interpretation</span></div><div class="line"><span class="keyword">enum</span> &#123; A_NORM = <span class="number">0</span>, A_TRANS, A_ESCAPE &#125;;</div><div class="line"></div><div class="line"><span class="comment">// colormap - number (x - 30/40)[0, 7] -&gt; attribute byte</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> colormap[<span class="number">8</span>] = &#123;</div><div class="line">    <span class="number">0x0000</span>, <span class="number">0x4400</span>, <span class="number">0x2200</span>, <span class="number">0x6600</span>, <span class="number">0x1100</span>, <span class="number">0x5500</span>, <span class="number">0x3300</span>, <span class="number">0x7700</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attribute_punch</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> *cnt)</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> value     = <span class="number">0</span>;         <span class="comment">// value</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> state     = A_NORM;    <span class="comment">// current state</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> temp      = <span class="number">0x0000</span>,</div><div class="line">               attribute = <span class="number">0x0000</span>;    <span class="comment">// temp attribute, current attribute</span></div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (state) &#123;    <span class="comment">// state machine</span></div><div class="line">        <span class="keyword">case</span> A_NORM:</div><div class="line">            <span class="keyword">if</span> (ch == <span class="number">0x1B</span>) &#123;       <span class="comment">// [ESC]</span></div><div class="line">                state = A_TRANS;    <span class="comment">// transfer from A_NORM to A_TRANS</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                cputchar((attribute &amp; <span class="number">0xFF00</span>) |</div><div class="line">                         ch);    <span class="comment">// put character with attribute</span></div><div class="line">                *cnt++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> A_TRANS:</div><div class="line">            <span class="keyword">if</span> (ch == <span class="string">'['</span>) &#123;         <span class="comment">// [</span></div><div class="line">                state = A_ESCAPE;    <span class="comment">// transfer from A_TRANS to A_ESCAPE</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                state = A_NORM;    <span class="comment">// transfer from A_TRANS to A_NORM</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> A_ESCAPE:</div><div class="line">            <span class="keyword">if</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;    <span class="comment">// digit - update value</span></div><div class="line">                value = value * <span class="number">10</span> + ch - <span class="string">'0'</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">';'</span> ||</div><div class="line">                       ch == <span class="string">'m'</span>) &#123;    <span class="comment">// ; or m set temp and clear value</span></div><div class="line">                <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</div><div class="line">                    temp = colormap[<span class="number">0</span>];</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == <span class="number">5</span>) &#123;</div><div class="line">                    temp |= <span class="number">0x8000</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="number">30</span> &amp;&amp; value &lt;= <span class="number">38</span>) &#123;</div><div class="line">                    temp |= colormap[value - <span class="number">30</span>] &amp;</div><div class="line">                            <span class="number">0x0700</span>;    <span class="comment">// look up in color map</span></div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="number">40</span> &amp;&amp; value &lt;= <span class="number">48</span>) &#123;</div><div class="line">                    temp |=</div><div class="line">                        colormap[value - <span class="number">40</span>] &amp; <span class="number">0x7000</span>;    <span class="comment">// avoid complex cases</span></div><div class="line">                &#125;</div><div class="line">                value = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span> (ch == <span class="string">'m'</span>) &#123;    <span class="comment">// m needed extra work - update attribute</span></div><div class="line">                    attribute = temp;</div><div class="line">                    temp      = <span class="number">0x0000</span>;</div><div class="line">                    state     = A_NORM;    <span class="comment">// transfer from A_ESCAPE to A_NORM</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;               <span class="comment">// non_digit nor m</span></div><div class="line">                state = A_NORM;    <span class="comment">// transfer from A_ESCAPE to A_NORM</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vcprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// vprintfmt((void*)putch, &amp;cnt, fmt, ap);</span></div><div class="line">    <span class="comment">// use attribute_punch rather than punch</span></div><div class="line">    vprintfmt((<span class="keyword">void</span> *)attribute_punch, &amp;cnt, fmt, ap);</div><div class="line">    <span class="keyword">return</span> cnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后在monitor.c中添加相关cprintf代码，并重新编译测试。最终如图所示：</p>
<img src="/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/lab1_final.png" alt="lab1_final.png" title="">
<p>有关于实验指导中提到的打开vga硬件的graphics mode使得控制台绘制文本到图形帧缓冲区的实现，由于时间和难度原因，这里暂时跳过。</p>
<h2 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h2><p>最终执行<code>make grade</code>，评分脚本的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">running JOS: (1.2s)</div><div class="line">  <span class="built_in">printf</span>: OK</div><div class="line">  backtrace count: OK</div><div class="line">  backtrace arguments: OK</div><div class="line">  backtrace symbols: OK</div><div class="line">  backtrace lines: OK</div><div class="line">Score: 50/50</div></pre></td></tr></table></figure><br>至此，实验一结束。</p>
<p>第一个实验总体来说更偏重于概念的理解、工具的使用而不是实际的代码。</p>
<p>尽管如此，大量的概念也浪费了我很多时间去理解。MIT的6.828同清华的ucore操作系统实验相比提供了相当多的reference（ucore的阅读材料几乎都是现成的），这也对文档阅读和信息检索能力有了更高的要求。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/12/12/OSTEP学习笔记1/">
                            OSTEP学习笔记1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-12-12T22:54:45+08:00">
	
		    12月 12, 2016
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <blockquote>
<p>最近开始看Operating Systems: Three Easy Pieces这本书，感觉光看书还是不够，还是需要将学习到的东西整理和归纳，以加深自己对于操作系统的理解。</p>
</blockquote>
<h2 id="CPU的虚拟化"><a href="#CPU的虚拟化" class="headerlink" title="CPU的虚拟化"></a>CPU的虚拟化</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程(Process)是操作系统对于一个正在运行的程序的抽象</p>
<h4 id="进程API"><a href="#进程API" class="headerlink" title="进程API"></a>进程API</h4><p>大体上可以分为创建(Create)，销毁(Destroy)，等待(Wait)，杂项控制(Miscellaneous Control)包括挂起等以及状态查询(Status)。</p>
<h5 id="Unix下的进程API"><a href="#Unix下的进程API" class="headerlink" title="Unix下的进程API"></a>Unix下的进程API</h5><p>fork() wait() 以及 exec()</p>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>进程的状态大体上可以分为运行(Running)，就绪(Ready)以及阻塞(Blocked)。</p>
<ul>
<li>运行(Running)，进程正在被处理器运行，这意味着，处理器正在执行指令。</li>
<li>就绪(Ready)，进程已经准备好去运行，但是出于某种原因，操作系统决定不在当前的时刻运行该进程。</li>
<li>阻塞(Blocked)，在阻塞状态，进程已经执行了某种其他的操作以至于在该操作完成前该进程不能就绪，如：进程对于磁盘的IO请求。</li>
</ul>
<h4 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a>进程表</h4><p>操作系统通常会使用进程表管理所有的进程，包括追踪每一个进程的寄存器，起始内存，内存大小，PID，父进程，已打开的文件，进程状态等。</p>
<h3 id="机制-Limited-Direct-Execution-LDE"><a href="#机制-Limited-Direct-Execution-LDE" class="headerlink" title="机制:Limited Direct Execution(LDE)"></a>机制:Limited Direct Execution(LDE)</h3><p>直接执行即系统直接将进程运行在CPU上以最大化效率，限制即不能直接让进程取得对硬件以及系统所有的控制。</p>
<h4 id="限制操作"><a href="#限制操作" class="headerlink" title="限制操作"></a>限制操作</h4><p>当进程需要执行IO请求等限制操作时，不应该使得进程获得整个操作系统的控制权限。因此引入了Protected Control Transfer的概念。</p>
<h5 id="Protected-Control-Transfer"><a href="#Protected-Control-Transfer" class="headerlink" title="Protected Control Transfer"></a>Protected Control Transfer</h5><p>引入两种处理器模式：<strong>User Mode</strong>和<strong>Kernal Mode</strong></p>
<ul>
<li>User Mode - 在User Mode下，运行在该模式下的代码受到了严格的限制。比如，在该模式下，进程无法发起IO请求，并且也无法执行所有的限制指令。</li>
<li>Kernal Mode - 在Kernal Mode下，由操作系统执行指令，执行的指令没有任何限制，包括IO请求以及所有的限制指令都可以被执行。</li>
</ul>
<p><strong>System Call</strong> - 用户程序通过执行System Call去执行限制指令如访问文件系统，与其他进程通信或是分配内存。<br>为了执行System Call，用户程序需要执行一个特殊的Trap指令，Trap指令同时地跳转至内核并且提升至Kernal Mode，一旦进入了内核，系统就可以执行任何限制指令，并且完成调用进程需要完成的任务。完成后，系统调用一个特殊的Return-From-Trap指令，跳转回用户程序并且降低至User Mode。</p>
<blockquote>
<p>在执行Trap指令时，系统需要额外的开销以保证执行Return-From-Trap指令时跳转正确，例如，在x86下，系统会将PC及其他几个寄存器存入每个进程的内核栈。</p>
</blockquote>
<p>此外，内核需要在引导时建立<strong>Trap Table</strong>以保证用户程序程序执行Trap指令后能跳转至对应的指令。操作系统通知硬件<strong>Trap Handlers</strong>的位置，通知之后，直到下次引导之前，硬件都会知道对应handlers的位置，这样，当System Call或是其他异常被抛出时，硬件能对应作出正确的反应。</p>
<blockquote>
<p>显然，建立Trap Table的指令也是限制指令。</p>
</blockquote>
<h4 id="进程间切换"><a href="#进程间切换" class="headerlink" title="进程间切换"></a>进程间切换</h4><p>进程的切换需要操作系统的介入，但是当用户程序在CPU上执行时，操作系统并不在运行，那么，操作系统要如何重新获得对CPU的控制呢？</p>
<h5 id="合作方法：等待System-Calls"><a href="#合作方法：等待System-Calls" class="headerlink" title="合作方法：等待System Calls"></a>合作方法：等待System Calls</h5><p>在这种方法下，操作系统相信系统进程能正确的执行，长时间运行的进程理应周期性的放弃CPU，从而操作系统能决定运行其他的任务。</p>
<p>大多数进程通过发起System Calls的方法转移CPU的控制权 - 在发起System Call，执行了Trap指令后，操作系统就获得了CPU的控制权。</p>
<blockquote>
<p>那么，当程序错误的执行死循环之后，操作系统还能拿到CPU的控制权吗？</p>
</blockquote>
<h5 id="非合作方法：系统直接控制CPU"><a href="#非合作方法：系统直接控制CPU" class="headerlink" title="非合作方法：系统直接控制CPU"></a>非合作方法：系统直接控制CPU</h5><p><strong>Timer Interrupt</strong> - 通过对定时器装置编程使得其每隔特定的时间（通常是毫秒级）发起中断。在这种情况下，当前执行的进程会被停止，并且操作系统中一个预先配置的<strong>Interrupt Handler</strong>会被执行，这样，操作系统就重新取得了对CPU的控制。</p>
<h5 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h5><p>通常，当系统决定切换进程时，操作系统会执行一段底层代码(<strong>Context Switch</strong>)。从概念上来说，Context Switch会保存当前进程的若干寄存器的值，并且恢复待执行的进程的寄存器的值（例如，从内核栈中），这样，当Return-From-Trap指令执行时，系统得以恢复另一个进程的运行。</p>
<p>在Timer Interrupt的LDE Protocal中（例如），存在着两种类型的寄存器保存／恢复，在中断产生时，由硬件隐式的将寄存器的值存入当前进程的内核栈中，而在操作系统决定从当前进程切换至待执行进程时，由软件（操作系统）显式的将当前进程的寄存器的值（如PC，栈指针）存入当前进程的进程结构中（例如，进程控制块），并且从带切换进程的进程结构中恢复对应寄存器的值，这样，当执行Return-From-Trap指令后，由硬件隐式的从切换进程的内核栈中恢复寄存器的值，就好像刚才的Trap是由切换后进程执行的一样。</p>
<h4 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h4><blockquote>
<p>如果当一个System Call被发起时，发生了一个Timer Interrupt怎么办？</p>
</blockquote>
<p>简单的做法是，在处理中断时，禁止其他中断的传入。更加复杂的机制留至并发行部分讨论。</p>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><h5 id="负载假设"><a href="#负载假设" class="headerlink" title="负载假设"></a>负载假设</h5><p>将正在运行在系统上的进程称为负载。为了简化调度过程，首先做出如下的假设：</p>
<ul>
<li>每一个任务(<strong>Job</strong>)运行同样的时间</li>
<li>所有的任务都在同样的时间到达</li>
<li>所有的任务都仅使用CPU(不执行I/O)</li>
<li>每一个任务的运行时间都已知</li>
</ul>
<p>我们会在稍后的讨论中放宽这些限制</p>
<h5 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a>调度指标</h5><p>我们用调度指标衡量调度器的好坏，我们将使用以下两个指标：</p>
<ul>
<li>周转时间(<strong>Turnaround Time</strong>) 周转时间是指完成时间与到达时间的差，周转时间是衡量性能性能的指标。</li>
<li>响应时间(<strong>Response Time</strong>) 响应时间是指任务第一次运行的时间与到达时间的差，响应时间是衡量公平性的指标。</li>
</ul>
<h4 id="先进先出-First-In-First-Out"><a href="#先进先出-First-In-First-Out" class="headerlink" title="先进先出(First In First Out)"></a>先进先出(First In First Out)</h4><p>该调度方法有时又被称作<strong>先到先得</strong>(<strong>First Come First Served</strong>)，即先到达的方法先被CPU运行。</p>
<p>假设有3个任务，每个任务都运行10s，那么它们的平均周转时间为(10+20+30)/3=20s<br>下面我们放宽假设1，即现在每一个任务运行的时间不必相同。</p>
<p>同样地，假设有3个任务，A运行100s而B和C运行10s，如果A先运行，然后运行B，最后运行C，那么现在的平均周转时间为(100+110+120)/3=110s，这就是<strong>护送效应</strong>(<strong>Convoy Effect</strong>)，即由于A的运行时间过长，而导致运行时间较短的B和C需要等待较长的时间。</p>
<p>提出如下的新规则——</p>
<h4 id="最短任务优先-Shortest-Job-First"><a href="#最短任务优先-Shortest-Job-First" class="headerlink" title="最短任务优先(Shortest Job First)"></a>最短任务优先(Shortest Job First)</h4><p>为此，我们提出一种新的规则称为最短任务优先，该规则同样易于理解，即首先执行最短的任务，然后次短的任务，以此类推。</p>
<p>同样地假设A、B、C三个任务，其中A运行100s，而B和C运行10s，在SJF下，系统会先运行B和C，再运行A，平均周转时间为(10+20+120)/3=50s，远好于FIFO下相同假设的结果。</p>
<p>下面我们放宽假设2，即每一个任务有可能在任意时间到达。</p>
<p>假设A、B、C三个任务，其中A运行100s，在0s时到达，B和C运行10s，在10s时到达，在SJF下，平均周转时间为(100+(110-10)+(120-10))/3=103.33s，这是我们不愿意看到的结果，我们仍然需要改进调度算法——</p>
<h4 id="最短完成时间优先-Shortest-Time-to-Completion-First"><a href="#最短完成时间优先-Shortest-Time-to-Completion-First" class="headerlink" title="最短完成时间优先(Shortest Time-to-Completion First)"></a>最短完成时间优先(Shortest Time-to-Completion First)</h4><p>SJF是一种<strong>非抢占</strong>(<strong>Non-preemptive</strong>)的调度器，而STCF是一种允许抢占的调度器，在上述的例子中，当B或者C到达时，调度器允许B或者C抢占A——即操作系统从任务A切换至任务B或者任务C（通过上下文切换），从而达到提升性能的目的。</p>
<p>在上例中，若采用STCF，平均周转时间为((120-0)+(20-10)+(30-10))/3=50s，远好于103.33s这一结果。</p>
<p>事实上，如果任务长度已知，任务仅使用CPU资源，且周转时间是唯一指标的话，STCF是最佳的调度算法，下面我们来讨论另一个指标——响应时间。</p>
<p>考虑到响应时间，上述的算法表现都不尽如人意，在上例中，用户要至少要等待10s才能得到任务C的响应，而这显然是对于交互不友好的，我们需要引入新的调度算法来解决这个问题——</p>
<h4 id="轮循-Round-Robin"><a href="#轮循-Round-Robin" class="headerlink" title="轮循(Round Robin)"></a>轮循(Round Robin)</h4><p>轮循的基本思想按照<strong>时间分片</strong>(<strong>Time Slice</strong>)或者说<strong>调度量子</strong>(<strong>Scheduling Quantum</strong>)来循环执行任务而不是运行任务直到完成。</p>
<p>假设有A、B、C三个任务，它们同时到达系统而且均运行5s，假设时间分片为1s，在这种情况下，操作系统首先运行A，1s后切换到B，B运行1s后再切换到C，然后再循环回A。这样，平均响应时间为(0+1+2)/3=1s；而在SJF下，平均响应时间为(0+5+10)/3=5s。</p>
<blockquote>
<p>需要权衡时间分片的大小，如果时间分片过小，那么操作系统执行上下文切换的开销会显著增加。</p>
</blockquote>
<p>在RR下，平均周转时间会变得非常糟糕。事实上，公平性和性能在调度中是矛盾的，任何注重公平性的调度算法（即拥有良好的响应时间）在性能上（即周转时间）都会表现的很差。这是固有的权衡，<strong>鱼和熊掌不可兼得</strong>。</p>
<h4 id="合并I-O"><a href="#合并I-O" class="headerlink" title="合并I/O"></a>合并I/O</h4><p>接下来我们放宽假设3，即任务除了使用CPU外，还可能执行I/O请求，在发起了I/O请求后，任务将不会使用CPU，并且将处于阻塞的状态以等待I/O完成。</p>
<p>调度器需要决定I/O请求启动时是否切换至另一个任务，以及I/O完成时是执行当前任务还是切换回之前阻塞的任务。</p>
<p>假设我们正试图建立一个STCF调度器，假设A和B两个任务均运行50ms，并且A每10ms会发起一个花费10ms的I/O请求。在这种情况下，通常的解决方法是将A划分为5个独立的子任务，这样，当A发起I/O请求并且阻塞之后，B就可以被执行，而当I/O完成后，新的A的子任务会抢占B而继续执行。</p>
<p>上述的做法允许了<strong>重叠</strong>(<strong>Overlap</strong>)的发生，系统得以更好的利用处理器资源。</p>
<h4 id="多级反馈队列-Multi-Level-Feedback-Queue"><a href="#多级反馈队列-Multi-Level-Feedback-Queue" class="headerlink" title="多级反馈队列(Multi-Level Feedback Queue)"></a>多级反馈队列(Multi-Level Feedback Queue)</h4><p>最后，我们将放宽限制4，即系统不知道每个任务的运行时间。在这种情况下，我们将引入最有名的调度器之一——多级反馈队列来解决该问题。多级反馈队列试图在提升性能（即缩短平均周转时间）的同时最小化任务的响应时间。首先，我们将介绍有关多级反馈队列的最基本的概念。</p>
<h5 id="MLFQ-基本规则"><a href="#MLFQ-基本规则" class="headerlink" title="MLFQ:基本规则"></a>MLFQ:基本规则</h5><p>多级反馈队列(MLFQ)具有一系列相互独立的<strong>队列</strong>(<strong>Queue</strong>)，每一个队列都对应着不同的<strong>优先级</strong>(<strong>Priority Level</strong>)，在同一时间，一个任务只会处在一个队列中。</p>
<p>MLFQ根据优先级决定运行哪一个任务：即具有更高优先级的任务会被运行。</p>
<p>同时，考虑到可能会有多个任务处于同一个队列，即有可能出现相同优先级的情况，在这种情况下，MLFQ以轮循的方式运行这些任务。</p>
<p>因此我们得到了如下的基本规则：</p>
<ul>
<li>如果A的优先级大于B的优先级，运行A(B不运行)</li>
<li>如果A和B的优先级相同，以轮循的方式运行A和B</li>
</ul>
<p>假设两个任务A和B，A和B位于最高的优先级，而C和D位于次高的优先级，那么我们会发现，A和B会一直被运行，而C和D将永远无法被运行。</p>
<h5 id="尝试1-如何改变优先级"><a href="#尝试1-如何改变优先级" class="headerlink" title="尝试1:如何改变优先级"></a>尝试1:如何改变优先级</h5><p>MLFQ依据已经观察到的结果确定一个任务的优先级：如果一个任务在一个相当长的周期内一直在使用CPU，那么MLFQ会降低它的优先级，如果一个任务周期性的放弃CPU而等待用户的输入，那么MLFQ会维持它的优先级，因为这样的任务是一个活跃的任务。</p>
<p>因此我们得到了如下的规则：</p>
<ul>
<li>当一个任务进入系统时，它将会被放置在优先级最高的队列</li>
<li>a如果一个任务在运行中占用了一个完整的时间分片，那么它的优先级会被降低</li>
<li>b如果一个任务在时间分片用完前放弃了CPU，那么它的优先级维持不变</li>
</ul>
<p>在上述的规则中，我们考虑如下的两个问题：</p>
<ul>
<li>如果有太多的活跃任务，那么他们会占用所有的CPU时间，那么，长时间运行的任务将永远不会得到任何的CPU时间。</li>
<li>程序可以以在时间分片用完前“故意”地放弃CPU以欺骗操作系统而使得其保持高优先级</li>
</ul>
<h5 id="尝试2-优先级提高"><a href="#尝试2-优先级提高" class="headerlink" title="尝试2:优先级提高"></a>尝试2:优先级提高</h5><p>我们引入如下的规则来解决上面提到的问题1：</p>
<ul>
<li>在某个时间周期S之后，将系统中所有的任务提升至优先级最高的队列</li>
</ul>
<p>通过该规则，过多的活跃进程并不会完全占用CPU的时间，此外，当一个程序从不活跃转变为活跃时也能够及时得得到响应的CPU时间。</p>
<h5 id="尝试3-更好的计量"><a href="#尝试3-更好的计量" class="headerlink" title="尝试3:更好的计量"></a>尝试3:更好的计量</h5><p>我们引入如下的规则来解决上面提到的问题2:</p>
<ul>
<li>一旦某个任务用完了在给定优先级下的分配时间，无论它已经放弃了多少次CPU，降低它的优先级。</li>
</ul>
<p>这么做避免了一个任务欺骗操作系统，避免了其通过不公正的手段分享CPU的时间。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2016/12/12/OSTEP学习笔记1/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 页 共 1 页</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 CoSidian. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">CoSidian</h4>
        
            <div id="about-card-bio"><p>码龙黑曜 - iOS开发者/计算机科学/兽人控</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>本科在读</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                HUST, Wuhan, China
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-i7zzex3jvqnxdf0lp2pg3bcyurjikigtrw9ljle5skc4mit2m7a13rwuyp8g.min.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
