
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="码龙的窝">
    <title>MIT6.828操作系统工程Lab1-Booting a PC实验报告 - 码龙的窝</title>
    <meta name="author" content="码龙黑曜">
    
        <meta name="keywords" content="博客,iOS,Computer Science,码龙,">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"码龙黑曜","sameAs":["https://github.com/BlackDragonF","https://t.me/Cosidian","http://steamcommunity.com/id/BlackDragonF/","mailto:obsidiandragon2016@gmail.com"],"image":"avatar.jpg"},"articleBody":"\n本学期开设了操作系统的专业课。根据老师的介绍，下个学期的操作系统课设就是MIT的6.828的Labs，再加上团队老学长/同学的推荐，打算先在这个学期完成6.828，加深对于系统的理解。Lab1 - Booting a PC是比较简单的实验，主要包括了引导、内核、控制台输出、以及栈。尽管如此，由于相关知识的缺失，我断断续续做了2周（2017年10月26日）才完成该实验。2017年12月9日，完成了实验的提高部分并写完了报告。\n\n实验准备首先需要完成实验环境的搭建。实验环境主要由两个部分组成：QEMU用来模拟运行内核，以及一条编译工具链用于编译和测试内核。这里我使用的系统是64位的ArchLinux。\n\n本部分可以参考MIT 6.828官网的Tools。\n\n编译工具链编译工具链包含了C编译器、汇编器、连接器，用于从源代码生成可执行二进制文件。本实验的目标代码是32位的Intel架构（x86），可执行文件格式为ELF。\n在Arch Linux下，若是在安装时选择了base-devel包组，则gcc应该是系统自带的编译工具链。但是，该gcc默认不能编译生成32位的可执行文件。需要手动开启multilib并安装gcc-multilib以及相关的软件包。\nGCC版本降级说明在我和华田的Arch下，使用gcc 7.1.1-3之后的版本编译生成的JOS kernel均无法使用。在无法查明原因的情况下，推荐将gcc降级至7.1.1-3完成6.828的实验。\n有关于Arch下软件包降级的教程请看这里。\n在后续的实验中，为了使得编译JOS内核的工具链不和系统工具链冲突以及为了保证系统工具链的最新，尝试了手动编译32位的gcc 4.6.1作为JOS专用的交叉编译工具链，并使用modules来管理环境变量，具体可以参考这里。\nQemu模拟器QEMU是一个现代并且快速的PC模拟器，但是为了与实验兼容，MIT推荐使用他们patched过的QEMU版本。需要按照Tools上的教程从源码编译并安装QEMU。\n注意：提供的QEMU并不支持make uninstall，需要手动卸载QEMU。如果您对于手动编译并安装可能存在的后果抱有顾虑，推荐使用包管理软件安装QEMU，或是修改编译前缀，不要将编译好的qemu安装到/usr/local/下\n问题\n所需要的库名可以在arch官网上通过搜索软件包的方式找到；\nconfigure的时候加上–disable-werror以保证不会因出现编译警告而终止编译；\n出现如下错误：\n 12345Unescaped left brace in regex is illegal here in regex; marked by &lt;-- HEREin m/^\\@strong&#123; &lt;-- HERE (.*)&#125;$/ at /home/guest/qemu/scripts/texi2pod.plline 320.make: *** [Makefile:474：qemu.1] 错误 255。\n 该错误是由于perl版本更新后正则表达式语法的变动造成的，直接修改安装脚本的/home/chenzhihao/qemu/scripts/texi2pod.pl line 320，将{改成 \\{即可；\n\nconfigure时可能需要指定python版本为2以避免调用python3出现错误，参数为--python=/usr/bin/python2.7。\n\n实验介绍实验1总共分为3个部分：\n\n第1部分主要关注x86汇编语言、QEMU x86模拟器以及PC的上电启动流程；\n第2部分主要关注6.828内核的引导程序；\n第3部分开始挖掘6.828内核的最初模板 - JOS。\n\n实验使用Git进行版本管理，需要从MIT的Git克隆最开始的仓库，有关这一部分的具体说明请自行参考Lab1实验讲义。\n有关于Git的教程推荐廖雪峰的官方博客或者是Pro Git 2。\n实验过程第一部分 PC Bootstrap - PC引导x86汇编练习1：本实验需要熟悉x86汇编。\n8086汇编已经在王爽的《汇编语言》以及学院的汇编语言课程中学习过，x86_64汇编也已经在《深入理解计算机系统》中有所涉猎。本实验中使用的是i386汇编。这里不再赘述。\n模拟x86在本实验中使用QEMU作为模拟器。尽管QEMU内置的监控只能提供少量的调试支持，但是QEMU却可以作为GNU-Debugging（GDB）的远程调试目标。\n根据实验指导使用make编译生成内核并且用make qemu或者是make qemu-nox启动QEMU。可以看到，当前的内核仅支持两条命令help和kerninfo。\nPC的物理地址空间PC的物理地址空间有着如下的布局：\n1234567891011121314151617181920212223242526272829+------------------+  &lt;- 0xFFFFFFFF (4GB)|      32-bit      ||  memory mapped   ||     devices      ||                  |/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\|                  ||      Unused      ||                  |+------------------+  &lt;- depends on amount of RAM|                  ||                  || Extended Memory  ||                  ||                  |+------------------+  &lt;- 0x00100000 (1MB)|     BIOS ROM     |+------------------+  &lt;- 0x000F0000 (960KB)|  16-bit devices, ||  expansion ROMs  |+------------------+  &lt;- 0x000C0000 (768KB)|   VGA Display    |+------------------+  &lt;- 0x000A0000 (640KB)|                  ||    Low Memory    ||                  |+------------------+  &lt;- 0x00000000\n最初的PC基于Intel的16位8088处理器，仅能够支持2^20B = 2^10KB = 1MB的寻址，早期的地址空间从0x00000开始到0xFFFFF结束。\n\n0x00000到0xA0000（640KB）被称作低内存，是早期PC能用的唯一的RAM；\n0xA0000到0xFFFFF（384KB）被硬件保留作特殊用途如视频缓冲区或是固件，该部分最重要的区域是从0xF0000到0xFFFFF（64KB）的基本输入输出系统（BIOS）。BIOS用作执行最基本的系统初始化如激活显卡、检查内存等。在初始化完成后，BIOS从软盘、硬盘、光驱或是网络中读取操作系统，并且将机器控制权转移给操作系统。\n\n从Intel的80286到80386，处理器能够支持16MB和4GB的地址空间。但为了后向兼容性，硬件设计者保留了低1M内存的布局。现代PC因此在0x000A0000到0x00100000的内存中有一个“洞”，这个洞将内存分为了低内存/保留内存（Low Memory）（低640KB）以及扩展内存（Extended Memory）（其他内存）。除此以外，32位PC的地址空间的最上方，常常被BIOS保留用作32位的PCI设备。\n最新的x86处理器能够支持超过4GB的物理内存，因此内存可以超过0xFFFFFFFF。因此BIOS需要预留出第二个“洞”以保证那些32位的PCI设备的地址可以被正确的映射。\n由于JOS只会使用256M内存，在此假设仅PC具有32位的地址空间。\nROM BIOS根据实验指导，进行QEMU和GDB的联合调试。会发现从上电开始，IBM PC从0x000ffff0开始执行指令。该处位于为BIOS预留的64kb的空间的顶层。此时CS = 0xf000 IP = 0xfff0。且第1条指令是一个jmp指令，跳转至CS = 0xf000 IP = 0xe05b。\n这些都是早期的8088处理器的设计者设计的。这样的设计保证了BIOS总能控制机器。因为在刚上电的时候，在内存中并不存在能够执行的代码。\n\n此处需要理解8086的分段式寻址，即通过两个16位寄存器的值构造20位地址。实际地址为CS × 16 + IP = 0xf000 × 16 + 0xfff0 = 0xffff0。\n\n练习2：使用gdb的si（单步调试）命令进入ROM BIOS并追踪几条指令，并猜测这些指令的作用。不需要指出指令具体的细节，只要理解BIOS一开始运行的核心思想而已。\nBIOS执行的前若干条指令和作用如下：1234567891011121314151617181920212223242526272829303132[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b # 跳到一个较早的位置[f000:e05b]    0xfe05b: cmpl   $0x0,%cs:0x6ac8[f000:e062]    0xfe062: jne    0xfd2e1         # 测试cs段的0x6ac8字是否为0        [f000:e066]    0xfe066: xor    %dx,%dx         # 测试为0[f000:e068]    0xfe068: mov    %dx,%ss         [f000:e06a]    0xfe06a: mov    $0x7000,%esp    # 设置栈段寄存器和栈指针寄存器                                               # 栈的延伸方向和代码段延伸方向相反[f000:e070]    0xfe070: mov    $0xf34c2,%edx   # 设置edx寄存器值[f000:e076]    0xfe076: jmp    0xfd15c         # 跳转[f000:d15c]    0xfd15c: mov    %eax,%ecx       [f000:d15f]    0xfd15f: cli                    # 关闭硬件中断[f000:d160]    0xfd160: cld                    # 设置串传送指令方向[f000:d161]    0xfd161: mov    $0x8f,%eax      [f000:d167]    0xfd167: out    %al,$0x70       # 关闭不可屏蔽中断[f000:d169]    0xfd169: in     $0x71,%al       # 从CMOS读取选择的寄存器[f000:d16b]    0xfd16b: in     $0x92,%al       # 读取系统控制端口A[f000:d16d]    0xfd16d: or     $0x2,%al        [f000:d16f]    0xfd16f: out    %al,$0x92       # 通过快速A20以启动A20[f000:d171]    0xfd171: lidtw  %cs:0x6ab8      # 将cs:0x6ab8加载进入IDT表[f000:d177]    0xfd177: lgdtw  %cs:0x6a74      # 将cs:0x6a74加载进入GDT表[f000:d17d]    0xfd17d: mov    %cr0,%eax   [f000:d180]    0xfd180: or     $0x1,%eax       [f000:d184]    0xfd184: mov    %eax,%cr0       # 将cr0寄存器的保护模式位打开[f000:d187]    0xfd187: ljmpl  $0x8,$0xfd18f   # 通过ljmp指令进入保护模式=&gt; 0xfd18f:     mov    $0x10,%eax              # 设置段寄存器=&gt; 0xfd194:     mov    %eax,%ds=&gt; 0xfd196:     mov    %eax,%es  =&gt; 0xfd198:     mov    %eax,%ss=&gt; 0xfd19a:     mov    %eax,%fs=&gt; 0xfd19c:     mov    %eax,%gs=&gt; 0xfd19e:     mov    %ecx,%eax  =&gt; 0xfd1a0:     jmp    *%edx                   # 跳转\n第二部分 引导软盘和硬盘被分为了512Bytes的区域 - 扇区（Sector）。一个扇区是磁盘传输的最小粒度：每一个读操作和写操作必须是一个或是一个以上的扇区，并且必须要对齐到扇区。\n如果一个磁盘是可引导的，那么它的第一个扇区就被称作引导扇区，引导代码就存储在引导扇区中。如果BIOS发现了一个可引导的硬件，那么它就将这个扇区从磁盘读取至内存的0x7c00到0x7dff处，并且使用一个jmp指令设置CS：IP = 0000:7C00，将控制传递给引导。和BIOS读取地址一样，这个地址对于PC来说是固定和标准化的。\n\n从光盘引导的情形更加复杂，因为光盘的一个扇区为2048Byte，BIOS可以从硬盘读取一个更大的引导镜像到内存中。\n\n在6.828中，使用硬盘的传统引导机制。这意味这引导必须满足512个Bytes的限制。引导由一个汇编文件boot/boot.S，以及一个C语言文件boot/main.c组成。\n练习3：追踪boot.S和main.C，分析每一个部分的作用。\n\n为了理解boot.S，需要以下的知识储备。\n实模式和保护模式实模式是为了与8086兼容而设置的。在实模式下，处理器相当于一个快速的8086处理器。当处理器被加电或者复位时以实模式启动。\n\n实模式下各寄存器以实模式的初始化值工作；\n实模式的地址空间总共为20位（1MB）；\n实模式下不支持内存分页机制；\n实模式下各内存段均是可读、可写、可执行的，不支持指令优先级，所有的指令均运行在特权级；\n实模式不支持多任务切换；\n实模式的中断处理也和8086相同，使用中断向量表来定位中断服务程序。\n\n在保护模式下，处理器的所有功能都是可用的。具体来说：\n\n保护模式提供了完全的32位地址空间，寻址空间为4GB；\n保护模式支持内存分页机制，提供了对虚拟内存的硬件支持；\n保护模式的处理器支持多任务（上下文切换）；\n保护模式的处理器支持指令和数据的特权级，配合边界检查等机制，既可以共享数据也可以隔离各个任务。\n\n为了保证后向兼容性，x86的处理器启动时默认是实模式，需要手动从实模式切换至保护模式。但是切换至保护模式之前需要做一些必要的准备工作，如打开A20和建立全局描述符表等。\nA20地址线在早期的PC上处理器仅支持20位的地址空间，任何超过20位的地址都会被卷回。例如：0xFFFF+0xFFFF = 0x1FFFE -&gt; 0xFFFE\n然而，从80286开始，Intel支持了24位的地址空间，上例的地址相加将不会发生卷回。为了保证与早期PC的完全兼容，Intel采用了“黑魔法” - 将A20（第21根）地址线与键盘控制器的一个输出进行了与运算。进而控制A20地址线的值。\n默认情况下，A20是置0的，PC将只能访问1M、3M、5M…这样的奇数段。进入保护模式前需要先打开A20以获得完全的寻址能力。\nJOS内核通过端口的方式与键盘控制器进行通信并打开A20。可以参考Reference中的PS/2 Keyboard Interface。\n\n8042有一个1 Byte的输入缓冲区，一个1 Byte的输出缓冲区、一个1 Byte的状态寄存器、以及一个1 Byte的控制寄存器。前三个寄存器可以直接从0x60和0x64端口进行访问。最后一个寄存器通过“Read Command Byte”命令进行读，通过“Write Command Byte”命令进行写。\n对0x60端口读会读输入缓冲区；对0x60端口写会写输出缓冲区；对0x64端口读会读状态寄存器；对0x64端口写会发送命令。\n状态寄存器的Bit1为IBF - Input Buffer Full，当该Bit为1时，输入缓冲区满，不能对0x60端口或0x64端口写。\n对0x64端口写0xd1发送的命令是“Write Output Port”写输出端口，表明将参数写入输出端口（0x60端口写）。\nA20使用的是键盘控制器输出的Bit 1，向输出端口写入0xdf可以打开A20；向输出端口写入0xdd则会关闭A20。\n\n分段机制与全局描述符表x86处理器提供了分段机制和分页机制两种内存管理模式。如果要进入保护模式，就必须要先启动分段机制。（分页机制不是必须的）\n分段机制将内存划分为若干个段，每个段都由段基址、段界限和段属性组成。由一个段描述符表（可以理解为一个数组）描述所有段的信息。段描述符表可以是全局的也可以是局部的。\n简化的说，程序首先将对应的段选择子（可以理解为数组的索引）加载进入段寄存器中。然后在执行程序时，根据指令的内容确定应该使用的段寄存器，根据段寄存器中的段选择子确定应该使用的段描述符。再结合段描述符中包含的信息加上指令自身的地址构造出实际的物理地址。最终将该地址发送到地址总线上，到物理内存中寻址，并取回相应的数据。这之中简化了有关特权级、边界检查的相关内容，但足以描述分段机制的基本原理。\n分段机制将虚拟地址转换成了线性地址。\n全局描述符表寄存器x86处理器提供了专门的全局描述符表寄存器（Global Descriptor Table Register）用于保存全局描述符表的表基址和表限长。GDTR由2个字节的表限长（limit）和4个字节的表基址（base）组成。其中表基址指定了全局描述符表的起始地址，表限长指定了全局描述符表的大小。其C结构体描述如下：1234struct gdtr &#123;\tu16 limite;\tu32 base;&#125; __attribute__ ((packed));\n在机器刚加电或者是处理器复位后，表基址默认被置为0，表限长则默认被置为0xFFFF。在保护模式初始化的过程中，必须给GDTR加载新的值。可以使用lgdt指令为GDTR加载新值。\n段选择子段选择子（2个字节）用于选择特定的描述符表以及表中的特定描述符。段选择子一般被放置于段寄存器中，段选择子由13位的索引、1位的表指示位和2位的请求特权级三部分组成。其中索引指定了描述符，表指示位选择应该访问的描述符表 - 0代表全局描述符表，1代表局部描述符表，请求特权级用于段级的保护机制，自0到4分别代表ring 0到ring 3。其C结构体描述如下：12345struct selector &#123;    u16 index:13;    u16 ti:1;    u16 rpl:2;&#125;\n段描述符段描述符（8个字节）是段描述符表这个“数组”的“元素”。用C结构体描述如下：123456789struct gdtdesc &#123;\tu16 lim0_15;\tu16 base0_15;\tu8 base16_23;\tu8 acces;\tu8 lim16_19:4;\tu8 other:4;\tu8 base24_31;&#125; __attribute__ ((packed));\n其中总共包含了32位的段基址、20位的段界限、以及12位的类型。段基址规定了段的起始地址。段界限规定了段的大小。而类型用于区别不同类型的描述符。包括描述符特权级、段存在位、已访问位等等。\nboot.S代码详解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;inc/mmu.h&gt;# Start the CPU: switch to 32-bit protected mode, jump into C.# The BIOS loads this code from the first sector of the hard disk into# memory at physical address 0x7c00 and starts executing in real mode# with %cs=0 %ip=7c00.# boot.S 主要将CPU切换至32位保护模式，并且跳转进入C代码.set PROT_MODE_CSEG, 0x8         # kernel code segment selector.set PROT_MODE_DSEG, 0x10        # kernel data segment selector.set CR0_PE_ON,      0x1         # protected mode enable flag.globl startstart:                        # 程序入口  .code16                     # Assemble for 16-bit mode 指导生成16位汇编代码  cli                         # Disable interrupts 关中断  cld                         # String operations increment 设置串传递顺序递增  # Set up the important data segment registers (DS, ES, SS). 设置重要的段寄存器为0  xorw    %ax,%ax             # Segment number zero  movw    %ax,%ds             # -&gt; Data Segment  movw    %ax,%es             # -&gt; Extra Segment  movw    %ax,%ss             # -&gt; Stack Segment  # Enable A20:  #   For backwards compatibility with the earliest PCs, physical  #   address line 20 is tied low, so that addresses higher than  #   1MB wrap around to zero by default.  This code undoes this.  # 开启A20：  #   A20的介绍已经给出，不再赘述。seta20.1:  inb     $0x64,%al               # Wait for not busy 等待缓冲区可用  testb   $0x2,%al                # Test for bit1                                  # if bit1 = 1 then buffer is full  jnz     seta20.1  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64  outb    %al,$0x64               # Prepare to write output port 准备写入输出端口seta20.2:  inb     $0x64,%al               # Wait for not busy 等待缓冲区可用  testb   $0x2,%al  jnz     seta20.2                # The same as above 同上  movb    $0xdf,%al               # 0xdf -&gt; port 0x60  outb    %al,$0x60               # 0xdf -&gt; A20 gate enable command 打开A20  # Switch from real to protected mode, using a bootstrap GDT  # and segment translation that makes virtual addresses  # identical to their physical addresses, so that the  # effective memory map does not change during the switch.  lgdt    gdtdesc                # Load gdt size/base to gdtr 设置全局描述符表  movl    %cr0, %eax             # Control register 0                                 # bit0 is protected enable bit                                 # 读取控制寄存器0的值，其Bit0为允许保护模式位  orl     $CR0_PE_ON, %eax       # Set PE 将允许保护模式位置1  movl    %eax, %cr0             # Update Control register 0 设置控制寄存器0  # Jump to next instruction, but in 32-bit code segment.  # Switches processor into 32-bit mode.  ljmp    $PROT_MODE_CSEG, $protcseg # 通过ljmp指令（跳转至下一条指令）进入保护模式  .code32                     # Assemble for 32-bit mode 指导生成32位汇编代码protcseg:  # Set up the protected-mode data segment registers 设置保护模式的数据段寄存器  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector  movw    %ax, %ds                # -&gt; DS: Data Segment  movw    %ax, %es                # -&gt; ES: Extra Segment  movw    %ax, %fs                # -&gt; FS  movw    %ax, %gs                # -&gt; GS  movw    %ax, %ss                # -&gt; SS: Stack Segment  # Set up the stack pointer and call into C. 设置栈指针并且调用C  movl    $start, %esp  # Stack has the opposite extension direction than Code                        # 注意栈的延伸方向和代码段相反  call bootmain #调用main.c中的bootmain函数  # If bootmain returns (it shouldn't), loop.spin:  jmp spin# Bootstrap GDT 引导GDT.p2align 2                                # force 4 byte alignmentgdt:  SEG_NULL\t\t\t\t# null seg 默认第一个段描述符为空  SEG(STA_X|STA_R, 0x0, 0xffffffff)\t# code seg 设置代码段描述符  SEG(STA_W, 0x0, 0xffffffff)\t        # data seg 设置数据段描述符  # 关于SEG宏可以参考mmu.hgdtdesc:                                  # 用于设置全局段描述符寄存器  .word   0x17                            # sizeof(gdt) - 1 # Size of gdt  .long   gdt                             # address gdt # Base address of gdt\n\n为了理解main.c，需要如下的知识储备。\nELF文件格式可执行和可链接格式（Executable and Linkable Format）是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。\nELF文件可以分为两种组成 - 链接视图（Linking View）和执行视图（Execution View）。这里只讨论执行视图。\n执行视图的结构如下：1234567891011121314+--------------------+|     ELF Header     |+--------------------+|Program Header Table|+--------------------+|      Segment 1     |+--------------------+|      Segment 2     |+--------------------+|         ...        |+--------------------+|Section Header Table||       optinal      |+--------------------+\nELF文件格式主要由ELF头（ELF Header）、程序头部表（Program Header Table）和节头部表（Section Header Table）组成。在执行视图中，节头部表是可选的。\n有关于这些数据结构的C语言定义可以参考头文件&lt;inc/elf.h&gt;。\n\nELF头主要包含了ELF魔数、文件类型、程序头部表偏移和大小、程序入口等信息；\n程序头部表可以看做一个数据结构的数组，每一个元素都描述了一个段。主要包含了段的偏移、段的虚拟地址、段的物理地址、段的大小等信息。\n\n磁盘控制器磁盘是电脑主要的存储媒介。磁盘是由盘片构成的。每个盘片有两面或者称为表面，表面覆盖着磁性记录材料。盘片中央有一个可以旋转的主轴，它使得盘片以固定的旋转速率旋转，通常是5400-15000转每分钟（Revolution Per Minute）。磁盘通常包含一个或多个这样的盘片，并封装在一个密封的容器内。\n每一个表面是由一组称为磁道的同心圆组成。每个磁道被划分为一组扇区。每个扇区包含相等数量的数据位（通常是512字节），这些数据编码在扇区上的磁性材料中。扇区之间由一些间隙分隔开，这些间隙中不存储数据位。间隙用来标识扇区的格式化位。\n磁盘的柱面是所有盘片表面上到主轴中心距离相等的磁道的集合。\n对于磁盘的寻址通常分为CHS和LBA两种。\n\nCHS即柱面（cylinder）-磁头（head）-扇区（sector）寻址。每个盘片都对应着一个磁头，每一个盘片都被划分成柱面，每一个柱面都被划分成多个段。磁盘的最小存储单元是段。早期的IBM PC架构上采用CHS进行磁盘寻址。CHS是一个三元组，包括10bit的柱面号，8bit的磁头号以及6bit的扇区号。这样CHS的最大寻址范围为2^10 × 2^8 × 2^6 × 512 = 8GB。\n随着磁盘容量的不断扩大，CHS的8GB寻址范围已经不能满足需要，现在的磁盘普遍采用逻辑区块地址（Logical Block Adress）的方式进行寻址来进行抽象。LBA是一个整数，代表磁盘上的一个逻辑区块编号，通过将这个整数转换成CHS格式来完成磁盘的具体寻址。LBA为48个bit，最大寻址范围为128PB。在本实验中，LBA按照旧的规范采用28个bit。\n\nIDE硬盘控制器（IDE Hard Drive Controller）的0x1F7端口读为磁盘0状态寄存器。其Bit6为RDY Bit，当其置1表明磁盘上电完成。在对于磁盘做任何操作（除了复位）之前务必要保证该Bit为1。其Bit7为BSY Bit，当其置1表明磁盘忙。在你向磁盘发送任何指令前务必保证该Bit为0。\n通过IDE硬盘控制器读取扇区需要如下的步骤：\n\n向0x1F2端口写入待操作的扇区数目；\n向0x1F3-0x1F5端口依次写入LBA的低24位；\n向0x1F6端口的低4位写入LBA的高4位，向0x1F6端口的高4位写入驱动器地址；\n向0x1F7端口写入读命令0x20。\n\n0x1F6寄存器又称Drive/Head寄存器。其低4位是LBA的高4位。其Bit5和Bit7一般是1。其Bit6为LBA位，当置1时表示启用LBA寻址。其Bit4为DRV位。用来选择驱动器，Master驱动器为0，Slave驱动器为1。这里将高4位置为0x1110\n在使用读命令0x20之前需要完整的设置柱面/磁头/扇区。当这个命令完成，你可以从磁盘的数据寄存器（0x1F0端口）读取256个字（16Bits）。\nmain.c代码详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;inc/elf.h&gt;#include &lt;inc/x86.h&gt;/********************************************************************** * This a dirt simple boot loader, whose sole job is to boot * an ELF kernel image from the first IDE hard disk. * * DISK LAYOUT *  * This program(boot.S and main.c) is the bootloader.  It should *    be stored in the first sector of the disk. * *  * The 2nd sector onward holds the kernel image. * *  * The kernel image must be in ELF format. * * BOOT UP STEPS *  * when the CPU boots it loads the BIOS into memory and executes it * *  * the BIOS intializes devices, sets of the interrupt routines, and *    reads the first sector of the boot device(e.g., hard-drive) *    into memory and jumps to it. * *  * Assuming this boot loader is stored in the first sector of the *    hard-drive, this code takes over... * *  * control starts in boot.S -- which sets up protected mode, *    and a stack so C code then run, then calls bootmain() * *  * bootmain() in this file takes over, reads in the kernel and jumps to it. **********************************************************************/#define SECTSIZE 512#define ELFHDR ((struct Elf *)0x10000)    // scratch spacevoid readsect(void *, uint32_t);void readseg(uint32_t, uint32_t, uint32_t);void bootmain(void) &#123;    struct Proghdr *ph, *eph;    // read 1st page off disk 从磁盘上读取第一页    readseg((uint32_t)ELFHDR, SECTSIZE * 8, 0);    // is this a valid ELF? 通过ELF魔数确认ELF有效    if (ELFHDR-&gt;e_magic != ELF_MAGIC) goto bad;    // load each program segment (ignores ph flags) 读取各个段    ph = (struct Proghdr *)((uint8_t *)ELFHDR + ELFHDR-&gt;e_phoff);    // 程序头部表的起始地址    eph = ph + ELFHDR-&gt;e_phnum;    // 程序头部表的结束地址    for (; ph &lt; eph; ph++)        // p_pa is the load address of this segment (as well        // as the physical address)        // p_pa是加载地址也是物理地址        readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);    // call the entry point from the ELF header 从ELF头调用程序入口    // note: does not return!    ((void (*)(void))(ELFHDR-&gt;e_entry))();bad:    // stops simulation and breaks into the debug console    outw(0x8A00, 0x8A00);    outw(0x8A00, 0x8E00);    while (1) /* do nothing */;&#125;// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.// 从内核的offset处读取count个字节到物理地址pa处// Might copy more than asked 可能会读取超过count个（扇区对齐）void readseg(uint32_t pa, uint32_t count, uint32_t offset) &#123;    uint32_t end_pa;    end_pa = pa + count;    // 结束物理地址    // round down to sector boundary 对齐到扇区    pa &amp;= ~(SECTSIZE - 1);    // translate from bytes to sectors, and kernel starts at sector 1    offset =        (offset / SECTSIZE) + 1;    // 算出扇区数 注意扇区从1开始（0为引导扇区）    // If this is too slow, we could read lots of sectors at a time.    // We'd write more to memory than asked, but it doesn't matter --    // we load in increasing order.    // 在实际中往往将多个扇区一起读出以提高效率。    while (pa &lt; end_pa) &#123;        // Since we haven't enabled paging yet and we're using        // an identity segment mapping (see boot.S), we can        // use physical addresses directly.  This won't be the        // case once JOS enables the MMU.        // 考虑到没有开启分页以及boot.S中使用了一一对应的映射规则，        // 加载地址和物理地址是一致的。        readsect((uint8_t *)pa, offset);        pa += SECTSIZE;        offset++;    &#125;&#125;void waitdisk(void) &#123;    // wait for disk reaady 等待磁盘准备完毕。    while ((inb(0x1F7) &amp; 0xC0) != 0x40) /* do nothing */;&#125;void readsect(void *dst, uint32_t offset) &#123;    // wait for disk to be ready    waitdisk();    outb(0x1F2, 1);    // count = 1 0x1F2 Disk 0 sector count    // Read one sector each time    outb(0x1F3, offset);    // Disk 0 sector number (CHS Mode)    // First sector's number    outb(0x1F4, offset &gt;&gt; 8);     // Cylinder low (CHS Mode)    outb(0x1F5, offset &gt;&gt; 16);    // Cylinder high (CHS Mode)    // Cylinder number    outb(0x1F6, (offset &gt;&gt; 24) | 0xE0);    // Disk 0 drive/head    // MASK 11100000    // Drive/Head Register: bit 7 and bit 5 should be set to 1    // Bit6: 1 LBA mode, 0 CHS mode    outb(0x1F7, 0x20);    // cmd 0x20 - read sectors    /*20H       Read sector with retry. NB: 21H = read sector                without retry. For this command you have to load                the complete circus of cylinder/head/sector                first. When the command completes (DRQ goes                active) you can read 256 words (16-bits) from the                disk's data register. */    // wait for disk to be ready    waitdisk();    // read a sector    insl(0x1F0, dst, SECTSIZE / 4);    // Data register: data exchange with 8/16 bits    // insl port addr cnt: read cnt dwords from the input port    // specified by port into the supplied output array addr.    // dword: 4 bytes = 16 bits&#125;\n练习3：\n\n0x7c2d: ljmp  $0x8, $0x7c32 从这句汇编指令之后处理器开始执行32位指令。ljmp指令导致了16位指令到32位指令的转变。\n引导最后执行的指令是call *0x10018，内核的第一条指令是movw $0x1234,0x472。\n内核的第一条指令位于0x10000c。\n引导从程序头部表中得到段的数目以及每个段的大小，以此决定要从磁盘上读出多少个扇区。\n\n加载内核本部分主要需要了解.text段.rodata段和.data段，并且使用objdump读取ELF格式的信息。\nboot/Makefrag文件中指定了引导的text段的位置为0x7c00。\n练习4：阅读并学习关于C语言指针的知识。下载pointer.c，编译运行并确保理解它。\npointer.c的代码和解释如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void f(void) &#123;    int  a[4];    // 含有4个元素的整形数组    int *b =        malloc(16);    // 分配16个字节的内存，并且用一个整形指针指向内存首地址    int *c;    // 一个悬挂的整形指针    int  i;    // 一个整形数    printf(\"1: a = %p, b = %p, c = %p\\n\", a, b, c);    // 打印a和b和c的地址，分别为0xff9bebcc, 0x566fc160和0xf7ede1e8    c = a;    // 令c指向数组a的首地址    for (i = 0; i &lt; 4; i++) a[i] = 100 + i;    // 为a[0]到a[3]分配100-103    c[0] = 200;                                // 将c[0]也就是a[0]改为200    printf(\"2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n\", a[0], a[1], a[2],           a[3]);    // 输出200 101 102 103    c[1]     = 300;    // 将c[1]也就是a[1]改为300    *(c + 2) = 301;    //将*(c + 2)也就是a[2]改为301    3 [c]    = 302;    // 将3[c]也就是c[3]改为302    printf(\"3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n\", a[0], a[1], a[2],           a[3]);    // 输出200 300 301 302    c  = c + 1;    // 令c指向a[1]    *c = 400;      // 将a[1]改为400    printf(\"4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n\", a[0], a[1], a[2],           a[3]);    // 输出200 400 301 302    c = (int *)((char *)c + 1);    // 将c先转换为char指针指向下一个字节后再转回int指针    // 现在a数组的字节分布为（小端）C8000000 90010000 2D010000 2E010000    | (c的指针)*c = 500;    // 执行后的a数组字节分布（小端）C8000000 90F40100 00010000 2E010000    printf(\"5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n\", a[0], a[1], a[2],           a[3]);    // 输出200 128144 256 302    b = (int *)a + 1;    // 将b指向a[1]    c = (int *)((char *)a + 1);    // 将a先转换为char指针指向下一个字节后再转回int指针    printf(\"6: a = %p, b = %p, c = %p\\n\", a, b, c);    // 输出0xff9bebcc, 0xff9bebd0和0xff9bebcd&#125;int main(int ac, char **av) &#123;    // 函数入口    f();    return 0;&#125;\n练习5：修改了text段的加载地址使得汇编代码中的跳转地址出现错误，进而导致整个引导因为错误提前终止。\n练习6：结果是非常显然的，因为引导的作用就是将内核从磁盘加载进入内存中。使用objdump -h obj/kern/kernel可以看到如下的信息：0 .text         00001809  f0100000  00100000  00001000  2**4                CONTENTS, ALLOC, LOAD, READONLY, CODE可以直到内核的text段会被加载至内存中0x100000（物理地址）处。\n第三部分 内核使用虚拟内存去解决位置依赖可以发现内核将自己链接至了非常高的虚拟地址，比如0xf0100000，为了将处理器虚拟地址的较低部分给用户程序去使用。将在下一个实验介绍这一现象。\n实际上，许多的机器在物理内存中并没有0xf0100000这样的高地址。实际上由处理器的内存管理硬件将虚拟地址0xf0100000映射到了实际内存中的物理地址0x100000。\n这涉及了分页机制以及页表。在kern/entry.S设置CR0_PG标记之前，内存引用被当做线性地址。实际上，由于在boot/boot.S设置了线性地址到物理地址的一致映射，所以线性地址在这里可以等同于物理地址。当CR0_PG标记被设置了之后，所有的内存引用都被当作虚拟地址。虚拟地址通过虚拟内存硬件被翻译成物理地址。kern/entrypgdir.c将0xf0000000到0xf0400000的虚拟地址翻译为物理地址的0x000000到0x400000，也将0x00000000到0x00400000的虚拟地址翻译为物理地址的0x00000000到0x00400000。引用这些地址范围以外的虚拟地址将会抛出缺页的异常。但是还没有为该异常设置中断处理程序。这会导致QEMU导出机器状态并退出。\n练习7：在movl %eax, %cr0指令（启动页表）之前，0x00100000出的内存不为空，0xf0100000出的内存全为0。当stepi之后，0xf0100000处的内存和0x00100000处的内存完全一样。这表明已经成功启用了页表，并且完成了地址的映射。\n控制台的格式化字符串练习8：缺失的代码为：1234case 'o':\tnum = getuint(&amp;ap, lflag);base = 8goto number;\n\nconsole.c提供了基本的I/O操作，同时封装了cputchar、getchar等函数供printf.c中的printf使用。printf使用了vprintfmt去解析格式化字符串并提供可变参数的特性。\n这段代码主要实现了换行。其首先检查了当前的光标是否超过了最大值，如果是，则证明需要进行换行。其将第1行到第MAX-1行的内容复制到第0行到第MAX-2行所在的内存中，然后将第MAX-1行置空。最后将光标设置到新一行的开始。\nfmt指向了格式化字符串”x %d, y %x, z %d\\n”ap指向了局部变量并且初始值为112345678910111213141516171819202122232425vcprintf(0xf0102449, 0xf0110e14);0xf0102449 -&gt; \"x %d, y %x, z %d\\n\" 0xf0110e14 -&gt; 1cons_putc(120);cons_putc(32);va_arg(0xf0110dbc, int);Before: 0xf0110dbc -&gt; 0xf0110e14 -&gt; 1After: 0xf0110dbc -&gt; 0xf0110e18 -&gt; 3cons_putc(49);cons_putc(44);cons_putc(32);cons_putc(121);cons_putc(32);va_arg(0xf0110dbc, int);Before: 0xf0110dbc -&gt; 0xf0110e18 -&gt; 3After: 0xf0110dbc -&gt; 0xf0110e1c -&gt; 4cons_putc(51);cons_putc(44);cons_putc(32);cons_putc(122);cons_put(32);va_arg(0xf0110dbc, int);Before: 0xf0110dbc -&gt; 0xf0110e1c -&gt; 4After: 0xf0110dbc -&gt; 0xf0110e20 -&gt; 536870922cons_put(52);cons_put(10);\n注意这里va_arg是宏而不是函数，不能通过加断点的方式跟踪。我采用的方法是在调用va_arg的地方添加断点并跟踪。在GNUmakefile中的C_FLAGS -O1会重排C代码，导致了追踪va_arg变得困难。所以，仅在此处将-O1变成-O0，尽管这会导致在backtrace时kernel panic。\n57616 = 0xe110。此外，根据x86的小端序，&amp;i指向了byte序列0x72、0x6c、0x64、0x00。这等同于字符串”rld”。所以，最终的输出为”He110 World”。需要将i改为0x726c6400。不需要修改57616。\n这是由于程序从格式化字符串中推断出了应当有3个参数，所以程序会从cprintf的栈中多读取一个参数。但实际上只有2个参数。所以最后一个参数是未指定的。\nvcprintf(…, const char * fmt)。\n\n栈练习9：f0100034:    bc 00 00 11 f0           mov    $0xf0110000,%esp这一条指令初始化了引导栈，它位于0xf0110000处。内核仅通过设置esp寄存器的值为栈预留空间。栈指针指向高地址，并且栈自高地址向低地址延伸。\n练习10：本题考察了x86架构下的栈帧与函数调用。函数调用时先将返回地址压栈，然后跳转至目标函数的起始地址；在目标函数内先将ebp寄存器的值（栈底）压栈保存，然后再将栈顶指针设置为新的栈底；在函数中调用函数需要使用栈来传递参数，即将函数的参数以此压入栈中；test_backtrace函数的汇编中使用了ebx寄存器，该寄存器为被调用者保存的寄存器，在使用的时候也要先压栈保存，再函数返回时恢复；函数返回的时候通过先操作esp释放栈资源，然后恢复相应的被调用者保存的寄存器的值，最后调用汇编指令leave、ret返回；leave指令先将esp的值置为ebp，然后再从栈中取出被保存的ebp的旧值；ret从栈中取出返回地址并跳转。\n练习10-12：mon_backtrace的实现如下：12345678910111213141516171819int mon_backtrace(int argc, char **argv, struct Trapframe *tf) &#123;    uint32_t            ebp, eip, args[5];    struct Eipdebuginfo info;    cprintf(\"Stack backtrace:\\n\");    for (ebp = read_ebp(); ebp != 0; ebp = *((uint32_t *)ebp)) &#123;        eip = *((uint32_t *)ebp + 1);        debuginfo_eip(eip, &amp;info);        args[0] = *((uintptr_t *)ebp + 2);        args[1] = *((uintptr_t *)ebp + 3);        args[2] = *((uintptr_t *)ebp + 4);        args[3] = *((uintptr_t *)ebp + 5);        args[4] = *((uintptr_t *)ebp + 6);        cprintf(\"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\\n\", ebp,                eip, args[0], args[1], args[2], args[3], args[4]);        cprintf(\"      %s:%d: %.*s+%d\\n\", info.eip_file, info.eip_line,                info.eip_fn_namelen, info.eip_fn_name, eip - info.eip_fn_addr);    &#125;    return 0;&#125;查阅STABS文档可以知道表示行号的成员是n_desc，所以debuginfo_eip的缺失的代码如下：123456stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);if (lline &lt;= rline) &#123;    info-&gt;eip_line = stabs[lline].n_desc;&#125; else &#123;    return -1;&#125;修改后的commands结构体如下：12345static struct Command commands[] = &#123;   &#123; \"help\", \"Display this list of commands\", mon_help &#125;,   &#123; \"kerninfo\", \"Display information about the kernel\", mon_kerninfo &#125;,   &#123; \"backtrace\", \"Display information about the stack frames\", mon_backtrace &#125;,&#125;;\n提高 - 允许控制台输出不同颜色的文本要求能增强控制台的功能使得控制台可以输出不同颜色的字体。这里使用了传统的实现，解析嵌入在文本字符串中的ANSI转义序列来实现题目的要求。\n在王爽的《汇编语言》中，已经接触过了字符的“属性字节”，一个字符的自低到高的第2个字节可以作为属性字节，用来指示字符的属性如闪烁、高亮、前景色、背景色等。有关于ANSI转义序列的相关知识可以参考这里。\n出于简化考虑，只部分实现ANSI转义序列中的ESC[Ps;...;Psm。\n实现的思路是实现&lt;kern/printf.c&gt;中的punch函数的替代版本attribute_punch，来实现对于ANSI转义序列的解析，并且相应地设置字符的属性字节。\n解析所需要的状态机具有三个状态：A_NORM代表正常的输出字符的状态、A_TRANS代表接收到[ESC]开始，从正常状态到解析转义序列的过渡状态、A_ESCAPE代表解析转义序列的状态。它们之间的状态转换图如图所示：\n\nvalue用来存储每一个解析到的值，temp代表了解析过程中临时的属性字节，attribute代表了当前打印字符时附加的属性字节。\n具体的实现代码在&lt;kern/printf.c&gt;中：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// state for ANSI escape sequence interpretationenum &#123; A_NORM = 0, A_TRANS, A_ESCAPE &#125;;// colormap - number (x - 30/40)[0, 7] -&gt; attribute bytestatic uint16_t colormap[8] = &#123;    0x0000, 0x4400, 0x2200, 0x6600, 0x1100, 0x5500, 0x3300, 0x7700,&#125;;static void attribute_punch(int ch, int *cnt) &#123;    static int value     = 0;         // value    static int state     = A_NORM;    // current state    static int temp      = 0x0000,               attribute = 0x0000;    // temp attribute, current attribute    switch (state) &#123;    // state machine        case A_NORM:            if (ch == 0x1B) &#123;       // [ESC]                state = A_TRANS;    // transfer from A_NORM to A_TRANS            &#125; else &#123;                cputchar((attribute &amp; 0xFF00) |                         ch);    // put character with attribute                *cnt++;            &#125;            break;        case A_TRANS:            if (ch == '[') &#123;         // [                state = A_ESCAPE;    // transfer from A_TRANS to A_ESCAPE            &#125; else &#123;                state = A_NORM;    // transfer from A_TRANS to A_NORM            &#125;            break;        case A_ESCAPE:            if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;    // digit - update value                value = value * 10 + ch - '0';            &#125; else if (ch == ';' ||                       ch == 'm') &#123;    // ; or m set temp and clear value                if (value == 0) &#123;                    temp = colormap[0];                &#125; else if (value == 5) &#123;                    temp |= 0x8000;                &#125; else if (value &gt;= 30 &amp;&amp; value &lt;= 38) &#123;                    temp |= colormap[value - 30] &amp;                            0x0700;    // look up in color map                &#125; else if (value &gt;= 40 &amp;&amp; value &lt;= 48) &#123;                    temp |=                        colormap[value - 40] &amp; 0x7000;    // avoid complex cases                &#125;                value = 0;                if (ch == 'm') &#123;    // m needed extra work - update attribute                    attribute = temp;                    temp      = 0x0000;                    state     = A_NORM;    // transfer from A_ESCAPE to A_NORM                &#125;            &#125; else &#123;               // non_digit nor m                state = A_NORM;    // transfer from A_ESCAPE to A_NORM            &#125;            break;    &#125;&#125;int vcprintf(const char *fmt, va_list ap) &#123;    int cnt = 0;    // vprintfmt((void*)putch, &amp;cnt, fmt, ap);    // use attribute_punch rather than punch    vprintfmt((void *)attribute_punch, &amp;cnt, fmt, ap);    return cnt;&#125;\n最后在monitor.c中添加相关cprintf代码，并重新编译测试。最终如图所示：\n\n有关于实验指导中提到的打开vga硬件的graphics mode使得控制台绘制文本到图形帧缓冲区的实现，由于时间和难度原因，这里暂时跳过。\n实验小结最终执行make grade，评分脚本的输出如下：1234567running JOS: (1.2s)  printf: OK  backtrace count: OK  backtrace arguments: OK  backtrace symbols: OK  backtrace lines: OKScore: 50/50至此，实验一结束。\n第一个实验总体来说更偏重于概念的理解、工具的使用而不是实际的代码。\n尽管如此，大量的概念也浪费了我很多时间去理解。MIT的6.828同清华的ucore操作系统实验相比提供了相当多的reference（ucore的阅读材料几乎都是现成的），这也对文档阅读和信息检索能力有了更高的要求。\n","dateCreated":"2017-12-09T03:32:48+08:00","dateModified":"2018-05-15T17:16:08+08:00","datePublished":"2017-12-09T03:32:48+08:00","description":"","headline":"MIT6.828操作系统工程Lab1-Booting a PC实验报告","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/"},"publisher":{"@type":"Organization","name":"码龙黑曜","sameAs":["https://github.com/BlackDragonF","https://t.me/Cosidian","http://steamcommunity.com/id/BlackDragonF/","mailto:obsidiandragon2016@gmail.com"],"image":"avatar.jpg","logo":{"@type":"ImageObject","url":"avatar.jpg"}},"url":"http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/","keywords":"操作系统, 实验"}</script>
    <meta name="description" content="本学期开设了操作系统的专业课。根据老师的介绍，下个学期的操作系统课设就是MIT的6.828的Labs，再加上团队老学长/同学的推荐，打算先在这个学期完成6.828，加深对于系统的理解。Lab1 - Booting a PC是比较简单的实验，主要包括了引导、内核、控制台输出、以及栈。尽管如此，由于相关知识的缺失，我断断续续做了2周（2017年10月26日）才完成该实验。2017年12月9日，完成了">
<meta name="keywords" content="操作系统,实验">
<meta property="og:type" content="blog">
<meta property="og:title" content="MIT6.828操作系统工程Lab1-Booting a PC实验报告">
<meta property="og:url" content="http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/index.html">
<meta property="og:site_name" content="码龙的窝">
<meta property="og:description" content="本学期开设了操作系统的专业课。根据老师的介绍，下个学期的操作系统课设就是MIT的6.828的Labs，再加上团队老学长/同学的推荐，打算先在这个学期完成6.828，加深对于系统的理解。Lab1 - Booting a PC是比较简单的实验，主要包括了引导、内核、控制台输出、以及栈。尽管如此，由于相关知识的缺失，我断断续续做了2周（2017年10月26日）才完成该实验。2017年12月9日，完成了">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/ansi_stm.png">
<meta property="og:image" content="http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/lab1_final.png">
<meta property="og:updated_time" content="2018-05-15T09:16:08.577Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT6.828操作系统工程Lab1-Booting a PC实验报告">
<meta name="twitter:description" content="本学期开设了操作系统的专业课。根据老师的介绍，下个学期的操作系统课设就是MIT的6.828的Labs，再加上团队老学长/同学的推荐，打算先在这个学期完成6.828，加深对于系统的理解。Lab1 - Booting a PC是比较简单的实验，主要包括了引导、内核、控制台输出、以及栈。尽管如此，由于相关知识的缺失，我断断续续做了2周（2017年10月26日）才完成该实验。2017年12月9日，完成了">
<meta name="twitter:image" content="http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/ansi_stm.png">
    
    
        
    
    
        <meta property="og:image" content="http://blog.codedragon.tech/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-j4w0tbtf1olriqsnfyv4egntpbdblucqpyraoqqnvawa2vd6l4m8ljtn2yes.min.css">
    <!--STYLES END-->
    
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-108458894-1', 'auto');
        ga('send', 'pageview');
    </script>


    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">码龙的窝</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">码龙黑曜</h4>
                
                    <h5 class="sidebar-profile-bio"><p>iOS开发者/计算机科学/兽人控</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="首页"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="分类"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="标签"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="归档"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/projects"
                            
                            title="项目"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-code" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">项目</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/about"
                            
                            title="关于"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/BlackDragonF" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://t.me/Cosidian" target="_blank" rel="noopener" title="Telegram">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-telegram" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Telegram</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://steamcommunity.com/id/BlackDragonF/" target="_blank" rel="noopener" title="Steam">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-steam" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Steam</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:obsidiandragon2016@gmail.com" target="_blank" rel="noopener" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/links"
                            
                            title="友情链接"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-link" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">友情链接</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/resources"
                            
                            title="学习资源"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-share-alt" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">学习资源</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            MIT6.828操作系统工程Lab1-Booting a PC实验报告
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2017-12-09T03:32:48+08:00">
	
		    12月 09, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <blockquote>
<p>本学期开设了操作系统的专业课。根据老师的介绍，下个学期的操作系统课设就是MIT的6.828的Labs，再加上团队老学长/同学的推荐，打算先在这个学期完成6.828，加深对于系统的理解。<br>Lab1 - Booting a PC是比较简单的实验，主要包括了引导、内核、控制台输出、以及栈。尽管如此，由于相关知识的缺失，我断断续续做了2周（2017年10月26日）才完成该实验。<br>2017年12月9日，完成了实验的提高部分并写完了报告。</p>
</blockquote>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>首先需要完成实验环境的搭建。实验环境主要由两个部分组成：QEMU用来模拟运行内核，以及一条编译工具链用于编译和测试内核。这里我使用的系统是64位的ArchLinux。</p>
<blockquote>
<p>本部分可以参考MIT 6.828官网的<a href="https://pdos.csail.mit.edu/6.828/2017/tools.html" target="_blank" rel="noopener">Tools</a>。</p>
</blockquote>
<h3 id="编译工具链"><a href="#编译工具链" class="headerlink" title="编译工具链"></a>编译工具链</h3><p>编译工具链包含了C编译器、汇编器、连接器，用于从源代码生成可执行二进制文件。本实验的目标代码是32位的Intel架构（x86），可执行文件格式为ELF。</p>
<p>在Arch Linux下，若是在安装时选择了base-devel包组，则gcc应该是系统自带的编译工具链。但是，该gcc默认不能编译生成32位的可执行文件。需要手动开启<a href="https://wiki.archlinux.org/index.php/multilib" target="_blank" rel="noopener">multilib</a>并安装gcc-multilib以及相关的软件包。</p>
<h4 id="GCC版本降级说明"><a href="#GCC版本降级说明" class="headerlink" title="GCC版本降级说明"></a>GCC版本降级说明</h4><p>在我和华田的Arch下，使用gcc 7.1.1-3之后的版本编译生成的JOS kernel均无法使用。在无法查明原因的情况下，推荐将gcc降级至7.1.1-3完成6.828的实验。</p>
<p>有关于Arch下软件包降级的教程请看<a href="https://wiki.archlinux.org/index.php/downgrading_packages" target="_blank" rel="noopener">这里</a>。</p>
<p>在后续的实验中，为了使得编译JOS内核的工具链不和系统工具链冲突以及为了保证系统工具链的最新，尝试了手动编译32位的gcc 4.6.1作为JOS专用的交叉编译工具链，并使用modules来管理环境变量，具体可以参考<a href="http://blog.codedragon.tech/2018/02/01/gcc4-6-1%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8Amodules%E7%9A%84%E4%BD%BF%E7%94%A8/">这里</a>。</p>
<h3 id="Qemu模拟器"><a href="#Qemu模拟器" class="headerlink" title="Qemu模拟器"></a>Qemu模拟器</h3><p>QEMU是一个现代并且快速的PC模拟器，但是为了与实验兼容，MIT推荐使用他们patched过的QEMU版本。需要按照Tools上的教程从源码编译并安装QEMU。</p>
<p>注意：提供的QEMU并不支持<code>make uninstall</code>，需要手动卸载QEMU。如果您对于手动编译并安装可能存在的<strong>后果</strong>抱有顾虑，推荐使用包管理软件安装QEMU，或是修改编译前缀，不要将编译好的qemu安装到<code>/usr/local/</code>下</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li>所需要的库名可以在arch官网上通过搜索软件包的方式找到；</li>
<li>configure的时候加上–disable-werror以保证不会因出现编译警告而终止编译；</li>
<li><p>出现如下错误：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Unescaped left brace <span class="keyword">in</span> regex is illegal here <span class="keyword">in</span> regex; marked by &lt;-- HERE</span><br><span class="line"><span class="keyword">in</span> m/^\@strong&#123; &lt;-- HERE (.*)&#125;$/ at /home/guest/qemu/scripts/texi2pod.pl</span><br><span class="line">line 320.</span><br><span class="line"></span><br><span class="line">make: *** [Makefile:474：qemu.1] 错误 255。</span><br></pre></td></tr></table></figure>
<p> 该错误是由于perl版本更新后正则表达式语法的变动造成的，直接修改安装脚本的<code>/home/chenzhihao/qemu/scripts/texi2pod.pl line 320</code>，将<code>{</code>改成 <code>\{</code>即可；</p>
</li>
<li>configure时可能需要指定python版本为2以避免调用python3出现错误，参数为<code>--python=/usr/bin/python2.7</code>。</li>
</ol>
<h2 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h2><p>实验1总共分为3个部分：</p>
<ul>
<li>第1部分主要关注x86汇编语言、QEMU x86模拟器以及PC的上电启动流程；</li>
<li>第2部分主要关注6.828内核的引导程序；</li>
<li>第3部分开始挖掘6.828内核的最初模板 - JOS。</li>
</ul>
<p>实验使用Git进行版本管理，需要从MIT的Git克隆最开始的仓库，有关这一部分的具体说明请自行参考<a href="https://pdos.csail.mit.edu/6.828/2017/labs/lab1/" target="_blank" rel="noopener">Lab1实验讲义</a>。</p>
<p>有关于Git的教程推荐<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的官方博客</a>或者是<a href="https://www.gitbook.com/book/bingohuang/progit2/details" target="_blank" rel="noopener">Pro Git 2</a>。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="第一部分-PC-Bootstrap-PC引导"><a href="#第一部分-PC-Bootstrap-PC引导" class="headerlink" title="第一部分 PC Bootstrap - PC引导"></a>第一部分 PC Bootstrap - PC引导</h3><h4 id="x86汇编"><a href="#x86汇编" class="headerlink" title="x86汇编"></a>x86汇编</h4><p>练习1：<br>本实验需要熟悉x86汇编。</p>
<p>8086汇编已经在王爽的《汇编语言》以及学院的汇编语言课程中学习过，x86_64汇编也已经在《深入理解计算机系统》中有所涉猎。本实验中使用的是i386汇编。这里不再赘述。</p>
<h4 id="模拟x86"><a href="#模拟x86" class="headerlink" title="模拟x86"></a>模拟x86</h4><p>在本实验中使用QEMU作为模拟器。尽管QEMU内置的监控只能提供少量的调试支持，但是QEMU却可以作为GNU-Debugging（GDB）的远程调试目标。</p>
<p>根据实验指导使用make编译生成内核并且用<code>make qemu</code>或者是<code>make qemu-nox</code>启动QEMU。可以看到，当前的内核仅支持两条命令help和kerninfo。</p>
<h4 id="PC的物理地址空间"><a href="#PC的物理地址空间" class="headerlink" title="PC的物理地址空间"></a>PC的物理地址空间</h4><p>PC的物理地址空间有着如下的布局：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>
<p>最初的PC基于Intel的16位8088处理器，仅能够支持2^20B = 2^10KB = 1MB的寻址，早期的地址空间从0x00000开始到0xFFFFF结束。</p>
<ul>
<li>0x00000到0xA0000（640KB）被称作低内存，是早期PC能用的唯一的RAM；</li>
<li>0xA0000到0xFFFFF（384KB）被硬件保留作特殊用途如视频缓冲区或是固件，该部分最重要的区域是从0xF0000到0xFFFFF（64KB）的基本输入输出系统（BIOS）。BIOS用作执行最基本的系统初始化如激活显卡、检查内存等。在初始化完成后，BIOS从软盘、硬盘、光驱或是网络中读取操作系统，并且将机器控制权转移给操作系统。</li>
</ul>
<p>从Intel的80286到80386，处理器能够支持16MB和4GB的地址空间。但为了后向兼容性，硬件设计者保留了低1M内存的布局。<br>现代PC因此在0x000A0000到0x00100000的内存中有一个“洞”，这个洞将内存分为了低内存/保留内存（Low Memory）（低640KB）以及扩展内存（Extended Memory）（其他内存）。除此以外，32位PC的地址空间的最上方，常常被BIOS保留用作32位的PCI设备。</p>
<p>最新的x86处理器能够支持超过4GB的物理内存，因此内存可以超过0xFFFFFFFF。因此BIOS需要预留出第二个“洞”以保证那些32位的PCI设备的地址可以被正确的映射。</p>
<p>由于JOS只会使用256M内存，在此假设仅PC具有32位的地址空间。</p>
<h4 id="ROM-BIOS"><a href="#ROM-BIOS" class="headerlink" title="ROM BIOS"></a>ROM BIOS</h4><p>根据实验指导，进行QEMU和GDB的联合调试。会发现从上电开始，IBM PC从0x000ffff0开始执行指令。该处位于为BIOS预留的64kb的空间的顶层。此时CS = 0xf000 IP = 0xfff0。且第1条指令是一个jmp指令，跳转至CS = 0xf000 IP = 0xe05b。</p>
<p>这些都是早期的8088处理器的设计者设计的。这样的设计保证了BIOS总能控制机器。因为在刚上电的时候，在内存中并不存在能够执行的代码。</p>
<blockquote>
<p>此处需要理解8086的分段式寻址，即通过两个16位寄存器的值构造20位地址。实际地址为CS × 16 + IP = 0xf000 × 16 + 0xfff0 = 0xffff0。</p>
</blockquote>
<p>练习2：<br>使用gdb的<code>si</code>（单步调试）命令进入ROM BIOS并追踪几条指令，并猜测这些指令的作用。不需要指出指令具体的细节，只要理解BIOS一开始运行的核心思想而已。</p>
<p>BIOS执行的前若干条指令和作用如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[f000:fff0]    <span class="number">0xffff0</span>: ljmp   <span class="number">$0</span>xf000,<span class="number">$0</span>xe05b # 跳到一个较早的位置</span><br><span class="line">[f000:e05b]    <span class="number">0xfe05b</span>: cmpl   <span class="number">$0</span>x0,%cs:<span class="number">0x6ac8</span></span><br><span class="line">[f000:e062]    <span class="number">0xfe062</span>: <span class="keyword">jne</span>    <span class="number">0xfd2e1</span>         # 测试<span class="built_in">cs</span>段的<span class="number">0x6ac8</span>字是否为<span class="number">0</span>        </span><br><span class="line">[f000:e066]    <span class="number">0xfe066</span>: <span class="keyword">xor</span>    %dx,%dx         # 测试为<span class="number">0</span></span><br><span class="line">[f000:e068]    <span class="number">0xfe068</span>: <span class="keyword">mov</span>    %dx,%ss         </span><br><span class="line">[f000:e06a]    <span class="number">0xfe06a</span>: <span class="keyword">mov</span>    <span class="number">$0</span>x7000,%esp    # 设置栈段寄存器和栈指针寄存器</span><br><span class="line">                                               # 栈的延伸方向和代码段延伸方向相反</span><br><span class="line">[f000:e070]    <span class="number">0xfe070</span>: <span class="keyword">mov</span>    <span class="number">$0</span>xf34c2,%edx   # 设置<span class="built_in">edx</span>寄存器值</span><br><span class="line">[f000:e076]    <span class="number">0xfe076</span>: <span class="keyword">jmp</span>    <span class="number">0xfd15c</span>         # 跳转</span><br><span class="line">[f000:d15c]    <span class="number">0xfd15c</span>: <span class="keyword">mov</span>    %eax,%ecx       </span><br><span class="line">[f000:d15f]    <span class="number">0xfd15f</span>: <span class="keyword">cli</span>                    # 关闭硬件中断</span><br><span class="line">[f000:d160]    <span class="number">0xfd160</span>: <span class="keyword">cld</span>                    # 设置串传送指令方向</span><br><span class="line">[f000:d161]    <span class="number">0xfd161</span>: <span class="keyword">mov</span>    <span class="number">$0</span>x8f,%eax      </span><br><span class="line">[f000:d167]    <span class="number">0xfd167</span>: <span class="keyword">out</span>    %al,<span class="number">$0</span>x70       # 关闭不可屏蔽中断</span><br><span class="line">[f000:d169]    <span class="number">0xfd169</span>: <span class="keyword">in</span>     <span class="number">$0</span>x71,%al       # 从CMOS读取选择的寄存器</span><br><span class="line">[f000:d16b]    <span class="number">0xfd16b</span>: <span class="keyword">in</span>     <span class="number">$0</span>x92,%al       # 读取系统控制端口A</span><br><span class="line">[f000:d16d]    <span class="number">0xfd16d</span>: <span class="keyword">or</span>     <span class="number">$0</span>x2,%al        </span><br><span class="line">[f000:d16f]    <span class="number">0xfd16f</span>: <span class="keyword">out</span>    %al,<span class="number">$0</span>x92       # 通过快速A20以启动A20</span><br><span class="line">[f000:d171]    <span class="number">0xfd171</span>: lidtw  %cs:<span class="number">0x6ab8</span>      # 将<span class="built_in">cs</span>:<span class="number">0x6ab8</span>加载进入IDT表</span><br><span class="line">[f000:d177]    <span class="number">0xfd177</span>: lgdtw  %cs:<span class="number">0x6a74</span>      # 将<span class="built_in">cs</span>:<span class="number">0x6a74</span>加载进入GDT表</span><br><span class="line">[f000:d17d]    <span class="number">0xfd17d</span>: <span class="keyword">mov</span>    %cr0,%eax   </span><br><span class="line">[f000:d180]    <span class="number">0xfd180</span>: <span class="keyword">or</span>     <span class="number">$0</span>x1,%eax       </span><br><span class="line">[f000:d184]    <span class="number">0xfd184</span>: <span class="keyword">mov</span>    %eax,%cr0       # 将<span class="built_in">cr0</span>寄存器的保护模式位打开</span><br><span class="line">[f000:d187]    <span class="number">0xfd187</span>: ljmpl  <span class="number">$0</span>x8,<span class="number">$0</span>xfd18f   # 通过ljmp指令进入保护模式</span><br><span class="line">=&gt; <span class="number">0xfd18f</span>:     <span class="keyword">mov</span>    <span class="number">$0</span>x10,%eax              # 设置段寄存器</span><br><span class="line">=&gt; <span class="number">0xfd194</span>:     <span class="keyword">mov</span>    %eax,%ds</span><br><span class="line">=&gt; <span class="number">0xfd196</span>:     <span class="keyword">mov</span>    %eax,%es  </span><br><span class="line">=&gt; <span class="number">0xfd198</span>:     <span class="keyword">mov</span>    %eax,%ss</span><br><span class="line">=&gt; <span class="number">0xfd19a</span>:     <span class="keyword">mov</span>    %eax,%fs</span><br><span class="line">=&gt; <span class="number">0xfd19c</span>:     <span class="keyword">mov</span>    %eax,%gs</span><br><span class="line">=&gt; <span class="number">0xfd19e</span>:     <span class="keyword">mov</span>    %ecx,%eax  </span><br><span class="line">=&gt; <span class="number">0xfd1a0</span>:     <span class="keyword">jmp</span>    *%edx                   # 跳转</span><br></pre></td></tr></table></figure></p>
<h3 id="第二部分-引导"><a href="#第二部分-引导" class="headerlink" title="第二部分 引导"></a>第二部分 引导</h3><p>软盘和硬盘被分为了512Bytes的区域 - 扇区（Sector）。一个扇区是磁盘传输的最小粒度：每一个读操作和写操作必须是一个或是一个以上的扇区，并且必须要对齐到扇区。</p>
<p>如果一个磁盘是可引导的，那么它的第一个扇区就被称作引导扇区，引导代码就存储在引导扇区中。如果BIOS发现了一个可引导的硬件，那么它就将这个扇区从磁盘读取至内存的0x7c00到0x7dff处，并且使用一个jmp指令设置CS：IP = 0000:7C00，将控制传递给引导。和BIOS读取地址一样，这个地址对于PC来说是固定和标准化的。</p>
<blockquote>
<p>从光盘引导的情形更加复杂，因为光盘的一个扇区为2048Byte，BIOS可以从硬盘读取一个更大的引导镜像到内存中。</p>
</blockquote>
<p>在6.828中，使用硬盘的传统引导机制。这意味这引导必须满足512个Bytes的限制。引导由一个汇编文件boot/boot.S，以及一个C语言文件boot/main.c组成。</p>
<p>练习3：追踪boot.S和main.C，分析每一个部分的作用。</p>
<hr>
<p>为了理解boot.S，需要以下的知识储备。</p>
<h4 id="实模式和保护模式"><a href="#实模式和保护模式" class="headerlink" title="实模式和保护模式"></a>实模式和保护模式</h4><p>实模式是为了与8086兼容而设置的。在实模式下，处理器相当于一个快速的8086处理器。当处理器被加电或者复位时以实模式启动。</p>
<ul>
<li>实模式下各寄存器以实模式的初始化值工作；</li>
<li>实模式的地址空间总共为20位（1MB）；</li>
<li>实模式下不支持内存分页机制；</li>
<li>实模式下各内存段均是可读、可写、可执行的，不支持指令优先级，所有的指令均运行在特权级；</li>
<li>实模式不支持多任务切换；</li>
<li>实模式的中断处理也和8086相同，使用中断向量表来定位中断服务程序。</li>
</ul>
<p>在保护模式下，处理器的所有功能都是可用的。具体来说：</p>
<ul>
<li>保护模式提供了完全的32位地址空间，寻址空间为4GB；</li>
<li>保护模式支持内存分页机制，提供了对虚拟内存的硬件支持；</li>
<li>保护模式的处理器支持多任务（上下文切换）；</li>
<li>保护模式的处理器支持指令和数据的特权级，配合边界检查等机制，既可以共享数据也可以隔离各个任务。</li>
</ul>
<p>为了保证后向兼容性，x86的处理器启动时默认是实模式，需要手动从实模式切换至保护模式。但是切换至保护模式之前需要做一些必要的准备工作，如打开A20和建立全局描述符表等。</p>
<h4 id="A20地址线"><a href="#A20地址线" class="headerlink" title="A20地址线"></a>A20地址线</h4><p>在早期的PC上处理器仅支持20位的地址空间，任何超过20位的地址都会被卷回。<br>例如：0xFFFF+0xFFFF = 0x1FFFE -&gt; 0xFFFE</p>
<p>然而，从80286开始，Intel支持了24位的地址空间，上例的地址相加将不会发生卷回。<br>为了保证与早期PC的完全兼容，Intel采用了“黑魔法” - 将A20（第21根）地址线与键盘控制器的一个输出进行了与运算。进而控制A20地址线的值。</p>
<p>默认情况下，A20是置0的，PC将只能访问1M、3M、5M…这样的奇数段。进入保护模式前需要先打开A20以获得完全的寻址能力。</p>
<p>JOS内核通过端口的方式与键盘控制器进行通信并打开A20。可以参考Reference中的<a href="http://www.computer-engineering.org/ps2keyboard/" target="_blank" rel="noopener">PS/2 Keyboard Interface</a>。</p>
<ul>
<li>8042有一个1 Byte的输入缓冲区，一个1 Byte的输出缓冲区、一个1 Byte的状态寄存器、以及一个1 Byte的控制寄存器。前三个寄存器可以直接从0x60和0x64端口进行访问。最后一个寄存器通过“Read Command Byte”命令进行读，通过“Write Command Byte”命令进行写。</li>
<li>对0x60端口读会读输入缓冲区；对0x60端口写会写输出缓冲区；对0x64端口读会读状态寄存器；对0x64端口写会发送命令。</li>
<li>状态寄存器的Bit1为IBF - Input Buffer Full，当该Bit为1时，输入缓冲区满，不能对0x60端口或0x64端口写。</li>
<li>对0x64端口写0xd1发送的命令是“Write Output Port”写输出端口，表明将参数写入输出端口（0x60端口写）。</li>
<li>A20使用的是键盘控制器输出的Bit 1，向输出端口写入0xdf可以打开A20；向输出端口写入0xdd则会关闭A20。</li>
</ul>
<h4 id="分段机制与全局描述符表"><a href="#分段机制与全局描述符表" class="headerlink" title="分段机制与全局描述符表"></a>分段机制与全局描述符表</h4><p>x86处理器提供了分段机制和分页机制两种内存管理模式。如果要进入保护模式，就必须要先启动分段机制。（分页机制不是必须的）</p>
<p>分段机制将内存划分为若干个段，每个段都由段基址、段界限和段属性组成。由一个段描述符表（可以理解为一个数组）描述所有段的信息。段描述符表可以是全局的也可以是局部的。</p>
<p>简化的说，程序首先将对应的段选择子（可以理解为数组的索引）加载进入段寄存器中。然后在执行程序时，根据指令的内容确定应该使用的段寄存器，根据段寄存器中的段选择子确定应该使用的段描述符。再结合段描述符中包含的信息加上指令自身的地址构造出实际的物理地址。最终将该地址发送到地址总线上，到物理内存中寻址，并取回相应的数据。这之中简化了有关特权级、边界检查的相关内容，但足以描述分段机制的基本原理。</p>
<p>分段机制将虚拟地址转换成了线性地址。</p>
<h5 id="全局描述符表寄存器"><a href="#全局描述符表寄存器" class="headerlink" title="全局描述符表寄存器"></a>全局描述符表寄存器</h5><p>x86处理器提供了专门的全局描述符表寄存器（Global Descriptor Table Register）用于保存全局描述符表的表基址和表限长。GDTR由2个字节的表限长（limit）和4个字节的表基址（base）组成。其中表基址指定了全局描述符表的起始地址，表限长指定了全局描述符表的大小。其C结构体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdtr</span> &#123;</span></span><br><span class="line">	u16 limite;</span><br><span class="line">	u32 base;</span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure></p>
<p>在机器刚加电或者是处理器复位后，表基址默认被置为0，表限长则默认被置为0xFFFF。在保护模式初始化的过程中，必须给GDTR加载新的值。可以使用lgdt指令为GDTR加载新值。</p>
<h5 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h5><p>段选择子（2个字节）用于选择特定的描述符表以及表中的特定描述符。段选择子一般被放置于段寄存器中，段选择子由13位的索引、1位的表指示位和2位的请求特权级三部分组成。其中索引指定了描述符，表指示位选择应该访问的描述符表 - 0代表全局描述符表，1代表局部描述符表，请求特权级用于段级的保护机制，自0到4分别代表ring 0到ring 3。其C结构体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">selector</span> &#123;</span></span><br><span class="line">    u16 index:<span class="number">13</span>;</span><br><span class="line">    u16 ti:<span class="number">1</span>;</span><br><span class="line">    u16 rpl:<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h5><p>段描述符（8个字节）是段描述符表这个“数组”的“元素”。用C结构体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdtdesc</span> &#123;</span></span><br><span class="line">	u16 lim0_15;</span><br><span class="line">	u16 base0_15;</span><br><span class="line">	u8 base16_23;</span><br><span class="line">	u8 acces;</span><br><span class="line">	u8 lim16_19:<span class="number">4</span>;</span><br><span class="line">	u8 other:<span class="number">4</span>;</span><br><span class="line">	u8 base24_31;</span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure></p>
<p>其中总共包含了32位的段基址、20位的段界限、以及12位的类型。<br>段基址规定了段的起始地址。段界限规定了段的大小。而类型用于区别不同类型的描述符。包括描述符特权级、段存在位、已访问位等等。</p>
<h4 id="boot-S代码详解"><a href="#boot-S代码详解" class="headerlink" title="boot.S代码详解"></a>boot.S代码详解</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;<span class="keyword">inc</span>/mmu.h&gt;</span><br><span class="line"></span><br><span class="line"># Start the <span class="meta">CPU</span>: switch to <span class="number">32</span>-bit protected mode, jump <span class="keyword">into</span> C.</span><br><span class="line"># The BIOS loads this code from the first sector of the hard disk <span class="keyword">into</span></span><br><span class="line"># memory <span class="meta">at</span> physical address <span class="number">0x7c00</span> <span class="keyword">and</span> starts executing <span class="keyword">in</span> real mode</span><br><span class="line"># with %cs=<span class="number">0</span> %ip=7c00.</span><br><span class="line"># boot.S 主要将<span class="meta">CPU</span>切换至<span class="number">32</span>位保护模式，并且跳转进入C代码</span><br><span class="line"></span><br><span class="line"><span class="meta">.set</span> PROT_MODE_CSEG, <span class="number">0x8</span>         # kernel code <span class="meta">segment</span> selector</span><br><span class="line"><span class="meta">.set</span> PROT_MODE_DSEG, <span class="number">0x10</span>        # kernel data <span class="meta">segment</span> selector</span><br><span class="line"><span class="meta">.set</span> CR0_PE_ON,      <span class="number">0x1</span>         # protected mode enable flag</span><br><span class="line"></span><br><span class="line"><span class="meta">.globl</span> start</span><br><span class="line"><span class="symbol">start:</span>                        # 程序入口</span><br><span class="line"><span class="meta">  .code16</span>                     # Assemble for <span class="number">16</span>-bit mode 指导生成<span class="number">16</span>位汇编代码</span><br><span class="line">  <span class="keyword">cli</span>                         # Disable interrupts 关中断</span><br><span class="line">  <span class="keyword">cld</span>                         # String operations increment 设置串传递顺序递增</span><br><span class="line"></span><br><span class="line">  # Set <span class="meta">up</span> the important data <span class="meta">segment</span> registers (<span class="built_in">DS</span>, <span class="built_in">ES</span>, <span class="built_in">SS</span>). 设置重要的段寄存器为<span class="number">0</span></span><br><span class="line">  xorw    %ax,%ax             # <span class="meta">Segment</span> number <span class="meta">zero</span></span><br><span class="line">  movw    %ax,%ds             # -&gt; Data <span class="meta">Segment</span></span><br><span class="line">  movw    %ax,%es             # -&gt; Extra <span class="meta">Segment</span></span><br><span class="line">  movw    %ax,%ss             # -&gt; Stack <span class="meta">Segment</span></span><br><span class="line"></span><br><span class="line">  # Enable A20:</span><br><span class="line">  #   For backwards compatibility with the earliest PCs, physical</span><br><span class="line">  #   address line <span class="number">20</span> is tied low, so that addresses higher than</span><br><span class="line">  #   1MB wrap around to <span class="meta">zero</span> by <span class="meta">default</span>.  This code undoes this.</span><br><span class="line">  # 开启A20：</span><br><span class="line">  #   A20的介绍已经给出，不再赘述。</span><br><span class="line"><span class="symbol">seta20.1:</span></span><br><span class="line">  inb     <span class="number">$0</span>x64,%al               # Wait for <span class="keyword">not</span> busy 等待缓冲区可用</span><br><span class="line">  testb   <span class="number">$0</span>x2,%al                # <span class="keyword">Test</span> for bit1</span><br><span class="line">                                  # if bit1 = <span class="number">1</span> then buffer is full</span><br><span class="line">  <span class="keyword">jnz</span>     seta20<span class="meta">.1</span></span><br><span class="line"></span><br><span class="line">  movb    <span class="number">$0</span>xd1,%al               # <span class="number">0xd1</span> -&gt; port <span class="number">0x64</span></span><br><span class="line">  outb    %al,<span class="number">$0</span>x64               # Prepare to write output port 准备写入输出端口</span><br><span class="line"></span><br><span class="line"><span class="symbol">seta20.2:</span></span><br><span class="line">  inb     <span class="number">$0</span>x64,%al               # Wait for <span class="keyword">not</span> busy 等待缓冲区可用</span><br><span class="line">  testb   <span class="number">$0</span>x2,%al</span><br><span class="line">  <span class="keyword">jnz</span>     seta20<span class="meta">.2</span>                # The same as above 同上</span><br><span class="line"></span><br><span class="line">  movb    <span class="number">$0</span>xdf,%al               # <span class="number">0xdf</span> -&gt; port <span class="number">0x60</span></span><br><span class="line">  outb    %al,<span class="number">$0</span>x60               # <span class="number">0xdf</span> -&gt; A20 gate enable command 打开A20</span><br><span class="line"></span><br><span class="line">  # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">  # <span class="keyword">and</span> <span class="meta">segment</span> translation that makes virtual addresses</span><br><span class="line">  # identical to their physical addresses, so that the</span><br><span class="line">  # effective memory map does <span class="keyword">not</span> change during the switch.</span><br><span class="line">  <span class="keyword">lgdt</span>    gdtdesc                # Load gdt size/base to gdtr 设置全局描述符表</span><br><span class="line">  movl    %cr0, %eax             # Control register <span class="number">0</span></span><br><span class="line">                                 # bit0 is protected enable bit</span><br><span class="line">                                 # 读取控制寄存器<span class="number">0</span>的值，其Bit0为允许保护模式位</span><br><span class="line">  orl     $CR0_PE_ON, %eax       # Set PE 将允许保护模式位置<span class="number">1</span></span><br><span class="line">  movl    %eax, %cr0             # Update Control register <span class="number">0</span> 设置控制寄存器<span class="number">0</span></span><br><span class="line"></span><br><span class="line">  # Jump to next instruction, but <span class="keyword">in</span> <span class="number">32</span>-bit code <span class="meta">segment</span>.</span><br><span class="line">  # Switches processor <span class="keyword">into</span> <span class="number">32</span>-bit mode.</span><br><span class="line">  ljmp    $PROT_MODE_CSEG, $protcseg # 通过ljmp指令（跳转至下一条指令）进入保护模式</span><br><span class="line"></span><br><span class="line"><span class="meta">  .code32</span>                     # Assemble for <span class="number">32</span>-bit mode 指导生成<span class="number">32</span>位汇编代码</span><br><span class="line"><span class="symbol">protcseg:</span></span><br><span class="line">  # Set <span class="meta">up</span> the protected-mode data <span class="meta">segment</span> registers 设置保护模式的数据段寄存器</span><br><span class="line">  movw    $PROT_MODE_DSEG, %ax    # Our data <span class="meta">segment</span> selector</span><br><span class="line">  movw    %ax, %ds                # -&gt; <span class="built_in">DS</span>: Data <span class="meta">Segment</span></span><br><span class="line">  movw    %ax, %es                # -&gt; <span class="built_in">ES</span>: Extra <span class="meta">Segment</span></span><br><span class="line">  movw    %ax, %fs                # -&gt; <span class="built_in">FS</span></span><br><span class="line">  movw    %ax, %gs                # -&gt; <span class="built_in">GS</span></span><br><span class="line">  movw    %ax, %ss                # -&gt; <span class="built_in">SS</span>: Stack <span class="meta">Segment</span></span><br><span class="line"></span><br><span class="line">  # Set <span class="meta">up</span> the stack pointer <span class="keyword">and</span> <span class="keyword">call</span> <span class="keyword">into</span> C. 设置栈指针并且调用C</span><br><span class="line">  movl    $start, %esp  # Stack has the opposite extension direction than Code</span><br><span class="line">                        # 注意栈的延伸方向和代码段相反</span><br><span class="line">  <span class="keyword">call</span> bootmain #调用main.c中的bootmain函数</span><br><span class="line"></span><br><span class="line">  # If bootmain returns (it shouldn<span class="string">'t), loop.</span></span><br><span class="line"><span class="string">spin:</span></span><br><span class="line"><span class="string">  jmp spin</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Bootstrap GDT 引导GDT</span></span><br><span class="line"><span class="string">.p2align 2                                # force 4 byte alignment</span></span><br><span class="line"><span class="string">gdt:</span></span><br><span class="line"><span class="string">  SEG_NULL				# null seg 默认第一个段描述符为空</span></span><br><span class="line"><span class="string">  SEG(STA_X|STA_R, 0x0, 0xffffffff)	# code seg 设置代码段描述符</span></span><br><span class="line"><span class="string">  SEG(STA_W, 0x0, 0xffffffff)	        # data seg 设置数据段描述符</span></span><br><span class="line"><span class="string">  # 关于SEG宏可以参考mmu.h</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">gdtdesc:                                  # 用于设置全局段描述符寄存器</span></span><br><span class="line"><span class="string">  .word   0x17                            # sizeof(gdt) - 1 # Size of gdt</span></span><br><span class="line"><span class="string">  .long   gdt                             # address gdt # Base address of gdt</span></span><br></pre></td></tr></table></figure>
<hr>
<p>为了理解main.c，需要如下的知识储备。</p>
<h4 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h4><p>可执行和可链接格式（Executable and Linkable Format）是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。</p>
<p>ELF文件可以分为两种组成 - 链接视图（Linking View）和执行视图（Execution View）。这里只讨论执行视图。</p>
<p>执行视图的结构如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">|     ELF Header     |</span><br><span class="line">+--------------------+</span><br><span class="line">|Program Header Table|</span><br><span class="line">+--------------------+</span><br><span class="line">|      Segment 1     |</span><br><span class="line">+--------------------+</span><br><span class="line">|      Segment 2     |</span><br><span class="line">+--------------------+</span><br><span class="line">|         ...        |</span><br><span class="line">+--------------------+</span><br><span class="line">|Section Header Table|</span><br><span class="line">|       optinal      |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure></p>
<p>ELF文件格式主要由ELF头（ELF Header）、程序头部表（Program Header Table）和节头部表（Section Header Table）组成。在执行视图中，节头部表是可选的。</p>
<p>有关于这些数据结构的C语言定义可以参考头文件&lt;inc/elf.h&gt;。</p>
<ul>
<li>ELF头主要包含了ELF魔数、文件类型、程序头部表偏移和大小、程序入口等信息；</li>
<li>程序头部表可以看做一个数据结构的数组，每一个元素都描述了一个段。主要包含了段的偏移、段的虚拟地址、段的物理地址、段的大小等信息。</li>
</ul>
<h4 id="磁盘控制器"><a href="#磁盘控制器" class="headerlink" title="磁盘控制器"></a>磁盘控制器</h4><p>磁盘是电脑主要的存储媒介。磁盘是由盘片构成的。每个盘片有两面或者称为表面，表面覆盖着磁性记录材料。盘片中央有一个可以旋转的主轴，它使得盘片以固定的旋转速率旋转，通常是5400-15000转每分钟（Revolution Per Minute）。磁盘通常包含一个或多个这样的盘片，并封装在一个密封的容器内。</p>
<p>每一个表面是由一组称为磁道的同心圆组成。每个磁道被划分为一组扇区。每个扇区包含相等数量的数据位（通常是512字节），这些数据编码在扇区上的磁性材料中。扇区之间由一些间隙分隔开，这些间隙中不存储数据位。间隙用来标识扇区的格式化位。</p>
<p>磁盘的柱面是所有盘片表面上到主轴中心距离相等的磁道的集合。</p>
<p>对于磁盘的寻址通常分为CHS和LBA两种。</p>
<ol>
<li>CHS即柱面（cylinder）-磁头（head）-扇区（sector）寻址。每个盘片都对应着一个磁头，每一个盘片都被划分成柱面，每一个柱面都被划分成多个段。磁盘的最小存储单元是段。早期的IBM PC架构上采用CHS进行磁盘寻址。CHS是一个三元组，包括10bit的柱面号，8bit的磁头号以及6bit的扇区号。这样CHS的最大寻址范围为2^10 × 2^8 × 2^6 × 512 = 8GB。</li>
<li>随着磁盘容量的不断扩大，CHS的8GB寻址范围已经不能满足需要，现在的磁盘普遍采用逻辑区块地址（Logical Block Adress）的方式进行寻址来进行抽象。LBA是一个整数，代表磁盘上的一个逻辑区块编号，通过将这个整数转换成CHS格式来完成磁盘的具体寻址。LBA为48个bit，最大寻址范围为128PB。在本实验中，LBA按照旧的规范采用28个bit。</li>
</ol>
<p>IDE硬盘控制器（IDE Hard Drive Controller）的0x1F7端口读为磁盘0状态寄存器。<br>其Bit6为RDY Bit，当其置1表明磁盘上电完成。在对于磁盘做任何操作（除了复位）之前务必要保证该Bit为1。<br>其Bit7为BSY Bit，当其置1表明磁盘忙。在你向磁盘发送任何指令前务必保证该Bit为0。</p>
<p>通过IDE硬盘控制器读取扇区需要如下的步骤：</p>
<ol>
<li>向0x1F2端口写入待操作的扇区数目；</li>
<li>向0x1F3-0x1F5端口依次写入LBA的低24位；</li>
<li>向0x1F6端口的低4位写入LBA的高4位，向0x1F6端口的高4位写入驱动器地址；</li>
<li>向0x1F7端口写入读命令0x20。</li>
</ol>
<p>0x1F6寄存器又称Drive/Head寄存器。其低4位是LBA的高4位。其Bit5和Bit7一般是1。其Bit6为LBA位，当置1时表示启用LBA寻址。其Bit4为DRV位。用来选择驱动器，Master驱动器为0，Slave驱动器为1。这里将高4位置为0x1110</p>
<p>在使用读命令0x20之前需要完整的设置柱面/磁头/扇区。当这个命令完成，你可以从磁盘的数据寄存器（0x1F0端口）读取256个字（16Bits）。</p>
<h4 id="main-c代码详解"><a href="#main-c代码详解" class="headerlink" title="main.c代码详解"></a>main.c代码详解</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/elf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/x86.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"> * This a dirt simple boot loader, whose sole job is to boot</span></span><br><span class="line"><span class="comment"> * an ELF kernel image from the first IDE hard disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DISK LAYOUT</span></span><br><span class="line"><span class="comment"> *  * This program(boot.S and main.c) is the bootloader.  It should</span></span><br><span class="line"><span class="comment"> *    be stored in the first sector of the disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The 2nd sector onward holds the kernel image.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The kernel image must be in ELF format.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BOOT UP STEPS</span></span><br><span class="line"><span class="comment"> *  * when the CPU boots it loads the BIOS into memory and executes it</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * the BIOS intializes devices, sets of the interrupt routines, and</span></span><br><span class="line"><span class="comment"> *    reads the first sector of the boot device(e.g., hard-drive)</span></span><br><span class="line"><span class="comment"> *    into memory and jumps to it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * Assuming this boot loader is stored in the first sector of the</span></span><br><span class="line"><span class="comment"> *    hard-drive, this code takes over...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * control starts in boot.S -- which sets up protected mode,</span></span><br><span class="line"><span class="comment"> *    and a stack so C code then run, then calls bootmain()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * bootmain() in this file takes over, reads in the kernel and jumps to it.</span></span><br><span class="line"><span class="comment"> **********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTSIZE 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELFHDR ((struct Elf *)0x10000)    <span class="comment">// scratch space</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">uint32_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readseg</span><span class="params">(<span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bootmain</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// read 1st page off disk 从磁盘上读取第一页</span></span><br><span class="line">    readseg((<span class="keyword">uint32_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is this a valid ELF? 通过ELF魔数确认ELF有效</span></span><br><span class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load each program segment (ignores ph flags) 读取各个段</span></span><br><span class="line">    ph = (struct Proghdr *)((<span class="keyword">uint8_t</span> *)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    <span class="comment">// 程序头部表的起始地址</span></span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;    <span class="comment">// 程序头部表的结束地址</span></span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">        <span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">        <span class="comment">// as the physical address)</span></span><br><span class="line">        <span class="comment">// p_pa是加载地址也是物理地址</span></span><br><span class="line">        readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the entry point from the ELF header 从ELF头调用程序入口</span></span><br><span class="line">    <span class="comment">// note: does not return!</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    <span class="comment">// stops simulation and breaks into the debug console</span></span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.</span></span><br><span class="line"><span class="comment">// 从内核的offset处读取count个字节到物理地址pa处</span></span><br><span class="line"><span class="comment">// Might copy more than asked 可能会读取超过count个（扇区对齐）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readseg</span><span class="params">(<span class="keyword">uint32_t</span> pa, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> end_pa;</span><br><span class="line"></span><br><span class="line">    end_pa = pa + count;    <span class="comment">// 结束物理地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// round down to sector boundary 对齐到扇区</span></span><br><span class="line">    pa &amp;= ~(SECTSIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// translate from bytes to sectors, and kernel starts at sector 1</span></span><br><span class="line">    offset =</span><br><span class="line">        (offset / SECTSIZE) + <span class="number">1</span>;    <span class="comment">// 算出扇区数 注意扇区从1开始（0为引导扇区）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">    <span class="comment">// We'd write more to memory than asked, but it doesn't matter --</span></span><br><span class="line">    <span class="comment">// we load in increasing order.</span></span><br><span class="line">    <span class="comment">// 在实际中往往将多个扇区一起读出以提高效率。</span></span><br><span class="line">    <span class="keyword">while</span> (pa &lt; end_pa) &#123;</span><br><span class="line">        <span class="comment">// Since we haven't enabled paging yet and we're using</span></span><br><span class="line">        <span class="comment">// an identity segment mapping (see boot.S), we can</span></span><br><span class="line">        <span class="comment">// use physical addresses directly.  This won't be the</span></span><br><span class="line">        <span class="comment">// case once JOS enables the MMU.</span></span><br><span class="line">        <span class="comment">// 考虑到没有开启分页以及boot.S中使用了一一对应的映射规则，</span></span><br><span class="line">        <span class="comment">// 加载地址和物理地址是一致的。</span></span><br><span class="line">        readsect((<span class="keyword">uint8_t</span> *)pa, offset);</span><br><span class="line">        pa += SECTSIZE;</span><br><span class="line">        offset++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitdisk</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// wait for disk reaady 等待磁盘准备完毕。</span></span><br><span class="line">    <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>) <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);    <span class="comment">// count = 1 0x1F2 Disk 0 sector count</span></span><br><span class="line">    <span class="comment">// Read one sector each time</span></span><br><span class="line">    outb(<span class="number">0x1F3</span>, offset);    <span class="comment">// Disk 0 sector number (CHS Mode)</span></span><br><span class="line">    <span class="comment">// First sector's number</span></span><br><span class="line">    outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>);     <span class="comment">// Cylinder low (CHS Mode)</span></span><br><span class="line">    outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>);    <span class="comment">// Cylinder high (CHS Mode)</span></span><br><span class="line">    <span class="comment">// Cylinder number</span></span><br><span class="line">    outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);    <span class="comment">// Disk 0 drive/head</span></span><br><span class="line">    <span class="comment">// MASK 11100000</span></span><br><span class="line">    <span class="comment">// Drive/Head Register: bit 7 and bit 5 should be set to 1</span></span><br><span class="line">    <span class="comment">// Bit6: 1 LBA mode, 0 CHS mode</span></span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);    <span class="comment">// cmd 0x20 - read sectors</span></span><br><span class="line">    <span class="comment">/*20H       Read sector with retry. NB: 21H = read sector</span></span><br><span class="line"><span class="comment">                without retry. For this command you have to load</span></span><br><span class="line"><span class="comment">                the complete circus of cylinder/head/sector</span></span><br><span class="line"><span class="comment">                first. When the command completes (DRQ goes</span></span><br><span class="line"><span class="comment">                active) you can read 256 words (16-bits) from the</span></span><br><span class="line"><span class="comment">                disk's data register. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a sector</span></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// Data register: data exchange with 8/16 bits</span></span><br><span class="line">    <span class="comment">// insl port addr cnt: read cnt dwords from the input port</span></span><br><span class="line">    <span class="comment">// specified by port into the supplied output array addr.</span></span><br><span class="line">    <span class="comment">// dword: 4 bytes = 16 bits</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>练习3：</p>
<ol>
<li>0x7c2d: ljmp  $0x8, $0x7c32 从这句汇编指令之后处理器开始执行32位指令。ljmp指令导致了16位指令到32位指令的转变。</li>
<li>引导最后执行的指令是call *0x10018，内核的第一条指令是movw $0x1234,0x472。</li>
<li>内核的第一条指令位于0x10000c。</li>
<li>引导从程序头部表中得到段的数目以及每个段的大小，以此决定要从磁盘上读出多少个扇区。</li>
</ol>
<h4 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h4><p>本部分主要需要了解.text段.rodata段和.data段，并且使用objdump读取ELF格式的信息。</p>
<p>boot/Makefrag文件中指定了引导的text段的位置为0x7c00。</p>
<p>练习4：<br>阅读并学习关于C语言指针的知识。下载pointer.c，编译运行并确保理解它。</p>
<p>pointer.c的代码和解释如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  a[<span class="number">4</span>];    <span class="comment">// 含有4个元素的整形数组</span></span><br><span class="line">    <span class="keyword">int</span> *b =</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">16</span>);    <span class="comment">// 分配16个字节的内存，并且用一个整形指针指向内存首地址</span></span><br><span class="line">    <span class="keyword">int</span> *c;    <span class="comment">// 一个悬挂的整形指针</span></span><br><span class="line">    <span class="keyword">int</span>  i;    <span class="comment">// 一个整形数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1: a = %p, b = %p, c = %p\n"</span>, a, b, c);</span><br><span class="line">    <span class="comment">// 打印a和b和c的地址，分别为0xff9bebcc, 0x566fc160和0xf7ede1e8</span></span><br><span class="line"></span><br><span class="line">    c = a;</span><br><span class="line">    <span class="comment">// 令c指向数组a的首地址</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) a[i] = <span class="number">100</span> + i;    <span class="comment">// 为a[0]到a[3]分配100-103</span></span><br><span class="line">    c[<span class="number">0</span>] = <span class="number">200</span>;                                <span class="comment">// 将c[0]也就是a[0]改为200</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>],</span><br><span class="line">           a[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// 输出200 101 102 103</span></span><br><span class="line"></span><br><span class="line">    c[<span class="number">1</span>]     = <span class="number">300</span>;    <span class="comment">// 将c[1]也就是a[1]改为300</span></span><br><span class="line">    *(c + <span class="number">2</span>) = <span class="number">301</span>;    <span class="comment">//将*(c + 2)也就是a[2]改为301</span></span><br><span class="line">    <span class="number">3</span> [c]    = <span class="number">302</span>;    <span class="comment">// 将3[c]也就是c[3]改为302</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>],</span><br><span class="line">           a[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// 输出200 300 301 302</span></span><br><span class="line"></span><br><span class="line">    c  = c + <span class="number">1</span>;    <span class="comment">// 令c指向a[1]</span></span><br><span class="line">    *c = <span class="number">400</span>;      <span class="comment">// 将a[1]改为400</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>],</span><br><span class="line">           a[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// 输出200 400 301 302</span></span><br><span class="line"></span><br><span class="line">    c = (<span class="keyword">int</span> *)((<span class="keyword">char</span> *)c + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将c先转换为char指针指向下一个字节后再转回int指针</span></span><br><span class="line">    <span class="comment">// 现在a数组的字节分布为（小端）C8000000 90010000 2D010000 2E010000</span></span><br><span class="line">    | (c的指针)*c = <span class="number">500</span>;</span><br><span class="line">    <span class="comment">// 执行后的a数组字节分布（小端）C8000000 90F40100 00010000 2E010000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>],</span><br><span class="line">           a[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// 输出200 128144 256 302</span></span><br><span class="line"></span><br><span class="line">    b = (<span class="keyword">int</span> *)a + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将b指向a[1]</span></span><br><span class="line">    c = (<span class="keyword">int</span> *)((<span class="keyword">char</span> *)a + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将a先转换为char指针指向下一个字节后再转回int指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"6: a = %p, b = %p, c = %p\n"</span>, a, b, c);</span><br><span class="line">    <span class="comment">// 输出0xff9bebcc, 0xff9bebd0和0xff9bebcd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> ac, <span class="keyword">char</span> **av)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数入口</span></span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>练习5：<br>修改了text段的加载地址使得汇编代码中的跳转地址出现错误，进而导致整个引导因为错误提前终止。</p>
<p>练习6：<br>结果是非常显然的，因为引导的作用就是将内核从磁盘加载进入内存中。使用objdump -h obj/kern/kernel可以看到如下的信息：<br>0 .text         00001809  f0100000  00100000  00001000  2**4<br>                CONTENTS, ALLOC, LOAD, READONLY, CODE<br>可以直到内核的text段会被加载至内存中0x100000（物理地址）处。</p>
<h3 id="第三部分-内核"><a href="#第三部分-内核" class="headerlink" title="第三部分 内核"></a>第三部分 内核</h3><h4 id="使用虚拟内存去解决位置依赖"><a href="#使用虚拟内存去解决位置依赖" class="headerlink" title="使用虚拟内存去解决位置依赖"></a>使用虚拟内存去解决位置依赖</h4><p>可以发现内核将自己链接至了非常高的虚拟地址，比如0xf0100000，为了将处理器虚拟地址的较低部分给用户程序去使用。将在下一个实验介绍这一现象。</p>
<p>实际上，许多的机器在物理内存中并没有0xf0100000这样的高地址。实际上由处理器的内存管理硬件将虚拟地址0xf0100000映射到了实际内存中的物理地址0x100000。</p>
<p>这涉及了分页机制以及页表。<br>在kern/entry.S设置CR0_PG标记之前，内存引用被当做线性地址。实际上，由于在boot/boot.S设置了线性地址到物理地址的一致映射，所以线性地址在这里可以等同于物理地址。<br>当CR0_PG标记被设置了之后，所有的内存引用都被当作虚拟地址。虚拟地址通过虚拟内存硬件被翻译成物理地址。<br>kern/entrypgdir.c将0xf0000000到0xf0400000的虚拟地址翻译为物理地址的0x000000到0x400000，也将0x00000000到0x00400000的虚拟地址翻译为物理地址的0x00000000到0x00400000。<br>引用这些地址范围以外的虚拟地址将会抛出缺页的异常。<br>但是还没有为该异常设置中断处理程序。这会导致QEMU导出机器状态并退出。</p>
<p>练习7：<br>在movl %eax, %cr0指令（启动页表）之前，0x00100000出的内存不为空，0xf0100000出的内存全为0。<br>当stepi之后，0xf0100000处的内存和0x00100000处的内存完全一样。这表明已经成功启用了页表，并且完成了地址的映射。</p>
<h4 id="控制台的格式化字符串"><a href="#控制台的格式化字符串" class="headerlink" title="控制台的格式化字符串"></a>控制台的格式化字符串</h4><p>练习8：<br>缺失的代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">	num = getuint(&amp;ap, lflag);</span><br><span class="line">base = <span class="number">8</span></span><br><span class="line"><span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>console.c提供了基本的I/O操作，同时封装了cputchar、getchar等函数供printf.c中的printf使用。printf使用了vprintfmt去解析格式化字符串并提供可变参数的特性。</li>
<li>这段代码主要实现了换行。其首先检查了当前的光标是否超过了最大值，如果是，则证明需要进行换行。其将第1行到第MAX-1行的内容复制到第0行到第MAX-2行所在的内存中，然后将第MAX-1行置空。最后将光标设置到新一行的开始。</li>
<li>fmt指向了格式化字符串”x %d, y %x, z %d\n”<br>ap指向了局部变量并且初始值为1<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vcprintf(<span class="number">0xf0102449</span>, <span class="number">0xf0110e14</span>);</span><br><span class="line"><span class="number">0xf0102449</span> -&gt; <span class="string">"x %d, y %x, z %d\n"</span> <span class="number">0xf0110e14</span> -&gt; <span class="number">1</span></span><br><span class="line">cons_putc(<span class="number">120</span>);</span><br><span class="line">cons_putc(<span class="number">32</span>);</span><br><span class="line">va_arg(<span class="number">0xf0110dbc</span>, <span class="keyword">int</span>);</span><br><span class="line">Before: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e14</span> -&gt; <span class="number">1</span></span><br><span class="line">After: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e18</span> -&gt; <span class="number">3</span></span><br><span class="line">cons_putc(<span class="number">49</span>);</span><br><span class="line">cons_putc(<span class="number">44</span>);</span><br><span class="line">cons_putc(<span class="number">32</span>);</span><br><span class="line">cons_putc(<span class="number">121</span>);</span><br><span class="line">cons_putc(<span class="number">32</span>);</span><br><span class="line">va_arg(<span class="number">0xf0110dbc</span>, <span class="keyword">int</span>);</span><br><span class="line">Before: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e18</span> -&gt; <span class="number">3</span></span><br><span class="line">After: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e1c</span> -&gt; <span class="number">4</span></span><br><span class="line">cons_putc(<span class="number">51</span>);</span><br><span class="line">cons_putc(<span class="number">44</span>);</span><br><span class="line">cons_putc(<span class="number">32</span>);</span><br><span class="line">cons_putc(<span class="number">122</span>);</span><br><span class="line">cons_put(<span class="number">32</span>);</span><br><span class="line">va_arg(<span class="number">0xf0110dbc</span>, <span class="keyword">int</span>);</span><br><span class="line">Before: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e1c</span> -&gt; <span class="number">4</span></span><br><span class="line">After: <span class="number">0xf0110dbc</span> -&gt; <span class="number">0xf0110e20</span> -&gt; <span class="number">536870922</span></span><br><span class="line">cons_put(<span class="number">52</span>);</span><br><span class="line">cons_put(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
注意这里va_arg是宏而不是函数，不能通过加断点的方式跟踪。我采用的方法是在调用va_arg的地方添加断点并跟踪。<br>在GNUmakefile中的C_FLAGS -O1会重排C代码，导致了追踪va_arg变得困难。所以，仅在此处将-O1变成-O0，尽管这会导致在backtrace时kernel panic。</li>
<li>57616 = 0xe110。此外，根据x86的小端序，&amp;i指向了byte序列0x72、0x6c、0x64、0x00。这等同于字符串”rld”。所以，最终的输出为”He110 World”。<br>需要将i改为0x726c6400。不需要修改57616。</li>
<li>这是由于程序从格式化字符串中推断出了应当有3个参数，所以程序会从cprintf的栈中多读取一个参数。但实际上只有2个参数。所以最后一个参数是未指定的。</li>
<li>vcprintf(…, const char * fmt)。</li>
</ol>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>练习9：<br>f0100034:    bc 00 00 11 f0           mov    $0xf0110000,%esp<br>这一条指令初始化了引导栈，它位于0xf0110000处。内核仅通过设置esp寄存器的值为栈预留空间。栈指针指向高地址，并且栈自高地址向低地址延伸。</p>
<p>练习10：<br>本题考察了x86架构下的栈帧与函数调用。<br>函数调用时先将返回地址压栈，然后跳转至目标函数的起始地址；在目标函数内先将ebp寄存器的值（栈底）压栈保存，然后再将栈顶指针设置为新的栈底；<br>在函数中调用函数需要使用栈来传递参数，即将函数的参数以此压入栈中；<br>test_backtrace函数的汇编中使用了ebx寄存器，该寄存器为被调用者保存的寄存器，在使用的时候也要先压栈保存，再函数返回时恢复；<br>函数返回的时候通过先操作esp释放栈资源，然后恢复相应的被调用者保存的寄存器的值，最后调用汇编指令leave、ret返回；<br>leave指令先将esp的值置为ebp，然后再从栈中取出被保存的ebp的旧值；ret从栈中取出返回地址并跳转。</p>
<p>练习10-12：<br>mon_backtrace的实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mon_backtrace</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span>            ebp, eip, args[<span class="number">5</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (ebp = read_ebp(); ebp != <span class="number">0</span>; ebp = *((<span class="keyword">uint32_t</span> *)ebp)) &#123;</span><br><span class="line">        eip = *((<span class="keyword">uint32_t</span> *)ebp + <span class="number">1</span>);</span><br><span class="line">        debuginfo_eip(eip, &amp;info);</span><br><span class="line">        args[<span class="number">0</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">2</span>);</span><br><span class="line">        args[<span class="number">1</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">3</span>);</span><br><span class="line">        args[<span class="number">2</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">4</span>);</span><br><span class="line">        args[<span class="number">3</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">5</span>);</span><br><span class="line">        args[<span class="number">4</span>] = *((<span class="keyword">uintptr_t</span> *)ebp + <span class="number">6</span>);</span><br><span class="line">        cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>, ebp,</span><br><span class="line">                eip, args[<span class="number">0</span>], args[<span class="number">1</span>], args[<span class="number">2</span>], args[<span class="number">3</span>], args[<span class="number">4</span>]);</span><br><span class="line">        cprintf(<span class="string">"      %s:%d: %.*s+%d\n"</span>, info.eip_file, info.eip_line,</span><br><span class="line">                info.eip_fn_namelen, info.eip_fn_name, eip - info.eip_fn_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>查阅STABS文档可以知道表示行号的成员是n_desc，所以debuginfo_eip的缺失的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line"><span class="keyword">if</span> (lline &lt;= rline) &#123;</span><br><span class="line">    info-&gt;eip_line = stabs[lline].n_desc;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>修改后的commands结构体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span> <span class="title">commands</span>[] = &#123;</span></span><br><span class="line">   &#123; <span class="string">"help"</span>, <span class="string">"Display this list of commands"</span>, mon_help &#125;,</span><br><span class="line">   &#123; <span class="string">"kerninfo"</span>, <span class="string">"Display information about the kernel"</span>, mon_kerninfo &#125;,</span><br><span class="line">   &#123; <span class="string">"backtrace"</span>, <span class="string">"Display information about the stack frames"</span>, mon_backtrace &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="提高-允许控制台输出不同颜色的文本"><a href="#提高-允许控制台输出不同颜色的文本" class="headerlink" title="提高 - 允许控制台输出不同颜色的文本"></a>提高 - 允许控制台输出不同颜色的文本</h4><p>要求能增强控制台的功能使得控制台可以输出不同颜色的字体。这里使用了传统的实现，解析嵌入在文本字符串中的ANSI转义序列来实现题目的要求。</p>
<p>在王爽的《汇编语言》中，已经接触过了字符的“属性字节”，一个字符的自低到高的第2个字节可以作为属性字节，用来指示字符的属性如闪烁、高亮、前景色、背景色等。<br>有关于ANSI转义序列的相关知识可以参考<a href="http://rrbrandt.dee.ufcg.edu.br/en/docs/ansi/" target="_blank" rel="noopener">这里</a>。</p>
<p>出于简化考虑，只部分实现ANSI转义序列中的<code>ESC[Ps;...;Psm</code>。</p>
<p>实现的思路是实现<code>&lt;kern/printf.c&gt;</code>中的punch函数的替代版本attribute_punch，来实现对于ANSI转义序列的解析，并且相应地设置字符的属性字节。</p>
<p>解析所需要的状态机具有三个状态：A_NORM代表正常的输出字符的状态、A_TRANS代表接收到[ESC]开始，从正常状态到解析转义序列的过渡状态、A_ESCAPE代表解析转义序列的状态。它们之间的状态转换图如图所示：</p>
<img src="/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/ansi_stm.png">
<p>value用来存储每一个解析到的值，temp代表了解析过程中临时的属性字节，attribute代表了当前打印字符时附加的属性字节。</p>
<p>具体的实现代码在&lt;kern/printf.c&gt;中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// state for ANSI escape sequence interpretation</span></span><br><span class="line"><span class="keyword">enum</span> &#123; A_NORM = <span class="number">0</span>, A_TRANS, A_ESCAPE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// colormap - number (x - 30/40)[0, 7] -&gt; attribute byte</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> colormap[<span class="number">8</span>] = &#123;</span><br><span class="line">    <span class="number">0x0000</span>, <span class="number">0x4400</span>, <span class="number">0x2200</span>, <span class="number">0x6600</span>, <span class="number">0x1100</span>, <span class="number">0x5500</span>, <span class="number">0x3300</span>, <span class="number">0x7700</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attribute_punch</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> *cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> value     = <span class="number">0</span>;         <span class="comment">// value</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> state     = A_NORM;    <span class="comment">// current state</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> temp      = <span class="number">0x0000</span>,</span><br><span class="line">               attribute = <span class="number">0x0000</span>;    <span class="comment">// temp attribute, current attribute</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;    <span class="comment">// state machine</span></span><br><span class="line">        <span class="keyword">case</span> A_NORM:</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="number">0x1B</span>) &#123;       <span class="comment">// [ESC]</span></span><br><span class="line">                state = A_TRANS;    <span class="comment">// transfer from A_NORM to A_TRANS</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cputchar((attribute &amp; <span class="number">0xFF00</span>) |</span><br><span class="line">                         ch);    <span class="comment">// put character with attribute</span></span><br><span class="line">                *cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> A_TRANS:</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'['</span>) &#123;         <span class="comment">// [</span></span><br><span class="line">                state = A_ESCAPE;    <span class="comment">// transfer from A_TRANS to A_ESCAPE</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state = A_NORM;    <span class="comment">// transfer from A_TRANS to A_NORM</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> A_ESCAPE:</span><br><span class="line">            <span class="keyword">if</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;    <span class="comment">// digit - update value</span></span><br><span class="line">                value = value * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">';'</span> ||</span><br><span class="line">                       ch == <span class="string">'m'</span>) &#123;    <span class="comment">// ; or m set temp and clear value</span></span><br><span class="line">                <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">                    temp = colormap[<span class="number">0</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == <span class="number">5</span>) &#123;</span><br><span class="line">                    temp |= <span class="number">0x8000</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="number">30</span> &amp;&amp; value &lt;= <span class="number">38</span>) &#123;</span><br><span class="line">                    temp |= colormap[value - <span class="number">30</span>] &amp;</span><br><span class="line">                            <span class="number">0x0700</span>;    <span class="comment">// look up in color map</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="number">40</span> &amp;&amp; value &lt;= <span class="number">48</span>) &#123;</span><br><span class="line">                    temp |=</span><br><span class="line">                        colormap[value - <span class="number">40</span>] &amp; <span class="number">0x7000</span>;    <span class="comment">// avoid complex cases</span></span><br><span class="line">                &#125;</span><br><span class="line">                value = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (ch == <span class="string">'m'</span>) &#123;    <span class="comment">// m needed extra work - update attribute</span></span><br><span class="line">                    attribute = temp;</span><br><span class="line">                    temp      = <span class="number">0x0000</span>;</span><br><span class="line">                    state     = A_NORM;    <span class="comment">// transfer from A_ESCAPE to A_NORM</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;               <span class="comment">// non_digit nor m</span></span><br><span class="line">                state = A_NORM;    <span class="comment">// transfer from A_ESCAPE to A_NORM</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vcprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vprintfmt((void*)putch, &amp;cnt, fmt, ap);</span></span><br><span class="line">    <span class="comment">// use attribute_punch rather than punch</span></span><br><span class="line">    vprintfmt((<span class="keyword">void</span> *)attribute_punch, &amp;cnt, fmt, ap);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在monitor.c中添加相关cprintf代码，并重新编译测试。最终如图所示：</p>
<img src="/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/lab1_final.png">
<p>有关于实验指导中提到的打开vga硬件的graphics mode使得控制台绘制文本到图形帧缓冲区的实现，由于时间和难度原因，这里暂时跳过。</p>
<h2 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h2><p>最终执行<code>make grade</code>，评分脚本的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">running JOS: (1.2s)</span><br><span class="line">  <span class="built_in">printf</span>: OK</span><br><span class="line">  backtrace count: OK</span><br><span class="line">  backtrace arguments: OK</span><br><span class="line">  backtrace symbols: OK</span><br><span class="line">  backtrace lines: OK</span><br><span class="line">Score: 50/50</span><br></pre></td></tr></table></figure><br>至此，实验一结束。</p>
<p>第一个实验总体来说更偏重于概念的理解、工具的使用而不是实际的代码。</p>
<p>尽管如此，大量的概念也浪费了我很多时间去理解。MIT的6.828同清华的ucore操作系统实验相比提供了相当多的reference（ucore的阅读材料几乎都是现成的），这也对文档阅读和信息检索能力有了更高的要求。</p>

            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/实验/">实验</a> <a class="tag tag--primary tag--small t-link" href="/tags/操作系统/">操作系统</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/12/11/Vim-Tmux配置Scheme编程环境/" data-tooltip="Vim+Tmux配置Scheme编程环境" aria-label="上一篇: Vim+Tmux配置Scheme编程环境">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/11/27/域名变更说明/" data-tooltip="域名变更说明" aria-label="下一篇: 域名变更说明">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/" title="分享到 Facebook">
                    <i class="fa fa-facebook-official" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/" title="分享到 Twitter">
                    <i class="fa fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/" title="分享到 Weibo">
                    <i class="fa fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/&amp;title=MIT6.828操作系统工程Lab1-Booting a PC实验报告" title="分享到 QQ">
                    <i class="fa fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/" title="分享到 Qzone">
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 码龙黑曜. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/12/11/Vim-Tmux配置Scheme编程环境/" data-tooltip="Vim+Tmux配置Scheme编程环境" aria-label="上一篇: Vim+Tmux配置Scheme编程环境">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/11/27/域名变更说明/" data-tooltip="域名变更说明" aria-label="下一篇: 域名变更说明">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/" title="分享到 Facebook">
                    <i class="fa fa-facebook-official" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/" title="分享到 Twitter">
                    <i class="fa fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/" title="分享到 Weibo">
                    <i class="fa fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/&amp;title=MIT6.828操作系统工程Lab1-Booting a PC实验报告" title="分享到 QQ">
                    <i class="fa fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/" title="分享到 Qzone">
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-close"></i>
    <ul class="share-options">
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/">
                    <i class="fa fa-facebook-official" aria-hidden="true"></i><span>分享到 Facebook</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/">
                    <i class="fa fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/">
                    <i class="fa fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/&amp;title=MIT6.828操作系统工程Lab1-Booting a PC实验报告">
                    <i class="fa fa-qq" aria-hidden="true"></i><span>分享到 QQ</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://blog.codedragon.tech/2017/12/09/MIT6-828操作系统工程Lab1-Booting-a-PC实验报告/">
                    <i class="fa fa-star" aria-hidden="true"></i><span>分享到 Qzone</span>
                </a>
            </li>
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">码龙黑曜</h4>
        
            <div id="about-card-bio"><p>iOS开发者/计算机科学/兽人控</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>华中科技大学 本科在读</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Wuhan, China
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-feiabjni254mgbxiozwsjblcsiodjqohurk0dcfkq0aooroewq6bvkdnadrg.min.js"></script>
<!--SCRIPTS END-->

    



    </body>
</html>
