
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="码龙的窝">
    <title>MIT6.828操作系统工程Lab3-User Environments实验报告 - 码龙的窝</title>
    <meta name="author" content="码龙黑曜">
    
        <meta name="keywords" content="博客,iOS,Computer Science,码龙,">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"码龙黑曜","sameAs":["https://github.com/BlackDragonF","https://t.me/Cosidian","http://steamcommunity.com/id/BlackDragonF/","mailto:obsidiandragon2016@gmail.com"],"image":"avatar.jpg"},"articleBody":"\nLab3 - User Environments需要实现基本的内核功能，使得一个受保护的用户环境（进程）可以运行。在本实验中，需要让内核设置数据结构以追踪用户环境，创建一个单用户环境，加载程序镜像并执行。此外，内核还需要能处理用户环境的系统调用以及引发的异常。2018年2月26日，完成了实验并写完了报告。\n\n实验准备根据官网，切换到分支lab3并且合并分支lab2。在合并的过程中，发生了冲突。\n12user% git checkout -b lab3 origin/lab3user% git merge lab2\n根据提示，是kern/monitor.c中发生了冲突，因为仅有一处冲突，手动编辑kern/monitor.c文件，并commit，即可解决冲突并合并分支。\n实验三包括如下的新文件：\n\ninc/env.h 用户模式环境的公有定义\ninc/trap.h 陷阱处理的公有定义\ninc/syscall.h 用户环境对内核的系统调用的公有定义\ninc/lib.h 用户模式支持的库公有定义\nkern/env.h 用户模式环境的内核私有定义\nkern/env.c 用户模式环境的内核代码实现\nkern/trap.h 内核私有的陷阱处理定义\nkern/trap.c 陷阱处理代码\nkern/trapentry.S 汇编语言的陷阱处理程序入口\nkern/syscall.h 系统调用处理的内核私有定义\nkern/syscall.c 系统调用实现代码\nlib/Makefrag 用户模式库obj/lib/libjos.a的Makefile\nlib/entry.S 用户环境的汇编语言入口\nlib/libmain.c entry.S调用的用户模式库安装代码\nlib/syscall.c 用户模式系统调用的打桩函数\nlib/console.c 用户模式的putchar和getchar实现，提供了控制台IO\nlib/exit.c 用户模式的exit实现\nlib/panic.c 用户模式的panic实现\nuser/* 检验内核实验三代码的测试程序\n\n此外，lab2中的一些文件在lab3中也被添加了新的内容，可以用git diff lab2查看具体的比较信息。\n内联汇编本实验中可能会用到GCC的内联汇编特性，应当至少理解给出的代码中的内联汇编代码片段。\n实验过程第一部分 User Environments and Exception Handling - 用户环境和错误处理inc/env.h中给出了用户环境的基本定义。内核通过struct Env追踪每一个用户环境。本实验中只需要创建一个环境，然而你需要设计JOS内核实际支持多用户环境。实验四中，你将通过允许一个用户环境fork别的用户环境来利用多用户环境的特性。\nkern/env.c中可以看到，内核管理3个与环境有关的全局变量：123struct Env *       envs   = NULL;    // All environmentsstruct Env *       curenv = NULL;    // The current envstatic struct Env *env_free_list;    // Free environment list\n当JOS成功运行之后，envs指针指向一个struct Env的数组，代表了系统中所有的环境。在设计上，JOS内核允许NNEV个同时激活的环境，NNEV在inc/env.h中定义。JOS内核使用env_free_list维护所有未激活的struct Env，这样的设计简化的环境的分配和释放，它们仅仅需要从该链表上添加或移除。JOS内核使用curenv去追踪在任意时刻当前正在执行的环境。在启动之后到第一个环境运行的时间段中，curenv被初始化为NULL。\n环境状态struct Env在inc/env.h中被定义：123456789101112struct Env &#123;\tstruct Trapframe env_tf;\t// Saved registers\tstruct Env *env_link;\t\t// Next free Env\tenvid_t env_id;\t\t\t// Unique environment identifier\tenvid_t env_parent_id;\t\t// env_id of this env's parent\tenum EnvType env_type;\t\t// Indicates special system environments\tunsigned env_status;\t\t// Status of the environment\tuint32_t env_runs;\t\t// Number of times environment has run\t// Address space\tpde_t *env_pgdir;\t\t// Kernel virtual address of page dir&#125;;\n\nenv_tf - struct TrapFrame在inc/trap.h中被定义，表示了当环境不运行时被保存的寄存器值，主要用于上下文切换\nenv_link - 指向了env_free_list上的下一个struct Env。env_free_list指向了链表中的第一个空闲环境\nenv_id - 唯一标识当前正在使用struct Env的环境。当环境终止后，struct Env可能被内核重新分配用于另一个不同的环境，但它们的env_id是不同的\nenv_parent_id - 存储了创建该环境的环境的env_id，通过该方式构建一个环境树，用于安全方面的决策\nenv_type - 用于区分特殊环境，对于大部分环境，该值为ENV_TYPE_USER，在后续Lab中会介绍其他的值\nenv_status - 状态\nENV_FREE - 表明struct Env处于空闲状态，应当位于env_free_list上\nENV_RUNNABLE - 表明struct Env代表的环境正等待运行于处理器上\nENV_RUNNING - 表明struct Env代表的环境为正在运行的环境\nENV_NOT_RUNNABLE - 表明struct Env代表了一个正在运行的环境，但却没有准备好运行，如正在等待另一个环境的IPC（进程间通信）\nENV_DYING - 表明struct Env代表了一个僵死环境，僵死环境将在下一次陷入内核时被释放（直到Lab4才会使用该Flag）\n\n\nenv_pgdir - 保存了环境的页目录的内核虚拟地址\n\nJOS中环境的概念综合了“线程”和“地址空间”，“线程”由env_tf域的被保存的寄存器值定义，“地址空间”由env_pgdir域指向的页目录和页表定义。为了运行一个环境，内核必须用保存的寄存器值和合适的地址空间设置CPU。\nJOS的struct Env和xv6的struct proc很像，两种结构体都持有环境的用户模式寄存器状态（通过struct TrapFrame），然而，JOS中，独立的环境并不具有不同的内核栈，因为JOS内核中同时只能有一个运行的JOS环境，因此JOS只需要一个内核栈。\n分配环境数组练习1的代码如下，仅供参考：123456789101112131415161718//////////////////////////////////////////////////////////////////////// Make 'envs' point to an array of size 'NENV' of 'struct Env'.// LAB 3: Your code here.// get size of envsuint32_t envs_size = sizeof(struct Env) * NENV;// use boot_alloc to allocate memoryenvs = (struct Env *)boot_alloc(envs_size);// initializationmemset(envs, 0, envs_size);//////////////////////////////////////////////////////////////////////// Map the 'envs' array read-only by the user at linear address UENVS// (ie. perm = PTE_U | PTE_P).// Permissions://    - the new image at UENVS  -- kernel R, user R//    - envs itself -- kernel RW, user NONE// LAB 3: Your code here.boot_map_region(kern_pgdir, UENVS, envs_size, PADDR(envs), PTE_U | PTE_P);\n创建并运行环境现在将在kern/env.c中编写必要的代码去运行用户环境。由于JOS内核还不支持文件系统，所以只能配置内核以加载一个嵌入内核中静态二进制镜像。JOS内核将这个二进制镜像以ELF可执行镜像格式嵌入。\nLab3的GNUMakefile在obj/user/目录下生成了一些二进制镜像。kern/Makefrag下可以看到，链接器的-b binary选项使得这些文件以原始的未被翻译二进制文件而非普通的被编译器生成的.o文件的方式链接， 通过-b binary方式链接的二进制文件就链接器而言可以为任意类型，甚至是文本文件或是图片。\n如果在构建内核后观察obj/kern/kernel.sym，可以看到链接器生成了一些“奇怪”名字的符号如_binary_obj_user_hello_start， _binary_obj_user_hello_end或 _binary_obj_user_hello_size。链接器通过二进制文件的名字生成了这些符号的名字，这些符号使得内核代码可以以某种方式引用这些嵌入的二进制文件。\n练习2中遇到的问题：\n\n除了env-&gt;env_tf.tf_eip以外不要修改其他的值，因为其已经在env_alloc()中被初始化\nregion_alloc()中笔误导致只映射了一页\nload_icode()中需要切换页表，之后加载每段仅用一个memcpy即可实现\n\n练习2的代码如下，仅供参考：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// In env_init():// LAB 3: Your code here.ssize_t i;// loop in reverse order to keep ascending order in env free listfor (i = NENV - 1; i &gt;= 0; i--) &#123;    // set env_status, env_id    envs[i].env_status = ENV_FREE;    envs[i].env_id     = 0;    // set env_link and insert into env_free_list    envs[i].env_link = env_free_list;    env_free_list    = &amp;envs[i];&#125;// In env_setup_vm():// LAB 3: Your code here.// set env_pgdir and generate page directory based on kern_pgdire-&gt;env_pgdir = (pde_t *)page2kva(p);memcpy(e-&gt;env_pgdir, kern_pgdir, PGSIZE);// increase pp_refp-&gt;pp_ref++;// In region_alloc():// LAB 3: Your code here.// (But only if you need it for load_icode.)//// Hint: It is easier to use region_alloc if the caller can pass//   'va' and 'len' values that are not page-aligned.//   You should round va down, and round (va + len) up.//   (Watch out for corner-cases!)// round va and va + lenuintptr_t start = (uintptr_t)ROUNDDOWN(va, PGSIZE);uintptr_t end   = (uintptr_t)ROUNDUP(va + len, PGSIZE);for (; start &lt; end; start += PGSIZE) &#123;    // alloc page    struct PageInfo *p;    p = page_alloc(ALLOC_ZERO);    if (!p) &#123; panic(\"out of memory when allocating region!\"); &#125;    // insert page into environment's page directory    if (page_insert(e-&gt;env_pgdir, p, (char *)start, PTE_W | PTE_U | PTE_P) &lt;        0) &#123;        panic(\"out of memory when allocating region!\");    &#125;&#125;// In load_icode():// LAB 3: Your code here.// switch address space for loading program segmentslcr3(PADDR(e-&gt;env_pgdir));struct Elf *elf = (struct Elf *)binary;// check elf magicif (elf-&gt;e_magic != ELF_MAGIC) &#123; panic(\"invalid elf format!\"); &#125;// set the program entry for enve-&gt;env_tf.tf_eip = elf-&gt;e_entry;struct Proghdr *ph, *eph;// get the start and end of program header entryph  = (struct Proghdr *)(binary + elf-&gt;e_phoff);eph = ph + elf-&gt;e_phnum;for (; ph &lt; eph; ph++) &#123;    if (ph-&gt;p_type == ELF_PROG_LOAD) &#123;    // if the segment is to be loaded        // alloc corresponding region(clear zero)        region_alloc(e, (char *)ph-&gt;p_va, ph-&gt;p_memsz);        // copy from ELF header to virtual addresses directly        memcpy((char *)ph-&gt;p_va, (char *)binary + ph-&gt;p_offset, ph-&gt;p_filesz);    &#125;&#125;// switch backlcr3(PADDR(kern_pgdir));// Now map one page for the program's initial stack// at virtual address USTACKTOP - PGSIZE.// LAB 3: Your code here.// allocate a page and insert it into env's page directory// panic when page_alloc or page_insert failedstruct PageInfo *stack_page = page_alloc(ALLOC_ZERO);if (!stack_page) &#123; panic(\"out of memory when alloc program's stack!\"); &#125;if (page_insert(e-&gt;env_pgdir, stack_page, (char *)(USTACKTOP - PGSIZE),                PTE_W | PTE_U | PTE_P) &lt; 0) &#123;    panic(\"failed to set program's stack!\");&#125;// In env_create():// LAB 3: Your code here.struct Env *env;// allocate new env with parent ID 0if (env_alloc(&amp;env, 0) &lt; 0) &#123; panic(\"failed to allocate env!\"); &#125;// load elf binary and set env_typeload_icode(env, binary);env-&gt;env_type = type;// In env_run():// LAB 3: Your code here.if (curenv != NULL) &#123;    // context switch    if (curenv-&gt;env_status == ENV_RUNNING) &#123;        // change to runnable if current status is running        // for not runnable, is not necessary to do this        curenv-&gt;env_status = ENV_RUNNABLE;    &#125;&#125;// set new curenv, update status and countercurenv        = e;e-&gt;env_status = ENV_RUNNING;e-&gt;env_runs++;// address space switch// reference from inc/x86.hlcr3(PADDR(e-&gt;env_pgdir));// drop into user modeenv_pop_tf(&amp;(e-&gt;env_tf));// panic(\"env_run not yet implemented\");\n\n成功进入用户环境后，若用户环境尝试使用int指令进行系统调用时，将产生错误，因为JOS没有设置任何从用户空间进入内核的方式。当CPU发现无法处理系统中断调用后，会产生一个通用保护错误，发现无法处理它，然后生成一个二重错误，最终因无法处理而生成一个三重错误并放弃，然后系统重启。但是为了便于调试，patch的qemu不会重启。关于重启的理由可以参考这里。\n\n完成后经过测试，程序在int $0x30处Triple Fault，可知本部分代码基本正确。\n处理中断和异常练习3要求阅读Intel 80386编程手册中的第九章：异常和中断。\n本实验中将沿用Intel关于中断和异常的术语。中断是由处理器以外的异步事件引发的，而异常是由当前正在执行的指令同步引发的。\n保护控制转移基础异常和中断均为“保护控制转移”，会引发处理器从用户到内核模式（CPL=0），从而避免给用户模式的代码干扰内核或是其他环境的机会。这要求了引发中断或者是异常的代码不能选择进入内核的地点或方式。在x86中，主要有两种机制一起保证了内核总是在受保护的情况下进入，这两种机制为中断描述符表（Interrupt Descriptor Table）和任务状态段（Task State Segment）。\n中断描述符表中，处理器保证了异常和中断仅能导致内核在若干个具体的、由内核明确定义好的入口执行，而不是在中断和异常发生时运行的代码。x86允许最多设立256个不同的中断或异常入口，每一个入口都具有一个中断向量。中断向量为0-255的数字，中断向量由中断来源决定：不同的设备，错误条件和应用程序对内核的请求会产生不同向量的中断。CPU使用中断向量作为处理器的中断描述符表的索引。中断描述符表在内核私有的内存中建立。处理器从该表中加载送入EIP寄存器的值（处理程序的入口），以及送入CS段寄存器的值（包括了特权级，在JOS中，所有的异常均在内核模式执行，即特权级0）。\n任务状态段。处理器需要在唤醒处理程序前将在中断或异常发生前的旧的处理器状态保存起来，如旧的EIP寄存器值和旧的CS段寄存器值，以便处理程序之后能恢复现场，从中断或异常发生的地方继续执行。然而，保存旧的处理器状态的区域必须对于非特权的用户模式代码处于被保护的状态。否则，错误的或是恶意的用户代码可能会破坏内核。因此，当x86处理器从用户模式特权级切换到内核模式时，其也会切换到内核内存中的一个栈。任务状态段指定了相应的段寄存器以及相应栈的地址。处理器将SS, EFLAGS, CS, EIP以及一个可选的错误码压入这个新栈中。然后从中断描述符中读取相应的CS和EIP，并设置ESP和SS指向新的栈。尽管TSS有着多种作用，JOS仅用它来定义从用户模式切换到内核模式时的内核栈。因为JOS中的内核模式为x86的特权级0，故处理器仅使用TSS的ESP0和SS0域。\n异常和中断的类型x86处理器能产生的所有同步异常均使用了0-31的中断向量，映射为IDT的0-31号入口。超过31的中断向量仅供由int指令或是由异步硬件中断产生的“软中断”使用。\n嵌套异常和中断处理器能同时处理内核模式和用户模式的异常。在内核模式中的异常不需要切换栈，因此，不需要压入旧的SS和ESP值。通过这种方式，内核可以优雅地处理内核产生的嵌套异常和中断。该能力对于实现保护是非常重要的。\n若处理器已经在内核模式中并且接受了一个异常并且无法将旧值压入内核栈中时（如内存不足），那么，处理器将无论如何也无法恢复，只能重启。内核必须设计良好以避免这种情况发生。\n建立IDT表由于JOS中使用的为IA_32的陷阱码，更推荐参考IA_32的第五章。\n练习4中遇到的问题如下：\n\n设置陷阱门时段选择子应当为GD_KT而不是GD_KD，因为错误处理函数均被链接至了内核的text段。\n已存在page_fault_handler的函数，命名时需避免重名。\n不能直接用立即数设置段寄存器。\n\n练习4的代码如下，仅供参考：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// In trapentry.S:/* * Lab 3: Your code here for generating entry points for the different traps. */TRAPHANDLER_NOEC(divide_error_handler, T_DIVIDE)TRAPHANDLER_NOEC(debug_exception_handler, T_DEBUG)TRAPHANDLER_NOEC(non_maskable_interrupt_handler, T_NMI)TRAPHANDLER_NOEC(breakpoint_handler, T_BRKPT)TRAPHANDLER_NOEC(overflow_handler, T_OFLOW)TRAPHANDLER_NOEC(bounds_check_handler, T_BOUND)TRAPHANDLER_NOEC(invalid_opcode_handler, T_ILLOP)TRAPHANDLER_NOEC(device_not_available_handler, T_DEVICE)TRAPHANDLER(double_fault_handler, T_DBLFLT)TRAPHANDLER(invalid_tss_handler, T_TSS)TRAPHANDLER(segment_not_present_handler, T_SEGNP)TRAPHANDLER(stack_exception_handler, T_STACK)TRAPHANDLER(general_protection_fault_handler, T_GPFLT)TRAPHANDLER(pagefault_handler, T_PGFLT)TRAPHANDLER_NOEC(floating_point_error_handler, T_FPERR)TRAPHANDLER(alignment_check_handler, T_ALIGN)TRAPHANDLER_NOEC(machine_check_handler, T_MCHK)TRAPHANDLER_NOEC(simd_floating_point_error_handler, T_SIMDERR)/* * Lab 3: Your code here for _alltraps */_alltraps:// push ds and es and general registerspush %dspush %espushal// load ds and es with GD_KD, for kernel stack locates in datamov $GD_KD, %axmov %ax, %dsmov %ax, %es// pass tf as an argumentpushl %esp// call trap and no need to returncall trap// In trap.c, trap_init():// LAB 3: Your code here.// declare of exception handlervoid divide_error_handler();void debug_exception_handler();void non_maskable_interrupt_handler();void breakpoint_handler();void overflow_handler();void bounds_check_handler();void invalid_opcode_handler();void device_not_available_handler();void double_fault_handler();void invalid_tss_handler();void segment_not_present_handler();void stack_exception_handler();void general_protection_fault_handler();void pagefault_handler();void floating_point_error_handler();void alignment_check_handler();void machine_check_handler();void simd_floating_point_error_handler();// set up trap gate descriptorSETGATE(idt[T_DIVIDE],\t 1, GD_KT, divide_error_handler,           \t   0);SETGATE(idt[T_DEBUG],    1, GD_KT, debug_exception_handler,            0);SETGATE(idt[T_NMI],      1, GD_KT, non_maskable_interrupt_handler,     0);SETGATE(idt[T_BRKPT],    1, GD_KT, breakpoint_handler,                 3);SETGATE(idt[T_OFLOW],    1, GD_KT, overflow_handler,                   0);SETGATE(idt[T_BOUND],    1, GD_KT, bounds_check_handler,               0);SETGATE(idt[T_ILLOP],    1, GD_KT, invalid_opcode_handler,             0);SETGATE(idt[T_DEVICE],   1, GD_KT, device_not_available_handler,       0);SETGATE(idt[T_DBLFLT],   1, GD_KT, double_fault_handler,               0);SETGATE(idt[T_TSS],      1, GD_KT, invalid_tss_handler,                0);SETGATE(idt[T_SEGNP],    1, GD_KT, segment_not_present_handler,        0);SETGATE(idt[T_STACK],    1, GD_KT, stack_exception_handler,            0);SETGATE(idt[T_GPFLT],    1, GD_KT, general_protection_fault_handler,   0);SETGATE(idt[T_PGFLT],    1, GD_KT, pagefault_handler,                  0);SETGATE(idt[T_FPERR],    1, GD_KT, floating_point_error_handler,       0);SETGATE(idt[T_ALIGN],    1, GD_KT, alignment_check_handler,            0);SETGATE(idt[T_MCHK],     1, GD_KT, machine_check_handler,              0);SETGATE(idt[T_SIMDERR],  1, GD_KT, simd_floating_point_error_handler,  0);\n问题1：若是使用同一个处理程序，将无法限制调用错误处理程序的代码的特权级，也无法得知中断向量的值。\n问题2：仅有内核代码允许执行页错误处理程序，尽管调用了int $14，仍然因为保护机制而生成了中断向量13。如果内核允许int $14唤醒页错误处理程序，那么恶意的程序可以因此而随意触发缺页错误，导致系统无法正常工作。\n第二部分 Page Faults, Breakpoints Exceptions, and System Calls - 页错误，断点异常和系统调用处理页错误页错误的中断向量号为14，是非常重要的异常。当处理器接收一个页错误时，会将引发页错误的线性地址存储在处理器控制寄存器CR2中。\n练习5的代码如下，仅供参考：12345// In trap_dispatch():if (tf-&gt;tf_trapno == T_PGFLT) &#123;    // dispatch page fault exceptions    page_fault_handler(tf);&#125;\n断点异常断点异常的中断向量号为3，通常被调试器用作向程序代码中添加断点，原理是将程序中的某一条指令暂时改为1字节的int3的软中断指令。在JOS中，将大量使用这一异常来实现一个原始的伪系统调用，使得用户环境可以使用它来环境JOS内核监视器，可以把内核监视器看做一个原始的调试器。用户模式的panic，就是通过显示panic消息后执行int3实现的。\n练习6的代码如下，仅供参考：1234if (tf-&gt;tf_trapno == T_BRKPT) &#123;    // dispatch breakpoint exceptions    monitor(tf);&#125;\n问题3：若是用特权级0初始化断点异常的IDT，那么会触发通用保护错误，这是因为用户模式的代码无法执行特权级0（内核模式）的处理程序，需要用特权级3初始化断点异常的IDT，这样才能使得断点测试正确通过。\n问题4：这些措施都是为了保护内核和用户环境的相互独立，使得用户环境仅能在收到允许的情况下执行某些内核的代码，保证了恶意程序不会破坏内核，窃取数据。同时也能保证用户环境能从内核得到必要的功能支持。\n系统调用用户进程通过系统调用请求内核为它工作。当用户进程唤醒系统调用时，处理器进入内核模式，处理器和内核合作保存用户进程状态，内核执行合适的代码完成系统调用，并恢复至用户进程。系统调用的具体实现随平台不同而不同。\nJOS内核使用int $0x30作为系统调用。需要建立相关的中断描述符，注意中断向量0x30不可能由硬件生成，毫无疑问应该允许用户执行对应的处理程序。\n应用程序会将系统调用号和系统调用参数存入寄存器中。避免了内核访问用户环境栈或是指令流。系统调用号放在寄存器%eax中，最多五个参数分别被相应地放在寄存器%edx, %ecx, %ebx, %edi和%esi中。内核将返回值放在寄存器%eax中。唤醒系统调用的汇编代码已经提供为lib/syscall.c中的syscall()。\n练习7中遇到的问题如下：\n\nsyscall作为软中断不会压入错误码\n调用syscall函数时应当使用保存的栈帧中的寄存器值而非实际的寄存器值，原因是在函数调用间某些寄存器的值会发生改变\n练习7需要参考lib/syscall.c中得知参数的位置关系\n\n练习7的代码如下，仅供参考：1234567891011121314151617181920212223242526272829303132333435// In trapentry.S:TRAPHANDLER_NOEC(syscall_handler, T_SYSCALL)// In trap.c, trap_init():void syscall_handler();SETGATE(idt[T_SYSCALL], 1, GD_KT, syscall_handler, 3);// In kern/syscall.c, syscall():// LAB 3: Your code here.// panic(\"syscall not implemented\");switch (syscallno) &#123;    case SYS_cputs:        // call sys_cputs        sys_cputs((const char *)a1, (size_t)a2);        break;    case SYS_cgetc:        // cll sys_cgetc        return sys_cgetc();        break;    case SYS_getenvid:        // call sys_getenvid        return sys_getenvid();        break;    case SYS_env_destroy:        // call sys_env_destroy        return sys_env_destroy((envid_t)a1);        break;    default: return -E_INVAL;&#125;// will not reach herereturn -E_UNSPECIFIED;\n用户模式启动一个用户在lib/entry.S的顶部开始运行，经过某些设置后，代码调用lib/libmain.c。你应当修改libmain()以初始化指向当前环境的struct Env指针thisenv（注意到lib/entry.S已经定义了指向你在第一部分映射的UENVS的envs）。\nlibmain()然后调用umain，对于hello程序而言，位于user/hello.c中。在打印hello, world后，它尝试访问thisenv-&gt;env_id。这也是为什么hello程序会出现fault。\n练习8中遇到的问题如下：\n\n可以使用宏ENVX从envid得到env在envs中的偏移量，而无需遍历整个envs\nLab2中pgdir_walk未设置PTE_U导致访问时出现了页错误（仅有PTE项中设置PTE_U是不足的）。\n\n练习8的答案如下，仅供参考：1234// In libmain.c, libmain():// LAB 3: Your code here.// get env id use system call and use ENVX to get indexthisenv = envs + ENVX(sys_getenvid());\n页错误和内存保护内存保护是操作系统的重要特性，保证了一个程序的错误不会毁坏内核或是其他的程序。操作系统通常和硬件一起实现内存保护。操作系统负责告知硬件哪些虚拟地址是有效的、哪些是无效的。当一个程序试图去访问一个无效的地址或是一个没有权限的地址时，处理器在引起错误的指令处停止程序，然后带着相应的信息陷入内核。若错误可修复，则内核修复该错误并继续执行程序；若错误不可恢复，则程序无法继续运行。现在考虑系统调用，系统调用允许用户程序向内核传递指针，内核在处理系统调用时将指针解引用，会出现以下两种问题：\n\n内核的缺页错误潜在地比用户程序的缺页更加严重。若内核在操作私有的数据结构时发生缺页，那么将是内核自己的漏洞，错误处理程序应当panic内核。然而当内核解引用用户程序传递的指针时，需要某种方式标记由解引用导致的缺页实际上代表的是用户程序的利益。\n内核比用户程序具有更多的权限。在这种情况下，用户程序可能传递给内核一个指针，该指针指向的内存只能被内核读写而不能被用户程序读写。在这种情况下，内核不能对该指针解引用，这么做会暴露私有数据或是破坏内核完整性。\n\n当内核处理用户程序传递的指针时必须非常小心。内核必须检查用户传入的指针。\n练习9和练习10遇到的问题如下：\n\n需要获取段寄存器的最低两位以得到段特权级\n\n练习9和练习10的答案如下，仅供参考：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// In kern/trap.c, page_fault_handler():// LAB 3: Your code here.if ((tf-&gt;tf_cs &amp; 3) == 0) &#123;    // code that causes page fault in kernel mode    panic(\"page fault in kernel!\");&#125;// In kern/pmap.c, user_mem_check():int user_mem_check(struct Env *env, const void *va, size_t len, int perm) &#123;    // LAB 3: Your code here.    if ((uintptr_t)va &gt;= ULIM) &#123;        // condition 1 - below ULIM violated        user_mem_check_addr = (uintptr_t)va;        return -E_FAULT;    &#125;    uintptr_t va_start = (uintptr_t)ROUNDDOWN(va, PGSIZE);    uintptr_t va_end   = (uintptr_t)ROUNDUP(va + len, PGSIZE);    for (; va_start &lt; va_end; va_start += PGSIZE) &#123;        // note we set page directory entry with less restrict        // we will only test page table entry here        pte_t *pgtable_entry_ptr =            pgdir_walk(env-&gt;env_pgdir, (char *)va_start, false);        if ((*pgtable_entry_ptr &amp; (perm | PTE_P)) != (perm | PTE_P)) &#123;            // condition 2 - permission violated            if (va_start &lt;= (uintptr_t)va) &#123;                // va lie in the first page and not aligned, return va                user_mem_check_addr = (uintptr_t)va;            &#125; else if (va_start &gt;= (uintptr_t)va + len) &#123;                // va lie in the last page and exceed va + len, return va + len                user_mem_check_addr = (uintptr_t)va + len;            &#125; else &#123;                // return corresponding page's initial address                user_mem_check_addr = va_start;            &#125;            return -E_FAULT;        &#125;    &#125;    // pass user memory check    return 0;&#125;// In kern/syscall.c, syscall():case SYS_cputs:    // checks memory before use sys_cputs to dereference a1    user_mem_assert(curenv, (char *)a1, (size_t)a2, PTE_U);    // call sys_cputs    sys_cputs((const char *)a1, (size_t)a2);    break;// In kern/kdebug.c, debuginfo_eip():// Make sure this memory is valid.// Return -1 if it is not.  Hint: Call user_mem_check.// LAB 3: Your code here.if (user_mem_check(curenv, usd, sizeof(struct UserStabData), PTE_U) &lt; 0) &#123;    return -1;&#125;// Make sure the STABS and string table memory is valid.// LAB 3: Your code here.if ((user_mem_check(curenv, stabs, stab_end - stabs, PTE_U) &lt; 0) ||    (user_mem_check(curenv, stabstr, stabstr_end - stabstr, PTE_U) &lt; 0)) &#123;    return -1;&#125;\n发生了页错误的原因还要观察memlayout.h，在USTACKTOP上方有一个位于0xeebfd000的Empty Memory，该虚拟地址没有映射任何的物理页。而在mon_backtrace的最后，访问到了位于此处的虚拟地址，因而导致了一个不可处理的页错误。\n实验小结最终执行make grade，评分脚本的输出如下：123456789101112131415161718192021222324252627282930313233343536373839404142divzero:$ make run-divzero-nox-gdb QEMUEXTRA+=-snapshotOK (1.3s)softint:$ make run-softint-nox-gdb QEMUEXTRA+=-snapshotOK (1.0s)badsegment:$ make run-badsegment-nox-gdb QEMUEXTRA+=-snapshotOK (1.0s)Part A score: 30/30faultread:$ make run-faultread-nox-gdb QEMUEXTRA+=-snapshotOK (1.0s)faultreadkernel:$ make run-faultreadkernel-nox-gdb QEMUEXTRA+=-snapshotOK (0.9s)faultwrite:$ make run-faultwrite-nox-gdb QEMUEXTRA+=-snapshotOK (1.0s)faultwritekernel:$ make run-faultwritekernel-nox-gdb QEMUEXTRA+=-snapshotOK (1.0s)breakpoint:$ make run-breakpoint-nox-gdb QEMUEXTRA+=-snapshotOK (2.0s)testbss:$ make run-testbss-nox-gdb QEMUEXTRA+=-snapshotOK (2.1s)hello:$ make run-hello-nox-gdb QEMUEXTRA+=-snapshotOK (1.0s)buggyhello:$ make run-buggyhello-nox-gdb QEMUEXTRA+=-snapshotOK (1.8s)buggyhello2:$ make run-buggyhello2-nox-gdb QEMUEXTRA+=-snapshotOK (2.1s)evilhello:$ make run-evilhello-nox-gdb QEMUEXTRA+=-snapshotOK (1.1s)Part B score: 50/50Score: 80/80至此，实验三结束。\n第三个实验的难度明显比实验一和实验二大。用户环境的管理相对简单，而设置陷阱和中断的部分涉及大量的x86硬件知识，需要大量参考Intel手册，要求直接写汇编代码设置栈帧也颇有挑战。\n","dateCreated":"2018-02-23T19:12:13+08:00","dateModified":"2018-05-15T17:22:23+08:00","datePublished":"2018-02-23T19:12:13+08:00","description":"","headline":"MIT6.828操作系统工程Lab3-User Environments实验报告","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/"},"publisher":{"@type":"Organization","name":"码龙黑曜","sameAs":["https://github.com/BlackDragonF","https://t.me/Cosidian","http://steamcommunity.com/id/BlackDragonF/","mailto:obsidiandragon2016@gmail.com"],"image":"avatar.jpg","logo":{"@type":"ImageObject","url":"avatar.jpg"}},"url":"http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/","keywords":"操作系统, 实验, 用户环境"}</script>
    <meta name="description" content="Lab3 - User Environments需要实现基本的内核功能，使得一个受保护的用户环境（进程）可以运行。在本实验中，需要让内核设置数据结构以追踪用户环境，创建一个单用户环境，加载程序镜像并执行。此外，内核还需要能处理用户环境的系统调用以及引发的异常。2018年2月26日，完成了实验并写完了报告。  实验准备根据官网，切换到分支lab3并且合并分支lab2。在合并的过程中，发生了冲突。">
<meta name="keywords" content="操作系统,实验,用户环境">
<meta property="og:type" content="blog">
<meta property="og:title" content="MIT6.828操作系统工程Lab3-User Environments实验报告">
<meta property="og:url" content="http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/index.html">
<meta property="og:site_name" content="码龙的窝">
<meta property="og:description" content="Lab3 - User Environments需要实现基本的内核功能，使得一个受保护的用户环境（进程）可以运行。在本实验中，需要让内核设置数据结构以追踪用户环境，创建一个单用户环境，加载程序镜像并执行。此外，内核还需要能处理用户环境的系统调用以及引发的异常。2018年2月26日，完成了实验并写完了报告。  实验准备根据官网，切换到分支lab3并且合并分支lab2。在合并的过程中，发生了冲突。">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2018-05-15T09:22:23.817Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT6.828操作系统工程Lab3-User Environments实验报告">
<meta name="twitter:description" content="Lab3 - User Environments需要实现基本的内核功能，使得一个受保护的用户环境（进程）可以运行。在本实验中，需要让内核设置数据结构以追踪用户环境，创建一个单用户环境，加载程序镜像并执行。此外，内核还需要能处理用户环境的系统调用以及引发的异常。2018年2月26日，完成了实验并写完了报告。  实验准备根据官网，切换到分支lab3并且合并分支lab2。在合并的过程中，发生了冲突。">
    
    
        
    
    
        <meta property="og:image" content="http://blog.codedragon.tech/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-j4w0tbtf1olriqsnfyv4egntpbdblucqpyraoqqnvawa2vd6l4m8ljtn2yes.min.css">
    <!--STYLES END-->
    
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-108458894-1', 'auto');
        ga('send', 'pageview');
    </script>


    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">码龙的窝</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">码龙黑曜</h4>
                
                    <h5 class="sidebar-profile-bio"><p>iOS开发者/计算机科学/兽人控</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="首页"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="分类"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="标签"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="归档"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/projects"
                            
                            title="项目"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-code" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">项目</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/about"
                            
                            title="关于"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/BlackDragonF" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://t.me/Cosidian" target="_blank" rel="noopener" title="Telegram">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-telegram" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Telegram</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://steamcommunity.com/id/BlackDragonF/" target="_blank" rel="noopener" title="Steam">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-steam" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Steam</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:obsidiandragon2016@gmail.com" target="_blank" rel="noopener" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/links"
                            
                            title="友情链接"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-link" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">友情链接</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/resources"
                            
                            title="学习资源"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-share-alt" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">学习资源</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            MIT6.828操作系统工程Lab3-User Environments实验报告
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-02-23T19:12:13+08:00">
	
		    2月 23, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <blockquote>
<p>Lab3 - User Environments需要实现基本的内核功能，使得一个受保护的用户环境（进程）可以运行。在本实验中，需要让内核设置数据结构以追踪用户环境，创建一个单用户环境，加载程序镜像并执行。此外，内核还需要能处理用户环境的系统调用以及引发的异常。<br>2018年2月26日，完成了实验并写完了报告。</p>
</blockquote>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>根据官网，切换到分支lab3并且合并分支lab2。在合并的过程中，发生了冲突。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user% git checkout -b lab3 origin/lab3</span><br><span class="line">user% git merge lab2</span><br></pre></td></tr></table></figure>
<p>根据提示，是<code>kern/monitor.c</code>中发生了冲突，因为仅有一处冲突，手动编辑<code>kern/monitor.c</code>文件，并commit，即可解决冲突并合并分支。</p>
<p>实验三包括如下的新文件：</p>
<ul>
<li>inc/env.h 用户模式环境的公有定义</li>
<li>inc/trap.h 陷阱处理的公有定义</li>
<li>inc/syscall.h 用户环境对内核的系统调用的公有定义</li>
<li>inc/lib.h 用户模式支持的库公有定义</li>
<li>kern/env.h 用户模式环境的内核私有定义</li>
<li>kern/env.c 用户模式环境的内核代码实现</li>
<li>kern/trap.h 内核私有的陷阱处理定义</li>
<li>kern/trap.c 陷阱处理代码</li>
<li>kern/trapentry.S 汇编语言的陷阱处理程序入口</li>
<li>kern/syscall.h 系统调用处理的内核私有定义</li>
<li>kern/syscall.c 系统调用实现代码</li>
<li>lib/Makefrag 用户模式库obj/lib/libjos.a的Makefile</li>
<li>lib/entry.S 用户环境的汇编语言入口</li>
<li>lib/libmain.c entry.S调用的用户模式库安装代码</li>
<li>lib/syscall.c 用户模式系统调用的打桩函数</li>
<li>lib/console.c 用户模式的putchar和getchar实现，提供了控制台IO</li>
<li>lib/exit.c 用户模式的exit实现</li>
<li>lib/panic.c 用户模式的panic实现</li>
<li>user/* 检验内核实验三代码的测试程序</li>
</ul>
<p>此外，lab2中的一些文件在lab3中也被添加了新的内容，可以用<code>git diff lab2</code>查看具体的比较信息。</p>
<h4 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h4><p>本实验中可能会用到<code>GCC</code>的内联汇编特性，应当至少理解给出的代码中的内联汇编代码片段。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="第一部分-User-Environments-and-Exception-Handling-用户环境和错误处理"><a href="#第一部分-User-Environments-and-Exception-Handling-用户环境和错误处理" class="headerlink" title="第一部分 User Environments and Exception Handling - 用户环境和错误处理"></a>第一部分 User Environments and Exception Handling - 用户环境和错误处理</h3><p><code>inc/env.h</code>中给出了用户环境的基本定义。内核通过<code>struct Env</code>追踪每一个用户环境。本实验中只需要创建一个环境，然而你需要设计JOS内核实际支持多用户环境。实验四中，你将通过允许一个用户环境<code>fork</code>别的用户环境来利用多用户环境的特性。</p>
<p><code>kern/env.c</code>中可以看到，内核管理3个与环境有关的全局变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *       <span class="title">envs</span>   = <span class="title">NULL</span>;</span>    <span class="comment">// All environments</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *       <span class="title">curenv</span> = <span class="title">NULL</span>;</span>    <span class="comment">// The current env</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span>    <span class="comment">// Free environment list</span></span><br></pre></td></tr></table></figure></p>
<p>当JOS成功运行之后，<code>envs</code>指针指向一个<code>struct Env</code>的数组，代表了系统中所有的环境。在设计上，JOS内核允许NNEV个同时激活的环境，NNEV在<code>inc/env.h</code>中定义。<br>JOS内核使用<code>env_free_list</code>维护所有未激活的<code>struct Env</code>，这样的设计简化的环境的分配和释放，它们仅仅需要从该链表上添加或移除。<br>JOS内核使用<code>curenv</code>去追踪在任意时刻当前正在执行的环境。在启动之后到第一个环境运行的时间段中，<code>curenv</code>被初始化为<code>NULL</code>。</p>
<h4 id="环境状态"><a href="#环境状态" class="headerlink" title="环境状态"></a>环境状态</h4><p><code>struct Env</code>在<code>inc/env.h</code>中被定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>	<span class="comment">// Saved registers</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>		<span class="comment">// Next free Env</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_id;			<span class="comment">// Unique environment identifier</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_parent_id;		<span class="comment">// env_id of this env's parent</span></span><br><span class="line">	<span class="keyword">enum</span> EnvType env_type;		<span class="comment">// Indicates special system environments</span></span><br><span class="line">	<span class="keyword">unsigned</span> env_status;		<span class="comment">// Status of the environment</span></span><br><span class="line">	<span class="keyword">uint32_t</span> env_runs;		<span class="comment">// Number of times environment has run</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Address space</span></span><br><span class="line">	<span class="keyword">pde_t</span> *env_pgdir;		<span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>env_tf - <code>struct TrapFrame</code>在<code>inc/trap.h</code>中被定义，表示了当环境不运行时被保存的寄存器值，主要用于上下文切换</li>
<li>env_link - 指向了<code>env_free_list</code>上的下一个<code>struct Env</code>。<code>env_free_list</code>指向了链表中的第一个空闲环境</li>
<li>env_id - 唯一标识当前正在使用<code>struct Env</code>的环境。当环境终止后，<code>struct Env</code>可能被内核重新分配用于另一个不同的环境，但它们的env_id是不同的</li>
<li>env_parent_id - 存储了创建该环境的环境的<code>env_id</code>，通过该方式构建一个环境树，用于安全方面的决策</li>
<li>env_type - 用于区分特殊环境，对于大部分环境，该值为<code>ENV_TYPE_USER</code>，在后续Lab中会介绍其他的值</li>
<li>env_status - 状态<ul>
<li>ENV_FREE - 表明<code>struct Env</code>处于空闲状态，应当位于<code>env_free_list</code>上</li>
<li>ENV_RUNNABLE - 表明<code>struct Env</code>代表的环境正等待运行于处理器上</li>
<li>ENV_RUNNING - 表明<code>struct Env</code>代表的环境为正在运行的环境</li>
<li>ENV_NOT_RUNNABLE - 表明<code>struct Env</code>代表了一个正在运行的环境，但却没有准备好运行，如正在等待另一个环境的IPC（进程间通信）</li>
<li>ENV_DYING - 表明<code>struct Env</code>代表了一个僵死环境，僵死环境将在下一次陷入内核时被释放（直到Lab4才会使用该Flag）</li>
</ul>
</li>
<li>env_pgdir - 保存了环境的页目录的内核虚拟地址</li>
</ul>
<p>JOS中环境的概念综合了“线程”和“地址空间”，“线程”由<code>env_tf</code>域的被保存的寄存器值定义，“地址空间”由<code>env_pgdir</code>域指向的页目录和页表定义。为了运行一个环境，内核必须用保存的寄存器值和合适的地址空间设置CPU。</p>
<p>JOS的<code>struct Env</code>和xv6的<code>struct proc</code>很像，两种结构体都持有环境的用户模式寄存器状态（通过<code>struct TrapFrame</code>），然而，JOS中，独立的环境并不具有不同的内核栈，因为JOS内核中同时只能有一个运行的JOS环境，因此JOS只需要一个内核栈。</p>
<h4 id="分配环境数组"><a href="#分配环境数组" class="headerlink" title="分配环境数组"></a>分配环境数组</h4><p>练习1的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Make 'envs' point to an array of size 'NENV' of 'struct Env'.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// get size of envs</span></span><br><span class="line"><span class="keyword">uint32_t</span> envs_size = <span class="keyword">sizeof</span>(struct Env) * NENV;</span><br><span class="line"><span class="comment">// use boot_alloc to allocate memory</span></span><br><span class="line">envs = (struct Env *)boot_alloc(envs_size);</span><br><span class="line"><span class="comment">// initialization</span></span><br><span class="line"><span class="built_in">memset</span>(envs, <span class="number">0</span>, envs_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map the 'envs' array read-only by the user at linear address UENVS</span></span><br><span class="line"><span class="comment">// (ie. perm = PTE_U | PTE_P).</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></span><br><span class="line"><span class="comment">//    - envs itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">boot_map_region(kern_pgdir, UENVS, envs_size, PADDR(envs), PTE_U | PTE_P);</span><br></pre></td></tr></table></figure></p>
<h4 id="创建并运行环境"><a href="#创建并运行环境" class="headerlink" title="创建并运行环境"></a>创建并运行环境</h4><p>现在将在<code>kern/env.c</code>中编写必要的代码去运行用户环境。由于JOS内核还不支持文件系统，所以只能配置内核以加载一个嵌入内核中静态二进制镜像。JOS内核将这个二进制镜像以ELF可执行镜像格式嵌入。</p>
<p>Lab3的GNU<code>Makefile</code>在<code>obj/user/</code>目录下生成了一些二进制镜像。<code>kern/Makefrag</code>下可以看到，链接器的<code>-b binary</code>选项使得这些文件以原始的未被翻译二进制文件而非普通的被编译器生成的<code>.o</code>文件的方式链接， 通过<code>-b binary</code>方式链接的二进制文件就链接器而言可以为任意类型，甚至是文本文件或是图片。</p>
<p>如果在构建内核后观察<code>obj/kern/kernel.sym</code>，可以看到链接器生成了一些“奇怪”名字的符号如<code>_binary_obj_user_hello_start</code>， <code>_binary_obj_user_hello_end</code>或 <code>_binary_obj_user_hello_size</code>。链接器通过二进制文件的名字生成了这些符号的名字，这些符号使得内核代码可以以某种方式引用这些嵌入的二进制文件。</p>
<p>练习2中遇到的问题：</p>
<ul>
<li>除了<code>env-&gt;env_tf.tf_eip</code>以外不要修改其他的值，因为其已经在<code>env_alloc()</code>中被初始化</li>
<li><code>region_alloc()</code>中笔误导致只映射了一页</li>
<li><code>load_icode()</code>中需要切换页表，之后加载每段仅用一个<code>memcpy</code>即可实现</li>
</ul>
<p>练习2的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In env_init():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">ssize_t</span> i;</span><br><span class="line"><span class="comment">// loop in reverse order to keep ascending order in env free list</span></span><br><span class="line"><span class="keyword">for</span> (i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// set env_status, env_id</span></span><br><span class="line">    envs[i].env_status = ENV_FREE;</span><br><span class="line">    envs[i].env_id     = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// set env_link and insert into env_free_list</span></span><br><span class="line">    envs[i].env_link = env_free_list;</span><br><span class="line">    env_free_list    = &amp;envs[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In env_setup_vm():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// set env_pgdir and generate page directory based on kern_pgdir</span></span><br><span class="line">e-&gt;env_pgdir = (<span class="keyword">pde_t</span> *)page2kva(p);</span><br><span class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br><span class="line"><span class="comment">// increase pp_ref</span></span><br><span class="line">p-&gt;pp_ref++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In region_alloc():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// (But only if you need it for load_icode.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></span><br><span class="line"><span class="comment">//   'va' and 'len' values that are not page-aligned.</span></span><br><span class="line"><span class="comment">//   You should round va down, and round (va + len) up.</span></span><br><span class="line"><span class="comment">//   (Watch out for corner-cases!)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// round va and va + len</span></span><br><span class="line"><span class="keyword">uintptr_t</span> start = (<span class="keyword">uintptr_t</span>)ROUNDDOWN(va, PGSIZE);</span><br><span class="line"><span class="keyword">uintptr_t</span> end   = (<span class="keyword">uintptr_t</span>)ROUNDUP(va + len, PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; start &lt; end; start += PGSIZE) &#123;</span><br><span class="line">    <span class="comment">// alloc page</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span>;</span></span><br><span class="line">    p = page_alloc(ALLOC_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123; panic(<span class="string">"out of memory when allocating region!"</span>); &#125;</span><br><span class="line">    <span class="comment">// insert page into environment's page directory</span></span><br><span class="line">    <span class="keyword">if</span> (page_insert(e-&gt;env_pgdir, p, (<span class="keyword">char</span> *)start, PTE_W | PTE_U | PTE_P) &lt;</span><br><span class="line">        <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">"out of memory when allocating region!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In load_icode():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// switch address space for loading program segments</span></span><br><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elf</span> = (<span class="title">struct</span> <span class="title">Elf</span> *)<span class="title">binary</span>;</span></span><br><span class="line"><span class="comment">// check elf magic</span></span><br><span class="line"><span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123; panic(<span class="string">"invalid elf format!"</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the program entry for env</span></span><br><span class="line">e-&gt;env_tf.tf_eip = elf-&gt;e_entry;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get the start and end of program header entry</span></span><br><span class="line">ph  = (struct Proghdr *)(binary + elf-&gt;e_phoff);</span><br><span class="line">eph = ph + elf-&gt;e_phnum;</span><br><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ph-&gt;p_type == ELF_PROG_LOAD) &#123;    <span class="comment">// if the segment is to be loaded</span></span><br><span class="line">        <span class="comment">// alloc corresponding region(clear zero)</span></span><br><span class="line">        region_alloc(e, (<span class="keyword">char</span> *)ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line">        <span class="comment">// copy from ELF header to virtual addresses directly</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span> *)ph-&gt;p_va, (<span class="keyword">char</span> *)binary + ph-&gt;p_offset, ph-&gt;p_filesz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// switch back</span></span><br><span class="line">lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now map one page for the program's initial stack</span></span><br><span class="line"><span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// allocate a page and insert it into env's page directory</span></span><br><span class="line"><span class="comment">// panic when page_alloc or page_insert failed</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">stack_page</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></span><br><span class="line"><span class="keyword">if</span> (!stack_page) &#123; panic(<span class="string">"out of memory when alloc program's stack!"</span>); &#125;</span><br><span class="line"><span class="keyword">if</span> (page_insert(e-&gt;env_pgdir, stack_page, (<span class="keyword">char</span> *)(USTACKTOP - PGSIZE),</span><br><span class="line">                PTE_W | PTE_U | PTE_P) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    panic(<span class="string">"failed to set program's stack!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In env_create():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"><span class="comment">// allocate new env with parent ID 0</span></span><br><span class="line"><span class="keyword">if</span> (env_alloc(&amp;env, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123; panic(<span class="string">"failed to allocate env!"</span>); &#125;</span><br><span class="line"><span class="comment">// load elf binary and set env_type</span></span><br><span class="line">load_icode(env, binary);</span><br><span class="line">env-&gt;env_type = type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In env_run():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (curenv != <span class="literal">NULL</span>) &#123;    <span class="comment">// context switch</span></span><br><span class="line">    <span class="keyword">if</span> (curenv-&gt;env_status == ENV_RUNNING) &#123;</span><br><span class="line">        <span class="comment">// change to runnable if current status is running</span></span><br><span class="line">        <span class="comment">// for not runnable, is not necessary to do this</span></span><br><span class="line">        curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set new curenv, update status and counter</span></span><br><span class="line">curenv        = e;</span><br><span class="line">e-&gt;env_status = ENV_RUNNING;</span><br><span class="line">e-&gt;env_runs++;</span><br><span class="line"><span class="comment">// address space switch</span></span><br><span class="line"><span class="comment">// reference from inc/x86.h</span></span><br><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line"><span class="comment">// drop into user mode</span></span><br><span class="line">env_pop_tf(&amp;(e-&gt;env_tf));</span><br><span class="line"></span><br><span class="line"><span class="comment">// panic("env_run not yet implemented");</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>成功进入用户环境后，若用户环境尝试使用<code>int</code>指令进行系统调用时，将产生错误，因为JOS没有设置任何从用户空间进入内核的方式。<br>当CPU发现无法处理系统中断调用后，会产生一个通用保护错误，发现无法处理它，然后生成一个二重错误，最终因无法处理而生成一个三重错误并放弃，然后系统重启。但是为了便于调试，patch的<code>qemu</code>不会重启。<br>关于重启的理由可以参考<a href="https://blogs.msdn.microsoft.com/larryosterman/2005/02/08/faster-syscall-trap-redux/" target="_blank" rel="noopener">这里</a>。</p>
</blockquote>
<p>完成后经过测试，程序在<code>int $0x30</code>处Triple Fault，可知本部分代码基本正确。</p>
<h4 id="处理中断和异常"><a href="#处理中断和异常" class="headerlink" title="处理中断和异常"></a>处理中断和异常</h4><p>练习3要求阅读Intel 80386编程手册中的<a href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/c09.htm" target="_blank" rel="noopener">第九章：异常和中断</a>。</p>
<p>本实验中将沿用Intel关于中断和异常的术语。中断是由处理器以外的异步事件引发的，而异常是由当前正在执行的指令同步引发的。</p>
<h4 id="保护控制转移基础"><a href="#保护控制转移基础" class="headerlink" title="保护控制转移基础"></a>保护控制转移基础</h4><p>异常和中断均为“保护控制转移”，会引发处理器从用户到内核模式（CPL=0），从而避免给用户模式的代码干扰内核或是其他环境的机会。这要求了引发中断或者是异常的代码不能选择进入内核的地点或方式。<br>在x86中，主要有两种机制一起保证了内核总是在受保护的情况下进入，这两种机制为中断描述符表（Interrupt Descriptor Table）和任务状态段（Task State Segment）。</p>
<p>中断描述符表中，处理器保证了异常和中断仅能导致内核在若干个具体的、由内核明确定义好的入口执行，而不是在中断和异常发生时运行的代码。<br>x86允许最多设立256个不同的中断或异常入口，每一个入口都具有一个中断向量。中断向量为0-255的数字，中断向量由中断来源决定：不同的设备，错误条件和应用程序对内核的请求会产生不同向量的中断。CPU使用中断向量作为处理器的中断描述符表的索引。中断描述符表在内核私有的内存中建立。<br>处理器从该表中加载送入EIP寄存器的值（处理程序的入口），以及送入CS段寄存器的值（包括了特权级，在JOS中，所有的异常均在内核模式执行，即特权级0）。</p>
<p>任务状态段。处理器需要在唤醒处理程序前将在中断或异常发生前的旧的处理器状态保存起来，如旧的EIP寄存器值和旧的CS段寄存器值，以便处理程序之后能恢复现场，从中断或异常发生的地方继续执行。然而，保存旧的处理器状态的区域必须对于非特权的用户模式代码处于被保护的状态。否则，错误的或是恶意的用户代码可能会破坏内核。<br>因此，当x86处理器从用户模式特权级切换到内核模式时，其也会切换到内核内存中的一个栈。任务状态段指定了相应的段寄存器以及相应栈的地址。处理器将<code>SS</code>, <code>EFLAGS</code>, <code>CS</code>, <code>EIP</code>以及一个可选的错误码压入这个新栈中。然后从中断描述符中读取相应的<code>CS</code>和<code>EIP</code>，并设置<code>ESP</code>和<code>SS</code>指向新的栈。<br>尽管<code>TSS</code>有着多种作用，JOS仅用它来定义从用户模式切换到内核模式时的内核栈。因为JOS中的内核模式为x86的特权级0，故处理器仅使用<code>TSS</code>的<code>ESP0</code>和<code>SS0</code>域。</p>
<h4 id="异常和中断的类型"><a href="#异常和中断的类型" class="headerlink" title="异常和中断的类型"></a>异常和中断的类型</h4><p>x86处理器能产生的所有同步异常均使用了0-31的中断向量，映射为<code>IDT</code>的0-31号入口。超过31的中断向量仅供由<code>int</code>指令或是由异步硬件中断产生的“软中断”使用。</p>
<h4 id="嵌套异常和中断"><a href="#嵌套异常和中断" class="headerlink" title="嵌套异常和中断"></a>嵌套异常和中断</h4><p>处理器能同时处理内核模式和用户模式的异常。在内核模式中的异常不需要切换栈，因此，不需要压入旧的<code>SS</code>和<code>ESP</code>值。通过这种方式，内核可以优雅地处理内核产生的嵌套异常和中断。该能力对于实现保护是非常重要的。</p>
<p>若处理器已经在内核模式中并且接受了一个异常并且无法将旧值压入内核栈中时（如内存不足），那么，处理器将无论如何也无法恢复，只能重启。内核必须设计良好以避免这种情况发生。</p>
<h4 id="建立IDT表"><a href="#建立IDT表" class="headerlink" title="建立IDT表"></a>建立IDT表</h4><p>由于JOS中使用的为IA_32的陷阱码，更推荐参考<a href="https://pdos.csail.mit.edu/6.828/2017/readings/ia32/IA32-3A.pdf" target="_blank" rel="noopener">IA_32的第五章</a>。</p>
<p>练习4中遇到的问题如下：</p>
<ul>
<li>设置陷阱门时段选择子应当为<code>GD_KT</code>而不是<code>GD_KD</code>，因为错误处理函数均被链接至了内核的<code>text</code>段。</li>
<li>已存在<code>page_fault_handler</code>的函数，命名时需避免重名。</li>
<li>不能直接用立即数设置段寄存器。</li>
</ul>
<p>练习4的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In trapentry.S:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab 3: Your code here for generating entry points for the different traps.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(divide_error_handler, T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(debug_exception_handler, T_DEBUG)</span><br><span class="line">TRAPHANDLER_NOEC(non_maskable_interrupt_handler, T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(breakpoint_handler, T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(overflow_handler, T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(bounds_check_handler, T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(invalid_opcode_handler, T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(device_not_available_handler, T_DEVICE)</span><br><span class="line">TRAPHANDLER(double_fault_handler, T_DBLFLT)</span><br><span class="line">TRAPHANDLER(invalid_tss_handler, T_TSS)</span><br><span class="line">TRAPHANDLER(segment_not_present_handler, T_SEGNP)</span><br><span class="line">TRAPHANDLER(stack_exception_handler, T_STACK)</span><br><span class="line">TRAPHANDLER(general_protection_fault_handler, T_GPFLT)</span><br><span class="line">TRAPHANDLER(pagefault_handler, T_PGFLT)</span><br><span class="line">TRAPHANDLER_NOEC(floating_point_error_handler, T_FPERR)</span><br><span class="line">TRAPHANDLER(alignment_check_handler, T_ALIGN)</span><br><span class="line">TRAPHANDLER_NOEC(machine_check_handler, T_MCHK)</span><br><span class="line">TRAPHANDLER_NOEC(simd_floating_point_error_handler, T_SIMDERR)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab 3: Your code here for _alltraps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">_alltraps:</span><br><span class="line"><span class="comment">// push ds and es and general registers</span></span><br><span class="line">push %ds</span><br><span class="line">push %es</span><br><span class="line">pushal</span><br><span class="line"></span><br><span class="line"><span class="comment">// load ds and es with GD_KD, for kernel stack locates in data</span></span><br><span class="line">mov $GD_KD, %ax</span><br><span class="line">mov %ax, %ds</span><br><span class="line">mov %ax, %es</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass tf as an argument</span></span><br><span class="line">pushl %esp</span><br><span class="line"></span><br><span class="line"><span class="comment">// call trap and no need to return</span></span><br><span class="line">call trap</span><br><span class="line"></span><br><span class="line"><span class="comment">// In trap.c, trap_init():</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// declare of exception handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide_error_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug_exception_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">non_maskable_interrupt_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">breakpoint_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bounds_check_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalid_opcode_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_not_available_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">double_fault_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalid_tss_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">segment_not_present_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stack_exception_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">general_protection_fault_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pagefault_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floating_point_error_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alignment_check_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">machine_check_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simd_floating_point_error_handler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up trap gate descriptor</span></span><br><span class="line">SETGATE(idt[T_DIVIDE],	 <span class="number">1</span>, GD_KT, divide_error_handler,           	   <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_DEBUG],    <span class="number">1</span>, GD_KT, debug_exception_handler,            <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_NMI],      <span class="number">1</span>, GD_KT, non_maskable_interrupt_handler,     <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_BRKPT],    <span class="number">1</span>, GD_KT, breakpoint_handler,                 <span class="number">3</span>);</span><br><span class="line">SETGATE(idt[T_OFLOW],    <span class="number">1</span>, GD_KT, overflow_handler,                   <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_BOUND],    <span class="number">1</span>, GD_KT, bounds_check_handler,               <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_ILLOP],    <span class="number">1</span>, GD_KT, invalid_opcode_handler,             <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_DEVICE],   <span class="number">1</span>, GD_KT, device_not_available_handler,       <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_DBLFLT],   <span class="number">1</span>, GD_KT, double_fault_handler,               <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_TSS],      <span class="number">1</span>, GD_KT, invalid_tss_handler,                <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_SEGNP],    <span class="number">1</span>, GD_KT, segment_not_present_handler,        <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_STACK],    <span class="number">1</span>, GD_KT, stack_exception_handler,            <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_GPFLT],    <span class="number">1</span>, GD_KT, general_protection_fault_handler,   <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_PGFLT],    <span class="number">1</span>, GD_KT, pagefault_handler,                  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_FPERR],    <span class="number">1</span>, GD_KT, floating_point_error_handler,       <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_ALIGN],    <span class="number">1</span>, GD_KT, alignment_check_handler,            <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_MCHK],     <span class="number">1</span>, GD_KT, machine_check_handler,              <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_SIMDERR],  <span class="number">1</span>, GD_KT, simd_floating_point_error_handler,  <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>问题1：<br>若是使用同一个处理程序，将无法限制调用错误处理程序的代码的特权级，也无法得知中断向量的值。</p>
<p>问题2：<br>仅有内核代码允许执行页错误处理程序，尽管调用了<code>int $14</code>，仍然因为保护机制而生成了中断向量13。如果内核允许<code>int $14</code>唤醒页错误处理程序，那么恶意的程序可以因此而随意触发缺页错误，导致系统无法正常工作。</p>
<h3 id="第二部分-Page-Faults-Breakpoints-Exceptions-and-System-Calls-页错误，断点异常和系统调用"><a href="#第二部分-Page-Faults-Breakpoints-Exceptions-and-System-Calls-页错误，断点异常和系统调用" class="headerlink" title="第二部分 Page Faults, Breakpoints Exceptions, and System Calls - 页错误，断点异常和系统调用"></a>第二部分 Page Faults, Breakpoints Exceptions, and System Calls - 页错误，断点异常和系统调用</h3><h4 id="处理页错误"><a href="#处理页错误" class="headerlink" title="处理页错误"></a>处理页错误</h4><p>页错误的中断向量号为14，是非常重要的异常。当处理器接收一个页错误时，会将引发页错误的线性地址存储在处理器控制寄存器<code>CR2</code>中。</p>
<p>练习5的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In trap_dispatch():</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_PGFLT) &#123;</span><br><span class="line">    <span class="comment">// dispatch page fault exceptions</span></span><br><span class="line">    page_fault_handler(tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="断点异常"><a href="#断点异常" class="headerlink" title="断点异常"></a>断点异常</h4><p>断点异常的中断向量号为3，通常被调试器用作向程序代码中添加断点，原理是将程序中的某一条指令暂时改为1字节的<code>int3</code>的软中断指令。在JOS中，将大量使用这一异常来实现一个原始的伪系统调用，使得用户环境可以使用它来环境JOS内核监视器，可以把内核监视器看做一个原始的调试器。<br>用户模式的<code>panic</code>，就是通过显示panic消息后执行<code>int3</code>实现的。</p>
<p>练习6的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_BRKPT) &#123;</span><br><span class="line">    <span class="comment">// dispatch breakpoint exceptions</span></span><br><span class="line">    monitor(tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>问题3：<br>若是用特权级0初始化断点异常的IDT，那么会触发通用保护错误，这是因为用户模式的代码无法执行特权级0（内核模式）的处理程序，需要用特权级3初始化断点异常的IDT，这样才能使得断点测试正确通过。</p>
<p>问题4：<br>这些措施都是为了保护内核和用户环境的相互独立，使得用户环境仅能在收到允许的情况下执行某些内核的代码，保证了恶意程序不会破坏内核，窃取数据。同时也能保证用户环境能从内核得到必要的功能支持。</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>用户进程通过系统调用请求内核为它工作。当用户进程唤醒系统调用时，处理器进入内核模式，处理器和内核合作保存用户进程状态，内核执行合适的代码完成系统调用，并恢复至用户进程。系统调用的具体实现随平台不同而不同。</p>
<p>JOS内核使用<code>int $0x30</code>作为系统调用。需要建立相关的中断描述符，注意中断向量<code>0x30</code>不可能由硬件生成，毫无疑问应该允许用户执行对应的处理程序。</p>
<p>应用程序会将系统调用号和系统调用参数存入寄存器中。避免了内核访问用户环境栈或是指令流。系统调用号放在寄存器<code>%eax</code>中，最多五个参数分别被相应地放在寄存器<code>%edx</code>, <code>%ecx</code>, <code>%ebx</code>, <code>%edi</code>和<code>%esi</code>中。内核将返回值放在寄存器<code>%eax</code>中。唤醒系统调用的汇编代码已经提供为<code>lib/syscall.c</code>中的<code>syscall()</code>。</p>
<p>练习7中遇到的问题如下：</p>
<ul>
<li>syscall作为软中断不会压入错误码</li>
<li>调用syscall函数时应当使用保存的栈帧中的寄存器值而非实际的寄存器值，原因是在函数调用间某些寄存器的值会发生改变</li>
<li>练习7需要参考<code>lib/syscall.c</code>中得知参数的位置关系</li>
</ul>
<p>练习7的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In trapentry.S:</span></span><br><span class="line">TRAPHANDLER_NOEC(syscall_handler, T_SYSCALL)</span><br><span class="line"></span><br><span class="line"><span class="comment">// In trap.c, trap_init():</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_handler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KT, syscall_handler, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/syscall.c, syscall():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// panic("syscall not implemented");</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">    <span class="keyword">case</span> SYS_cputs:</span><br><span class="line">        <span class="comment">// call sys_cputs</span></span><br><span class="line">        sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, (<span class="keyword">size_t</span>)a2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">        <span class="comment">// cll sys_cgetc</span></span><br><span class="line">        <span class="keyword">return</span> sys_cgetc();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">        <span class="comment">// call sys_getenvid</span></span><br><span class="line">        <span class="keyword">return</span> sys_getenvid();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">        <span class="comment">// call sys_env_destroy</span></span><br><span class="line">        <span class="keyword">return</span> sys_env_destroy((<span class="keyword">envid_t</span>)a1);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// will not reach here</span></span><br><span class="line"><span class="keyword">return</span> -E_UNSPECIFIED;</span><br></pre></td></tr></table></figure></p>
<h4 id="用户模式启动"><a href="#用户模式启动" class="headerlink" title="用户模式启动"></a>用户模式启动</h4><p>一个用户在<code>lib/entry.S</code>的顶部开始运行，经过某些设置后，代码调用<code>lib/libmain.c</code>。你应当修改<code>libmain()</code>以初始化指向当前环境的<code>struct Env</code>指针<code>thisenv</code>（注意到<code>lib/entry.S</code>已经定义了指向你在第一部分映射的<code>UENVS</code>的<code>envs</code>）。</p>
<p><code>libmain()</code>然后调用<code>umain</code>，对于hello程序而言，位于<code>user/hello.c</code>中。在打印<code>hello, world</code>后，它尝试访问<code>thisenv-&gt;env_id</code>。这也是为什么hello程序会出现<code>fault</code>。</p>
<p>练习8中遇到的问题如下：</p>
<ul>
<li>可以使用宏<code>ENVX</code>从<code>envid</code>得到<code>env</code>在<code>envs</code>中的偏移量，而无需遍历整个<code>envs</code></li>
<li>Lab2中<code>pgdir_walk</code>未设置<code>PTE_U</code>导致访问时出现了页错误（仅有PTE项中设置<code>PTE_U</code>是不足的）。</li>
</ul>
<p>练习8的答案如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In libmain.c, libmain():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// get env id use system call and use ENVX to get index</span></span><br><span class="line">thisenv = envs + ENVX(sys_getenvid());</span><br></pre></td></tr></table></figure></p>
<h4 id="页错误和内存保护"><a href="#页错误和内存保护" class="headerlink" title="页错误和内存保护"></a>页错误和内存保护</h4><p>内存保护是操作系统的重要特性，保证了一个程序的错误不会毁坏内核或是其他的程序。<br>操作系统通常和硬件一起实现内存保护。操作系统负责告知硬件哪些虚拟地址是有效的、哪些是无效的。当一个程序试图去访问一个无效的地址或是一个没有权限的地址时，处理器在引起错误的指令处停止程序，然后带着相应的信息陷入内核。若错误可修复，则内核修复该错误并继续执行程序；若错误不可恢复，则程序无法继续运行。<br>现在考虑系统调用，系统调用允许用户程序向内核传递指针，内核在处理系统调用时将指针解引用，会出现以下两种问题：</p>
<ol>
<li>内核的缺页错误潜在地比用户程序的缺页更加严重。若内核在操作私有的数据结构时发生缺页，那么将是内核自己的漏洞，错误处理程序应当panic内核。然而当内核解引用用户程序传递的指针时，需要某种方式标记由解引用导致的缺页实际上代表的是用户程序的利益。</li>
<li>内核比用户程序具有更多的权限。在这种情况下，用户程序可能传递给内核一个指针，该指针指向的内存只能被内核读写而不能被用户程序读写。在这种情况下，内核不能对该指针解引用，这么做会暴露私有数据或是破坏内核完整性。</li>
</ol>
<p>当内核处理用户程序传递的指针时必须非常小心。内核必须检查用户传入的指针。</p>
<p>练习9和练习10遇到的问题如下：</p>
<ul>
<li>需要获取段寄存器的最低两位以得到段特权级</li>
</ul>
<p>练习9和练习10的答案如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In kern/trap.c, page_fault_handler():</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// code that causes page fault in kernel mode</span></span><br><span class="line">    panic(<span class="string">"page fault in kernel!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/pmap.c, user_mem_check():</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">user_mem_check</span><span class="params">(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= ULIM) &#123;</span><br><span class="line">        <span class="comment">// condition 1 - below ULIM violated</span></span><br><span class="line">        user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va;</span><br><span class="line">        <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span> va_start = (<span class="keyword">uintptr_t</span>)ROUNDDOWN(va, PGSIZE);</span><br><span class="line">    <span class="keyword">uintptr_t</span> va_end   = (<span class="keyword">uintptr_t</span>)ROUNDUP(va + len, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; va_start &lt; va_end; va_start += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// note we set page directory entry with less restrict</span></span><br><span class="line">        <span class="comment">// we will only test page table entry here</span></span><br><span class="line">        <span class="keyword">pte_t</span> *pgtable_entry_ptr =</span><br><span class="line">            pgdir_walk(env-&gt;env_pgdir, (<span class="keyword">char</span> *)va_start, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> ((*pgtable_entry_ptr &amp; (perm | PTE_P)) != (perm | PTE_P)) &#123;</span><br><span class="line">            <span class="comment">// condition 2 - permission violated</span></span><br><span class="line">            <span class="keyword">if</span> (va_start &lt;= (<span class="keyword">uintptr_t</span>)va) &#123;</span><br><span class="line">                <span class="comment">// va lie in the first page and not aligned, return va</span></span><br><span class="line">                user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (va_start &gt;= (<span class="keyword">uintptr_t</span>)va + len) &#123;</span><br><span class="line">                <span class="comment">// va lie in the last page and exceed va + len, return va + len</span></span><br><span class="line">                user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va + len;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// return corresponding page's initial address</span></span><br><span class="line">                user_mem_check_addr = va_start;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass user memory check</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/syscall.c, syscall():</span></span><br><span class="line"><span class="keyword">case</span> SYS_cputs:</span><br><span class="line">    <span class="comment">// checks memory before use sys_cputs to dereference a1</span></span><br><span class="line">    user_mem_assert(curenv, (<span class="keyword">char</span> *)a1, (<span class="keyword">size_t</span>)a2, PTE_U);</span><br><span class="line">    <span class="comment">// call sys_cputs</span></span><br><span class="line">    sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, (<span class="keyword">size_t</span>)a2);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/kdebug.c, debuginfo_eip():</span></span><br><span class="line"><span class="comment">// Make sure this memory is valid.</span></span><br><span class="line"><span class="comment">// Return -1 if it is not.  Hint: Call user_mem_check.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (user_mem_check(curenv, usd, <span class="keyword">sizeof</span>(struct UserStabData), PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure the STABS and string table memory is valid.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> ((user_mem_check(curenv, stabs, stab_end - stabs, PTE_U) &lt; <span class="number">0</span>) ||</span><br><span class="line">    (user_mem_check(curenv, stabstr, stabstr_end - stabstr, PTE_U) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发生了页错误的原因还要观察<code>memlayout.h</code>，在<code>USTACKTOP</code>上方有一个位于<code>0xeebfd000</code>的<code>Empty Memory</code>，该虚拟地址没有映射任何的物理页。而在<code>mon_backtrace</code>的最后，访问到了位于此处的虚拟地址，因而导致了一个不可处理的页错误。</p>
<h2 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h2><p>最终执行<code>make grade</code>，评分脚本的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">divzero:</span><br><span class="line">$ make run-divzero-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.3s)</span><br><span class="line">softint:</span><br><span class="line">$ make run-softint-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">badsegment:</span><br><span class="line">$ make run-badsegment-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">Part A score: 30/30</span><br><span class="line">faultread:</span><br><span class="line">$ make run-faultread-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">faultreadkernel:</span><br><span class="line">$ make run-faultreadkernel-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (0.9s)</span><br><span class="line">faultwrite:</span><br><span class="line">$ make run-faultwrite-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">faultwritekernel:</span><br><span class="line">$ make run-faultwritekernel-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">breakpoint:</span><br><span class="line">$ make run-breakpoint-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (2.0s)</span><br><span class="line">testbss:</span><br><span class="line">$ make run-testbss-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (2.1s)</span><br><span class="line">hello:</span><br><span class="line">$ make run-hello-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">buggyhello:</span><br><span class="line">$ make run-buggyhello-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.8s)</span><br><span class="line">buggyhello2:</span><br><span class="line">$ make run-buggyhello2-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (2.1s)</span><br><span class="line">evilhello:</span><br><span class="line">$ make run-evilhello-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.1s)</span><br><span class="line">Part B score: 50/50</span><br><span class="line">Score: 80/80</span><br></pre></td></tr></table></figure><br>至此，实验三结束。</p>
<p>第三个实验的难度明显比实验一和实验二大。<br>用户环境的管理相对简单，而设置陷阱和中断的部分涉及大量的x86硬件知识，需要大量参考Intel手册，要求直接写汇编代码设置栈帧也颇有挑战。</p>

            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/实验/">实验</a> <a class="tag tag--primary tag--small t-link" href="/tags/操作系统/">操作系统</a> <a class="tag tag--primary tag--small t-link" href="/tags/用户环境/">用户环境</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/" data-tooltip="MIT6.828操作系统工程Lab4-Preemptive Multitasking实验报告" aria-label="上一篇: MIT6.828操作系统工程Lab4-Preemptive Multitasking实验报告">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/02/20/MIT6-828操作系统工程Lab2-Memory-Management实验报告/" data-tooltip="MIT6.828操作系统工程Lab2-Memory Management实验报告" aria-label="下一篇: MIT6.828操作系统工程Lab2-Memory Management实验报告">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/" title="分享到 Facebook">
                    <i class="fa fa-facebook-official" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/" title="分享到 Twitter">
                    <i class="fa fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/" title="分享到 Weibo">
                    <i class="fa fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/&amp;title=MIT6.828操作系统工程Lab3-User Environments实验报告" title="分享到 QQ">
                    <i class="fa fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/" title="分享到 Qzone">
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 码龙黑曜. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/" data-tooltip="MIT6.828操作系统工程Lab4-Preemptive Multitasking实验报告" aria-label="上一篇: MIT6.828操作系统工程Lab4-Preemptive Multitasking实验报告">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/02/20/MIT6-828操作系统工程Lab2-Memory-Management实验报告/" data-tooltip="MIT6.828操作系统工程Lab2-Memory Management实验报告" aria-label="下一篇: MIT6.828操作系统工程Lab2-Memory Management实验报告">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/" title="分享到 Facebook">
                    <i class="fa fa-facebook-official" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/" title="分享到 Twitter">
                    <i class="fa fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/" title="分享到 Weibo">
                    <i class="fa fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/&amp;title=MIT6.828操作系统工程Lab3-User Environments实验报告" title="分享到 QQ">
                    <i class="fa fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/" title="分享到 Qzone">
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-close"></i>
    <ul class="share-options">
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/">
                    <i class="fa fa-facebook-official" aria-hidden="true"></i><span>分享到 Facebook</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/">
                    <i class="fa fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/">
                    <i class="fa fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/&amp;title=MIT6.828操作系统工程Lab3-User Environments实验报告">
                    <i class="fa fa-qq" aria-hidden="true"></i><span>分享到 QQ</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://blog.codedragon.tech/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/">
                    <i class="fa fa-star" aria-hidden="true"></i><span>分享到 Qzone</span>
                </a>
            </li>
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">码龙黑曜</h4>
        
            <div id="about-card-bio"><p>iOS开发者/计算机科学/兽人控</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>华中科技大学 本科在读</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Wuhan, China
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-feiabjni254mgbxiozwsjblcsiodjqohurk0dcfkq0aooroewq6bvkdnadrg.min.js"></script>
<!--SCRIPTS END-->

    



    </body>
</html>
