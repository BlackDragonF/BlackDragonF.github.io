
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="码龙的窝">
    <title>MIT6.828操作系统工程Lab4-Preemptive Multitasking实验报告 - 码龙的窝</title>
    <meta name="author" content="码龙黑曜">
    
        <meta name="keywords" content="博客,iOS,Computer Science,码龙,">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"码龙黑曜","sameAs":["https://github.com/BlackDragonF","https://t.me/Cosidian","http://steamcommunity.com/id/BlackDragonF/","mailto:obsidiandragon2016@gmail.com"],"image":"avatar.jpg"},"articleBody":"\nLab4 - Preemptive Multitasking需要在多个同时激活的用户模式环境中实现抢占式多任务。实验分为三个部分。第一部分要求为JOS添加多处理器支持，并实现论询调度以及基本的环境管理系统调用；第二部分需要实现一个Unix-like的fork函数，使得用户环境可以创建一份自己的拷贝；第三部分需要实现进程间通讯功能，允许不同的用户环境显式地互相通信和同步。同时还需要实现对于硬件时钟中断和抢占的支持。2018年3月2日，完成了实验并写完了报告。\n\n实验准备 根据官网，切换到分支lab4并合并分支lab3。在合并的过程中，发生了冲突。\n 12user% git checkout -b lab3 origin/lab3user% git merge lab3\n 根据提示，是conf/lab.mk中发生了冲突。打开后可以发现是其中记录的时间和实验数发生了变化，直接采用分支lab4的版本即可，然后提交，分支合并完成。\n 实验四包括如下的新文件：\n\nkern/cpu.h 内核私有的关于多处理器的支持\nkern/mpconfig.c 读取多处理器配置的代码\nkern/lapic.c 内核驱动每个处理的的APIC（高级可编程中断控制器）的代码\nkern/mpentry.S 非引导CPU的汇编入口代码\nkern/spinlock.h 内核私有的自旋锁定义，包括大内核锁\nkern/spinlock.c 内核实现自旋锁的代码\nkern/sched.c 需要实现的调度器的代码框架\n\n实验过程第一部分 Multiprocessor Support and Cooperative Multitasking - 多处理器支和写作式多任务在第一部分中，需要使JOS运行在一个多处理器系统上，并且实现新的JOS内核系统调用去允许用户级别的环境创建额外的新环境。还需要实现协同式的论询调度，允许内核当旧的用户环境自愿放弃CPU或退出时切换至一个新的用户环境。\n多处理器支持需要使JOS支持“对称多处理”（Symmetric Multiprocessing），在该模型下，所有的CPU都有着对系统资源（内存、IO总线等）的平等访问权。尽管在SMP下所有的CPU在功能上均等价，在启动时仍然分为两种类型——引导处理器（Bootstrap Processor或是BSP）负责初始化系统并且引导操作系统；应用处理器（Application Processors或是APs）仅在系统启动运行后被BSP激活。BSP处理器由硬件和BIOS决定。在此刻，所有已有的代码已经运行在了BSP上。\n在SMP中，每一个CPU都有一个相伴的本地APIC（LAPIC）单元。LAPIC单元负责在整个系统中传递中断。LAPIC为相连的CPU提供了一个唯一标识。在本实验中，将利用LAPIC的一下功能（在kern/lapic.c中）：\n\n读取LAPIC标识（APIC ID）以告知CPU代码运行在哪一个CPU上（参考cpunum()）\n从BSP向APs发送STARTUP处理器间中断（Interprocessor interrupt或IPI）以唤醒其他CPU（参考lapic_startup()）\n在第三部分中，通过编程LAPIC内置的计时器去引发时钟中断以实现抢占式多任务（参考apic_init()\n\n处理器通过内存映射IO（Memory-mapped I/O 或是MMIO）访问LAPIC。在MMIO中，一部分物理内存被硬连接至某些IO设备的寄存器。所以相同的访问内存的load/store指令可以被用来访问设备寄存器。你可能已经见过了存在于物理地址0xA0000中IO洞（以此来写VGA显示缓存）。LAPIC存在于物理地址从0xFE000000（4064M）开始的洞中。该地址太高以至于无法在KERNBASE的直接映射访问。JOS的虚拟内存映射在MMIOBASE处留下了4MB的空隙。在之后的实验中会引入更多的MMIO区域，所以应当写一个简单的函数从该区域分配空间并映射内存。\n练习1的答案如下，仅供参考：1234567891011121314151617// In kern/pmap.c, mmio_map_region():// Your code here:size = ROUNDUP(size, PGSIZE);if (base + size &gt; MMIOLIM) &#123;    // reservation overflog MMIOLIM    panic(\"reservation bytes overflows!\");&#125;// use boot_map_region to map [pa, pa + size) to [base, base + size)boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_PWT);// update base and returnuintptr_t saved_base = base;base += size;return (char *)saved_base;// panic(\"mmio_map_region not implemented\");\n应用处理器引导BSP在引导APs之前应当首先收集多处理器系统的信息，如总CPU数，APIC IDs以及LAPIC单元的内存映射IO地址等。kern/mpconfig.c中的mp_init()函数通过读取BIOS内存中的MP配置表获取相应的信息。在kern/init.c中的boot_aps()函数驱动AP引导过程。APs在实模式中启动，所以boot_aps()从kern/mpentry.S中拷贝AP入口代码到一个实模式可寻址的位置。可以在一定程度上控制AP执行开始代码的位置。在本实验中，将入口代码拷贝至0x7000（MPENTRY_PADDR），但实际上任何640KB以下的、页对齐的和未使用的物理地址均可使用。然后，boot_aps()通过向对应AP的LAPIC单元发送STARTUP处理器间中断和初始的CS:IP地址（本实验中为MPENTRY_PADDR），依次激活APs。在简单的设置后，将AP启动分页，使得AP进入保护模式，然后调用启动例程mp_main()（在kern/init.c中。boot_aps()在唤醒下一个AP之前先等待当前AP在struct CpuInfo的cpu_status域中发送一个CPU_STARTED标记。AP引导的汇编代码和C代码同实验一BSP的引导代码相似，可以比对异同。\n练习2的代码如下，仅供参考：12345678910111213141516171819// In kern/pmap.c, page_init():// code MODIFIEDsize_t i;// initialize from page 1 to page npages_basemem - 1// set pp_ref to 0, set pp_link to last page_free_list// and then update page_free_list// Lab 4: remove page at MPENTRY_PADDRsize_t mp_entry_page = PGNUM(MPENTRY_PADDR);for(i = 1 ; i &lt; npages_basemem ; i++) &#123;    if (i == mp_entry_page) &#123;        continue;    &#125;    pages[i].pp_ref = 0;    pages[i].pp_link = page_free_list;    page_free_list = &amp;pages[i];&#125;\n问题1：宏MPBOOTPHYS作用是将给定的内核虚拟地址（在mpentry.S中）转换成相应的加载后的物理地址。这么做的原因是在mpentry.S中，保护模式与分页机制尚未开启，设置分段等需要知道相应的物理地址。\n每CPU状态和初始化当编写多处理器操作系统时，区分对于每个处理器而言私有的每CPU状态以及整个系统共享的全局状态是很重要的。kern/cpu.h定义了大部分每CPU状态，包括了存储了每CPU变量的struct CpuInfo。cpunum()总是返回调用它的CPU ID，能用来索引例如cpus的数组。宏thiscpu是当前CPU的struct CpuInfo的简写。\n以下是你需要注意的每CPU状态：\n\n每CPU内核栈 - 多个CPU可能会同时陷入内核，因此每个处理器需要独立的内核栈以避免互相干扰。percpu_kstacks[NCPU][KSTKSIZE]为NCPU个内核栈预留空间。在实验二中，将bootstack指向的物理内存作为BSP的栈映射在了KSTACKTOP下面。相似地，本实验中，需要将每个CPU的内核栈映射到该区域同时分配保护页作为它们之间的缓冲。CPU 0的栈将从KSTACKTOP开始向下增长；CPU 1的栈将从CPU 0栈下方间隔KSTKGAP处开始增长。inc/memlayout.h展示了映射约束。\n每CPU的TSS和TSS描述符 - 每CPU的任务状态段同样用来致命每个CPU内核栈的位置。CPU i的TSS被存储于cpus[i].cpu_ts中，相应的TSS描述符在GDT入口gdt[(GD_TSS0 &gt;&gt; 3) + i]处被定义。kern/trap.c中定义的ts将不再有效。\n每CPU的当前环境指针 - 由于每个CPU都能同步地执行不同的用户环境。重新将curenv定义为指向当前CPU（当前代码正在执行的CPU）正在执行的环境的cpus[cpunum()].cpu_env（或是thiscpu-&gt;cpu_env）。\n每CPU的系统寄存器 - 包括系统寄存器在内的所有寄存器都属于CPU私有。因此初始化这些寄存器的指令如lcr3, ltr, ‘lgdt’等，必须在每个CPU上都被执行。函数env_init_percpu()以及trap_init_percpu正是为此而被定义。\n\n除此之外任何额外的用来CPU初始化的所有每CPU状态都应该在每个CPU处重复。\n练习3中遇到的问题：\n\n在使用boot_map_region映射内存时忘记将kstacktop_i减去KSTKSIZE，导致未通过检查\n\n练习3的代码如下，仅供参考：12345678910// LAB 4: Your code here:size_t i;for (i = 0; i &lt; NCPU; i++) &#123;    // traverser through 0 to NCPU to use boot_map_region to map    // per-CPU's kernel stack to corresponding va    uintptr_t kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);    boot_map_region(kern_pgdir, kstacktop_i - KSTKSIZE, KSTKSIZE,                    PADDR(percpu_kstacks[i]), PTE_W | PTE_P);&#125;\n练习4中遇到的问题：\n\n使用ltr加载任务段选择子时，每个CPU应当使用不同的选择子，inc/memlayout.c中的GD_TSS0为CPU0的任务段选择子，应该加上i &lt;&lt; 3的偏移\n完成trap_init_percpu()后，旧的使用ts的代码应当被注释\n\n练习4的代码如下，仅供参考：12345678910111213141516171819202122// LAB 4: Your code here:// trap_init_percpu() is called by all CPUs// set esp0 and ss0 of task state segment to provide// per-CPU's kernel stack accessthiscpu-&gt;cpu_ts.ts_esp0 = (uintptr_t)percpu_kstacks[cpunum()];thiscpu-&gt;cpu_ts.ts_ss0  = GD_KD;// set IO map base address to prevent unauthorized environments// this line works together as we'll set TSS segment limit later// so all ports in address space have no corresponding IOPBthiscpu-&gt;cpu_ts.ts_iomb = sizeof(struct Taskstate);// set TSS in gdt// 0 means RPL and sd_s = 0 means system segmentgdt[(GD_TSS0 &gt;&gt; 3) + cpunum()] = SEG16(STS_T32A, (uint32_t)(&amp;(thiscpu-&gt;cpu_ts)),                                       sizeof(struct Taskstate) - 1, 0);gdt[(GD_TSS0 &gt;&gt; 3) + cpunum()].sd_s = 0;// Load TSS selectorltr(GD_TSS0 + (cpunum() &lt;&lt; 3));// load the IDTlidt(&amp;idt_pd);\n同步锁当前的代码在mp_main()中初始化完AP之后忙等待。在继续下一步之前，首先得解决多个CPU同时执行内核代码时的竞争条件。最简答的方式是使用一个“大”内核锁，大内核锁在从用户模式进入内核模式时被获取，在从环境返回用户模式时被释放。在这种模型下，用户模式环境可以在任意多个CPU上运行，但同时只能有一个环境能在内核中运行，其他想在内核中运行的环境被强制等待。\nkern/spinlock.h声明了内核锁，同时提供了lock_kernel提供加锁的功能；unlock_kernel提供解锁的功能，你应当在如下4个地方应用内核锁：\n\n在i386_init()中，在BSP唤醒其他CPU之前加锁\n在mp_main()中，在初始化AP后加锁，然后调用sched_yield()去在当前AP上执行环境\n在trap()中，当从用户模式陷入的时候加锁，通过检查tf_cs的低位判断陷阱发生于用户模式还是内核模式\n在env_run()中，在“刚好”切换回用户模式之前解锁。太早或太晚解锁会导致严重的竞争和死锁\n\n练习5的代码如下，仅供参考：123456789101112131415161718192021222324252627282930// In i386_init():// Acquire the big kernel lock before waking up APs// Your code here:lock_kernel();// In mp_main():// Now that we have finished some basic setup, call sched_yield()// to start running processes on this CPU.  But make sure that// only one CPU can enter the scheduler at a time!//// Your code here:// lock the kernel and start running enviromentslock_kernel();sched_yield();// In trap():// Trapped from user mode.// Acquire the big kernel lock before doing any// serious kernel work.// LAB 4: Your code here.lock_kernel();// In env_run():// address space switch// reference from inc/x86.hlcr3(PADDR(e-&gt;env_pgdir));// release kernel lock hereunlock_kernel(); // newly added code// drop into user modeenv_pop_tf(&amp;(e-&gt;env_tf));\n问题2：即使受到内核锁的保护，CPU之间仍然需要独立的内核栈。假设CPU0因中断陷入内核并在内核栈中保留了相关的信息，此时若CPU1也发生中断而陷入内核，在同一个内核栈的情况下，CPU0中的信息将会被覆盖从而导致出现错误。\n论询调度下一个任务是改变JOS内核使得其能按照“论询”的方式在多个环境中切换。在JOS中，论询调度按如下方式工作：\n\n‘kern/sched.c’中的sched_yield()负责选择一个新环境执行。其循环按顺序遍历envs数组，从上一次运行的环境（如果没有之前运行的环境，则从第一个环境）开始，找到第一个具有状态ENV_RUNNABLE的环境，调用env_run()执行。\nsched_yield()绝对不能同时在两个CPU上运行相同的环境。其会告知环境当前已经正在运行在某CPU上（很可能是当前环境），因为该环境的状态将为ENV_RUNNING。\n将实现一个新的系统调用sys_yield()，用户环境可以通过该系统调用唤醒sched_yield()函数以主动放弃CPU。\n\n练习6中遇到的问题：\n\n在实现sched_yield()的时候没有检查thiscpu-&gt;cpu_env是否为空，对空指针的访问导致了缺页错误\n一开始的实现弄错了获取env_index和自增的顺序，参考代码中第一个if处的else分支的注释\n练习6结束后需要将init.c中mp_main()的最后一行注释\n\n练习6的代码如下，仅供参考：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// In kern/sched.c, sched_yield():// LAB 4: Your code here.// get index from current CPU's envsize_t env_index;// set curenv_flag to default trueint curenv_flag = true;size_t i;if (thiscpu-&gt;cpu_env == NULL) &#123;    // no previous running environment    // start at beginning of envs array    i         = 0;    env_index = NENV - 1;    // mark curenv_flag as true    curenv_flag = false;&#125; else &#123;    // start at previous running environment    env_index = ENVX(thiscpu-&gt;cpu_env-&gt;env_id);    // NB: don't mess with code order here, must first retrieve    // env_index then increment    i = (env_index == NENV - 1) ? 0 : env_index + 1;&#125;// traverse through envs list to find first ENV_RUNNABLE// envfor (; i != env_index; i = ((i == NENV - 1) ? 0 : i + 1)) &#123;    if (envs[i].env_status == ENV_RUNNABLE) &#123;        // found, set idle and break from loop        idle = &amp;envs[i];        break;    &#125;&#125;// if idle is NULL and curenv_flag is true,// means no envs are runnable and last previous running env is ENV_RUNNING// check if last previous environment is ENV_RUNNING,// if so, choose it.if (!idle &amp;&amp; curenv_flag &amp;&amp; envs[env_index].env_status == ENV_RUNNING) &#123;    idle = &amp;envs[env_index];&#125;if (idle) &#123;    // idle env choosed, run it directly    env_run(idle);&#125; else &#123;    // failed to choose idle env, halt CPU    // sched_halt never returns    sched_halt();&#125;// In kern/syscall.c, syscall():// code added:case SYS_yield:    // call sys_yield    sys_yield();    break;// In kern/init.c, i386_init():// code modified:#if defined(TEST)    // Don't touch -- used by grading script!    ENV_CREATE(TEST, ENV_TYPE_USER);#else    // Touch all you want.    // create three user_yield    // code MODIFIED here    ENV_CREATE(user_yield, ENV_TYPE_USER);    ENV_CREATE(user_yield, ENV_TYPE_USER);    ENV_CREATE(user_yield, ENV_TYPE_USER);#endif    // TEST*\n问题3：地址切换前后的页表中，e指向的虚拟地址都被同一块物理页映射。出现这种情况的原因在于env的env_pgdir是以kern_pgdir为原型产生的，e出于UTOP之上的地址，而UTOP以上的地址的映射关系在两个页表中是一样的。\n问题4：当发生地址转换时一定是从用户陷入内核之后，无论以何种方式陷入内核，必须要经过kern/trap.c中的trap()函数。观察该函数，可以发现，当从用户模式陷入内核时，代码将内核栈中的tf（包括页表和寄存器等）拷贝至内核间共享的对应的env中，所以之后寄存器状态才能恢复。\n环境创建的系统调用尽管内核已经可以运行并在不同环境间切换了，但内核任然被限制了只能执行内核初始设置的用户环境。需要实现必要的系统调用使得JOS可以允许用户环境创建和启动其他的用户环境。\nUnix提供了fork()作为它的进程创建原语。Unix的fork()拷贝调用进程（父进程）的整个地址空间以创建子进程。从用户空间来看，父子进程唯一可观察的差异就是它们的进程ID和父进程ID（通过gitpid()和getppid()返回。在父进程中，fork()返回子进程ID；在子进程中，fork()返回0。默认情况下，每个进程均获得其私有的地址空间，并且任意一个进程对于内存的修改对于其他进程都是不可见的。\n将要实现一个不同的、更加原始的JOS系统调用原语集合去创建新的用户模式环境，通过这些系统调用，除了其他类型的环境创建以外，将能够在用户空间实现一个完整的类Unixfork()系统调用。需要实现的系统调用为：\n\nsys_exofork - 创建一个几乎空白的新环境：在地址空间没有任何的用户映射，并且也无法运行。新环境将会有和父环境在执行sys_exofork系统调用时完全一致的寄存器状态。在父进程中，sys_exofork会返回新创建环境的envid_t（若环境创建错误则返回一个错误码）；子进程则会返回0（因为子进程最初被标记为不可运行，直到父进程通过显式标记子进程可运行之后，sys_exofork返回。\nsys_env_set_status - 设置指定的环境的状态为ENV_RUNNABLE或是ENV_NOT_RUNNABLE。该系统调用通常在一个新环境的地址空间和寄存器状态完全初始化之后标记其为可运行。\nsys_page_alloc - 分配一页的物理内存并将其映射到给定环境地址空间的给定虚拟地址。\nsys_page_alloc - 将一页映射（而不是实际的页内容）从一个环境的地址空间拷贝至另一个，共享内存使得新映射和旧映射指向同一页物理内存。\nsys_page_unmap - 将给定环境的给定虚拟地址的页面解除映射。\n\n上述所有的系统调用接受环境ID，内核支持将0到“当前环境”转换，在kern/env.c中的envid2env()实现。\n已经在user/dumpfork.c中提供了非常原始的类Unix的fork()实现。测试程序用上述系统调用创建并运行一个当前地址空间拷贝的子进程，然后两个环境使用sys_yield()来回切换。父进程在10次迭代后退出；子进程在20次迭代后退出。\n练习7的代码如下，仅供参考：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269// In sys_exofork():// Allocate a new environment.// Returns envid of new environment, or &lt; 0 on error.  Errors are://  -E_NO_FREE_ENV if no free environment is available.//  -E_NO_MEM on memory exhaustion.static envid_t sys_exofork(void) &#123;    // Create the new environment with env_alloc(), from kern/env.c.    // It should be left as env_alloc created it, except that    // status is set to ENV_NOT_RUNNABLE, and the register set is copied    // from the current environment -- but tweaked so sys_exofork    // will appear to return 0.    // LAB 4: Your code here.    // get env_id of current environment    envid_t parent_id = thiscpu-&gt;cpu_env-&gt;env_id;    // use env_alloc to create new environment and    // do some basic setup(status and register set)    struct Env *env = NULL;    if (env_alloc(&amp;env, parent_id) &lt; 0) &#123; panic(\"sys_exofork failed!\"); &#125;    env-&gt;env_status = ENV_NOT_RUNNABLE;    env-&gt;env_tf     = thiscpu-&gt;cpu_env-&gt;env_tf;    // do the trick to set eax register of newly    // alloc environment to 0    env-&gt;env_tf.tf_regs.reg_eax = 0;    // return new environment's ID    return env-&gt;env_id;    // panic(\"sys_exofork not implemented\");&#125;// In sys_env_set_status():// Set envid's env_status to status, which must be ENV_RUNNABLE// or ENV_NOT_RUNNABLE.//// Returns 0 on success, &lt; 0 on error.  Errors are://  -E_BAD_ENV if environment envid doesn't currently exist,//\t\tor the caller doesn't have permission to change envid.//  -E_INVAL if status is not a valid status for an environment.static int sys_env_set_status(envid_t envid, int status) &#123;    // Hint: Use the 'envid2env' function from kern/env.c to translate an    // envid to a struct Env.    // You should set envid2env's third argument to 1, which will    // check whether the current environment has permission to set    // envid's status.    // LAB 4: Your code here.    // check status passed in    if (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) &#123;        // invalid status        return -E_INVAL;    &#125;    struct Env *env;    // call envid2env to translate envid passed in    if (envid2env(envid, &amp;env, true) &lt; 0) &#123;        // bad environment        return -E_BAD_ENV;    &#125;    // set status    env-&gt;env_status = status;    // panic(\"sys_env_set_status not implemented\");    return 0;&#125;// In sys_page_alloc():// Allocate a page of memory and map it at 'va' with permission// 'perm' in the address space of 'envid'.// The page's contents are set to 0.// If a page is already mapped at 'va', that page is unmapped as a// side effect.//// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set,//         but no other bits may be set.  See PTE_SYSCALL in inc/mmu.h.//// Return 0 on success, &lt; 0 on error.  Errors are://  -E_BAD_ENV if environment envid doesn't currently exist,//      or the caller doesn't have permission to change envid.//  -E_INVAL if va &gt;= UTOP, or va is not page-aligned.//  -E_INVAL if perm is inappropriate (see above).//  -E_NO_MEM if there's no memory to allocate the new page,//      or to allocate any necessary page tables.static int sys_page_alloc(envid_t envid, void *va, int perm) &#123;    // Hint: This function is a wrapper around page_alloc() and    //   page_insert() from kern/pmap.c.    //   Most of the new code you write should be to check the    //   parameters for correctness.    //   If page_insert() fails, remember to free the page you    //   allocated!    // LAB 4: Your code here.    struct Env *env;    // check and get env    if (envid2env(envid, &amp;env, true) &lt; 0) &#123;        // envid not exist or permission error        return -E_BAD_ENV;    &#125;    // check va    if ((uintptr_t)va &gt;= UTOP || PGOFF(va) != 0) &#123;        // va above UTOP or va is not page-aligned        return -E_INVAL;    &#125;    // check perm    if ((perm &amp; (~PTE_SYSCALL)) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P)) &#123;        // invalid perm        return -E_INVAL;    &#125;    // allocate page and then insert it    // check if out of memory    struct PageInfo *page;    if ((page = page_alloc(ALLOC_ZERO)) == NULL) &#123;        // failed to allocate page        return -E_NO_MEM;    &#125;    if (page_insert(env-&gt;env_pgdir, page, va, perm) &lt; 0) &#123;        // page table couldn't be allocated        // free ununsed page        page_free(page);        return -E_NO_MEM;    &#125;    // panic(\"sys_page_alloc not implemented\");    // page successfully allocated    return 0;&#125;// In sys_page_map():// Map the page of memory at 'srcva' in srcenvid's address space// at 'dstva' in dstenvid's address space with permission 'perm'.// Perm has the same restrictions as in sys_page_alloc, except// that it also must not grant write access to a read-only// page.//// Return 0 on success, &lt; 0 on error.  Errors are://  -E_BAD_ENV if srcenvid and/or dstenvid doesn't currently exist,//      or the caller doesn't have permission to change one of them.//  -E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,//      or dstva &gt;= UTOP or dstva is not page-aligned.//  -E_INVAL is srcva is not mapped in srcenvid's address space.//  -E_INVAL if perm is inappropriate (see sys_page_alloc).//  -E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid's//      address space.//  -E_NO_MEM if there's no memory to allocate any necessary page tables.static int sys_page_map(envid_t srcenvid, void *srcva, envid_t dstenvid,                        void *dstva, int perm) &#123;    // Hint: This function is a wrapper around page_lookup() and    //   page_insert() from kern/pmap.c.    //   Again, most of the new code you write should be to check the    //   parameters for correctness.    //   Use the third argument to page_lookup() to    //   check the current permissions on the page.    // LAB 4: Your code here.    struct Env *srcenv, *dstenv;    // check environment    if ((envid2env(srcenvid, &amp;srcenv, true) &lt; 0) ||        (envid2env(dstenvid, &amp;dstenv, true) &lt; 0)) &#123;        // srcenvid or dstenvid doesn't exist or        // caller doesn't have permissions        return -E_BAD_ENV;    &#125;    // check srcva and dstva about address and page-aligned    // get srcenv and dstenv    if (((uintptr_t)srcva &gt;= UTOP) || ((uintptr_t)dstva &gt;= UTOP) ||        (PGOFF(srcva) != 0) || (PGOFF(dstva) != 0)) &#123;        // addresses above UTOP or addresses not page_aligned        return -E_INVAL;    &#125;    struct PageInfo *srcpage;    pte_t *          scrpte_ptr;    // use page look up to get source page and corresponding pte_t *    if ((srcpage = page_lookup(srcenv-&gt;env_pgdir, srcva, &amp;scrpte_ptr)) ==        NULL) &#123;        // srcva not mapped in srcenvid's address space        return -E_INVAL;    &#125;    // check perm passed in    if ((perm &amp; (~PTE_SYSCALL)) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P)) &#123;        // invalid perm        return -E_INVAL;    &#125;    // check if srcva is writable if perm has PTE_W    if ((perm &amp; PTE_W) &amp;&amp; (!((*scrpte_ptr) &amp; PTE_W))) &#123;        // perm has PTE_W while srcva ISN'T writable        return -E_INVAL;    &#125;    // insert source page into dstenv's pgdir with perm    // check if out of memory    if (page_insert(dstenv-&gt;env_pgdir, srcpage, dstva, perm) &lt; 0) &#123;        // out of memory to allocate page table        return -E_NO_MEM;    &#125;    // panic(\"sys_page_map not implemented\");    // page successfully mapped    return 0;&#125;// In sys_page_unmap():// Unmap the page of memory at 'va' in the address space of 'envid'.// If no page is mapped, the function silently succeeds.//// Return 0 on success, &lt; 0 on error.  Errors are://  -E_BAD_ENV if environment envid doesn't currently exist,//      or the caller doesn't have permission to change envid.//  -E_INVAL if va &gt;= UTOP, or va is not page-aligned.static int sys_page_unmap(envid_t envid, void *va) &#123;    // Hint: This function is a wrapper around page_remove().    // LAB 4: Your code here.    struct Env *env;    // check and get env    if (envid2env(envid, &amp;env, true) &lt; 0) &#123;        // envid not exist or permission error        return -E_BAD_ENV;    &#125;    // check va    if ((uintptr_t)va &gt;= UTOP || PGOFF(va) != 0) &#123;        // va above UTOP or va is not page-aligned        return -E_INVAL;    &#125;    // call page_remove to unmap page    page_remove(env-&gt;env_pgdir, va);    // panic(\"sys_page_unmap not implemented\");    // page successfully unmapped    return 0;&#125;// In syscall():// new code addedcase SYS_exofork:    // call sys_exofork    return sys_exofork();    break;case SYS_env_set_status:    // call sys_env_set_status    return sys_env_set_status((envid_t)a1, (int)a2);    break;case SYS_page_alloc:    // call sys_page_alloc    return sys_page_alloc((envid_t)a1, (void *)a2, (int)a3);    break;case SYS_page_map:    // call sys_page_map    return sys_page_map((envid_t)a1, (void *)a2, (envid_t)a3, (void *)a4,                        (int)a5);    break;case SYS_page_unmap:    // call sys_page_unmap    return sys_page_unmap((envid_t)a1, (void *)a2);    break;\n第二部分 Copy-on-Write Fork - 写时复制ForkUnix提供了一个fork()系统调用作为其原始的进程创建原语。fork()系统调用将调用进程的整个地址空间拷贝以创建子进程。\nxv6通过将父进程页中的所有数据复制到子进程中的新页中来实现fork()，这本质上就是dumbfowk()采用的方法。对于父进程地址空间的拷贝是整个fork()操作中最“贵”的部分。\n然而，对于fork()的调用通常紧跟着一个对子进程的exec()系统调用，该系统调用用一个新程序替换子进程的内存，这就是一个典型的shell所做的。在这种情况下，花费的用于复制父进程的地址空间的时间是被浪费的，因为子进程在调用exec()前只会使用很少的内存。\n出于以上的原因，Unix之后的版本利用了虚拟内存硬件去允许父进程和子进程共享映射到各自地址空间的内存，直到其中一个进程实际修改为止。该技术又被称作写时复制。为了实现写时复制，在fork()中内核仅仅从父进程拷贝地址的映射而非实际映射的页面到子进程，并且在同时将共享的页面标记为只读。当两个进程之一尝试写入其中一个共享页面时，该过程触发页面错误。内核意识到该页面实际上是一个“虚拟”或是“写时复制”页面，所以其会创建一个错误页面的新的，私有的，可写的页副本。通过这种方式，直到实际写入时，独立页面的内容才被复制。该过程使得紧接着exec()的fork()调用更加节约：子进程在调用exec()很可能只会复制一页（栈的当前页）。\n本实验的下一个部分要求完成一个合适的类Unix的fork()的写时复制的实现（作为用户空间库例程）。在用户空间实现fork()并且支持写时复制使得内核能保留相对简洁，因此更不容易出现严重的错误。这同样可以允许独立的用户模式程序实现自己的fork()语义。\n用户级别的页错误处理用户级别的写时复制fork()实现需要知道写保护页面的页错误。写时复制只是用户级别的页错误处理的诸多可能用处之一。\n通常的做法是设置一个地址空间以便页错误指示何时需要采取某些行动。大多数Unix内核通常只会为新进程的栈区域分配一页，随着进程栈逐渐增长直至访问到了还未被映射的栈地址，触发页错误，然后内核会“按需”分配更多的栈页面。典型的Unix内核必须追踪进程的空间中的不同区域发生页错误时所采取的行动。栈区域的页错误通常会导致新页的分配和映射。BSS区域的页错误通常会导致分配一个新页，填充0，并映射。对于具有按需分页的可执行文件的系统，text段的页错误会导致内核从磁盘上的二进制文件读取相应的页面并映射。\n内核需要追踪大量的信息。与传统的Unix方法不同，本实验需要用户决定如何处理用户空间中的每个页面错误，而这些错误的损害通常不大。这种设计还为程序定义存储区域带来了极大的灵活性。之后将会应用用户级别的错误处理程序来映射和访问基于磁盘的文件系统上的文件。\n设置页错误处理程序为了处理用户环境自己的页错误，用户环境必须向JOS内核注册一个页错误处理程序入口。用户环境通过sys_env_set_pgfault_upcall()的“上行”系统调用注册自己的错误处理程序入口。已经向struct Env添加了新的域env_pgfault_upcall来记录该信息。\n练习8的代码如下，仅供参考：1234567891011121314151617181920212223242526272829303132// In sys_env_set_pgfault_upcall():// Set the page fault upcall for 'envid' by modifying the corresponding struct// Env's 'env_pgfault_upcall' field.  When 'envid' causes a page fault, the// kernel will push a fault record onto the exception stack, then branch to// 'func'.//// Returns 0 on success, &lt; 0 on error.  Errors are://  -E_BAD_ENV if environment envid doesn't currently exist,//      or the caller doesn't have permission to change envid.static int sys_env_set_pgfault_upcall(envid_t envid, void *func) &#123;    // LAB 4: Your code here.    struct Env *env;    // check and translate the envid    if (envid2env(envid, &amp;env, true) &lt; 0) &#123;        // envid not exist or permission error        return -E_BAD_ENV;    &#125;    // set func    env-&gt;env_pgfault_upcall = func;    // panic(\"sys_env_set_pgfault_upcall not implemented\");    return 0;&#125;// In syscall():// new code addedcase SYS_env_set_pgfault_upcall:    // call sys_env_set_pgfault_upcall    return sys_env_set_pgfault_upcall((envid_t)a1, (void *)a2);    break;\n用户环境中的正常栈和异常栈在正常执行时，JOS中的用户环境会在正常栈中执行：正常栈的ESP寄存器指向USTACKTOP，并且压入的栈数据会存放于USTACKTOP - PGSIZE到USTACKTOP - 1的闭区域。然而，当一个页错误在用户模式发生时，内核将重启用户环境，在一个另外的栈上运行一个特定的用户级别的页错误处理程序，该栈被称为用户异常栈。实际上，将使JOS代表用户环境自动执行“栈切换”，就像x86处理器在用户模式转换到内核模式时已经代表JOS实现了栈切换一样。\nJOS用户异常栈的大小也为一个页面大，栈顶被定义为指向虚拟地址UXSTACKTOP，用户异常栈的有效字节为UXSTACKTOP - PGSIZE到UXSTACKTOP - 1的闭区域。当运行于异常栈上时，用户级别的页错误处理程序可以使用JOS的常规系统调用映射新的页或是调整页映射以修复任何可能导致页错误的问题。然后用户级别的页错误处理程序通过汇编语言存根返回至原始栈上的错误代码处。\n每一个想要支持用户级别页错误处理程序的用户环境需要自己为其异常栈通过sys_page_alloc()分配内存。\n唤醒用户页错误处理程序现在需要改变kern/trap.c中的页错误处理程序按特定的方式处理用户模式的页错误。将错误时的用户环境状态叫做陷阱时状态。\n若是没有页面错误处理函数被注册，则JOS内核会和之前一样，摧毁用户环境并输出一条消息。否则，内核会在异常栈设置在inc/trap.h中如struct UTrapFrame定义的陷阱帧。\n然后内核会安排用户环境以页错误处理程序以上述栈帧在异常栈上恢复执行。fault_va是导致也错误的虚拟地址。\n如果当异常发生时用户环境已经在用户异常栈上运行，则错误处理程序自身发生了错误。在这种情况下，你应当在当前的tf-&gt;tf_esp中而非UXSTACKTOP中重新启动栈帧。你应当首先压入一个4字节的字，然后一个struct UTrapFrame。\n检查tf-&gt;tf_esp是否在UXSTACKTOP - PGSIZE到UXSTACKTOP - 1的闭区间内来判断其是否已经在用户异常栈上。\n练习9中遇到的问题：\n\ncurenv已经被重新定义为thiscpu-&gt;cpu_env，因此可以使用\n判断tf-&gt;tf_esp的if语句中，将与写成了或\n\n练习9的代码如下，仅供参考：12345678910111213141516171819202122232425262728293031323334353637383940414243// In trap.c, page_fault_handler():// LAB 4: Your code here.struct UTrapframe *utf;uintptr_t          utf_addr;// check tf-&gt;tf_esp's location to calculate utf's addressif ((tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE) &amp;&amp; (tf-&gt;tf_esp &lt; UXSTACKTOP)) &#123;    // recursive case    // reason why here needs to substract a 4-byte word    // is to reserve space for reset eip/esp    utf_addr = tf-&gt;tf_esp - sizeof(struct UTrapframe) - 4;&#125; else &#123;    // non-recursive case, set utf_addr to the top of    // user exception stack    utf_addr = UXSTACKTOP - sizeof(struct UTrapframe);&#125;if (curenv-&gt;env_pgfault_upcall) &#123;    // page fault upcall exist    // use mem assert to check environment allocates the exception    // stack and has write permission to it, and stack ISN'T overflow    // combine three case with only one user_mem_assert to check utf_addr    // NB: curenv HAS been redefined as thiscpu-&gt;cpu_env    user_mem_assert(curenv, (void *)utf_addr, sizeof(struct UTrapframe),                    PTE_U | PTE_W | PTE_P);    // set user stack frame    utf               = (struct UTrapframe *)utf_addr;    utf-&gt;utf_fault_va = fault_va;    utf-&gt;utf_err      = tf-&gt;tf_err;    utf-&gt;utf_regs     = tf-&gt;tf_regs;    utf-&gt;utf_eip      = tf-&gt;tf_eip;    utf-&gt;utf_eflags   = tf-&gt;tf_eflags;    utf-&gt;utf_esp      = tf-&gt;tf_esp;    // modify stack frame to set entry for env_pgfault_upcall    // and set address for user exception stack    tf-&gt;tf_eip = (uintptr_t)curenv-&gt;env_pgfault_upcall;    tf-&gt;tf_esp = utf_addr;    env_run(curenv);&#125;\n用户模式页错误入口然后需要实现汇编例程，该例程调用C页错误处理程序，然后在恢复在原始的错误指令处的执行。该例程就是被sys_env_set_pgfault_upcall()注册的例程。\n最后需要在C用户库实现用户模式的页错误处理机制。\n练习10中遇到的问题：\n\n需要想清楚思路，即先将eip“压入”陷阱时栈中，使用一个sub后接一个mov指令来模拟该压栈过程，若为递归过程，则会将eip填入之前留下的空白。然后依次恢复寄存器以及eflags。最后pop %esp以切换栈并调用ret返回\n\n练习10的代码如下，仅供参考：1234567891011121314151617181920212223242526272829303132// In pfentry.S:// LAB 4: Your code here.// push trap-time %eip to trap-time stack// mov utf_eip to %eaxmovl 0x28(%esp), %eax// use sub and mov to *simulate* pushsubl $0x4, 0x30(%esp)movl 0x30(%esp), %ebpmovl %eax, (%ebp)// pop the unused fault_va and errpopl %eaxpopl %eax// Restore the trap-time registers.  After you do this, you// can no longer modify any general-purpose registers.// LAB 4: Your code here.popal// Restore eflags from the stack.  After you do this, you can// no longer use arithmetic operations or anything else that// modifies eflags.// LAB 4: Your code here.addl $0x4, %esppopfl// Switch back to the adjusted trap-time stack.// LAB 4: Your code here.popl %esp// Return to re-execute the instruction that faulted.// LAB 4: Your code here.ret\n练习11中遇到的问题：\n\n注意描述，要使用_pgfault_upcall()（汇编例程包装）来注册用户页处理函数而非传入的那个函数\n\n练习11的代码如下，仅供参考：12345678910111213141516// In set_pgfault_handler():if (_pgfault_handler == 0) &#123;    // First time through!    // LAB 4: Your code here.    // alloc one page for user exception stack    // and register user-level page fault upcall    if (sys_page_alloc(thisenv-&gt;env_id, (void *)(UXSTACKTOP - PGSIZE),                       PTE_U | PTE_W | PTE_P) &lt; 0) &#123;        panic(\"failed to alloc page for user exception stack!\");    &#125;    if (sys_env_set_pgfault_upcall(thisenv-&gt;env_id, _pgfault_upcall) &lt; 0) &#123;        panic(\"failed to register page fault upcall!\");    &#125;    // panic(\"set_pgfault_handler not implemented\");&#125;\nfaultalloc能成功而faultallocbad失败的原因在于faultallocbad直接使用系统调用输出，该输出会使用先使用内存检查而失败；而faultalloc使用了用户库中的cprintf，该函数在使用系统调用输出之前已经尝试对错误地址进行了解引用，触发了用户级别的缺页错误，在实际执行系统调用时，错误的地址已经被分配了页面，因此能通过内存检查。\n实现写时复制已经拥有了在用户空间中完整实现写时复制fork()的内核设施基础。\n现在已经在lib/fork.c中给出了fork()的框架。同dumbfork()相似，fork()首先创建了一个新环境，然后扫描父进程的地址空间并在子进程中建立相同的页映射。核心区别在于dumbfork()复制页，而fork()只实现页映射的复制。fork()直到某环境尝试写时在复制对应的页。\nfork()的基本控制流为：\n\n父进程设置pgfault()作为C级别的页错误处理程序，使用实现了的set_pgfault_handler()函数\n父进程调用sys_exofork()去创建子环境\n对于地址空间中每一个在UTOP下的可写的或是写时复制的页面，父进程调用duppage()，该函数将该页面以写时复制映射进子进程然后在父进程的地址空间中重新映射该页面为写时复制（顺序很重要）。duppage()同时设置PTE，所以页面将不可写。通过avail域的PTE_COW区分写时复制页面和真正的只读页面。然而，异常栈却不按该方式重映射。需要为子进程分配一个新页面作为异常栈。由于页处理程序实际执行了页复制并且页处理程序运行于异常栈上，异常栈不能写时复制。fork()也需要处理存在但既不是写时复制也不是可写的页面。\n父进程为子进程设置用户页错误入口。\n子进程已经准备好运行了，有父进程将其标记为可运行。\n\n每一次环境尝试向一个还不可写的写时复制的页面写入时，将出现页错误，用户页错误处理程序的控制流为：\n\n内核将页错误传递给页错误上行调用，即调用了fork()的页错误处理程序。\npgfault()检查错误为写入导致并且相应页面的PTE被标记为写时复制，否则使内核恐慌。\npgfault()分配一个新的页面，映射至一个临时位置，然后复制错误页面的内容到新分配的页面，最后将新页面以读写权限映射到合适的地址，替代旧的只读页。\n\n用户级别的lib/fork.c代码必须查询环境的页表（如查询某页面的PTE被标记为写时复制）。内核将环境的页表映射在UVPT正是为了这个目的。内核通过将页目录的指针指向自己的映射技巧使得可以为用户代码快速查找PTEs，lib/entry.S已经设置了uvpd和uvpd，你可以快速在lib/fork.c中查找页表信息。\n练习12中遇到的问题：\n\n注意在pgfault()和duppage()中，必须使用0而不是thisenv-&gt;env_id，原因已经在代码注释中标出\n在fork()中需要显式地判断用户异常页并跳过duppage()\n阅读给出的uvpt技巧，需要在代码中使用\n为了简化错误处理，避免重复代码，使用了goto\n假定先将父进程的用户栈标记为COW，然后再尝试将子进程的用户栈标记为COW之前，可能会出现父进程的用户栈已经被写入的情况而触发缺页错误，因此fork()会立刻分配新页，拷贝内容并重新映射。子进程被标记COW时复制的页映射已经不是原来的页映射了，因此，后来对父进程做的改动会反映在子进程上，这显然是错误的\nfork后必须修改thisenv的值以保证用户程序行为正确\n\n练习12的代码如下，仅供参考：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211// In lib/fork.c, fork()://// User-level fork with copy-on-write.// Set up our page fault handler appropriately.// Create a child.// Copy our address space and page fault handler setup to the child.// Then mark the child as runnable and return.//// Returns: child's envid to the parent, 0 to the child, &lt; 0 on error.// It is also OK to panic on error.//// Hint://   Use uvpd, uvpt, and duppage.//   Remember to fix \"thisenv\" in the child process.//   Neither user exception stack should ever be marked copy-on-write,//   so you must allocate a new page for the child's user exception stack.//envid_t fork(void) &#123;    // LAB 4: Your code here.    int r;    // use set_pgfault_handler to install pgfault() as page fault handler    set_pgfault_handler(pgfault);    // use system call to create new blank child environment    envid_t child_env_id = sys_exofork();    if (child_env_id == 0) &#123;        // must update thisenv to make sure user program behave        // normally        thisenv = envs + ENVX(sys_getenvid());    &#125;    if (child_env_id &lt; 0) &#123;        // error when create new environment, simply return        return child_env_id;    &#125;    // traverse through parent's address space and use duppage    // to copy address mappings    uintptr_t addr;    for (addr = 0; addr &lt; UTOP; addr += PGSIZE) &#123;        if ((((pde_t *)uvpd)[PDX(addr)] &amp; PTE_P) &amp;&amp;            (((pte_t *)uvpt)[PGNUM(addr)] &amp; PTE_P)) &#123;            // if both page directory entry and page table entry            // exist for one address(page-aligned), then call duppage            if (addr == (UXSTACKTOP - PGSIZE)) &#123;                // ignore user exception stack                // for we will map a page for user exception later                continue;            &#125;            if ((r = duppage(child_env_id, PGNUM(addr))) &lt; 0) &#123;                // duppage failed                // destroy child environment and return                goto error_handle;            &#125;        &#125;    &#125;    // child must have its own exception stack    // so alloc page and map it for child here    if ((r = sys_page_alloc(child_env_id, (void *)(UXSTACKTOP - PGSIZE),                            PTE_P | PTE_U | PTE_W)) &lt; 0) &#123;        // failed to set child environment's exception stack        // destroy child environment and return        goto error_handle;    &#125;    // set child's page fault handler so that parent    // and child looks the same    // use sys_env_set_pgfault_upcall system call    extern void _pgfault_upcall(void);    if ((r = sys_env_set_pgfault_upcall(child_env_id, _pgfault_upcall)) &lt; 0) &#123;        // failed to set child's page fault upcall        // destroy child environment and return        goto error_handle;    &#125;    // now child is ready to run, set child to ENV_RUNNABLE    // use sys_env_set_status system call    if ((r = sys_env_set_status(child_env_id, ENV_RUNNABLE)) &lt; 0) &#123;        // failed to change child environment's running status        // destroy child environment and return        goto error_handle;    &#125;    // panic(\"fork not implemented\");    return child_env_id;// use goto to avoid meaningless error_handle code// copy and paste everywhereerror_handle:    if (sys_env_destroy(child_env_id) &lt; 0) &#123;        // failed either, panic then        panic(\"failed to destroy child environment!\");    &#125;    return r;&#125;// In lib/fork.c, duppage()://// Map our virtual page pn (address pn*PGSIZE) into the target envid// at the same virtual address.  If the page is writable or copy-on-write,// the new mapping must be created copy-on-write, and then our mapping must be// marked copy-on-write as well.  (Exercise: Why do we need to mark ours// copy-on-write again if it was already copy-on-write at the beginning of// this function?)//// Returns: 0 on success, &lt; 0 on error.// It is also OK to panic on error.//static int duppage(envid_t envid, unsigned pn) &#123;    int r;    // LAB 4: Your code here.    int perm = PTE_P | PTE_U;    if ((((pte_t *)uvpt)[pn] &amp; (PTE_W | PTE_COW))) &#123;        // check for writable or copy-on-write page        // and add perm with PTE_COW        perm |= PTE_COW;        // NB: we also use 0 to replace thisenv-&gt;env_id        // for in unix-like fork() implementation, we will copy        // address space from parent process to child process        // at current time, thisenv-&gt;env_id IS ABSOLUTELY WRONG        // map from parent environment to child environment        if (sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE),                         perm) &lt; 0) &#123;            panic(\"failed to map page from parent to child!\");        &#125;        // remap parent's environment        if (sys_page_map(0, (void *)(pn * PGSIZE), 0, (void *)(pn * PGSIZE),                         perm) &lt; 0) &#123;            panic(\"failed to remap page in parent!\");        &#125;    &#125; else &#123;        // for other pages, simply map from        // parent environment to child environment        if (sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE),                         perm) &lt; 0) &#123;            panic(\"failed to map page from parent to child!\");        &#125;    &#125;    // panic(\"duppage not implemented\");    return 0;&#125;// In lib/fork.c, pgfault()://// Custom page fault handler - if faulting page is copy-on-write,// map in our own private writable copy.//static void pgfault(struct UTrapframe *utf) &#123;    void *   addr = (void *)utf-&gt;utf_fault_va;    uint32_t err  = utf-&gt;utf_err;    int      r;    // Check that the faulting access was (1) a write, and (2) to a    // copy-on-write page.  If not, panic.    // Hint:    //   Use the read-only page table mappings at uvpt    //   (see &lt;inc/memlayout.h&gt;).    // LAB 4: Your code here.    // use uvpt to get PTE and check premissions    if (!(err &amp; FEC_WR) || !(((pte_t *)uvpt)[PGNUM(addr)] &amp; PTE_COW)) &#123;        panic(\"fault isn't write or PTE is not marked as PTE_COW or both!\");    &#125;    // Allocate a new page, map it at a temporary location (PFTEMP),    // copy the data from the old page to the new page, then move the new    // page to the old page's address.    // Hint:    //   You should make three system calls.    // LAB 4: Your code here.    // allocate a page and map it at PFTEMP    // use sys_page_alloc system call    // NB: use 0 instead of thisenv-&gt;env_id    // for normally when child environment scheduled by JOS    // first it tries to store 0(return value of fork()) to    // local variable child_env_id on the stack    // which will take a page fault and kernel will trasfer control    // to pgfault here    // thisenv-&gt;env_id IS ABSOLUTELY WRONG here, so use 0    // and let kernel convert from 0 to correct env_id    if ((r = sys_page_alloc(0, (void *)PFTEMP, PTE_P | PTE_U | PTE_W)) &lt; 0) &#123;        panic(\"failed to allocate page at temp location - %e, %x!\", r,              thisenv-&gt;env_id);    &#125;    addr = ROUNDDOWN(addr, PGSIZE);    // use memcpy to copy from fault address's page to PFTEMP's newly    // allocated page    memcpy((void *)PFTEMP, addr, PGSIZE);    // use sys_page_map system call to map newly allocated    // page at PFTEMP at addr with read/write permissions    if ((r = sys_page_map(0, (void *)PFTEMP, 0, addr, PTE_P | PTE_U | PTE_W)) &lt;        0) &#123;        panic(\"failed to map new page - %e!\", r);    &#125;    // use sys_page_unmap system call to unmap page at    // temp location PFTEMP    if ((r = sys_page_unmap(0, (void *)PFTEMP)) &lt; 0) &#123;        panic(\"failed to unmap page at PFTEMP - %e!\", r);    &#125;    // panic(\"pgfault not implemented\");&#125;\n第三部分 - Preemptive Multitasking and Inter-Process communication (IPC) 抢占式多任务和进程间通信最后一部分要求你修改内核，实现抢占式非协作环境以及允许环境显式传递信息。\n时钟中断和抢占运行user/spin测试程序，该测试程序fork一个用户环境，生成的子环境一旦获得了CPU，就会执行一个无限循环，无论是父环境还是内核都无法重新获得CPU。对于从错误和恶意代码中保护系统而言，这不是一个理想的情况，因为任何用户环境都可以通过一个无限循环以及永不放弃使得整个系统停机。为了允许内核抢占一个用户环境并强制从该环境处获取CPU的控制，需要扩展JOS内核以支持时钟硬件的外部硬件中断。\n中断规则外部中断（如设备中断）被称为IRQs（Interrupt request）。总共有16种可能的IRQs，分别从0编号到15。从IRQ号到IDT入口的映射并不固定。picirq.c中的pic_init()将IRQs从0到15映射到了IRQ_OFFSET到IRQ_OFFSET + 15。\n在inc/trap.h中，IRQ_OFFSET被定义为32，因此IDT入口32-47对应于IRQ的0-15。例如，始终中断是IRQ 0。因此，IDT[IRQ_OFFSET + 0]包含了内核中时钟中断处理程序的地址。IRQ_OFFSET设置为32后，设备中断将不会和处理器异常号重叠。\n同xv6 Unix相比，JOS内核提供了一个关键性简化。在内核中时，外部设备中断永远是被禁止的（但是在用户环境中是被允许的）。外部中断被%eflags寄存器的FL_IF标记控制。当该bit被设置时，外部中断被允许。尽管有若干种方式可以修改该bit位，将在进入和退出用户模式时通过保存和恢复%eflags寄存器的过程来处理它。\n必须确保在用户环境中FL_IF标记被设置，这样当中断到达后，并且将中断传递给处理器，并由内核中的中断处理程序处理。否则中断会被屏蔽和忽略之道中断重新被允许。在引导程序的第一条指定就屏蔽了外部设备中断，并且直到目前为止，还没有重新启用。\n练习13中遇到的问题：\n\n注意到简化规则要求中说明必须在陷入内核时将IF置0，所以必须修改之前的代码，将所有门都改为中断门\n\n练习13的代码如下，仅供参考：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// In kern/trapentry.S:// externel interruptsTRAPHANDLER_NOEC(irq_0_handler,  IRQ_OFFSET + 0);TRAPHANDLER_NOEC(irq_1_handler,  IRQ_OFFSET + 1);TRAPHANDLER_NOEC(irq_2_handler,  IRQ_OFFSET + 2);TRAPHANDLER_NOEC(irq_3_handler,  IRQ_OFFSET + 3);TRAPHANDLER_NOEC(irq_4_handler,  IRQ_OFFSET + 4);TRAPHANDLER_NOEC(irq_5_handler,  IRQ_OFFSET + 5);TRAPHANDLER_NOEC(irq_6_handler,  IRQ_OFFSET + 6);TRAPHANDLER_NOEC(irq_7_handler,  IRQ_OFFSET + 7);TRAPHANDLER_NOEC(irq_8_handler,  IRQ_OFFSET + 8);TRAPHANDLER_NOEC(irq_9_handler,  IRQ_OFFSET + 9);TRAPHANDLER_NOEC(irq_10_handler, IRQ_OFFSET + 10);TRAPHANDLER_NOEC(irq_11_handler, IRQ_OFFSET + 11);TRAPHANDLER_NOEC(irq_12_handler, IRQ_OFFSET + 12);TRAPHANDLER_NOEC(irq_13_handler, IRQ_OFFSET + 13);TRAPHANDLER_NOEC(irq_14_handler, IRQ_OFFSET + 14);TRAPHANDLER_NOEC(irq_15_handler, IRQ_OFFSET + 15);// In kern/trap.c, trap_init():// set up interupt gate descriptorSETGATE(idt[IRQ_OFFSET + 0],  0, GD_KT, irq_0_handler,  0);SETGATE(idt[IRQ_OFFSET + 1],  0, GD_KT, irq_1_handler,  0);SETGATE(idt[IRQ_OFFSET + 2],  0, GD_KT, irq_2_handler,  0);SETGATE(idt[IRQ_OFFSET + 3],  0, GD_KT, irq_3_handler,  0);SETGATE(idt[IRQ_OFFSET + 4],  0, GD_KT, irq_4_handler,  0);SETGATE(idt[IRQ_OFFSET + 5],  0, GD_KT, irq_5_handler,  0);SETGATE(idt[IRQ_OFFSET + 6],  0, GD_KT, irq_6_handler,  0);SETGATE(idt[IRQ_OFFSET + 7],  0, GD_KT, irq_7_handler,  0);SETGATE(idt[IRQ_OFFSET + 8],  0, GD_KT, irq_8_handler,  0);SETGATE(idt[IRQ_OFFSET + 9],  0, GD_KT, irq_9_handler,  0);SETGATE(idt[IRQ_OFFSET + 10], 0, GD_KT, irq_10_handler, 0);SETGATE(idt[IRQ_OFFSET + 11], 0, GD_KT, irq_11_handler, 0);SETGATE(idt[IRQ_OFFSET + 12], 0, GD_KT, irq_12_handler, 0);SETGATE(idt[IRQ_OFFSET + 13], 0, GD_KT, irq_13_handler, 0);SETGATE(idt[IRQ_OFFSET + 14], 0, GD_KT, irq_14_handler, 0);SETGATE(idt[IRQ_OFFSET + 15], 0, GD_KT, irq_15_handler, 0);// In kern/env.c, env_alloc():// Enable interrupts while in user mode.// LAB 4: Your code here.// simply use bit or to set FL_IFe-&gt;env_tf.tf_eflags |= FL_IF;// In kern/sched.c, sched_halt():// Reset stack pointer, enable interrupts and then halt.asm volatile (    \"movl $0, %%ebp\\n\"    \"movl %0, %%esp\\n\"    \"pushl $0\\n\"    \"pushl $0\\n\"    // Uncomment the following line after completing exercise 13    \"sti\\n\"    \"1:\\n\"    \"hlt\\n\"    \"jmp 1b\\n\": : \"a\" (thiscpu-&gt;cpu_ts.ts_esp0));\n处理时钟中断在user/spin程序中，在子环境第一次运行后，会陷入无限循环，而内核将无法得到控制权，需要对硬件编程以定时产生时钟中断，该终端会将控制权强行切回CPU，然后可以将控制权交给另一个用户环境。\n对于lapic_init()和pic_init()的调用已经写好，它们会设置时钟并且终端控制器会定时生成中断。需要完成代码处理这些中断。\n练习14中遇到的问题：\n\n首先需要调用lapic_eoi()以确认接收到了中断，否则会一直卡住\n\n练习14的代码如下，仅供参考：12345678910// in kern/trap.c, trap_dispatch():// new code addedif (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;    // dispatch clock interupts    // call sched_yield() to find and run a different environment    // NB: should first call lapic_eoi() to ACKNOWLEDGE interupt    lapic_eoi();    sched_yield();    // sched_yield() might not return&#125;\n进程间通讯到目前位置实验一直关注于操作系统的独立部分，操作系统通过虚拟化提供了一种每个环境都独占整个机器的“错觉”。然而操作系统的另一项服务是允许程序在必要的时候通讯，该功能非常强大，Unix管道就是一个典型的例子。\n有许多进程间通讯的模型，即使是现在也有许多关于哪一种模型是最好的争论。我们不参与争论。相反，我们将实现一个简单的IPC模型。\nJOS中的IPC你将实现一些额外的JOS内核系统调用，这些调用共同提供一个简单的进程间通讯机制。具体的系统调用为sys_ipc_recv()和sys_ipc_try_send()，然后你将实现两个库包装ipc_recv()和ipc_send()。\n用户环境通过JOS的IPC机制向其他环境互相发送的信息包括两部分，一个32-bit的值和一个可选的单页映射。允许环境传递页映射提供了一个比传递一个32-bit的整数更有效的数据交换方式，这也可以较为方便的设置共享内存。\n发送和接收消息环境调用sys_ipc_recv()去接受消息。该系统调用取消调度当前环境并且直到一条消息被收到后才会被继续运行。当一个环境等待接收消息时，任何其他的环境可以向其发送一条消息 - 并不限于特定的环境，也不限于父子进程间传递消息，换言之，你在第一部分中实现的权限检查将不适用于IPC，因为IPC系统调用经过精心设计以保证安全，环境不会通过简单地发送消息而导致其他环境出现错误（除非目标环境也有错误）。\n环境调用sys_ipc_try_send()去尝试发送一个值（并附带上接受者的环境ID），如果指定的环境实际上正在接受该值（已调用sys_ipc_recv()并且尚未获得值），则值成功发送并返回0。否则，返回-E_IPC_NOT_RECV表示目标环境当前不期望接收值。\n用户空间的库函数ipc_recv()将负责调用sys_ipc_recv()并在当前环境的struct Env中查找接收值的信息。\n用户空间的库函数ipc_send()将负责反复调用sys_ipc_try_send()直到发送成功。\n传输页当一个环境以一个有效的dstva参数（小于UTOP）调用sys_ipc_recv()时，环境改变状态以表明想要接受一个页映射。如果发送者发送了一个页，那么该页将会被映射到接收者地址空间的dstva处。如果接收者已经在dstva映射了一页，那么之前的页会被解映射。\n当一个环境以一个有效的srcva参数（小于UTOP）调用sys_ipc_try_send()时，表明发送者想要将当前映射在srcva的页发送给接收者，并且带有权限perm。在一次成功的IPC之后，发送者在其地址空间保留在srcva处原有的页映射，但是接收者也持有最开始由发送者指定的相同的物理页面在dstva的映射。最终，该页面在发送者和接收者之间共享。\n如果发送者和接收者两者之一没有表明要传输页面，那么将不会有页面被传输。在任意一次IPC之后将接收者的struct Env中新的域env_ipc_perm设置为接受页面的权限，如果没有收到页面，则为0。\n实现IPC练习15中遇到的问题：\n\n在sys_ipc_try_send()和sys_ipc_recv()中，均不将超过UTOP的地址标记为错误，超过UTOP的地址是无效的，但并不会导致系统调用失败\n在sys_ipc_recv()中在接收到消息前将环境状态置为不可运行，那么在收到消息后，应当恢复到可运行的状态\n在sys_ipc_try_send()中调用page_lookup()时，要记住检查的是源地址的映射，因此应当使用当前环境的页表而非接收者环境的页表\n\n练习15的代码如下，仅供参考：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248// In kern/syscall.c, sys_ipc_recv():// Block until a value is ready.  Record that you want to receive// using the env_ipc_recving and env_ipc_dstva fields of struct Env,// mark yourself not runnable, and then give up the CPU.//// If 'dstva' is &lt; UTOP, then you are willing to receive a page of data.// 'dstva' is the virtual address at which the sent page should be mapped.//// This function only returns on error, but the system call will eventually// return 0 on success.// Return &lt; 0 on error.  Errors are://  -E_INVAL if dstva &lt; UTOP but dstva is not page-aligned.static int sys_ipc_recv(void *dstva) &#123;    // LAB 4: Your code here.    // similar to sys_ipc_try_send, will not mark an error    // if dstva &gt;= UTOP    if ((uintptr_t)dstva &lt; UTOP &amp;&amp; PGOFF(dstva) != 0) &#123;        // if dstva &lt; UTOP but dstva is not page-aligned        // NB: &amp;&amp; rather than ||, we won't report error        // when dstva &gt;= UTOP        return -E_INVAL;    &#125;    // mark calling environment as not runnable    curenv-&gt;env_status = ENV_NOT_RUNNABLE;    // update status to mark receiver is willing to receive message    curenv-&gt;env_ipc_recving = true;    curenv-&gt;env_ipc_dstva   = dstva;    // give up cpu    sys_yield();    // panic(\"sys_ipc_recv not implemented\");    // ipc succeeds    return 0;&#125;// In kern/syscall.c, sys_ipc_try_send():// Try to send 'value' to the target env 'envid'.// If srcva &lt; UTOP, then also send page currently mapped at 'srcva',// so that receiver gets a duplicate mapping of the same page.//// The send fails with a return value of -E_IPC_NOT_RECV if the// target is not blocked, waiting for an IPC.//// The send also can fail for the other reasons listed below.//// Otherwise, the send succeeds, and the target's ipc fields are// updated as follows://    env_ipc_recving is set to 0 to block future sends;//    env_ipc_from is set to the sending envid;//    env_ipc_value is set to the 'value' parameter;//    env_ipc_perm is set to 'perm' if a page was transferred, 0 otherwise.// The target environment is marked runnable again, returning 0// from the paused sys_ipc_recv system call.  (Hint: does the// sys_ipc_recv function ever actually return?)//// If the sender wants to send a page but the receiver isn't asking for one,// then no page mapping is transferred, but no error occurs.// The ipc only happens when no errors occur.//// Returns 0 on success, &lt; 0 on error.// Errors are://  -E_BAD_ENV if environment envid doesn't currently exist.//      (No need to check permissions.)//  -E_IPC_NOT_RECV if envid is not currently blocked in sys_ipc_recv,//      or another environment managed to send first.//  -E_INVAL if srcva &lt; UTOP but srcva is not page-aligned.//  -E_INVAL if srcva &lt; UTOP and perm is inappropriate//      (see sys_page_alloc).//  -E_INVAL if srcva &lt; UTOP but srcva is not mapped in the caller's//      address space.//  -E_INVAL if (perm &amp; PTE_W), but srcva is read-only in the//      current environment's address space.//  -E_NO_MEM if there's not enough memory to map srcva in envid's//      address space.static int sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva,                            unsigned perm) &#123;    // LAB 4: Your code here.    // check for existence of env with envid    struct Env *env;    if (envid2env(envid, &amp;env, false) &lt; 0) &#123;        // environment envid doesn't currently exist        return -E_BAD_ENV;    &#125;    // check receiver's status    if (!env-&gt;env_ipc_recving) &#123;        // envid is not currently blocked in sys_ipc_recv        // or another environment managed to send first        return -E_IPC_NOT_RECV;    &#125;    if ((uintptr_t)srcva &lt; UTOP) &#123;        // srcva is valid        // check srcva is page-aligned        if (PGOFF(srcva) != 0) &#123;            // srcva is not page-aligned            return -E_INVAL;        &#125;        // check perm passed in        if ((perm &amp; (~PTE_SYSCALL)) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P)) &#123;            // invalid perm            return -E_INVAL;        &#125;        // check srcva actually be mapped        pte_t *          pgtable_entry;        struct PageInfo *page;        if ((page = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;pgtable_entry)) ==            NULL) &#123;            // NB: check for SRCVA here, so use curenv-&gt;env_pgdir            // srcva is not mapped at caller's address space            return -E_INVAL;        &#125;        // check PTE_W between sender and receiver        if ((perm &amp; PTE_W) &amp;&amp; (!((*pgtable_entry) &amp; PTE_W))) &#123;            // if perm has PTE_W while srcva is read-only in            // current environment's address space            return -E_INVAL;        &#125;        if ((uintptr_t)(env-&gt;env_ipc_dstva) &lt; UTOP) &#123;            // receiver also expects page to be transferred            // call page_insert to actually transer the page            if (page_insert(env-&gt;env_pgdir, page, env-&gt;env_ipc_dstva, perm) &lt;                0) &#123;                // out of memory when try to insert page                return -E_NO_MEM;            &#125;            // page successfully transferred            env-&gt;env_ipc_perm = perm;        &#125;    &#125; else &#123;        // srcva &gt;= UTOP        // invalid srcva, but we won't return error here        // ipc_send will panic if we do so    &#125;    // update receiver's information    env-&gt;env_ipc_recving = false;    env-&gt;env_ipc_from    = curenv-&gt;env_id;    env-&gt;env_ipc_value   = value;    // mark receiver to be runnable to match what we do in sys_ipc_recv    env-&gt;env_status = ENV_RUNNABLE;    // modify trapframe's eax register to `update' return value    env-&gt;env_tf.tf_regs.reg_eax = 0;    // panic(\"sys_ipc_try_send not implemented\");    // ipc succeeds    return 0;&#125;// In lib/ipc.c, ipc_recv():// Receive a value via IPC and return it.// If 'pg' is nonnull, then any page sent by the sender will be mapped at//\tthat address.// If 'from_env_store' is nonnull, then store the IPC sender's envid in//\t*from_env_store.// If 'perm_store' is nonnull, then store the IPC sender's page permission//\tin *perm_store (this is nonzero if a page was successfully//\ttransferred to 'pg').// If the system call fails, then store 0 in *fromenv and *perm (if//\tthey're nonnull) and return the error.// Otherwise, return the value sent by the sender//// Hint://   Use 'thisenv' to discover the value and who sent it.//   If 'pg' is null, pass sys_ipc_recv a value that it will understand//   as meaning \"no page\".  (Zero is not the right value, since that's//   a perfectly valid place to map a page.)int32_t ipc_recv(envid_t *from_env_store, void *pg, int *perm_store) &#123;    // LAB 4: Your code here.    // check pg, if pg is null, then should set it to UTOP,    // for only if dstva is below UTOP, sender knows that    // receiver wants a page to be transferred    if (!pg) &#123; pg = (void *)UTOP; &#125;    int r;    if ((r = sys_ipc_recv(pg)) &lt; 0) &#123;        // system call fails        // store from env and perm if corresponding pointer is not null        if (from_env_store) &#123; *from_env_store = 0; &#125;        if (perm_store) &#123; *perm_store = 0; &#125;        // return the error        return r;    &#125;    // system call succeeds    // extract information from thisenv's IPC fields    if (from_env_store) &#123;        // store IPC sender's envid into *from_env_store        *from_env_store = thisenv-&gt;env_ipc_from;    &#125;    if (perm_store) &#123;        // store IPC sender's page permission        *perm_store = thisenv-&gt;env_ipc_perm;    &#125;    // panic(\"ipc_recv not implemented\");    // return the value send by the sender    return thisenv-&gt;env_ipc_value;&#125;// In kern/syscall.c, syscall():// new code addedcase SYS_ipc_recv:    // call sys_ipc_recv    return sys_ipc_recv((void *)a1);    break;case SYS_ipc_try_send:    // call sys_ipc_try_send    return sys_ipc_try_send((envid_t)a1, (uint32_t)a2, (void *)a3,                            (unsigned)a4);// In lib/ipc.c, ipc_send():// Send 'val' (and 'pg' with 'perm', if 'pg' is nonnull) to 'toenv'.// This function keeps trying until it succeeds.// It should panic() on any error other than -E_IPC_NOT_RECV.//// Hint://   Use sys_yield() to be CPU-friendly.//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand//   as meaning \"no page\".  (Zero is not the right value.)void ipc_send(envid_t to_env, uint32_t val, void *pg, int perm) &#123;    // LAB 4: Your code here.    // check pg, if pg is null, then should set it to UTOP(invalid value    // but won't result in panic)    if (!pg) &#123; pg = (void *)UTOP; &#125;    int r;    while (true) &#123;        // keeps trying until succeeds or panic        r = sys_ipc_try_send(to_env, val, pg, perm);        if (r == 0) &#123;            // message successfully sent, return            return;        &#125;        if (r != -E_IPC_NOT_RECV) &#123;            // error when sending, should panic            panic(\"failed to send messages - %e!\", r);        &#125;        // use sys_yield to avoid waste on CPU        sys_yield();    &#125;    // panic(\"ipc_send not implemented\");&#125;\n实验小结最终执行make grade，评分脚本的输出如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152dumbfork:$ make run-dumbfork-nox-gdb QEMUEXTRA+=-snapshotOK (1.6s)Part A score: 5/5faultread:$ make run-faultread-nox-gdb QEMUEXTRA+=-snapshotOK (1.0s)faultwrite:$ make run-faultwrite-nox-gdb QEMUEXTRA+=-snapshotOK (1.0s)faultdie:$ make run-faultdie-nox-gdb QEMUEXTRA+=-snapshotOK (1.0s)faultregs:$ make run-faultregs-nox-gdb QEMUEXTRA+=-snapshotOK (1.1s)faultalloc:$ make run-faultalloc-nox-gdb QEMUEXTRA+=-snapshotOK (4.6s)faultallocbad:$ make run-faultallocbad-nox-gdb QEMUEXTRA+=-snapshotOK (1.3s)faultnostack:$ make run-faultnostack-nox-gdb QEMUEXTRA+=-snapshotOK (1.8s)faultbadhandler:$ make run-faultbadhandler-nox-gdb QEMUEXTRA+=-snapshotOK (1.2s)faultevilhandler:$ make run-faultevilhandler-nox-gdb QEMUEXTRA+=-snapshotOK (1.0s)forktree:$ make run-forktree-nox-gdb QEMUEXTRA+=-snapshotOK (1.4s)Part B score: 50/50spin:$ make run-spin-nox-gdb QEMUEXTRA+=-snapshotOK (0.7s)stresssched:$ make run-stresssched-nox-gdb CPUS=4 QEMUEXTRA+=-snapshotOK (3.0s)sendpage:$ make run-sendpage-nox-gdb CPUS=2 QEMUEXTRA+=-snapshotOK (1.7s)pingpong:$ make run-pingpong-nox-gdb CPUS=4 QEMUEXTRA+=-snapshotOK (2.1s)primes:$ make run-primes-nox-gdb CPUS=4 QEMUEXTRA+=-snapshotOK (4.5s)Part C score: 25/25Score: 80/80至此，实验四结束。\n第四个实验是第一到第四个实验中难度最大、代码量最多的一个实验，在前三个实验中任何的代码错误（尽管可能在当时的实验评分中没有反映出来）都会导致实验四出现难以调试的错误。\n实验四中每个练习遇到的问题我都已经在报告中总结，此外，也在代码中以NB标明。其中大部分都是一些小错误，还有少部分是没有将问题考虑全面导致的。尽管如此，几乎每一个错误我都花费了至少几十分钟去调试。\n操作系统的调试不仅仅困难（Triple Fault会导致不打补丁的qemu重启），任何一个小错误都会导致系统崩溃。现代操作系统如Linux的鲁棒性可见一斑。\n本学期的事情比起上学期只增不减，加上课程设计只要求完成四个实验，实验四结束后，MIT-6.828系列就告一段落了。\n希望我的这四篇实验报告能对正在写实验的你产生些许的启发，也欢迎找我交流相关的问题。\n","dateCreated":"2018-02-26T16:52:56+08:00","dateModified":"2018-05-15T17:16:08+08:00","datePublished":"2018-02-26T16:52:56+08:00","description":"","headline":"MIT6.828操作系统工程Lab4-Preemptive Multitasking实验报告","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/"},"publisher":{"@type":"Organization","name":"码龙黑曜","sameAs":["https://github.com/BlackDragonF","https://t.me/Cosidian","http://steamcommunity.com/id/BlackDragonF/","mailto:obsidiandragon2016@gmail.com"],"image":"avatar.jpg","logo":{"@type":"ImageObject","url":"avatar.jpg"}},"url":"http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/","keywords":"操作系统, 实验, 多处理器, 抢占式调度, 进程间通信, 写时复制"}</script>
    <meta name="description" content="Lab4 - Preemptive Multitasking需要在多个同时激活的用户模式环境中实现抢占式多任务。实验分为三个部分。第一部分要求为JOS添加多处理器支持，并实现论询调度以及基本的环境管理系统调用；第二部分需要实现一个Unix-like的fork函数，使得用户环境可以创建一份自己的拷贝；第三部分需要实现进程间通讯功能，允许不同的用户环境显式地互相通信和同步。同时还需要实现对于硬件时钟">
<meta name="keywords" content="操作系统,实验,多处理器,抢占式调度,进程间通信,写时复制">
<meta property="og:type" content="blog">
<meta property="og:title" content="MIT6.828操作系统工程Lab4-Preemptive Multitasking实验报告">
<meta property="og:url" content="http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/index.html">
<meta property="og:site_name" content="码龙的窝">
<meta property="og:description" content="Lab4 - Preemptive Multitasking需要在多个同时激活的用户模式环境中实现抢占式多任务。实验分为三个部分。第一部分要求为JOS添加多处理器支持，并实现论询调度以及基本的环境管理系统调用；第二部分需要实现一个Unix-like的fork函数，使得用户环境可以创建一份自己的拷贝；第三部分需要实现进程间通讯功能，允许不同的用户环境显式地互相通信和同步。同时还需要实现对于硬件时钟">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2018-05-15T09:16:08.580Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT6.828操作系统工程Lab4-Preemptive Multitasking实验报告">
<meta name="twitter:description" content="Lab4 - Preemptive Multitasking需要在多个同时激活的用户模式环境中实现抢占式多任务。实验分为三个部分。第一部分要求为JOS添加多处理器支持，并实现论询调度以及基本的环境管理系统调用；第二部分需要实现一个Unix-like的fork函数，使得用户环境可以创建一份自己的拷贝；第三部分需要实现进程间通讯功能，允许不同的用户环境显式地互相通信和同步。同时还需要实现对于硬件时钟">
    
    
        
    
    
        <meta property="og:image" content="http://blog.codedragon.tech/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-j4w0tbtf1olriqsnfyv4egntpbdblucqpyraoqqnvawa2vd6l4m8ljtn2yes.min.css">
    <!--STYLES END-->
    
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-108458894-1', 'auto');
        ga('send', 'pageview');
    </script>


    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">码龙的窝</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">码龙黑曜</h4>
                
                    <h5 class="sidebar-profile-bio"><p>iOS开发者/计算机科学/兽人控</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="首页"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="分类"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="标签"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="归档"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/projects"
                            
                            title="项目"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-code" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">项目</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/about"
                            
                            title="关于"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/BlackDragonF" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://t.me/Cosidian" target="_blank" rel="noopener" title="Telegram">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-telegram" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Telegram</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://steamcommunity.com/id/BlackDragonF/" target="_blank" rel="noopener" title="Steam">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-steam" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Steam</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:obsidiandragon2016@gmail.com" target="_blank" rel="noopener" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/links"
                            
                            title="友情链接"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-link" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">友情链接</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/resources"
                            
                            title="学习资源"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-share-alt" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">学习资源</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            MIT6.828操作系统工程Lab4-Preemptive Multitasking实验报告
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-02-26T16:52:56+08:00">
	
		    2月 26, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/操作系统/">操作系统</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <blockquote>
<p>Lab4 - Preemptive Multitasking需要在多个同时激活的用户模式环境中实现抢占式多任务。<br>实验分为三个部分。第一部分要求为JOS添加多处理器支持，并实现论询调度以及基本的环境管理系统调用；第二部分需要实现一个Unix-like的fork函数，使得用户环境可以创建一份自己的拷贝；第三部分需要实现进程间通讯功能，允许不同的用户环境显式地互相通信和同步。同时还需要实现对于硬件时钟中断和抢占的支持。<br>2018年3月2日，完成了实验并写完了报告。</p>
</blockquote>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p> 根据官网，切换到分支lab4并合并分支lab3。在合并的过程中，发生了冲突。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user% git checkout -b lab3 origin/lab3</span><br><span class="line">user% git merge lab3</span><br></pre></td></tr></table></figure>
<p> 根据提示，是<code>conf/lab.mk</code>中发生了冲突。打开后可以发现是其中记录的时间和实验数发生了变化，直接采用分支lab4的版本即可，然后提交，分支合并完成。</p>
<p> 实验四包括如下的新文件：</p>
<ul>
<li>kern/cpu.h 内核私有的关于多处理器的支持</li>
<li>kern/mpconfig.c 读取多处理器配置的代码</li>
<li>kern/lapic.c 内核驱动每个处理的的APIC（高级可编程中断控制器）的代码</li>
<li>kern/mpentry.S 非引导CPU的汇编入口代码</li>
<li>kern/spinlock.h 内核私有的自旋锁定义，包括大内核锁</li>
<li>kern/spinlock.c 内核实现自旋锁的代码</li>
<li>kern/sched.c 需要实现的调度器的代码框架</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="第一部分-Multiprocessor-Support-and-Cooperative-Multitasking-多处理器支和写作式多任务"><a href="#第一部分-Multiprocessor-Support-and-Cooperative-Multitasking-多处理器支和写作式多任务" class="headerlink" title="第一部分 Multiprocessor Support and Cooperative Multitasking - 多处理器支和写作式多任务"></a>第一部分 Multiprocessor Support and Cooperative Multitasking - 多处理器支和写作式多任务</h3><p>在第一部分中，需要使JOS运行在一个多处理器系统上，并且实现新的JOS内核系统调用去允许用户级别的环境创建额外的新环境。还需要实现协同式的论询调度，允许内核当旧的用户环境自愿放弃CPU或退出时切换至一个新的用户环境。</p>
<h4 id="多处理器支持"><a href="#多处理器支持" class="headerlink" title="多处理器支持"></a>多处理器支持</h4><p>需要使JOS支持“对称多处理”（Symmetric Multiprocessing），在该模型下，所有的CPU都有着对系统资源（内存、IO总线等）的平等访问权。尽管在SMP下所有的CPU在功能上均等价，在启动时仍然分为两种类型——引导处理器（Bootstrap Processor或是BSP）负责初始化系统并且引导操作系统；应用处理器（Application Processors或是APs）仅在系统启动运行后被BSP激活。BSP处理器由硬件和BIOS决定。在此刻，所有已有的代码已经运行在了BSP上。</p>
<p>在SMP中，每一个CPU都有一个相伴的本地APIC（LAPIC）单元。LAPIC单元负责在整个系统中传递中断。LAPIC为相连的CPU提供了一个唯一标识。在本实验中，将利用LAPIC的一下功能（在<code>kern/lapic.c</code>中）：</p>
<ul>
<li>读取LAPIC标识（APIC ID）以告知CPU代码运行在哪一个CPU上（参考<code>cpunum()</code>）</li>
<li>从BSP向APs发送STARTUP处理器间中断（Interprocessor interrupt或IPI）以唤醒其他CPU（参考<code>lapic_startup()</code>）</li>
<li>在第三部分中，通过编程LAPIC内置的计时器去引发时钟中断以实现抢占式多任务（参考<code>apic_init()</code></li>
</ul>
<p>处理器通过内存映射IO（Memory-mapped I/O 或是MMIO）访问LAPIC。在MMIO中，一部分物理内存被硬连接至某些IO设备的寄存器。所以相同的访问内存的<code>load/store</code>指令可以被用来访问设备寄存器。你可能已经见过了存在于物理地址<code>0xA0000</code>中IO洞（以此来写VGA显示缓存）。LAPIC存在于物理地址从<code>0xFE000000</code>（4064M）开始的洞中。该地址太高以至于无法在KERNBASE的直接映射访问。JOS的虚拟内存映射在<code>MMIOBASE</code>处留下了4MB的空隙。在之后的实验中会引入更多的<code>MMIO</code>区域，所以应当写一个简单的函数从该区域分配空间并映射内存。</p>
<p>练习1的答案如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In kern/pmap.c, mmio_map_region():</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">size = ROUNDUP(size, PGSIZE);</span><br><span class="line"><span class="keyword">if</span> (base + size &gt; MMIOLIM) &#123;</span><br><span class="line">    <span class="comment">// reservation overflog MMIOLIM</span></span><br><span class="line">    panic(<span class="string">"reservation bytes overflows!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use boot_map_region to map [pa, pa + size) to [base, base + size)</span></span><br><span class="line">boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_PWT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update base and return</span></span><br><span class="line"><span class="keyword">uintptr_t</span> saved_base = base;</span><br><span class="line">base += size;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">char</span> *)saved_base;</span><br><span class="line"></span><br><span class="line"><span class="comment">// panic("mmio_map_region not implemented");</span></span><br></pre></td></tr></table></figure></p>
<h5 id="应用处理器引导"><a href="#应用处理器引导" class="headerlink" title="应用处理器引导"></a>应用处理器引导</h5><p>BSP在引导APs之前应当首先收集多处理器系统的信息，如总CPU数，APIC IDs以及LAPIC单元的内存映射IO地址等。<code>kern/mpconfig.c</code>中的<code>mp_init()</code>函数通过读取BIOS内存中的MP配置表获取相应的信息。<br>在<code>kern/init.c</code>中的<code>boot_aps()</code>函数驱动AP引导过程。APs在实模式中启动，所以<code>boot_aps()</code>从<code>kern/mpentry.S</code>中拷贝AP入口代码到一个实模式可寻址的位置。可以在一定程度上控制AP执行开始代码的位置。在本实验中，将入口代码拷贝至<code>0x7000</code>（MPENTRY_PADDR），但实际上任何640KB以下的、页对齐的和未使用的物理地址均可使用。<br>然后，<code>boot_aps()</code>通过向对应AP的LAPIC单元发送STARTUP处理器间中断和初始的CS:IP地址（本实验中为MPENTRY_PADDR），依次激活APs。在简单的设置后，将AP启动分页，使得AP进入保护模式，然后调用启动例程<code>mp_main()</code>（在<code>kern/init.c</code>中。<code>boot_aps()</code>在唤醒下一个AP之前先等待当前AP在<code>struct CpuInfo</code>的<code>cpu_status</code>域中发送一个<code>CPU_STARTED</code>标记。<br>AP引导的汇编代码和C代码同实验一BSP的引导代码相似，可以比对异同。</p>
<p>练习2的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In kern/pmap.c, page_init():</span></span><br><span class="line"><span class="comment">// code MODIFIED</span></span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize from page 1 to page npages_basemem - 1</span></span><br><span class="line"><span class="comment">// set pp_ref to 0, set pp_link to last page_free_list</span></span><br><span class="line"><span class="comment">// and then update page_free_list</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lab 4: remove page at MPENTRY_PADDR</span></span><br><span class="line"><span class="keyword">size_t</span> mp_entry_page = PGNUM(MPENTRY_PADDR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; npages_basemem ; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == mp_entry_page) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">    pages[i].pp_link = page_free_list;</span><br><span class="line">    page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>问题1：<br>宏<code>MPBOOTPHYS</code>作用是将给定的内核虚拟地址（在<code>mpentry.S</code>中）转换成相应的加载后的物理地址。这么做的原因是在<code>mpentry.S</code>中，保护模式与分页机制尚未开启，设置分段等需要知道相应的物理地址。</p>
<h5 id="每CPU状态和初始化"><a href="#每CPU状态和初始化" class="headerlink" title="每CPU状态和初始化"></a>每CPU状态和初始化</h5><p>当编写多处理器操作系统时，区分对于每个处理器而言私有的每CPU状态以及整个系统共享的全局状态是很重要的。<code>kern/cpu.h</code>定义了大部分每CPU状态，包括了存储了每CPU变量的<code>struct CpuInfo</code>。<code>cpunum()</code>总是返回调用它的CPU ID，能用来索引例如<code>cpus</code>的数组。宏<code>thiscpu</code>是当前CPU的<code>struct CpuInfo</code>的简写。</p>
<p>以下是你需要注意的每CPU状态：</p>
<ul>
<li>每CPU内核栈 - 多个CPU可能会同时陷入内核，因此每个处理器需要独立的内核栈以避免互相干扰。<code>percpu_kstacks[NCPU][KSTKSIZE]</code>为<code>NCPU</code>个内核栈预留空间。在实验二中，将<code>bootstack</code>指向的物理内存作为BSP的栈映射在了KSTACKTOP下面。相似地，本实验中，需要将每个CPU的内核栈映射到该区域同时分配保护页作为它们之间的缓冲。CPU 0的栈将从KSTACKTOP开始向下增长；CPU 1的栈将从CPU 0栈下方间隔KSTKGAP处开始增长。<code>inc/memlayout.h</code>展示了映射约束。</li>
<li>每CPU的TSS和TSS描述符 - 每CPU的任务状态段同样用来致命每个CPU内核栈的位置。CPU i的TSS被存储于<code>cpus[i].cpu_ts</code>中，相应的TSS描述符在GDT入口<code>gdt[(GD_TSS0 &gt;&gt; 3) + i]</code>处被定义。<code>kern/trap.c</code>中定义的<code>ts</code>将不再有效。</li>
<li>每CPU的当前环境指针 - 由于每个CPU都能同步地执行不同的用户环境。重新将<code>curenv</code>定义为指向当前CPU（当前代码正在执行的CPU）正在执行的环境的<code>cpus[cpunum()].cpu_env</code>（或是<code>thiscpu-&gt;cpu_env</code>）。</li>
<li>每CPU的系统寄存器 - 包括系统寄存器在内的所有寄存器都属于CPU私有。因此初始化这些寄存器的指令如<code>lcr3</code>, <code>ltr</code>, ‘lgdt’等，必须在每个CPU上都被执行。函数<code>env_init_percpu()</code>以及<code>trap_init_percpu</code>正是为此而被定义。</li>
</ul>
<p>除此之外任何额外的用来CPU初始化的所有每CPU状态都应该在每个CPU处重复。</p>
<p>练习3中遇到的问题：</p>
<ul>
<li>在使用boot_map_region映射内存时忘记将kstacktop_i减去KSTKSIZE，导致未通过检查</li>
</ul>
<p>练习3的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LAB 4: Your code here:</span></span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">    <span class="comment">// traverser through 0 to NCPU to use boot_map_region to map</span></span><br><span class="line">    <span class="comment">// per-CPU's kernel stack to corresponding va</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);</span><br><span class="line">    boot_map_region(kern_pgdir, kstacktop_i - KSTKSIZE, KSTKSIZE,</span><br><span class="line">                    PADDR(percpu_kstacks[i]), PTE_W | PTE_P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>练习4中遇到的问题：</p>
<ul>
<li>使用ltr加载任务段选择子时，每个CPU应当使用不同的选择子，<code>inc/memlayout.c</code>中的GD_TSS0为CPU0的任务段选择子，应该加上i &lt;&lt; 3的偏移</li>
<li>完成<code>trap_init_percpu()</code>后，旧的使用<code>ts</code>的代码应当被注释</li>
</ul>
<p>练习4的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LAB 4: Your code here:</span></span><br><span class="line"><span class="comment">// trap_init_percpu() is called by all CPUs</span></span><br><span class="line"><span class="comment">// set esp0 and ss0 of task state segment to provide</span></span><br><span class="line"><span class="comment">// per-CPU's kernel stack access</span></span><br><span class="line">thiscpu-&gt;cpu_ts.ts_esp0 = (<span class="keyword">uintptr_t</span>)percpu_kstacks[cpunum()];</span><br><span class="line">thiscpu-&gt;cpu_ts.ts_ss0  = GD_KD;</span><br><span class="line"><span class="comment">// set IO map base address to prevent unauthorized environments</span></span><br><span class="line"><span class="comment">// this line works together as we'll set TSS segment limit later</span></span><br><span class="line"><span class="comment">// so all ports in address space have no corresponding IOPB</span></span><br><span class="line">thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set TSS in gdt</span></span><br><span class="line"><span class="comment">// 0 means RPL and sd_s = 0 means system segment</span></span><br><span class="line">gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>)(&amp;(thiscpu-&gt;cpu_ts)),</span><br><span class="line">                                       <span class="keyword">sizeof</span>(struct Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpunum()].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load TSS selector</span></span><br><span class="line">ltr(GD_TSS0 + (cpunum() &lt;&lt; <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// load the IDT</span></span><br><span class="line">lidt(&amp;idt_pd);</span><br></pre></td></tr></table></figure></p>
<h5 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h5><p>当前的代码在<code>mp_main()</code>中初始化完AP之后忙等待。在继续下一步之前，首先得解决多个CPU同时执行内核代码时的竞争条件。最简答的方式是使用一个“大”内核锁，大内核锁在从用户模式进入内核模式时被获取，在从环境返回用户模式时被释放。在这种模型下，用户模式环境可以在任意多个CPU上运行，但同时只能有一个环境能在内核中运行，其他想在内核中运行的环境被强制等待。</p>
<p><code>kern/spinlock.h</code>声明了内核锁，同时提供了<code>lock_kernel</code>提供加锁的功能；<code>unlock_kernel</code>提供解锁的功能，你应当在如下4个地方应用内核锁：</p>
<ul>
<li>在<code>i386_init()</code>中，在BSP唤醒其他CPU之前加锁</li>
<li>在<code>mp_main()</code>中，在初始化AP后加锁，然后调用<code>sched_yield()</code>去在当前AP上执行环境</li>
<li>在<code>trap()</code>中，当从用户模式陷入的时候加锁，通过检查tf_cs的低位判断陷阱发生于用户模式还是内核模式</li>
<li>在<code>env_run()</code>中，在“刚好”切换回用户模式之前解锁。太早或太晚解锁会导致严重的竞争和死锁</li>
</ul>
<p>练习5的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In i386_init():</span></span><br><span class="line"><span class="comment">// Acquire the big kernel lock before waking up APs</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">lock_kernel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// In mp_main():</span></span><br><span class="line"><span class="comment">// Now that we have finished some basic setup, call sched_yield()</span></span><br><span class="line"><span class="comment">// to start running processes on this CPU.  But make sure that</span></span><br><span class="line"><span class="comment">// only one CPU can enter the scheduler at a time!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line"><span class="comment">// lock the kernel and start running enviroments</span></span><br><span class="line">lock_kernel();</span><br><span class="line">sched_yield();</span><br><span class="line"></span><br><span class="line"><span class="comment">// In trap():</span></span><br><span class="line"><span class="comment">// Trapped from user mode.</span></span><br><span class="line"><span class="comment">// Acquire the big kernel lock before doing any</span></span><br><span class="line"><span class="comment">// serious kernel work.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">lock_kernel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// In env_run():</span></span><br><span class="line"><span class="comment">// address space switch</span></span><br><span class="line"><span class="comment">// reference from inc/x86.h</span></span><br><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line"><span class="comment">// release kernel lock here</span></span><br><span class="line">unlock_kernel(); <span class="comment">// newly added code</span></span><br><span class="line"><span class="comment">// drop into user mode</span></span><br><span class="line">env_pop_tf(&amp;(e-&gt;env_tf));</span><br></pre></td></tr></table></figure></p>
<p>问题2：<br>即使受到内核锁的保护，CPU之间仍然需要独立的内核栈。假设CPU0因中断陷入内核并在内核栈中保留了相关的信息，此时若CPU1也发生中断而陷入内核，在同一个内核栈的情况下，CPU0中的信息将会被覆盖从而导致出现错误。</p>
<h4 id="论询调度"><a href="#论询调度" class="headerlink" title="论询调度"></a>论询调度</h4><p>下一个任务是改变JOS内核使得其能按照“论询”的方式在多个环境中切换。在JOS中，论询调度按如下方式工作：</p>
<ul>
<li>‘kern/sched.c’中的<code>sched_yield()</code>负责选择一个新环境执行。其循环按顺序遍历<code>envs</code>数组，从上一次运行的环境（如果没有之前运行的环境，则从第一个环境）开始，找到第一个具有状态ENV_RUNNABLE的环境，调用<code>env_run()</code>执行。</li>
<li><code>sched_yield()</code>绝对不能同时在两个CPU上运行相同的环境。其会告知环境当前已经正在运行在某CPU上（很可能是当前环境），因为该环境的状态将为ENV_RUNNING。</li>
<li>将实现一个新的系统调用<code>sys_yield()</code>，用户环境可以通过该系统调用唤醒<code>sched_yield()</code>函数以主动放弃CPU。</li>
</ul>
<p>练习6中遇到的问题：</p>
<ul>
<li>在实现<code>sched_yield()</code>的时候没有检查<code>thiscpu-&gt;cpu_env</code>是否为空，对空指针的访问导致了缺页错误</li>
<li>一开始的实现弄错了获取env_index和自增的顺序，参考代码中第一个<code>if</code>处的<code>else</code>分支的注释</li>
<li>练习6结束后需要将<code>init.c</code>中<code>mp_main()</code>的最后一行注释</li>
</ul>
<p>练习6的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In kern/sched.c, sched_yield():</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">// get index from current CPU's env</span></span><br><span class="line"><span class="keyword">size_t</span> env_index;</span><br><span class="line"><span class="comment">// set curenv_flag to default true</span></span><br><span class="line"><span class="keyword">int</span> curenv_flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">if</span> (thiscpu-&gt;cpu_env == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// no previous running environment</span></span><br><span class="line">    <span class="comment">// start at beginning of envs array</span></span><br><span class="line">    i         = <span class="number">0</span>;</span><br><span class="line">    env_index = NENV - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// mark curenv_flag as true</span></span><br><span class="line">    curenv_flag = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// start at previous running environment</span></span><br><span class="line">    env_index = ENVX(thiscpu-&gt;cpu_env-&gt;env_id);</span><br><span class="line">    <span class="comment">// NB: don't mess with code order here, must first retrieve</span></span><br><span class="line">    <span class="comment">// env_index then increment</span></span><br><span class="line">    i = (env_index == NENV - <span class="number">1</span>) ? <span class="number">0</span> : env_index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// traverse through envs list to find first ENV_RUNNABLE</span></span><br><span class="line"><span class="comment">// env</span></span><br><span class="line"><span class="keyword">for</span> (; i != env_index; i = ((i == NENV - <span class="number">1</span>) ? <span class="number">0</span> : i + <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (envs[i].env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// found, set idle and break from loop</span></span><br><span class="line">        idle = &amp;envs[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if idle is NULL and curenv_flag is true,</span></span><br><span class="line"><span class="comment">// means no envs are runnable and last previous running env is ENV_RUNNING</span></span><br><span class="line"><span class="comment">// check if last previous environment is ENV_RUNNING,</span></span><br><span class="line"><span class="comment">// if so, choose it.</span></span><br><span class="line"><span class="keyword">if</span> (!idle &amp;&amp; curenv_flag &amp;&amp; envs[env_index].env_status == ENV_RUNNING) &#123;</span><br><span class="line">    idle = &amp;envs[env_index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (idle) &#123;</span><br><span class="line">    <span class="comment">// idle env choosed, run it directly</span></span><br><span class="line">    env_run(idle);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// failed to choose idle env, halt CPU</span></span><br><span class="line">    <span class="comment">// sched_halt never returns</span></span><br><span class="line">    sched_halt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/syscall.c, syscall():</span></span><br><span class="line"><span class="comment">// code added:</span></span><br><span class="line"><span class="keyword">case</span> SYS_yield:</span><br><span class="line">    <span class="comment">// call sys_yield</span></span><br><span class="line">    sys_yield();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/init.c, i386_init():</span></span><br><span class="line"><span class="comment">// code modified:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(TEST)</span></span><br><span class="line">    <span class="comment">// Don't touch -- used by grading script!</span></span><br><span class="line">    ENV_CREATE(TEST, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// Touch all you want.</span></span><br><span class="line">    <span class="comment">// create three user_yield</span></span><br><span class="line">    <span class="comment">// code MODIFIED here</span></span><br><span class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>    <span class="comment">// TEST*</span></span></span><br></pre></td></tr></table></figure></p>
<p>问题3：<br>地址切换前后的页表中，<code>e</code>指向的虚拟地址都被同一块物理页映射。出现这种情况的原因在于<code>env</code>的<code>env_pgdir</code>是以<code>kern_pgdir</code>为原型产生的，<code>e</code>出于UTOP之上的地址，而UTOP以上的地址的映射关系在两个页表中是一样的。</p>
<p>问题4：<br>当发生地址转换时一定是从用户陷入内核之后，无论以何种方式陷入内核，必须要经过<code>kern/trap.c</code>中的<code>trap()</code>函数。观察该函数，可以发现，当从用户模式陷入内核时，代码将内核栈中的<code>tf</code>（包括页表和寄存器等）拷贝至内核间共享的对应的<code>env</code>中，所以之后寄存器状态才能恢复。</p>
<h4 id="环境创建的系统调用"><a href="#环境创建的系统调用" class="headerlink" title="环境创建的系统调用"></a>环境创建的系统调用</h4><p>尽管内核已经可以运行并在不同环境间切换了，但内核任然被限制了只能执行内核初始设置的用户环境。<br>需要实现必要的系统调用使得JOS可以允许用户环境创建和启动其他的用户环境。</p>
<p>Unix提供了<code>fork()</code>作为它的进程创建原语。Unix的<code>fork()</code>拷贝调用进程（父进程）的整个地址空间以创建子进程。<br>从用户空间来看，父子进程唯一可观察的差异就是它们的进程ID和父进程ID（通过<code>gitpid()</code>和<code>getppid()</code>返回。在父进程中，<code>fork()</code>返回子进程ID；在子进程中，<code>fork()</code>返回0。默认情况下，每个进程均获得其私有的地址空间，并且任意一个进程对于内存的修改对于其他进程都是不可见的。</p>
<p>将要实现一个不同的、更加原始的JOS系统调用原语集合去创建新的用户模式环境，通过这些系统调用，除了其他类型的环境创建以外，将能够在用户空间实现一个完整的类Unix<code>fork()</code>系统调用。需要实现的系统调用为：</p>
<ul>
<li><code>sys_exofork</code> - 创建一个几乎空白的新环境：在地址空间没有任何的用户映射，并且也无法运行。新环境将会有和父环境在执行<code>sys_exofork</code>系统调用时完全一致的寄存器状态。在父进程中，<code>sys_exofork</code>会返回新创建环境的<code>envid_t</code>（若环境创建错误则返回一个错误码）；子进程则会返回0（因为子进程最初被标记为不可运行，直到父进程通过显式标记子进程可运行之后，<code>sys_exofork</code>返回。</li>
<li><code>sys_env_set_status</code> - 设置指定的环境的状态为ENV_RUNNABLE或是ENV_NOT_RUNNABLE。该系统调用通常在一个新环境的地址空间和寄存器状态完全初始化之后标记其为可运行。</li>
<li><code>sys_page_alloc</code> - 分配一页的物理内存并将其映射到给定环境地址空间的给定虚拟地址。</li>
<li><code>sys_page_alloc</code> - 将一页映射（而不是实际的页内容）从一个环境的地址空间拷贝至另一个，共享内存使得新映射和旧映射指向同一页物理内存。</li>
<li><code>sys_page_unmap</code> - 将给定环境的给定虚拟地址的页面解除映射。</li>
</ul>
<p>上述所有的系统调用接受环境ID，内核支持将0到“当前环境”转换，在<code>kern/env.c</code>中的<code>envid2env()</code>实现。</p>
<p>已经在<code>user/dumpfork.c</code>中提供了非常原始的类Unix的<code>fork()</code>实现。测试程序用上述系统调用创建并运行一个当前地址空间拷贝的子进程，然后两个环境使用<code>sys_yield()</code>来回切换。父进程在10次迭代后退出；子进程在20次迭代后退出。</p>
<p>练习7的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In sys_exofork():</span></span><br><span class="line"><span class="comment">// Allocate a new environment.</span></span><br><span class="line"><span class="comment">// Returns envid of new environment, or &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//  -E_NO_FREE_ENV if no free environment is available.</span></span><br><span class="line"><span class="comment">//  -E_NO_MEM on memory exhaustion.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> envid_t <span class="title">sys_exofork</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create the new environment with env_alloc(), from kern/env.c.</span></span><br><span class="line">    <span class="comment">// It should be left as env_alloc created it, except that</span></span><br><span class="line">    <span class="comment">// status is set to ENV_NOT_RUNNABLE, and the register set is copied</span></span><br><span class="line">    <span class="comment">// from the current environment -- but tweaked so sys_exofork</span></span><br><span class="line">    <span class="comment">// will appear to return 0.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// get env_id of current environment</span></span><br><span class="line">    <span class="keyword">envid_t</span> parent_id = thiscpu-&gt;cpu_env-&gt;env_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use env_alloc to create new environment and</span></span><br><span class="line">    <span class="comment">// do some basic setup(status and register set)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (env_alloc(&amp;env, parent_id) &lt; <span class="number">0</span>) &#123; panic(<span class="string">"sys_exofork failed!"</span>); &#125;</span><br><span class="line">    env-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    env-&gt;env_tf     = thiscpu-&gt;cpu_env-&gt;env_tf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do the trick to set eax register of newly</span></span><br><span class="line">    <span class="comment">// alloc environment to 0</span></span><br><span class="line">    env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return new environment's ID</span></span><br><span class="line">    <span class="keyword">return</span> env-&gt;env_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("sys_exofork not implemented");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In sys_env_set_status():</span></span><br><span class="line"><span class="comment">// Set envid's env_status to status, which must be ENV_RUNNABLE</span></span><br><span class="line"><span class="comment">// or ENV_NOT_RUNNABLE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if status is not a valid status for an environment.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_env_set_status</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Hint: Use the 'envid2env' function from kern/env.c to translate an</span></span><br><span class="line">    <span class="comment">// envid to a struct Env.</span></span><br><span class="line">    <span class="comment">// You should set envid2env's third argument to 1, which will</span></span><br><span class="line">    <span class="comment">// check whether the current environment has permission to set</span></span><br><span class="line">    <span class="comment">// envid's status.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// check status passed in</span></span><br><span class="line">    <span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// invalid status</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="comment">// call envid2env to translate envid passed in</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">true</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// bad environment</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set status</span></span><br><span class="line">    env-&gt;env_status = status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("sys_env_set_status not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In sys_page_alloc():</span></span><br><span class="line"><span class="comment">// Allocate a page of memory and map it at 'va' with permission</span></span><br><span class="line"><span class="comment">// 'perm' in the address space of 'envid'.</span></span><br><span class="line"><span class="comment">// The page's contents are set to 0.</span></span><br><span class="line"><span class="comment">// If a page is already mapped at 'va', that page is unmapped as a</span></span><br><span class="line"><span class="comment">// side effect.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set,</span></span><br><span class="line"><span class="comment">//         but no other bits may be set.  See PTE_SYSCALL in inc/mmu.h.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//      or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if perm is inappropriate (see above).</span></span><br><span class="line"><span class="comment">//  -E_NO_MEM if there's no memory to allocate the new page,</span></span><br><span class="line"><span class="comment">//      or to allocate any necessary page tables.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_page_alloc</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Hint: This function is a wrapper around page_alloc() and</span></span><br><span class="line">    <span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">    <span class="comment">//   Most of the new code you write should be to check the</span></span><br><span class="line">    <span class="comment">//   parameters for correctness.</span></span><br><span class="line">    <span class="comment">//   If page_insert() fails, remember to free the page you</span></span><br><span class="line">    <span class="comment">//   allocated!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="comment">// check and get env</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">true</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// envid not exist or permission error</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check va</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= UTOP || PGOFF(va) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// va above UTOP or va is not page-aligned</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check perm</span></span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; (~PTE_SYSCALL)) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P)) &#123;</span><br><span class="line">        <span class="comment">// invalid perm</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate page and then insert it</span></span><br><span class="line">    <span class="comment">// check if out of memory</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((page = page_alloc(ALLOC_ZERO)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// failed to allocate page</span></span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (page_insert(env-&gt;env_pgdir, page, va, perm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// page table couldn't be allocated</span></span><br><span class="line">        <span class="comment">// free ununsed page</span></span><br><span class="line">        page_free(page);</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("sys_page_alloc not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// page successfully allocated</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In sys_page_map():</span></span><br><span class="line"><span class="comment">// Map the page of memory at 'srcva' in srcenvid's address space</span></span><br><span class="line"><span class="comment">// at 'dstva' in dstenvid's address space with permission 'perm'.</span></span><br><span class="line"><span class="comment">// Perm has the same restrictions as in sys_page_alloc, except</span></span><br><span class="line"><span class="comment">// that it also must not grant write access to a read-only</span></span><br><span class="line"><span class="comment">// page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//  -E_BAD_ENV if srcenvid and/or dstenvid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//      or the caller doesn't have permission to change one of them.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,</span></span><br><span class="line"><span class="comment">//      or dstva &gt;= UTOP or dstva is not page-aligned.</span></span><br><span class="line"><span class="comment">//  -E_INVAL is srcva is not mapped in srcenvid's address space.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if perm is inappropriate (see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//  -E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid's</span></span><br><span class="line"><span class="comment">//      address space.</span></span><br><span class="line"><span class="comment">//  -E_NO_MEM if there's no memory to allocate any necessary page tables.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_page_map</span><span class="params">(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva, <span class="keyword">envid_t</span> dstenvid,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Hint: This function is a wrapper around page_lookup() and</span></span><br><span class="line">    <span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">    <span class="comment">//   Again, most of the new code you write should be to check the</span></span><br><span class="line">    <span class="comment">//   parameters for correctness.</span></span><br><span class="line">    <span class="comment">//   Use the third argument to page_lookup() to</span></span><br><span class="line">    <span class="comment">//   check the current permissions on the page.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srcenv</span>, *<span class="title">dstenv</span>;</span></span><br><span class="line">    <span class="comment">// check environment</span></span><br><span class="line">    <span class="keyword">if</span> ((envid2env(srcenvid, &amp;srcenv, <span class="literal">true</span>) &lt; <span class="number">0</span>) ||</span><br><span class="line">        (envid2env(dstenvid, &amp;dstenv, <span class="literal">true</span>) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// srcenvid or dstenvid doesn't exist or</span></span><br><span class="line">        <span class="comment">// caller doesn't have permissions</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check srcva and dstva about address and page-aligned</span></span><br><span class="line">    <span class="comment">// get srcenv and dstenv</span></span><br><span class="line">    <span class="keyword">if</span> (((<span class="keyword">uintptr_t</span>)srcva &gt;= UTOP) || ((<span class="keyword">uintptr_t</span>)dstva &gt;= UTOP) ||</span><br><span class="line">        (PGOFF(srcva) != <span class="number">0</span>) || (PGOFF(dstva) != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// addresses above UTOP or addresses not page_aligned</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">srcpage</span>;</span></span><br><span class="line">    <span class="keyword">pte_t</span> *          scrpte_ptr;</span><br><span class="line">    <span class="comment">// use page look up to get source page and corresponding pte_t *</span></span><br><span class="line">    <span class="keyword">if</span> ((srcpage = page_lookup(srcenv-&gt;env_pgdir, srcva, &amp;scrpte_ptr)) ==</span><br><span class="line">        <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// srcva not mapped in srcenvid's address space</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check perm passed in</span></span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; (~PTE_SYSCALL)) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P)) &#123;</span><br><span class="line">        <span class="comment">// invalid perm</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if srcva is writable if perm has PTE_W</span></span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; (!((*scrpte_ptr) &amp; PTE_W))) &#123;</span><br><span class="line">        <span class="comment">// perm has PTE_W while srcva ISN'T writable</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert source page into dstenv's pgdir with perm</span></span><br><span class="line">    <span class="comment">// check if out of memory</span></span><br><span class="line">    <span class="keyword">if</span> (page_insert(dstenv-&gt;env_pgdir, srcpage, dstva, perm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// out of memory to allocate page table</span></span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("sys_page_map not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// page successfully mapped</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In sys_page_unmap():</span></span><br><span class="line"><span class="comment">// Unmap the page of memory at 'va' in the address space of 'envid'.</span></span><br><span class="line"><span class="comment">// If no page is mapped, the function silently succeeds.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//      or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_page_unmap</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Hint: This function is a wrapper around page_remove().</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="comment">// check and get env</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">true</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// envid not exist or permission error</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check va</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= UTOP || PGOFF(va) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// va above UTOP or va is not page-aligned</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call page_remove to unmap page</span></span><br><span class="line">    page_remove(env-&gt;env_pgdir, va);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("sys_page_unmap not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// page successfully unmapped</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In syscall():</span></span><br><span class="line"><span class="comment">// new code added</span></span><br><span class="line"><span class="keyword">case</span> SYS_exofork:</span><br><span class="line">    <span class="comment">// call sys_exofork</span></span><br><span class="line">    <span class="keyword">return</span> sys_exofork();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_env_set_status:</span><br><span class="line">    <span class="comment">// call sys_env_set_status</span></span><br><span class="line">    <span class="keyword">return</span> sys_env_set_status((<span class="keyword">envid_t</span>)a1, (<span class="keyword">int</span>)a2);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_page_alloc:</span><br><span class="line">    <span class="comment">// call sys_page_alloc</span></span><br><span class="line">    <span class="keyword">return</span> sys_page_alloc((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2, (<span class="keyword">int</span>)a3);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_page_map:</span><br><span class="line">    <span class="comment">// call sys_page_map</span></span><br><span class="line">    <span class="keyword">return</span> sys_page_map((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2, (<span class="keyword">envid_t</span>)a3, (<span class="keyword">void</span> *)a4,</span><br><span class="line">                        (<span class="keyword">int</span>)a5);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_page_unmap:</span><br><span class="line">    <span class="comment">// call sys_page_unmap</span></span><br><span class="line">    <span class="keyword">return</span> sys_page_unmap((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="第二部分-Copy-on-Write-Fork-写时复制Fork"><a href="#第二部分-Copy-on-Write-Fork-写时复制Fork" class="headerlink" title="第二部分 Copy-on-Write Fork - 写时复制Fork"></a>第二部分 Copy-on-Write Fork - 写时复制Fork</h3><p>Unix提供了一个<code>fork()</code>系统调用作为其原始的进程创建原语。<code>fork()</code>系统调用将调用进程的整个地址空间拷贝以创建子进程。</p>
<p>xv6通过将父进程页中的所有数据复制到子进程中的新页中来实现<code>fork()</code>，这本质上就是<code>dumbfowk()</code>采用的方法。对于父进程地址空间的拷贝是整个<code>fork()</code>操作中最“贵”的部分。</p>
<p>然而，对于fork()的调用通常紧跟着一个对子进程的<code>exec()</code>系统调用，该系统调用用一个新程序替换子进程的内存，这就是一个典型的shell所做的。在这种情况下，花费的用于复制父进程的地址空间的时间是被浪费的，因为子进程在调用<code>exec()</code>前只会使用很少的内存。</p>
<p>出于以上的原因，Unix之后的版本利用了虚拟内存硬件去允许父进程和子进程共享映射到各自地址空间的内存，直到其中一个进程实际修改为止。该技术又被称作写时复制。<br>为了实现写时复制，在<code>fork()</code>中内核仅仅从父进程拷贝地址的映射而非实际映射的页面到子进程，并且在同时将共享的页面标记为只读。<br>当两个进程之一尝试写入其中一个共享页面时，该过程触发页面错误。<br>内核意识到该页面实际上是一个“虚拟”或是“写时复制”页面，所以其会创建一个错误页面的新的，私有的，可写的页副本。<br>通过这种方式，直到实际写入时，独立页面的内容才被复制。<br>该过程使得紧接着<code>exec()</code>的<code>fork()</code>调用更加节约：子进程在调用<code>exec()</code>很可能只会复制一页（栈的当前页）。</p>
<p>本实验的下一个部分要求完成一个合适的类Unix的<code>fork()</code>的写时复制的实现（作为用户空间库例程）。在用户空间实现<code>fork()</code>并且支持写时复制使得内核能保留相对简洁，因此更不容易出现严重的错误。这同样可以允许独立的用户模式程序实现自己的<code>fork()</code>语义。</p>
<h4 id="用户级别的页错误处理"><a href="#用户级别的页错误处理" class="headerlink" title="用户级别的页错误处理"></a>用户级别的页错误处理</h4><p>用户级别的写时复制<code>fork()</code>实现需要知道写保护页面的页错误。写时复制只是用户级别的页错误处理的诸多可能用处之一。</p>
<p>通常的做法是设置一个地址空间以便页错误指示何时需要采取某些行动。大多数Unix内核通常只会为新进程的栈区域分配一页，随着进程栈逐渐增长直至访问到了还未被映射的栈地址，触发页错误，然后内核会“按需”分配更多的栈页面。<br>典型的Unix内核必须追踪进程的空间中的不同区域发生页错误时所采取的行动。栈区域的页错误通常会导致新页的分配和映射。BSS区域的页错误通常会导致分配一个新页，填充0，并映射。对于具有按需分页的可执行文件的系统，text段的页错误会导致内核从磁盘上的二进制文件读取相应的页面并映射。</p>
<p>内核需要追踪大量的信息。与传统的Unix方法不同，本实验需要用户决定如何处理用户空间中的每个页面错误，而这些错误的损害通常不大。这种设计还为程序定义存储区域带来了极大的灵活性。之后将会应用用户级别的错误处理程序来映射和访问基于磁盘的文件系统上的文件。</p>
<h5 id="设置页错误处理程序"><a href="#设置页错误处理程序" class="headerlink" title="设置页错误处理程序"></a>设置页错误处理程序</h5><p>为了处理用户环境自己的页错误，用户环境必须向JOS内核注册一个页错误处理程序入口。用户环境通过<code>sys_env_set_pgfault_upcall()</code>的“上行”系统调用注册自己的错误处理程序入口。已经向<code>struct Env</code>添加了新的域<code>env_pgfault_upcall</code>来记录该信息。</p>
<p>练习8的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In sys_env_set_pgfault_upcall():</span></span><br><span class="line"><span class="comment">// Set the page fault upcall for 'envid' by modifying the corresponding struct</span></span><br><span class="line"><span class="comment">// Env's 'env_pgfault_upcall' field.  When 'envid' causes a page fault, the</span></span><br><span class="line"><span class="comment">// kernel will push a fault record onto the exception stack, then branch to</span></span><br><span class="line"><span class="comment">// 'func'.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//      or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_env_set_pgfault_upcall</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *func)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="comment">// check and translate the envid</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">true</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// envid not exist or permission error</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set func</span></span><br><span class="line">    env-&gt;env_pgfault_upcall = func;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("sys_env_set_pgfault_upcall not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In syscall():</span></span><br><span class="line"><span class="comment">// new code added</span></span><br><span class="line"><span class="keyword">case</span> SYS_env_set_pgfault_upcall:</span><br><span class="line">    <span class="comment">// call sys_env_set_pgfault_upcall</span></span><br><span class="line">    <span class="keyword">return</span> sys_env_set_pgfault_upcall((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="用户环境中的正常栈和异常栈"><a href="#用户环境中的正常栈和异常栈" class="headerlink" title="用户环境中的正常栈和异常栈"></a>用户环境中的正常栈和异常栈</h5><p>在正常执行时，JOS中的用户环境会在正常栈中执行：正常栈的ESP寄存器指向USTACKTOP，并且压入的栈数据会存放于USTACKTOP - PGSIZE到USTACKTOP - 1的闭区域。<br>然而，当一个页错误在用户模式发生时，内核将重启用户环境，在一个另外的栈上运行一个特定的用户级别的页错误处理程序，该栈被称为用户异常栈。<br>实际上，将使JOS代表用户环境自动执行“栈切换”，就像x86处理器在用户模式转换到内核模式时已经代表JOS实现了栈切换一样。</p>
<p>JOS用户异常栈的大小也为一个页面大，栈顶被定义为指向虚拟地址UXSTACKTOP，用户异常栈的有效字节为UXSTACKTOP - PGSIZE到UXSTACKTOP - 1的闭区域。<br>当运行于异常栈上时，用户级别的页错误处理程序可以使用JOS的常规系统调用映射新的页或是调整页映射以修复任何可能导致页错误的问题。<br>然后用户级别的页错误处理程序通过汇编语言存根返回至原始栈上的错误代码处。</p>
<p>每一个想要支持用户级别页错误处理程序的用户环境需要自己为其异常栈通过<code>sys_page_alloc()</code>分配内存。</p>
<h5 id="唤醒用户页错误处理程序"><a href="#唤醒用户页错误处理程序" class="headerlink" title="唤醒用户页错误处理程序"></a>唤醒用户页错误处理程序</h5><p>现在需要改变<code>kern/trap.c</code>中的页错误处理程序按特定的方式处理用户模式的页错误。<br>将错误时的用户环境状态叫做陷阱时状态。</p>
<p>若是没有页面错误处理函数被注册，则JOS内核会和之前一样，摧毁用户环境并输出一条消息。否则，内核会在异常栈设置在<code>inc/trap.h</code>中如<code>struct UTrapFrame</code>定义的陷阱帧。</p>
<p>然后内核会安排用户环境以页错误处理程序以上述栈帧在异常栈上恢复执行。<code>fault_va</code>是导致也错误的虚拟地址。</p>
<p>如果当异常发生时用户环境已经在用户异常栈上运行，则错误处理程序自身发生了错误。在这种情况下，你应当在当前的<code>tf-&gt;tf_esp</code>中而非UXSTACKTOP中重新启动栈帧。你应当首先压入一个4字节的字，然后一个<code>struct UTrapFrame</code>。</p>
<p>检查tf-&gt;tf_esp是否在UXSTACKTOP - PGSIZE到UXSTACKTOP - 1的闭区间内来判断其是否已经在用户异常栈上。</p>
<p>练习9中遇到的问题：</p>
<ul>
<li><code>curenv</code>已经被重新定义为<code>thiscpu-&gt;cpu_env</code>，因此可以使用</li>
<li>判断tf-&gt;tf_esp的if语句中，将与写成了或</li>
</ul>
<p>练习9的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In trap.c, page_fault_handler():</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> *<span class="title">utf</span>;</span></span><br><span class="line"><span class="keyword">uintptr_t</span>          utf_addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check tf-&gt;tf_esp's location to calculate utf's address</span></span><br><span class="line"><span class="keyword">if</span> ((tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE) &amp;&amp; (tf-&gt;tf_esp &lt; UXSTACKTOP)) &#123;</span><br><span class="line">    <span class="comment">// recursive case</span></span><br><span class="line">    <span class="comment">// reason why here needs to substract a 4-byte word</span></span><br><span class="line">    <span class="comment">// is to reserve space for reset eip/esp</span></span><br><span class="line">    utf_addr = tf-&gt;tf_esp - <span class="keyword">sizeof</span>(struct UTrapframe) - <span class="number">4</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// non-recursive case, set utf_addr to the top of</span></span><br><span class="line">    <span class="comment">// user exception stack</span></span><br><span class="line">    utf_addr = UXSTACKTOP - <span class="keyword">sizeof</span>(struct UTrapframe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (curenv-&gt;env_pgfault_upcall) &#123;</span><br><span class="line">    <span class="comment">// page fault upcall exist</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// use mem assert to check environment allocates the exception</span></span><br><span class="line">    <span class="comment">// stack and has write permission to it, and stack ISN'T overflow</span></span><br><span class="line">    <span class="comment">// combine three case with only one user_mem_assert to check utf_addr</span></span><br><span class="line">    <span class="comment">// NB: curenv HAS been redefined as thiscpu-&gt;cpu_env</span></span><br><span class="line">    user_mem_assert(curenv, (<span class="keyword">void</span> *)utf_addr, <span class="keyword">sizeof</span>(struct UTrapframe),</span><br><span class="line">                    PTE_U | PTE_W | PTE_P);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set user stack frame</span></span><br><span class="line">    utf               = (struct UTrapframe *)utf_addr;</span><br><span class="line">    utf-&gt;utf_fault_va = fault_va;</span><br><span class="line">    utf-&gt;utf_err      = tf-&gt;tf_err;</span><br><span class="line">    utf-&gt;utf_regs     = tf-&gt;tf_regs;</span><br><span class="line">    utf-&gt;utf_eip      = tf-&gt;tf_eip;</span><br><span class="line">    utf-&gt;utf_eflags   = tf-&gt;tf_eflags;</span><br><span class="line">    utf-&gt;utf_esp      = tf-&gt;tf_esp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// modify stack frame to set entry for env_pgfault_upcall</span></span><br><span class="line">    <span class="comment">// and set address for user exception stack</span></span><br><span class="line">    tf-&gt;tf_eip = (<span class="keyword">uintptr_t</span>)curenv-&gt;env_pgfault_upcall;</span><br><span class="line">    tf-&gt;tf_esp = utf_addr;</span><br><span class="line"></span><br><span class="line">    env_run(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="用户模式页错误入口"><a href="#用户模式页错误入口" class="headerlink" title="用户模式页错误入口"></a>用户模式页错误入口</h5><p>然后需要实现汇编例程，该例程调用C页错误处理程序，然后在恢复在原始的错误指令处的执行。该例程就是被<code>sys_env_set_pgfault_upcall()</code>注册的例程。</p>
<p>最后需要在C用户库实现用户模式的页错误处理机制。</p>
<p>练习10中遇到的问题：</p>
<ul>
<li>需要想清楚思路，即先将eip“压入”陷阱时栈中，使用一个sub后接一个mov指令来模拟该压栈过程，若为递归过程，则会将eip填入之前留下的空白。然后依次恢复寄存器以及eflags。最后pop %esp以切换栈并调用ret返回</li>
</ul>
<p>练习10的代码如下，仅供参考：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">In</span> pfentry.S:</span><br><span class="line">// LAB <span class="number">4</span>: Your code here.</span><br><span class="line">// <span class="keyword">push</span> trap-time %eip to trap-time stack</span><br><span class="line">// <span class="keyword">mov</span> utf_eip to %eax</span><br><span class="line">movl <span class="number">0x28</span>(%esp), %eax</span><br><span class="line">// use <span class="keyword">sub</span> <span class="keyword">and</span> <span class="keyword">mov</span> to *simulate* <span class="keyword">push</span></span><br><span class="line">subl <span class="number">$0</span>x4, <span class="number">0x30</span>(%esp)</span><br><span class="line">movl <span class="number">0x30</span>(%esp), %ebp</span><br><span class="line">movl %eax, (%ebp)</span><br><span class="line">// <span class="keyword">pop</span> the unused fault_va <span class="keyword">and</span> err</span><br><span class="line">popl %eax</span><br><span class="line">popl %eax</span><br><span class="line"></span><br><span class="line">// Restore the trap-time registers.  After you <span class="built_in">do</span> this, you</span><br><span class="line">// can no longer modify any general-purpose registers.</span><br><span class="line">// LAB <span class="number">4</span>: Your code here.</span><br><span class="line">popal</span><br><span class="line"></span><br><span class="line">// Restore eflags from the stack.  After you <span class="built_in">do</span> this, you can</span><br><span class="line">// no longer use arithmetic operations <span class="keyword">or</span> anything else that</span><br><span class="line">// modifies eflags.</span><br><span class="line">// LAB <span class="number">4</span>: Your code here.</span><br><span class="line">addl <span class="number">$0</span>x4, %esp</span><br><span class="line">popfl</span><br><span class="line"></span><br><span class="line">// Switch back to the adjusted trap-time stack.</span><br><span class="line">// LAB <span class="number">4</span>: Your code here.</span><br><span class="line">popl %esp</span><br><span class="line"></span><br><span class="line">// Return to re-execute the instruction that faulted.</span><br><span class="line">// LAB <span class="number">4</span>: Your code here.</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p>练习11中遇到的问题：</p>
<ul>
<li>注意描述，要使用<code>_pgfault_upcall()</code>（汇编例程包装）来注册用户页处理函数而非传入的那个函数</li>
</ul>
<p>练习11的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In set_pgfault_handler():</span></span><br><span class="line"><span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// First time through!</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// alloc one page for user exception stack</span></span><br><span class="line">    <span class="comment">// and register user-level page fault upcall</span></span><br><span class="line">    <span class="keyword">if</span> (sys_page_alloc(thisenv-&gt;env_id, (<span class="keyword">void</span> *)(UXSTACKTOP - PGSIZE),</span><br><span class="line">                       PTE_U | PTE_W | PTE_P) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">"failed to alloc page for user exception stack!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sys_env_set_pgfault_upcall(thisenv-&gt;env_id, _pgfault_upcall) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">"failed to register page fault upcall!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("set_pgfault_handler not implemented");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>faultalloc能成功而faultallocbad失败的原因在于faultallocbad直接使用系统调用输出，该输出会使用先使用内存检查而失败；而faultalloc使用了用户库中的<code>cprintf</code>，该函数在使用系统调用输出之前已经尝试对错误地址进行了解引用，触发了用户级别的缺页错误，在实际执行系统调用时，错误的地址已经被分配了页面，因此能通过内存检查。</p>
<h4 id="实现写时复制"><a href="#实现写时复制" class="headerlink" title="实现写时复制"></a>实现写时复制</h4><p>已经拥有了在用户空间中完整实现写时复制<code>fork()</code>的内核设施基础。</p>
<p>现在已经在<code>lib/fork.c</code>中给出了<code>fork()</code>的框架。同<code>dumbfork()</code>相似，<code>fork()</code>首先创建了一个新环境，然后扫描父进程的地址空间并在子进程中建立相同的页映射。核心区别在于<code>dumbfork()</code>复制页，而<code>fork()</code>只实现页映射的复制。<code>fork()</code>直到某环境尝试写时在复制对应的页。</p>
<p><code>fork()</code>的基本控制流为：</p>
<ol>
<li>父进程设置<code>pgfault()</code>作为C级别的页错误处理程序，使用实现了的<code>set_pgfault_handler()</code>函数</li>
<li>父进程调用<code>sys_exofork()</code>去创建子环境</li>
<li>对于地址空间中每一个在UTOP下的可写的或是写时复制的页面，父进程调用<code>duppage()</code>，该函数将该页面以写时复制映射进子进程然后在父进程的地址空间中重新映射该页面为写时复制（顺序很重要）。<code>duppage()</code>同时设置PTE，所以页面将不可写。通过avail域的PTE_COW区分写时复制页面和真正的只读页面。然而，异常栈却不按该方式重映射。需要为子进程分配一个新页面作为异常栈。由于页处理程序实际执行了页复制并且页处理程序运行于异常栈上，异常栈不能写时复制。<code>fork()</code>也需要处理存在但既不是写时复制也不是可写的页面。</li>
<li>父进程为子进程设置用户页错误入口。</li>
<li>子进程已经准备好运行了，有父进程将其标记为可运行。</li>
</ol>
<p>每一次环境尝试向一个还不可写的写时复制的页面写入时，将出现页错误，用户页错误处理程序的控制流为：</p>
<ol>
<li>内核将页错误传递给页错误上行调用，即调用了<code>fork()</code>的页错误处理程序。</li>
<li><code>pgfault()</code>检查错误为写入导致并且相应页面的PTE被标记为写时复制，否则使内核恐慌。</li>
<li><code>pgfault()</code>分配一个新的页面，映射至一个临时位置，然后复制错误页面的内容到新分配的页面，最后将新页面以读写权限映射到合适的地址，替代旧的只读页。</li>
</ol>
<p>用户级别的<code>lib/fork.c</code>代码必须查询环境的页表（如查询某页面的PTE被标记为写时复制）。内核将环境的页表映射在UVPT正是为了这个目的。内核通过将页目录的指针指向自己的映射技巧使得可以为用户代码快速查找PTEs，<code>lib/entry.S</code>已经设置了<code>uvpd</code>和<code>uvpd</code>，你可以快速在<code>lib/fork.c</code>中查找页表信息。</p>
<p>练习12中遇到的问题：</p>
<ul>
<li>注意在<code>pgfault()</code>和<code>duppage()</code>中，必须使用0而不是<code>thisenv-&gt;env_id</code>，原因已经在代码注释中标出</li>
<li>在<code>fork()</code>中需要显式地判断用户异常页并跳过<code>duppage()</code></li>
<li>阅读给出的uvpt技巧，需要在代码中使用</li>
<li>为了简化错误处理，避免重复代码，使用了<code>goto</code></li>
<li>假定先将父进程的用户栈标记为COW，然后再尝试将子进程的用户栈标记为COW之前，可能会出现父进程的用户栈已经被写入的情况而触发缺页错误，因此<code>fork()</code>会立刻分配新页，拷贝内容并重新映射。子进程被标记COW时复制的页映射已经不是原来的页映射了，因此，后来对父进程做的改动会反映在子进程上，这显然是错误的</li>
<li>fork后必须修改thisenv的值以保证用户程序行为正确</li>
</ul>
<p>练习12的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In lib/fork.c, fork():</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// User-level fork with copy-on-write.</span></span><br><span class="line"><span class="comment">// Set up our page fault handler appropriately.</span></span><br><span class="line"><span class="comment">// Create a child.</span></span><br><span class="line"><span class="comment">// Copy our address space and page fault handler setup to the child.</span></span><br><span class="line"><span class="comment">// Then mark the child as runnable and return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns: child's envid to the parent, 0 to the child, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// It is also OK to panic on error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use uvpd, uvpt, and duppage.</span></span><br><span class="line"><span class="comment">//   Remember to fix "thisenv" in the child process.</span></span><br><span class="line"><span class="comment">//   Neither user exception stack should ever be marked copy-on-write,</span></span><br><span class="line"><span class="comment">//   so you must allocate a new page for the child's user exception stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">envid_t</span> fork(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use set_pgfault_handler to install pgfault() as page fault handler</span></span><br><span class="line">    set_pgfault_handler(pgfault);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use system call to create new blank child environment</span></span><br><span class="line">    <span class="keyword">envid_t</span> child_env_id = sys_exofork();</span><br><span class="line">    <span class="keyword">if</span> (child_env_id == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// must update thisenv to make sure user program behave</span></span><br><span class="line">        <span class="comment">// normally</span></span><br><span class="line">        thisenv = envs + ENVX(sys_getenvid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child_env_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// error when create new environment, simply return</span></span><br><span class="line">        <span class="keyword">return</span> child_env_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traverse through parent's address space and use duppage</span></span><br><span class="line">    <span class="comment">// to copy address mappings</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> addr;</span><br><span class="line">    <span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; UTOP; addr += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((((<span class="keyword">pde_t</span> *)uvpd)[PDX(addr)] &amp; PTE_P) &amp;&amp;</span><br><span class="line">            (((<span class="keyword">pte_t</span> *)uvpt)[PGNUM(addr)] &amp; PTE_P)) &#123;</span><br><span class="line">            <span class="comment">// if both page directory entry and page table entry</span></span><br><span class="line">            <span class="comment">// exist for one address(page-aligned), then call duppage</span></span><br><span class="line">            <span class="keyword">if</span> (addr == (UXSTACKTOP - PGSIZE)) &#123;</span><br><span class="line">                <span class="comment">// ignore user exception stack</span></span><br><span class="line">                <span class="comment">// for we will map a page for user exception later</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((r = duppage(child_env_id, PGNUM(addr))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// duppage failed</span></span><br><span class="line">                <span class="comment">// destroy child environment and return</span></span><br><span class="line">                <span class="keyword">goto</span> error_handle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// child must have its own exception stack</span></span><br><span class="line">    <span class="comment">// so alloc page and map it for child here</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_alloc(child_env_id, (<span class="keyword">void</span> *)(UXSTACKTOP - PGSIZE),</span><br><span class="line">                            PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// failed to set child environment's exception stack</span></span><br><span class="line">        <span class="comment">// destroy child environment and return</span></span><br><span class="line">        <span class="keyword">goto</span> error_handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set child's page fault handler so that parent</span></span><br><span class="line">    <span class="comment">// and child looks the same</span></span><br><span class="line">    <span class="comment">// use sys_env_set_pgfault_upcall system call</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">void</span> _pgfault_upcall(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_env_set_pgfault_upcall(child_env_id, _pgfault_upcall)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// failed to set child's page fault upcall</span></span><br><span class="line">        <span class="comment">// destroy child environment and return</span></span><br><span class="line">        <span class="keyword">goto</span> error_handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now child is ready to run, set child to ENV_RUNNABLE</span></span><br><span class="line">    <span class="comment">// use sys_env_set_status system call</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_env_set_status(child_env_id, ENV_RUNNABLE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// failed to change child environment's running status</span></span><br><span class="line">        <span class="comment">// destroy child environment and return</span></span><br><span class="line">        <span class="keyword">goto</span> error_handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("fork not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child_env_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use goto to avoid meaningless error_handle code</span></span><br><span class="line"><span class="comment">// copy and paste everywhere</span></span><br><span class="line">error_handle:</span><br><span class="line">    <span class="keyword">if</span> (sys_env_destroy(child_env_id) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// failed either, panic then</span></span><br><span class="line">        panic(<span class="string">"failed to destroy child environment!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In lib/fork.c, duppage():</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Map our virtual page pn (address pn*PGSIZE) into the target envid</span></span><br><span class="line"><span class="comment">// at the same virtual address.  If the page is writable or copy-on-write,</span></span><br><span class="line"><span class="comment">// the new mapping must be created copy-on-write, and then our mapping must be</span></span><br><span class="line"><span class="comment">// marked copy-on-write as well.  (Exercise: Why do we need to mark ours</span></span><br><span class="line"><span class="comment">// copy-on-write again if it was already copy-on-write at the beginning of</span></span><br><span class="line"><span class="comment">// this function?)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns: 0 on success, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// It is also OK to panic on error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">duppage</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">int</span> perm = PTE_P | PTE_U;</span><br><span class="line">    <span class="keyword">if</span> ((((<span class="keyword">pte_t</span> *)uvpt)[pn] &amp; (PTE_W | PTE_COW))) &#123;</span><br><span class="line">        <span class="comment">// check for writable or copy-on-write page</span></span><br><span class="line">        <span class="comment">// and add perm with PTE_COW</span></span><br><span class="line">        perm |= PTE_COW;</span><br><span class="line">        <span class="comment">// NB: we also use 0 to replace thisenv-&gt;env_id</span></span><br><span class="line">        <span class="comment">// for in unix-like fork() implementation, we will copy</span></span><br><span class="line">        <span class="comment">// address space from parent process to child process</span></span><br><span class="line">        <span class="comment">// at current time, thisenv-&gt;env_id IS ABSOLUTELY WRONG</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// map from parent environment to child environment</span></span><br><span class="line">        <span class="keyword">if</span> (sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)(pn * PGSIZE), envid, (<span class="keyword">void</span> *)(pn * PGSIZE),</span><br><span class="line">                         perm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">"failed to map page from parent to child!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remap parent's environment</span></span><br><span class="line">        <span class="keyword">if</span> (sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)(pn * PGSIZE), <span class="number">0</span>, (<span class="keyword">void</span> *)(pn * PGSIZE),</span><br><span class="line">                         perm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">"failed to remap page in parent!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// for other pages, simply map from</span></span><br><span class="line">        <span class="comment">// parent environment to child environment</span></span><br><span class="line">        <span class="keyword">if</span> (sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)(pn * PGSIZE), envid, (<span class="keyword">void</span> *)(pn * PGSIZE),</span><br><span class="line">                         perm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">"failed to map page from parent to child!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("duppage not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In lib/fork.c, pgfault():</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Custom page fault handler - if faulting page is copy-on-write,</span></span><br><span class="line"><span class="comment">// map in our own private writable copy.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pgfault</span><span class="params">(struct UTrapframe *utf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *   addr = (<span class="keyword">void</span> *)utf-&gt;utf_fault_va;</span><br><span class="line">    <span class="keyword">uint32_t</span> err  = utf-&gt;utf_err;</span><br><span class="line">    <span class="keyword">int</span>      r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the faulting access was (1) a write, and (2) to a</span></span><br><span class="line">    <span class="comment">// copy-on-write page.  If not, panic.</span></span><br><span class="line">    <span class="comment">// Hint:</span></span><br><span class="line">    <span class="comment">//   Use the read-only page table mappings at uvpt</span></span><br><span class="line">    <span class="comment">//   (see &lt;inc/memlayout.h&gt;).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// use uvpt to get PTE and check premissions</span></span><br><span class="line">    <span class="keyword">if</span> (!(err &amp; FEC_WR) || !(((<span class="keyword">pte_t</span> *)uvpt)[PGNUM(addr)] &amp; PTE_COW)) &#123;</span><br><span class="line">        panic(<span class="string">"fault isn't write or PTE is not marked as PTE_COW or both!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span></span><br><span class="line">    <span class="comment">// copy the data from the old page to the new page, then move the new</span></span><br><span class="line">    <span class="comment">// page to the old page's address.</span></span><br><span class="line">    <span class="comment">// Hint:</span></span><br><span class="line">    <span class="comment">//   You should make three system calls.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// allocate a page and map it at PFTEMP</span></span><br><span class="line">    <span class="comment">// use sys_page_alloc system call</span></span><br><span class="line">    <span class="comment">// NB: use 0 instead of thisenv-&gt;env_id</span></span><br><span class="line">    <span class="comment">// for normally when child environment scheduled by JOS</span></span><br><span class="line">    <span class="comment">// first it tries to store 0(return value of fork()) to</span></span><br><span class="line">    <span class="comment">// local variable child_env_id on the stack</span></span><br><span class="line">    <span class="comment">// which will take a page fault and kernel will trasfer control</span></span><br><span class="line">    <span class="comment">// to pgfault here</span></span><br><span class="line">    <span class="comment">// thisenv-&gt;env_id IS ABSOLUTELY WRONG here, so use 0</span></span><br><span class="line">    <span class="comment">// and let kernel convert from 0 to correct env_id</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, (<span class="keyword">void</span> *)PFTEMP, PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">"failed to allocate page at temp location - %e, %x!"</span>, r,</span><br><span class="line">              thisenv-&gt;env_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    <span class="comment">// use memcpy to copy from fault address's page to PFTEMP's newly</span></span><br><span class="line">    <span class="comment">// allocated page</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)PFTEMP, addr, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use sys_page_map system call to map newly allocated</span></span><br><span class="line">    <span class="comment">// page at PFTEMP at addr with read/write permissions</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)PFTEMP, <span class="number">0</span>, addr, PTE_P | PTE_U | PTE_W)) &lt;</span><br><span class="line">        <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">"failed to map new page - %e!"</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// use sys_page_unmap system call to unmap page at</span></span><br><span class="line">    <span class="comment">// temp location PFTEMP</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_unmap(<span class="number">0</span>, (<span class="keyword">void</span> *)PFTEMP)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">"failed to unmap page at PFTEMP - %e!"</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("pgfault not implemented");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="第三部分-Preemptive-Multitasking-and-Inter-Process-communication-IPC-抢占式多任务和进程间通信"><a href="#第三部分-Preemptive-Multitasking-and-Inter-Process-communication-IPC-抢占式多任务和进程间通信" class="headerlink" title="第三部分 - Preemptive Multitasking and Inter-Process communication (IPC) 抢占式多任务和进程间通信"></a>第三部分 - Preemptive Multitasking and Inter-Process communication (IPC) 抢占式多任务和进程间通信</h3><p>最后一部分要求你修改内核，实现抢占式非协作环境以及允许环境显式传递信息。</p>
<h4 id="时钟中断和抢占"><a href="#时钟中断和抢占" class="headerlink" title="时钟中断和抢占"></a>时钟中断和抢占</h4><p>运行<code>user/spin</code>测试程序，该测试程序<code>fork</code>一个用户环境，生成的子环境一旦获得了CPU，就会执行一个无限循环，无论是父环境还是内核都无法重新获得CPU。<br>对于从错误和恶意代码中保护系统而言，这不是一个理想的情况，因为任何用户环境都可以通过一个无限循环以及永不放弃使得整个系统停机。为了允许内核抢占一个用户环境并强制从该环境处获取CPU的控制，需要扩展JOS内核以支持时钟硬件的外部硬件中断。</p>
<h5 id="中断规则"><a href="#中断规则" class="headerlink" title="中断规则"></a>中断规则</h5><p>外部中断（如设备中断）被称为IRQs（Interrupt request）。总共有16种可能的IRQs，分别从0编号到15。从IRQ号到IDT入口的映射并不固定。<code>picirq.c</code>中的<code>pic_init()</code>将IRQs从0到15映射到了IRQ_OFFSET到IRQ_OFFSET + 15。</p>
<p>在<code>inc/trap.h</code>中，IRQ_OFFSET被定义为32，因此IDT入口32-47对应于IRQ的0-15。例如，始终中断是IRQ 0。因此，IDT[IRQ_OFFSET + 0]包含了内核中时钟中断处理程序的地址。IRQ_OFFSET设置为32后，设备中断将不会和处理器异常号重叠。</p>
<p>同xv6 Unix相比，JOS内核提供了一个关键性简化。在内核中时，外部设备中断永远是被禁止的（但是在用户环境中是被允许的）。外部中断被%eflags寄存器的FL_IF标记控制。当该bit被设置时，外部中断被允许。尽管有若干种方式可以修改该bit位，将在进入和退出用户模式时通过保存和恢复%eflags寄存器的过程来处理它。</p>
<p>必须确保在用户环境中FL_IF标记被设置，这样当中断到达后，并且将中断传递给处理器，并由内核中的中断处理程序处理。否则中断会被屏蔽和忽略之道中断重新被允许。在引导程序的第一条指定就屏蔽了外部设备中断，并且直到目前为止，还没有重新启用。</p>
<p>练习13中遇到的问题：</p>
<ul>
<li>注意到简化规则要求中说明必须在陷入内核时将IF置0，所以必须修改之前的代码，将所有门都改为中断门</li>
</ul>
<p>练习13的代码如下，仅供参考：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In kern/trapentry.S:</span></span><br><span class="line"><span class="comment">// externel interrupts</span></span><br><span class="line">TRAPHANDLER_NOEC(irq_0_handler,  IRQ_OFFSET + <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_1_handler,  IRQ_OFFSET + <span class="number">1</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_2_handler,  IRQ_OFFSET + <span class="number">2</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_3_handler,  IRQ_OFFSET + <span class="number">3</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_4_handler,  IRQ_OFFSET + <span class="number">4</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_5_handler,  IRQ_OFFSET + <span class="number">5</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_6_handler,  IRQ_OFFSET + <span class="number">6</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_7_handler,  IRQ_OFFSET + <span class="number">7</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_8_handler,  IRQ_OFFSET + <span class="number">8</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_9_handler,  IRQ_OFFSET + <span class="number">9</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_10_handler, IRQ_OFFSET + <span class="number">10</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_11_handler, IRQ_OFFSET + <span class="number">11</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_12_handler, IRQ_OFFSET + <span class="number">12</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_13_handler, IRQ_OFFSET + <span class="number">13</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_14_handler, IRQ_OFFSET + <span class="number">14</span>);</span><br><span class="line">TRAPHANDLER_NOEC(irq_15_handler, IRQ_OFFSET + <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/trap.c, trap_init():</span></span><br><span class="line"><span class="comment">// set up interupt gate descriptor</span></span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">0</span>],  <span class="number">0</span>, GD_KT, irq_0_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">1</span>],  <span class="number">0</span>, GD_KT, irq_1_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">2</span>],  <span class="number">0</span>, GD_KT, irq_2_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">3</span>],  <span class="number">0</span>, GD_KT, irq_3_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">4</span>],  <span class="number">0</span>, GD_KT, irq_4_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">5</span>],  <span class="number">0</span>, GD_KT, irq_5_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">6</span>],  <span class="number">0</span>, GD_KT, irq_6_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">7</span>],  <span class="number">0</span>, GD_KT, irq_7_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">8</span>],  <span class="number">0</span>, GD_KT, irq_8_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">9</span>],  <span class="number">0</span>, GD_KT, irq_9_handler,  <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">10</span>], <span class="number">0</span>, GD_KT, irq_10_handler, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">11</span>], <span class="number">0</span>, GD_KT, irq_11_handler, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">12</span>], <span class="number">0</span>, GD_KT, irq_12_handler, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">13</span>], <span class="number">0</span>, GD_KT, irq_13_handler, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">14</span>], <span class="number">0</span>, GD_KT, irq_14_handler, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + <span class="number">15</span>], <span class="number">0</span>, GD_KT, irq_15_handler, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/env.c, env_alloc():</span></span><br><span class="line"><span class="comment">// Enable interrupts while in user mode.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">// simply use bit or to set FL_IF</span></span><br><span class="line">e-&gt;env_tf.tf_eflags |= FL_IF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/sched.c, sched_halt():</span></span><br><span class="line"><span class="comment">// Reset stack pointer, enable interrupts and then halt.</span></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"movl $0, %%ebp\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"movl %0, %%esp\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"pushl $0\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"pushl $0\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// Uncomment the following line after completing exercise 13</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"sti\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"1:\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"hlt\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"jmp 1b\n"</span></span></span></span><br><span class="line">: : "a" (thiscpu-&gt;cpu_ts.ts_esp0));</span><br></pre></td></tr></table></figure></p>
<h5 id="处理时钟中断"><a href="#处理时钟中断" class="headerlink" title="处理时钟中断"></a>处理时钟中断</h5><p>在<code>user/spin</code>程序中，在子环境第一次运行后，会陷入无限循环，而内核将无法得到控制权，需要对硬件编程以定时产生时钟中断，该终端会将控制权强行切回CPU，然后可以将控制权交给另一个用户环境。</p>
<p>对于<code>lapic_init()</code>和<code>pic_init()</code>的调用已经写好，它们会设置时钟并且终端控制器会定时生成中断。需要完成代码处理这些中断。</p>
<p>练习14中遇到的问题：</p>
<ul>
<li>首先需要调用<code>lapic_eoi()</code>以确认接收到了中断，否则会一直卡住</li>
</ul>
<p>练习14的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kern/trap.c, trap_dispatch():</span></span><br><span class="line"><span class="comment">// new code added</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</span><br><span class="line">    <span class="comment">// dispatch clock interupts</span></span><br><span class="line">    <span class="comment">// call sched_yield() to find and run a different environment</span></span><br><span class="line">    <span class="comment">// NB: should first call lapic_eoi() to ACKNOWLEDGE interupt</span></span><br><span class="line">    lapic_eoi();</span><br><span class="line">    sched_yield();</span><br><span class="line">    <span class="comment">// sched_yield() might not return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h4><p>到目前位置实验一直关注于操作系统的独立部分，操作系统通过虚拟化提供了一种每个环境都独占整个机器的“错觉”。然而操作系统的另一项服务是允许程序在必要的时候通讯，该功能非常强大，Unix管道就是一个典型的例子。</p>
<p>有许多进程间通讯的模型，即使是现在也有许多关于哪一种模型是最好的争论。我们不参与争论。相反，我们将实现一个简单的IPC模型。</p>
<h5 id="JOS中的IPC"><a href="#JOS中的IPC" class="headerlink" title="JOS中的IPC"></a>JOS中的IPC</h5><p>你将实现一些额外的JOS内核系统调用，这些调用共同提供一个简单的进程间通讯机制。具体的系统调用为<code>sys_ipc_recv()</code>和<code>sys_ipc_try_send()</code>，然后你将实现两个库包装<code>ipc_recv()</code>和<code>ipc_send()</code>。</p>
<p>用户环境通过JOS的IPC机制向其他环境互相发送的信息包括两部分，一个32-bit的值和一个可选的单页映射。允许环境传递页映射提供了一个比传递一个32-bit的整数更有效的数据交换方式，这也可以较为方便的设置共享内存。</p>
<h5 id="发送和接收消息"><a href="#发送和接收消息" class="headerlink" title="发送和接收消息"></a>发送和接收消息</h5><p>环境调用<code>sys_ipc_recv()</code>去接受消息。该系统调用取消调度当前环境并且直到一条消息被收到后才会被继续运行。当一个环境等待接收消息时，任何其他的环境可以向其发送一条消息 - 并不限于特定的环境，也不限于父子进程间传递消息，换言之，你在第一部分中实现的权限检查将不适用于IPC，因为IPC系统调用经过精心设计以保证安全，环境不会通过简单地发送消息而导致其他环境出现错误（除非目标环境也有错误）。</p>
<p>环境调用<code>sys_ipc_try_send()</code>去尝试发送一个值（并附带上接受者的环境ID），如果指定的环境实际上正在接受该值（已调用<code>sys_ipc_recv()</code>并且尚未获得值），则值成功发送并返回0。否则，返回-E_IPC_NOT_RECV表示目标环境当前不期望接收值。</p>
<p>用户空间的库函数<code>ipc_recv()</code>将负责调用<code>sys_ipc_recv()</code>并在当前环境的<code>struct Env</code>中查找接收值的信息。</p>
<p>用户空间的库函数<code>ipc_send()</code>将负责反复调用<code>sys_ipc_try_send()</code>直到发送成功。</p>
<h5 id="传输页"><a href="#传输页" class="headerlink" title="传输页"></a>传输页</h5><p>当一个环境以一个有效的<code>dstva</code>参数（小于UTOP）调用<code>sys_ipc_recv()</code>时，环境改变状态以表明想要接受一个页映射。如果发送者发送了一个页，那么该页将会被映射到接收者地址空间的<code>dstva</code>处。如果接收者已经在<code>dstva</code>映射了一页，那么之前的页会被解映射。</p>
<p>当一个环境以一个有效的<code>srcva</code>参数（小于UTOP）调用<code>sys_ipc_try_send()</code>时，表明发送者想要将当前映射在<code>srcva</code>的页发送给接收者，并且带有权限<code>perm</code>。在一次成功的IPC之后，发送者在其地址空间保留在<code>srcva</code>处原有的页映射，但是接收者也持有最开始由发送者指定的相同的物理页面在<code>dstva</code>的映射。最终，该页面在发送者和接收者之间共享。</p>
<p>如果发送者和接收者两者之一没有表明要传输页面，那么将不会有页面被传输。在任意一次IPC之后将接收者的<code>struct Env</code>中新的域<code>env_ipc_perm</code>设置为接受页面的权限，如果没有收到页面，则为0。</p>
<h5 id="实现IPC"><a href="#实现IPC" class="headerlink" title="实现IPC"></a>实现IPC</h5><p>练习15中遇到的问题：</p>
<ul>
<li>在<code>sys_ipc_try_send()</code>和<code>sys_ipc_recv()</code>中，均不将超过UTOP的地址标记为错误，超过UTOP的地址是无效的，但并不会导致系统调用失败</li>
<li>在<code>sys_ipc_recv()</code>中在接收到消息前将环境状态置为不可运行，那么在收到消息后，应当恢复到可运行的状态</li>
<li>在<code>sys_ipc_try_send()</code>中调用<code>page_lookup()</code>时，要记住检查的是源地址的映射，因此应当使用当前环境的页表而非接收者环境的页表</li>
</ul>
<p>练习15的代码如下，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In kern/syscall.c, sys_ipc_recv():</span></span><br><span class="line"><span class="comment">// Block until a value is ready.  Record that you want to receive</span></span><br><span class="line"><span class="comment">// using the env_ipc_recving and env_ipc_dstva fields of struct Env,</span></span><br><span class="line"><span class="comment">// mark yourself not runnable, and then give up the CPU.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If 'dstva' is &lt; UTOP, then you are willing to receive a page of data.</span></span><br><span class="line"><span class="comment">// 'dstva' is the virtual address at which the sent page should be mapped.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function only returns on error, but the system call will eventually</span></span><br><span class="line"><span class="comment">// return 0 on success.</span></span><br><span class="line"><span class="comment">// Return &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//  -E_INVAL if dstva &lt; UTOP but dstva is not page-aligned.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_ipc_recv</span><span class="params">(<span class="keyword">void</span> *dstva)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// similar to sys_ipc_try_send, will not mark an error</span></span><br><span class="line">    <span class="comment">// if dstva &gt;= UTOP</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)dstva &lt; UTOP &amp;&amp; PGOFF(dstva) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// if dstva &lt; UTOP but dstva is not page-aligned</span></span><br><span class="line">        <span class="comment">// NB: &amp;&amp; rather than ||, we won't report error</span></span><br><span class="line">        <span class="comment">// when dstva &gt;= UTOP</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mark calling environment as not runnable</span></span><br><span class="line">    curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    <span class="comment">// update status to mark receiver is willing to receive message</span></span><br><span class="line">    curenv-&gt;env_ipc_recving = <span class="literal">true</span>;</span><br><span class="line">    curenv-&gt;env_ipc_dstva   = dstva;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// give up cpu</span></span><br><span class="line">    sys_yield();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("sys_ipc_recv not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ipc succeeds</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/syscall.c, sys_ipc_try_send():</span></span><br><span class="line"><span class="comment">// Try to send 'value' to the target env 'envid'.</span></span><br><span class="line"><span class="comment">// If srcva &lt; UTOP, then also send page currently mapped at 'srcva',</span></span><br><span class="line"><span class="comment">// so that receiver gets a duplicate mapping of the same page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The send fails with a return value of -E_IPC_NOT_RECV if the</span></span><br><span class="line"><span class="comment">// target is not blocked, waiting for an IPC.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The send also can fail for the other reasons listed below.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Otherwise, the send succeeds, and the target's ipc fields are</span></span><br><span class="line"><span class="comment">// updated as follows:</span></span><br><span class="line"><span class="comment">//    env_ipc_recving is set to 0 to block future sends;</span></span><br><span class="line"><span class="comment">//    env_ipc_from is set to the sending envid;</span></span><br><span class="line"><span class="comment">//    env_ipc_value is set to the 'value' parameter;</span></span><br><span class="line"><span class="comment">//    env_ipc_perm is set to 'perm' if a page was transferred, 0 otherwise.</span></span><br><span class="line"><span class="comment">// The target environment is marked runnable again, returning 0</span></span><br><span class="line"><span class="comment">// from the paused sys_ipc_recv system call.  (Hint: does the</span></span><br><span class="line"><span class="comment">// sys_ipc_recv function ever actually return?)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the sender wants to send a page but the receiver isn't asking for one,</span></span><br><span class="line"><span class="comment">// then no page mapping is transferred, but no error occurs.</span></span><br><span class="line"><span class="comment">// The ipc only happens when no errors occur.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// Errors are:</span></span><br><span class="line"><span class="comment">//  -E_BAD_ENV if environment envid doesn't currently exist.</span></span><br><span class="line"><span class="comment">//      (No need to check permissions.)</span></span><br><span class="line"><span class="comment">//  -E_IPC_NOT_RECV if envid is not currently blocked in sys_ipc_recv,</span></span><br><span class="line"><span class="comment">//      or another environment managed to send first.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if srcva &lt; UTOP but srcva is not page-aligned.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if srcva &lt; UTOP and perm is inappropriate</span></span><br><span class="line"><span class="comment">//      (see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//  -E_INVAL if srcva &lt; UTOP but srcva is not mapped in the caller's</span></span><br><span class="line"><span class="comment">//      address space.</span></span><br><span class="line"><span class="comment">//  -E_INVAL if (perm &amp; PTE_W), but srcva is read-only in the</span></span><br><span class="line"><span class="comment">//      current environment's address space.</span></span><br><span class="line"><span class="comment">//  -E_NO_MEM if there's not enough memory to map srcva in envid's</span></span><br><span class="line"><span class="comment">//      address space.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_ipc_try_send</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">uint32_t</span> value, <span class="keyword">void</span> *srcva,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">unsigned</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// check for existence of env with envid</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="literal">false</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// environment envid doesn't currently exist</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check receiver's status</span></span><br><span class="line">    <span class="keyword">if</span> (!env-&gt;env_ipc_recving) &#123;</span><br><span class="line">        <span class="comment">// envid is not currently blocked in sys_ipc_recv</span></span><br><span class="line">        <span class="comment">// or another environment managed to send first</span></span><br><span class="line">        <span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)srcva &lt; UTOP) &#123;</span><br><span class="line">        <span class="comment">// srcva is valid</span></span><br><span class="line">        <span class="comment">// check srcva is page-aligned</span></span><br><span class="line">        <span class="keyword">if</span> (PGOFF(srcva) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// srcva is not page-aligned</span></span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check perm passed in</span></span><br><span class="line">        <span class="keyword">if</span> ((perm &amp; (~PTE_SYSCALL)) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P)) &#123;</span><br><span class="line">            <span class="comment">// invalid perm</span></span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check srcva actually be mapped</span></span><br><span class="line">        <span class="keyword">pte_t</span> *          pgtable_entry;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="keyword">if</span> ((page = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;pgtable_entry)) ==</span><br><span class="line">            <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// NB: check for SRCVA here, so use curenv-&gt;env_pgdir</span></span><br><span class="line">            <span class="comment">// srcva is not mapped at caller's address space</span></span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check PTE_W between sender and receiver</span></span><br><span class="line">        <span class="keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; (!((*pgtable_entry) &amp; PTE_W))) &#123;</span><br><span class="line">            <span class="comment">// if perm has PTE_W while srcva is read-only in</span></span><br><span class="line">            <span class="comment">// current environment's address space</span></span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)(env-&gt;env_ipc_dstva) &lt; UTOP) &#123;</span><br><span class="line">            <span class="comment">// receiver also expects page to be transferred</span></span><br><span class="line">            <span class="comment">// call page_insert to actually transer the page</span></span><br><span class="line">            <span class="keyword">if</span> (page_insert(env-&gt;env_pgdir, page, env-&gt;env_ipc_dstva, perm) &lt;</span><br><span class="line">                <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// out of memory when try to insert page</span></span><br><span class="line">                <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// page successfully transferred</span></span><br><span class="line">            env-&gt;env_ipc_perm = perm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// srcva &gt;= UTOP</span></span><br><span class="line">        <span class="comment">// invalid srcva, but we won't return error here</span></span><br><span class="line">        <span class="comment">// ipc_send will panic if we do so</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update receiver's information</span></span><br><span class="line">    env-&gt;env_ipc_recving = <span class="literal">false</span>;</span><br><span class="line">    env-&gt;env_ipc_from    = curenv-&gt;env_id;</span><br><span class="line">    env-&gt;env_ipc_value   = value;</span><br><span class="line">    <span class="comment">// mark receiver to be runnable to match what we do in sys_ipc_recv</span></span><br><span class="line">    env-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    <span class="comment">// modify trapframe's eax register to `update' return value</span></span><br><span class="line">    env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("sys_ipc_try_send not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ipc succeeds</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In lib/ipc.c, ipc_recv():</span></span><br><span class="line"><span class="comment">// Receive a value via IPC and return it.</span></span><br><span class="line"><span class="comment">// If 'pg' is nonnull, then any page sent by the sender will be mapped at</span></span><br><span class="line"><span class="comment">//	that address.</span></span><br><span class="line"><span class="comment">// If 'from_env_store' is nonnull, then store the IPC sender's envid in</span></span><br><span class="line"><span class="comment">//	*from_env_store.</span></span><br><span class="line"><span class="comment">// If 'perm_store' is nonnull, then store the IPC sender's page permission</span></span><br><span class="line"><span class="comment">//	in *perm_store (this is nonzero if a page was successfully</span></span><br><span class="line"><span class="comment">//	transferred to 'pg').</span></span><br><span class="line"><span class="comment">// If the system call fails, then store 0 in *fromenv and *perm (if</span></span><br><span class="line"><span class="comment">//	they're nonnull) and return the error.</span></span><br><span class="line"><span class="comment">// Otherwise, return the value sent by the sender</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use 'thisenv' to discover the value and who sent it.</span></span><br><span class="line"><span class="comment">//   If 'pg' is null, pass sys_ipc_recv a value that it will understand</span></span><br><span class="line"><span class="comment">//   as meaning "no page".  (Zero is not the right value, since that's</span></span><br><span class="line"><span class="comment">//   a perfectly valid place to map a page.)</span></span><br><span class="line"><span class="keyword">int32_t</span> ipc_recv(<span class="keyword">envid_t</span> *from_env_store, <span class="keyword">void</span> *pg, <span class="keyword">int</span> *perm_store) &#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// check pg, if pg is null, then should set it to UTOP,</span></span><br><span class="line">    <span class="comment">// for only if dstva is below UTOP, sender knows that</span></span><br><span class="line">    <span class="comment">// receiver wants a page to be transferred</span></span><br><span class="line">    <span class="keyword">if</span> (!pg) &#123; pg = (<span class="keyword">void</span> *)UTOP; &#125;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_ipc_recv(pg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// system call fails</span></span><br><span class="line">        <span class="comment">// store from env and perm if corresponding pointer is not null</span></span><br><span class="line">        <span class="keyword">if</span> (from_env_store) &#123; *from_env_store = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (perm_store) &#123; *perm_store = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="comment">// return the error</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// system call succeeds</span></span><br><span class="line">    <span class="comment">// extract information from thisenv's IPC fields</span></span><br><span class="line">    <span class="keyword">if</span> (from_env_store) &#123;</span><br><span class="line">        <span class="comment">// store IPC sender's envid into *from_env_store</span></span><br><span class="line">        *from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (perm_store) &#123;</span><br><span class="line">        <span class="comment">// store IPC sender's page permission</span></span><br><span class="line">        *perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("ipc_recv not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the value send by the sender</span></span><br><span class="line">    <span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In kern/syscall.c, syscall():</span></span><br><span class="line"><span class="comment">// new code added</span></span><br><span class="line"><span class="keyword">case</span> SYS_ipc_recv:</span><br><span class="line">    <span class="comment">// call sys_ipc_recv</span></span><br><span class="line">    <span class="keyword">return</span> sys_ipc_recv((<span class="keyword">void</span> *)a1);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_ipc_try_send:</span><br><span class="line">    <span class="comment">// call sys_ipc_try_send</span></span><br><span class="line">    <span class="keyword">return</span> sys_ipc_try_send((<span class="keyword">envid_t</span>)a1, (<span class="keyword">uint32_t</span>)a2, (<span class="keyword">void</span> *)a3,</span><br><span class="line">                            (<span class="keyword">unsigned</span>)a4);</span><br><span class="line"></span><br><span class="line"><span class="comment">// In lib/ipc.c, ipc_send():</span></span><br><span class="line"><span class="comment">// Send 'val' (and 'pg' with 'perm', if 'pg' is nonnull) to 'toenv'.</span></span><br><span class="line"><span class="comment">// This function keeps trying until it succeeds.</span></span><br><span class="line"><span class="comment">// It should panic() on any error other than -E_IPC_NOT_RECV.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use sys_yield() to be CPU-friendly.</span></span><br><span class="line"><span class="comment">//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand</span></span><br><span class="line"><span class="comment">//   as meaning "no page".  (Zero is not the right value.)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ipc_send</span><span class="params">(<span class="keyword">envid_t</span> to_env, <span class="keyword">uint32_t</span> val, <span class="keyword">void</span> *pg, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// check pg, if pg is null, then should set it to UTOP(invalid value</span></span><br><span class="line">    <span class="comment">// but won't result in panic)</span></span><br><span class="line">    <span class="keyword">if</span> (!pg) &#123; pg = (<span class="keyword">void</span> *)UTOP; &#125;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// keeps trying until succeeds or panic</span></span><br><span class="line">        r = sys_ipc_try_send(to_env, val, pg, perm);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// message successfully sent, return</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r != -E_IPC_NOT_RECV) &#123;</span><br><span class="line">            <span class="comment">// error when sending, should panic</span></span><br><span class="line">            panic(<span class="string">"failed to send messages - %e!"</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// use sys_yield to avoid waste on CPU</span></span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic("ipc_send not implemented");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h2><p>最终执行<code>make grade</code>，评分脚本的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">dumbfork:</span><br><span class="line">$ make run-dumbfork-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.6s)</span><br><span class="line">Part A score: 5/5</span><br><span class="line">faultread:</span><br><span class="line">$ make run-faultread-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">faultwrite:</span><br><span class="line">$ make run-faultwrite-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">faultdie:</span><br><span class="line">$ make run-faultdie-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">faultregs:</span><br><span class="line">$ make run-faultregs-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.1s)</span><br><span class="line">faultalloc:</span><br><span class="line">$ make run-faultalloc-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (4.6s)</span><br><span class="line">faultallocbad:</span><br><span class="line">$ make run-faultallocbad-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.3s)</span><br><span class="line">faultnostack:</span><br><span class="line">$ make run-faultnostack-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.8s)</span><br><span class="line">faultbadhandler:</span><br><span class="line">$ make run-faultbadhandler-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.2s)</span><br><span class="line">faultevilhandler:</span><br><span class="line">$ make run-faultevilhandler-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.0s)</span><br><span class="line">forktree:</span><br><span class="line">$ make run-forktree-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.4s)</span><br><span class="line">Part B score: 50/50</span><br><span class="line">spin:</span><br><span class="line">$ make run-spin-nox-gdb QEMUEXTRA+=-snapshot</span><br><span class="line">OK (0.7s)</span><br><span class="line">stresssched:</span><br><span class="line">$ make run-stresssched-nox-gdb CPUS=4 QEMUEXTRA+=-snapshot</span><br><span class="line">OK (3.0s)</span><br><span class="line">sendpage:</span><br><span class="line">$ make run-sendpage-nox-gdb CPUS=2 QEMUEXTRA+=-snapshot</span><br><span class="line">OK (1.7s)</span><br><span class="line">pingpong:</span><br><span class="line">$ make run-pingpong-nox-gdb CPUS=4 QEMUEXTRA+=-snapshot</span><br><span class="line">OK (2.1s)</span><br><span class="line">primes:</span><br><span class="line">$ make run-primes-nox-gdb CPUS=4 QEMUEXTRA+=-snapshot</span><br><span class="line">OK (4.5s)</span><br><span class="line">Part C score: 25/25</span><br><span class="line">Score: 80/80</span><br></pre></td></tr></table></figure><br>至此，实验四结束。</p>
<p>第四个实验是第一到第四个实验中难度最大、代码量最多的一个实验，在前三个实验中任何的代码错误（尽管可能在当时的实验评分中没有反映出来）都会导致实验四出现难以调试的错误。</p>
<p>实验四中每个练习遇到的问题我都已经在报告中总结，此外，也在代码中以NB标明。其中大部分都是一些小错误，还有少部分是没有将问题考虑全面导致的。尽管如此，几乎每一个错误我都花费了至少几十分钟去调试。</p>
<p>操作系统的调试不仅仅困难（Triple Fault会导致不打补丁的qemu重启），任何一个小错误都会导致系统崩溃。现代操作系统如Linux的鲁棒性可见一斑。</p>
<p>本学期的事情比起上学期只增不减，加上课程设计只要求完成四个实验，实验四结束后，MIT-6.828系列就告一段落了。</p>
<p>希望我的这四篇实验报告能对正在写实验的你产生些许的启发，也欢迎找我交流相关的问题。</p>

            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/写时复制/">写时复制</a> <a class="tag tag--primary tag--small t-link" href="/tags/多处理器/">多处理器</a> <a class="tag tag--primary tag--small t-link" href="/tags/实验/">实验</a> <a class="tag tag--primary tag--small t-link" href="/tags/抢占式调度/">抢占式调度</a> <a class="tag tag--primary tag--small t-link" href="/tags/操作系统/">操作系统</a> <a class="tag tag--primary tag--small t-link" href="/tags/进程间通信/">进程间通信</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--disabled">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/" data-tooltip="MIT6.828操作系统工程Lab3-User Environments实验报告" aria-label="下一篇: MIT6.828操作系统工程Lab3-User Environments实验报告">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/" title="分享到 Facebook">
                    <i class="fa fa-facebook-official" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/" title="分享到 Twitter">
                    <i class="fa fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/" title="分享到 Weibo">
                    <i class="fa fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/&amp;title=MIT6.828操作系统工程Lab4-Preemptive Multitasking实验报告" title="分享到 QQ">
                    <i class="fa fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/" title="分享到 Qzone">
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 码龙黑曜. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--disabled">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/02/23/MIT6-828操作系统工程Lab3-User-Environments实验报告/" data-tooltip="MIT6.828操作系统工程Lab3-User Environments实验报告" aria-label="下一篇: MIT6.828操作系统工程Lab3-User Environments实验报告">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/" title="分享到 Facebook">
                    <i class="fa fa-facebook-official" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/" title="分享到 Twitter">
                    <i class="fa fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/" title="分享到 Weibo">
                    <i class="fa fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/&amp;title=MIT6.828操作系统工程Lab4-Preemptive Multitasking实验报告" title="分享到 QQ">
                    <i class="fa fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/" title="分享到 Qzone">
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-close"></i>
    <ul class="share-options">
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/">
                    <i class="fa fa-facebook-official" aria-hidden="true"></i><span>分享到 Facebook</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/">
                    <i class="fa fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/">
                    <i class="fa fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/&amp;title=MIT6.828操作系统工程Lab4-Preemptive Multitasking实验报告">
                    <i class="fa fa-qq" aria-hidden="true"></i><span>分享到 QQ</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://blog.codedragon.tech/2018/02/26/MIT6-828操作系统工程Lab4-Preemptive-Multitasking实验报告/">
                    <i class="fa fa-star" aria-hidden="true"></i><span>分享到 Qzone</span>
                </a>
            </li>
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">码龙黑曜</h4>
        
            <div id="about-card-bio"><p>iOS开发者/计算机科学/兽人控</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>华中科技大学 本科在读</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Wuhan, China
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-feiabjni254mgbxiozwsjblcsiodjqohurk0dcfkq0aooroewq6bvkdnadrg.min.js"></script>
<!--SCRIPTS END-->

    



    </body>
</html>
